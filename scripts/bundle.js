var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/@spectrum-web-components/base/src/version.js
var version;
var init_version = __esm({
  "node_modules/@spectrum-web-components/base/src/version.js"() {
    version = "1.9.0";
  }
});

// node_modules/@lit/reactive-element/css-tag.js
var t, e, s, o3, n, r, i, S, c;
var init_css_tag = __esm({
  "node_modules/@lit/reactive-element/css-tag.js"() {
    t = globalThis;
    e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
    s = Symbol();
    o3 = /* @__PURE__ */ new WeakMap();
    n = class {
      constructor(t34, e36, o52) {
        if (this._$cssResult$ = true, o52 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t34, this.t = e36;
      }
      get styleSheet() {
        let t34 = this.o;
        const s19 = this.t;
        if (e && void 0 === t34) {
          const e36 = void 0 !== s19 && 1 === s19.length;
          e36 && (t34 = o3.get(s19)), void 0 === t34 && ((this.o = t34 = new CSSStyleSheet()).replaceSync(this.cssText), e36 && o3.set(s19, t34));
        }
        return t34;
      }
      toString() {
        return this.cssText;
      }
    };
    r = (t34) => new n("string" == typeof t34 ? t34 : t34 + "", void 0, s);
    i = (t34, ...e36) => {
      const o52 = 1 === t34.length ? t34[0] : e36.reduce((e37, s19, o53) => e37 + ((t35) => {
        if (true === t35._$cssResult$) return t35.cssText;
        if ("number" == typeof t35) return t35;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + t35 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
      })(s19) + t34[o53 + 1], t34[0]);
      return new n(o52, t34, s);
    };
    S = (s19, o52) => {
      if (e) s19.adoptedStyleSheets = o52.map((t34) => t34 instanceof CSSStyleSheet ? t34 : t34.styleSheet);
      else for (const e36 of o52) {
        const o53 = document.createElement("style"), n25 = t.litNonce;
        void 0 !== n25 && o53.setAttribute("nonce", n25), o53.textContent = e36.cssText, s19.appendChild(o53);
      }
    };
    c = e ? (t34) => t34 : (t34) => t34 instanceof CSSStyleSheet ? ((t35) => {
      let e36 = "";
      for (const s19 of t35.cssRules) e36 += s19.cssText;
      return r(e36);
    })(t34) : t34;
  }
});

// node_modules/@lit/reactive-element/reactive-element.js
var i2, e2, h, r2, o4, n2, a, c2, l, p, d, u, f, b, y;
var init_reactive_element = __esm({
  "node_modules/@lit/reactive-element/reactive-element.js"() {
    init_css_tag();
    init_css_tag();
    ({ is: i2, defineProperty: e2, getOwnPropertyDescriptor: h, getOwnPropertyNames: r2, getOwnPropertySymbols: o4, getPrototypeOf: n2 } = Object);
    a = globalThis;
    c2 = a.trustedTypes;
    l = c2 ? c2.emptyScript : "";
    p = a.reactiveElementPolyfillSupport;
    d = (t34, s19) => t34;
    u = { toAttribute(t34, s19) {
      switch (s19) {
        case Boolean:
          t34 = t34 ? l : null;
          break;
        case Object:
        case Array:
          t34 = null == t34 ? t34 : JSON.stringify(t34);
      }
      return t34;
    }, fromAttribute(t34, s19) {
      let i21 = t34;
      switch (s19) {
        case Boolean:
          i21 = null !== t34;
          break;
        case Number:
          i21 = null === t34 ? null : Number(t34);
          break;
        case Object:
        case Array:
          try {
            i21 = JSON.parse(t34);
          } catch (t35) {
            i21 = null;
          }
      }
      return i21;
    } };
    f = (t34, s19) => !i2(t34, s19);
    b = { attribute: true, type: String, converter: u, reflect: false, useDefault: false, hasChanged: f };
    Symbol.metadata ??= Symbol("metadata"), a.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
    y = class extends HTMLElement {
      static addInitializer(t34) {
        this._$Ei(), (this.l ??= []).push(t34);
      }
      static get observedAttributes() {
        return this.finalize(), this._$Eh && [...this._$Eh.keys()];
      }
      static createProperty(t34, s19 = b) {
        if (s19.state && (s19.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t34) && ((s19 = Object.create(s19)).wrapped = true), this.elementProperties.set(t34, s19), !s19.noAccessor) {
          const i21 = Symbol(), h16 = this.getPropertyDescriptor(t34, i21, s19);
          void 0 !== h16 && e2(this.prototype, t34, h16);
        }
      }
      static getPropertyDescriptor(t34, s19, i21) {
        const { get: e36, set: r25 } = h(this.prototype, t34) ?? { get() {
          return this[s19];
        }, set(t35) {
          this[s19] = t35;
        } };
        return { get: e36, set(s20) {
          const h16 = e36?.call(this);
          r25?.call(this, s20), this.requestUpdate(t34, h16, i21);
        }, configurable: true, enumerable: true };
      }
      static getPropertyOptions(t34) {
        return this.elementProperties.get(t34) ?? b;
      }
      static _$Ei() {
        if (this.hasOwnProperty(d("elementProperties"))) return;
        const t34 = n2(this);
        t34.finalize(), void 0 !== t34.l && (this.l = [...t34.l]), this.elementProperties = new Map(t34.elementProperties);
      }
      static finalize() {
        if (this.hasOwnProperty(d("finalized"))) return;
        if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
          const t35 = this.properties, s19 = [...r2(t35), ...o4(t35)];
          for (const i21 of s19) this.createProperty(i21, t35[i21]);
        }
        const t34 = this[Symbol.metadata];
        if (null !== t34) {
          const s19 = litPropertyMetadata.get(t34);
          if (void 0 !== s19) for (const [t35, i21] of s19) this.elementProperties.set(t35, i21);
        }
        this._$Eh = /* @__PURE__ */ new Map();
        for (const [t35, s19] of this.elementProperties) {
          const i21 = this._$Eu(t35, s19);
          void 0 !== i21 && this._$Eh.set(i21, t35);
        }
        this.elementStyles = this.finalizeStyles(this.styles);
      }
      static finalizeStyles(s19) {
        const i21 = [];
        if (Array.isArray(s19)) {
          const e36 = new Set(s19.flat(1 / 0).reverse());
          for (const s20 of e36) i21.unshift(c(s20));
        } else void 0 !== s19 && i21.push(c(s19));
        return i21;
      }
      static _$Eu(t34, s19) {
        const i21 = s19.attribute;
        return false === i21 ? void 0 : "string" == typeof i21 ? i21 : "string" == typeof t34 ? t34.toLowerCase() : void 0;
      }
      constructor() {
        super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
      }
      _$Ev() {
        this._$ES = new Promise((t34) => this.enableUpdating = t34), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t34) => t34(this));
      }
      addController(t34) {
        (this._$EO ??= /* @__PURE__ */ new Set()).add(t34), void 0 !== this.renderRoot && this.isConnected && t34.hostConnected?.();
      }
      removeController(t34) {
        this._$EO?.delete(t34);
      }
      _$E_() {
        const t34 = /* @__PURE__ */ new Map(), s19 = this.constructor.elementProperties;
        for (const i21 of s19.keys()) this.hasOwnProperty(i21) && (t34.set(i21, this[i21]), delete this[i21]);
        t34.size > 0 && (this._$Ep = t34);
      }
      createRenderRoot() {
        const t34 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return S(t34, this.constructor.elementStyles), t34;
      }
      connectedCallback() {
        this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t34) => t34.hostConnected?.());
      }
      enableUpdating(t34) {
      }
      disconnectedCallback() {
        this._$EO?.forEach((t34) => t34.hostDisconnected?.());
      }
      attributeChangedCallback(t34, s19, i21) {
        this._$AK(t34, i21);
      }
      _$ET(t34, s19) {
        const i21 = this.constructor.elementProperties.get(t34), e36 = this.constructor._$Eu(t34, i21);
        if (void 0 !== e36 && true === i21.reflect) {
          const h16 = (void 0 !== i21.converter?.toAttribute ? i21.converter : u).toAttribute(s19, i21.type);
          this._$Em = t34, null == h16 ? this.removeAttribute(e36) : this.setAttribute(e36, h16), this._$Em = null;
        }
      }
      _$AK(t34, s19) {
        const i21 = this.constructor, e36 = i21._$Eh.get(t34);
        if (void 0 !== e36 && this._$Em !== e36) {
          const t35 = i21.getPropertyOptions(e36), h16 = "function" == typeof t35.converter ? { fromAttribute: t35.converter } : void 0 !== t35.converter?.fromAttribute ? t35.converter : u;
          this._$Em = e36, this[e36] = h16.fromAttribute(s19, t35.type) ?? this._$Ej?.get(e36) ?? null, this._$Em = null;
        }
      }
      requestUpdate(t34, s19, i21) {
        if (void 0 !== t34) {
          const e36 = this.constructor, h16 = this[t34];
          if (i21 ??= e36.getPropertyOptions(t34), !((i21.hasChanged ?? f)(h16, s19) || i21.useDefault && i21.reflect && h16 === this._$Ej?.get(t34) && !this.hasAttribute(e36._$Eu(t34, i21)))) return;
          this.C(t34, s19, i21);
        }
        false === this.isUpdatePending && (this._$ES = this._$EP());
      }
      C(t34, s19, { useDefault: i21, reflect: e36, wrapped: h16 }, r25) {
        i21 && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t34) && (this._$Ej.set(t34, r25 ?? s19 ?? this[t34]), true !== h16 || void 0 !== r25) || (this._$AL.has(t34) || (this.hasUpdated || i21 || (s19 = void 0), this._$AL.set(t34, s19)), true === e36 && this._$Em !== t34 && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t34));
      }
      async _$EP() {
        this.isUpdatePending = true;
        try {
          await this._$ES;
        } catch (t35) {
          Promise.reject(t35);
        }
        const t34 = this.scheduleUpdate();
        return null != t34 && await t34, !this.isUpdatePending;
      }
      scheduleUpdate() {
        return this.performUpdate();
      }
      performUpdate() {
        if (!this.isUpdatePending) return;
        if (!this.hasUpdated) {
          if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
            for (const [t36, s20] of this._$Ep) this[t36] = s20;
            this._$Ep = void 0;
          }
          const t35 = this.constructor.elementProperties;
          if (t35.size > 0) for (const [s20, i21] of t35) {
            const { wrapped: t36 } = i21, e36 = this[s20];
            true !== t36 || this._$AL.has(s20) || void 0 === e36 || this.C(s20, void 0, i21, e36);
          }
        }
        let t34 = false;
        const s19 = this._$AL;
        try {
          t34 = this.shouldUpdate(s19), t34 ? (this.willUpdate(s19), this._$EO?.forEach((t35) => t35.hostUpdate?.()), this.update(s19)) : this._$EM();
        } catch (s20) {
          throw t34 = false, this._$EM(), s20;
        }
        t34 && this._$AE(s19);
      }
      willUpdate(t34) {
      }
      _$AE(t34) {
        this._$EO?.forEach((t35) => t35.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t34)), this.updated(t34);
      }
      _$EM() {
        this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
      }
      get updateComplete() {
        return this.getUpdateComplete();
      }
      getUpdateComplete() {
        return this._$ES;
      }
      shouldUpdate(t34) {
        return true;
      }
      update(t34) {
        this._$Eq &&= this._$Eq.forEach((t35) => this._$ET(t35, this[t35])), this._$EM();
      }
      updated(t34) {
      }
      firstUpdated(t34) {
      }
    };
    y.elementStyles = [], y.shadowRootOptions = { mode: "open" }, y[d("elementProperties")] = /* @__PURE__ */ new Map(), y[d("finalized")] = /* @__PURE__ */ new Map(), p?.({ ReactiveElement: y }), (a.reactiveElementVersions ??= []).push("2.1.0");
  }
});

// node_modules/lit-html/lit-html.js
function P(t34, i21) {
  if (!a2(t34) || !t34.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s2 ? s2.createHTML(i21) : i21;
}
function S2(t34, i21, s19 = t34, e36) {
  if (i21 === T) return i21;
  let h16 = void 0 !== e36 ? s19._$Co?.[e36] : s19._$Cl;
  const o52 = c3(i21) ? void 0 : i21._$litDirective$;
  return h16?.constructor !== o52 && (h16?._$AO?.(false), void 0 === o52 ? h16 = void 0 : (h16 = new o52(t34), h16._$AT(t34, s19, e36)), void 0 !== e36 ? (s19._$Co ??= [])[e36] = h16 : s19._$Cl = h16), void 0 !== h16 && (i21 = S2(t34, h16._$AS(t34, i21.values), h16, e36)), i21;
}
var t2, i3, s2, e3, h2, o5, n3, r3, l2, c3, a2, u2, d2, f2, v, _, m, p2, g, $, y2, x, b2, w, T, E, A, C, V, N, M, R, k, H, I, L, z, Z, j, B;
var init_lit_html = __esm({
  "node_modules/lit-html/lit-html.js"() {
    t2 = globalThis;
    i3 = t2.trustedTypes;
    s2 = i3 ? i3.createPolicy("lit-html", { createHTML: (t34) => t34 }) : void 0;
    e3 = "$lit$";
    h2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
    o5 = "?" + h2;
    n3 = `<${o5}>`;
    r3 = document;
    l2 = () => r3.createComment("");
    c3 = (t34) => null === t34 || "object" != typeof t34 && "function" != typeof t34;
    a2 = Array.isArray;
    u2 = (t34) => a2(t34) || "function" == typeof t34?.[Symbol.iterator];
    d2 = "[ 	\n\f\r]";
    f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    v = /-->/g;
    _ = />/g;
    m = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
    p2 = /'/g;
    g = /"/g;
    $ = /^(?:script|style|textarea|title)$/i;
    y2 = (t34) => (i21, ...s19) => ({ _$litType$: t34, strings: i21, values: s19 });
    x = y2(1);
    b2 = y2(2);
    w = y2(3);
    T = Symbol.for("lit-noChange");
    E = Symbol.for("lit-nothing");
    A = /* @__PURE__ */ new WeakMap();
    C = r3.createTreeWalker(r3, 129);
    V = (t34, i21) => {
      const s19 = t34.length - 1, o52 = [];
      let r25, l16 = 2 === i21 ? "<svg>" : 3 === i21 ? "<math>" : "", c33 = f2;
      for (let i22 = 0; i22 < s19; i22++) {
        const s20 = t34[i22];
        let a23, u36, d22 = -1, y5 = 0;
        for (; y5 < s20.length && (c33.lastIndex = y5, u36 = c33.exec(s20), null !== u36); ) y5 = c33.lastIndex, c33 === f2 ? "!--" === u36[1] ? c33 = v : void 0 !== u36[1] ? c33 = _ : void 0 !== u36[2] ? ($.test(u36[2]) && (r25 = RegExp("</" + u36[2], "g")), c33 = m) : void 0 !== u36[3] && (c33 = m) : c33 === m ? ">" === u36[0] ? (c33 = r25 ?? f2, d22 = -1) : void 0 === u36[1] ? d22 = -2 : (d22 = c33.lastIndex - u36[2].length, a23 = u36[1], c33 = void 0 === u36[3] ? m : '"' === u36[3] ? g : p2) : c33 === g || c33 === p2 ? c33 = m : c33 === v || c33 === _ ? c33 = f2 : (c33 = m, r25 = void 0);
        const x5 = c33 === m && t34[i22 + 1].startsWith("/>") ? " " : "";
        l16 += c33 === f2 ? s20 + n3 : d22 >= 0 ? (o52.push(a23), s20.slice(0, d22) + e3 + s20.slice(d22) + h2 + x5) : s20 + h2 + (-2 === d22 ? i22 : x5);
      }
      return [P(t34, l16 + (t34[s19] || "<?>") + (2 === i21 ? "</svg>" : 3 === i21 ? "</math>" : "")), o52];
    };
    N = class _N {
      constructor({ strings: t34, _$litType$: s19 }, n25) {
        let r25;
        this.parts = [];
        let c33 = 0, a23 = 0;
        const u36 = t34.length - 1, d22 = this.parts, [f11, v6] = V(t34, s19);
        if (this.el = _N.createElement(f11, n25), C.currentNode = this.el.content, 2 === s19 || 3 === s19) {
          const t35 = this.el.content.firstChild;
          t35.replaceWith(...t35.childNodes);
        }
        for (; null !== (r25 = C.nextNode()) && d22.length < u36; ) {
          if (1 === r25.nodeType) {
            if (r25.hasAttributes()) for (const t35 of r25.getAttributeNames()) if (t35.endsWith(e3)) {
              const i21 = v6[a23++], s20 = r25.getAttribute(t35).split(h2), e36 = /([.?@])?(.*)/.exec(i21);
              d22.push({ type: 1, index: c33, name: e36[2], strings: s20, ctor: "." === e36[1] ? H : "?" === e36[1] ? I : "@" === e36[1] ? L : k }), r25.removeAttribute(t35);
            } else t35.startsWith(h2) && (d22.push({ type: 6, index: c33 }), r25.removeAttribute(t35));
            if ($.test(r25.tagName)) {
              const t35 = r25.textContent.split(h2), s20 = t35.length - 1;
              if (s20 > 0) {
                r25.textContent = i3 ? i3.emptyScript : "";
                for (let i21 = 0; i21 < s20; i21++) r25.append(t35[i21], l2()), C.nextNode(), d22.push({ type: 2, index: ++c33 });
                r25.append(t35[s20], l2());
              }
            }
          } else if (8 === r25.nodeType) if (r25.data === o5) d22.push({ type: 2, index: c33 });
          else {
            let t35 = -1;
            for (; -1 !== (t35 = r25.data.indexOf(h2, t35 + 1)); ) d22.push({ type: 7, index: c33 }), t35 += h2.length - 1;
          }
          c33++;
        }
      }
      static createElement(t34, i21) {
        const s19 = r3.createElement("template");
        return s19.innerHTML = t34, s19;
      }
    };
    M = class {
      constructor(t34, i21) {
        this._$AV = [], this._$AN = void 0, this._$AD = t34, this._$AM = i21;
      }
      get parentNode() {
        return this._$AM.parentNode;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      u(t34) {
        const { el: { content: i21 }, parts: s19 } = this._$AD, e36 = (t34?.creationScope ?? r3).importNode(i21, true);
        C.currentNode = e36;
        let h16 = C.nextNode(), o52 = 0, n25 = 0, l16 = s19[0];
        for (; void 0 !== l16; ) {
          if (o52 === l16.index) {
            let i22;
            2 === l16.type ? i22 = new R(h16, h16.nextSibling, this, t34) : 1 === l16.type ? i22 = new l16.ctor(h16, l16.name, l16.strings, this, t34) : 6 === l16.type && (i22 = new z(h16, this, t34)), this._$AV.push(i22), l16 = s19[++n25];
          }
          o52 !== l16?.index && (h16 = C.nextNode(), o52++);
        }
        return C.currentNode = r3, e36;
      }
      p(t34) {
        let i21 = 0;
        for (const s19 of this._$AV) void 0 !== s19 && (void 0 !== s19.strings ? (s19._$AI(t34, s19, i21), i21 += s19.strings.length - 2) : s19._$AI(t34[i21])), i21++;
      }
    };
    R = class _R {
      get _$AU() {
        return this._$AM?._$AU ?? this._$Cv;
      }
      constructor(t34, i21, s19, e36) {
        this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t34, this._$AB = i21, this._$AM = s19, this.options = e36, this._$Cv = e36?.isConnected ?? true;
      }
      get parentNode() {
        let t34 = this._$AA.parentNode;
        const i21 = this._$AM;
        return void 0 !== i21 && 11 === t34?.nodeType && (t34 = i21.parentNode), t34;
      }
      get startNode() {
        return this._$AA;
      }
      get endNode() {
        return this._$AB;
      }
      _$AI(t34, i21 = this) {
        t34 = S2(this, t34, i21), c3(t34) ? t34 === E || null == t34 || "" === t34 ? (this._$AH !== E && this._$AR(), this._$AH = E) : t34 !== this._$AH && t34 !== T && this._(t34) : void 0 !== t34._$litType$ ? this.$(t34) : void 0 !== t34.nodeType ? this.T(t34) : u2(t34) ? this.k(t34) : this._(t34);
      }
      O(t34) {
        return this._$AA.parentNode.insertBefore(t34, this._$AB);
      }
      T(t34) {
        this._$AH !== t34 && (this._$AR(), this._$AH = this.O(t34));
      }
      _(t34) {
        this._$AH !== E && c3(this._$AH) ? this._$AA.nextSibling.data = t34 : this.T(r3.createTextNode(t34)), this._$AH = t34;
      }
      $(t34) {
        const { values: i21, _$litType$: s19 } = t34, e36 = "number" == typeof s19 ? this._$AC(t34) : (void 0 === s19.el && (s19.el = N.createElement(P(s19.h, s19.h[0]), this.options)), s19);
        if (this._$AH?._$AD === e36) this._$AH.p(i21);
        else {
          const t35 = new M(e36, this), s20 = t35.u(this.options);
          t35.p(i21), this.T(s20), this._$AH = t35;
        }
      }
      _$AC(t34) {
        let i21 = A.get(t34.strings);
        return void 0 === i21 && A.set(t34.strings, i21 = new N(t34)), i21;
      }
      k(t34) {
        a2(this._$AH) || (this._$AH = [], this._$AR());
        const i21 = this._$AH;
        let s19, e36 = 0;
        for (const h16 of t34) e36 === i21.length ? i21.push(s19 = new _R(this.O(l2()), this.O(l2()), this, this.options)) : s19 = i21[e36], s19._$AI(h16), e36++;
        e36 < i21.length && (this._$AR(s19 && s19._$AB.nextSibling, e36), i21.length = e36);
      }
      _$AR(t34 = this._$AA.nextSibling, i21) {
        for (this._$AP?.(false, true, i21); t34 !== this._$AB; ) {
          const i22 = t34.nextSibling;
          t34.remove(), t34 = i22;
        }
      }
      setConnected(t34) {
        void 0 === this._$AM && (this._$Cv = t34, this._$AP?.(t34));
      }
    };
    k = class {
      get tagName() {
        return this.element.tagName;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      constructor(t34, i21, s19, e36, h16) {
        this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t34, this.name = i21, this._$AM = e36, this.options = h16, s19.length > 2 || "" !== s19[0] || "" !== s19[1] ? (this._$AH = Array(s19.length - 1).fill(new String()), this.strings = s19) : this._$AH = E;
      }
      _$AI(t34, i21 = this, s19, e36) {
        const h16 = this.strings;
        let o52 = false;
        if (void 0 === h16) t34 = S2(this, t34, i21, 0), o52 = !c3(t34) || t34 !== this._$AH && t34 !== T, o52 && (this._$AH = t34);
        else {
          const e37 = t34;
          let n25, r25;
          for (t34 = h16[0], n25 = 0; n25 < h16.length - 1; n25++) r25 = S2(this, e37[s19 + n25], i21, n25), r25 === T && (r25 = this._$AH[n25]), o52 ||= !c3(r25) || r25 !== this._$AH[n25], r25 === E ? t34 = E : t34 !== E && (t34 += (r25 ?? "") + h16[n25 + 1]), this._$AH[n25] = r25;
        }
        o52 && !e36 && this.j(t34);
      }
      j(t34) {
        t34 === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t34 ?? "");
      }
    };
    H = class extends k {
      constructor() {
        super(...arguments), this.type = 3;
      }
      j(t34) {
        this.element[this.name] = t34 === E ? void 0 : t34;
      }
    };
    I = class extends k {
      constructor() {
        super(...arguments), this.type = 4;
      }
      j(t34) {
        this.element.toggleAttribute(this.name, !!t34 && t34 !== E);
      }
    };
    L = class extends k {
      constructor(t34, i21, s19, e36, h16) {
        super(t34, i21, s19, e36, h16), this.type = 5;
      }
      _$AI(t34, i21 = this) {
        if ((t34 = S2(this, t34, i21, 0) ?? E) === T) return;
        const s19 = this._$AH, e36 = t34 === E && s19 !== E || t34.capture !== s19.capture || t34.once !== s19.once || t34.passive !== s19.passive, h16 = t34 !== E && (s19 === E || e36);
        e36 && this.element.removeEventListener(this.name, this, s19), h16 && this.element.addEventListener(this.name, this, t34), this._$AH = t34;
      }
      handleEvent(t34) {
        "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t34) : this._$AH.handleEvent(t34);
      }
    };
    z = class {
      constructor(t34, i21, s19) {
        this.element = t34, this.type = 6, this._$AN = void 0, this._$AM = i21, this.options = s19;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(t34) {
        S2(this, t34);
      }
    };
    Z = { M: e3, P: h2, A: o5, C: 1, L: V, R: M, D: u2, V: S2, I: R, H: k, N: I, U: L, B: H, F: z };
    j = t2.litHtmlPolyfillSupport;
    j?.(N, R), (t2.litHtmlVersions ??= []).push("3.3.1");
    B = (t34, i21, s19) => {
      const e36 = s19?.renderBefore ?? i21;
      let h16 = e36._$litPart$;
      if (void 0 === h16) {
        const t35 = s19?.renderBefore ?? null;
        e36._$litPart$ = h16 = new R(i21.insertBefore(l2(), t35), t35, void 0, s19 ?? {});
      }
      return h16._$AI(t34), h16;
    };
  }
});

// node_modules/lit/node_modules/lit-element/lit-element.js
var s3, i4, o6;
var init_lit_element = __esm({
  "node_modules/lit/node_modules/lit-element/lit-element.js"() {
    init_reactive_element();
    init_reactive_element();
    init_lit_html();
    init_lit_html();
    s3 = globalThis;
    i4 = class extends y {
      constructor() {
        super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
      }
      createRenderRoot() {
        const t34 = super.createRenderRoot();
        return this.renderOptions.renderBefore ??= t34.firstChild, t34;
      }
      update(t34) {
        const r25 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t34), this._$Do = B(r25, this.renderRoot, this.renderOptions);
      }
      connectedCallback() {
        super.connectedCallback(), this._$Do?.setConnected(true);
      }
      disconnectedCallback() {
        super.disconnectedCallback(), this._$Do?.setConnected(false);
      }
      render() {
        return T;
      }
    };
    i4._$litElement$ = true, i4["finalized"] = true, s3.litElementHydrateSupport?.({ LitElement: i4 });
    o6 = s3.litElementPolyfillSupport;
    o6?.({ LitElement: i4 });
    (s3.litElementVersions ??= []).push("4.2.0");
  }
});

// node_modules/lit-html/is-server.js
var init_is_server = __esm({
  "node_modules/lit-html/is-server.js"() {
  }
});

// node_modules/lit/index.js
var init_lit = __esm({
  "node_modules/lit/index.js"() {
    init_reactive_element();
    init_lit_html();
    init_lit_element();
    init_is_server();
  }
});

// node_modules/@spectrum-web-components/base/src/Base.js
function SpectrumMixin(s19) {
  class o52 extends s19 {
    get isLTR() {
      return this.dir === "ltr";
    }
    hasVisibleFocusInTree() {
      const n25 = ((r25 = document) => {
        var l16;
        let t34 = r25.activeElement;
        for (; t34 != null && t34.shadowRoot && t34.shadowRoot.activeElement; ) t34 = t34.shadowRoot.activeElement;
        const a23 = t34 ? [t34] : [];
        for (; t34; ) {
          const i21 = t34.assignedSlot || t34.parentElement || ((l16 = t34.getRootNode()) == null ? void 0 : l16.host);
          i21 && a23.push(i21), t34 = i21;
        }
        return a23;
      })(this.getRootNode())[0];
      if (!n25) return false;
      try {
        return n25.matches(":focus-visible") || n25.matches(".focus-visible");
      } catch (r25) {
        return n25.matches(".focus-visible");
      }
    }
    connectedCallback() {
      if (!this.hasAttribute("dir")) {
        let e36 = this.assignedSlot || this.parentNode;
        for (; e36 !== document.documentElement && !p3(e36); ) e36 = e36.assignedSlot || e36.parentNode || e36.host;
        if (this.dir = e36.dir === "rtl" ? e36.dir : this.dir || "ltr", e36 === document.documentElement) c4.add(this);
        else {
          const { localName: n25 } = e36;
          n25.search("-") > -1 && !customElements.get(n25) ? customElements.whenDefined(n25).then(() => {
            e36.startManagingContentDirection(this);
          }) : e36.startManagingContentDirection(this);
        }
        this._dirParent = e36;
      }
      super.connectedCallback();
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this._dirParent && (this._dirParent === document.documentElement ? c4.delete(this) : this._dirParent.stopManagingContentDirection(this), this.removeAttribute("dir"));
    }
  }
  return o52;
}
var c4, g2, w2, p3, SpectrumElement;
var init_Base = __esm({
  "node_modules/@spectrum-web-components/base/src/Base.js"() {
    "use strict";
    init_version();
    init_lit();
    c4 = /* @__PURE__ */ new Set();
    g2 = () => {
      const s19 = document.documentElement.dir === "rtl" ? document.documentElement.dir : "ltr";
      c4.forEach((o52) => {
        o52.setAttribute("dir", s19);
      });
    };
    w2 = new MutationObserver(g2);
    w2.observe(document.documentElement, { attributes: true, attributeFilter: ["dir"] });
    p3 = (s19) => typeof s19.startManagingContentDirection != "undefined" || s19.tagName === "SP-THEME";
    SpectrumElement = class extends SpectrumMixin(i4) {
    };
    SpectrumElement.VERSION = version;
  }
});

// node_modules/@lit/reactive-element/decorators/custom-element.js
var init_custom_element = __esm({
  "node_modules/@lit/reactive-element/decorators/custom-element.js"() {
  }
});

// node_modules/@lit/reactive-element/decorators/property.js
function n4(t34) {
  return (e36, o52) => "object" == typeof o52 ? r4(t34, e36, o52) : ((t35, e37, o53) => {
    const r25 = e37.hasOwnProperty(o53);
    return e37.constructor.createProperty(o53, t35), r25 ? Object.getOwnPropertyDescriptor(e37, o53) : void 0;
  })(t34, e36, o52);
}
var o7, r4;
var init_property = __esm({
  "node_modules/@lit/reactive-element/decorators/property.js"() {
    init_reactive_element();
    o7 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
    r4 = (t34 = o7, e36, r25) => {
      const { kind: n25, metadata: i21 } = r25;
      let s19 = globalThis.litPropertyMetadata.get(i21);
      if (void 0 === s19 && globalThis.litPropertyMetadata.set(i21, s19 = /* @__PURE__ */ new Map()), "setter" === n25 && ((t34 = Object.create(t34)).wrapped = true), s19.set(r25.name, t34), "accessor" === n25) {
        const { name: o52 } = r25;
        return { set(r26) {
          const n26 = e36.get.call(this);
          e36.set.call(this, r26), this.requestUpdate(o52, n26, t34);
        }, init(e37) {
          return void 0 !== e37 && this.C(o52, void 0, t34, e37), e37;
        } };
      }
      if ("setter" === n25) {
        const { name: o52 } = r25;
        return function(r26) {
          const n26 = this[o52];
          e36.call(this, r26), this.requestUpdate(o52, n26, t34);
        };
      }
      throw Error("Unsupported decorator location: " + n25);
    };
  }
});

// node_modules/@lit/reactive-element/decorators/state.js
function r5(r25) {
  return n4({ ...r25, state: true, attribute: false });
}
var init_state = __esm({
  "node_modules/@lit/reactive-element/decorators/state.js"() {
    init_property();
  }
});

// node_modules/@lit/reactive-element/decorators/event-options.js
var init_event_options = __esm({
  "node_modules/@lit/reactive-element/decorators/event-options.js"() {
  }
});

// node_modules/@lit/reactive-element/decorators/base.js
var e4;
var init_base = __esm({
  "node_modules/@lit/reactive-element/decorators/base.js"() {
    e4 = (e36, t34, c33) => (c33.configurable = true, c33.enumerable = true, Reflect.decorate && "object" != typeof t34 && Object.defineProperty(e36, t34, c33), c33);
  }
});

// node_modules/@lit/reactive-element/decorators/query.js
function e5(e36, r25) {
  return (n25, s19, i21) => {
    const o52 = (t34) => t34.renderRoot?.querySelector(e36) ?? null;
    if (r25) {
      const { get: e37, set: r26 } = "object" == typeof s19 ? n25 : i21 ?? (() => {
        const t34 = Symbol();
        return { get() {
          return this[t34];
        }, set(e38) {
          this[t34] = e38;
        } };
      })();
      return e4(n25, s19, { get() {
        let t34 = e37.call(this);
        return void 0 === t34 && (t34 = o52(this), (null !== t34 || this.hasUpdated) && r26.call(this, t34)), t34;
      } });
    }
    return e4(n25, s19, { get() {
      return o52(this);
    } });
  };
}
var init_query = __esm({
  "node_modules/@lit/reactive-element/decorators/query.js"() {
    init_base();
  }
});

// node_modules/@lit/reactive-element/decorators/query-all.js
var init_query_all = __esm({
  "node_modules/@lit/reactive-element/decorators/query-all.js"() {
    init_base();
  }
});

// node_modules/@lit/reactive-element/decorators/query-async.js
var init_query_async = __esm({
  "node_modules/@lit/reactive-element/decorators/query-async.js"() {
    init_base();
  }
});

// node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
function o8(o52) {
  return (e36, n25) => {
    const { slot: r25, selector: s19 } = o52 ?? {}, c33 = "slot" + (r25 ? `[name=${r25}]` : ":not([name])");
    return e4(e36, n25, { get() {
      const t34 = this.renderRoot?.querySelector(c33), e37 = t34?.assignedElements(o52) ?? [];
      return void 0 === s19 ? e37 : e37.filter((t35) => t35.matches(s19));
    } });
  };
}
var init_query_assigned_elements = __esm({
  "node_modules/@lit/reactive-element/decorators/query-assigned-elements.js"() {
    init_base();
  }
});

// node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js
function n5(n25) {
  return (o52, r25) => {
    const { slot: e36 } = n25 ?? {}, s19 = "slot" + (e36 ? `[name=${e36}]` : ":not([name])");
    return e4(o52, r25, { get() {
      const t34 = this.renderRoot?.querySelector(s19);
      return t34?.assignedNodes(n25) ?? [];
    } });
  };
}
var init_query_assigned_nodes = __esm({
  "node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js"() {
    init_base();
  }
});

// node_modules/lit/decorators.js
var init_decorators = __esm({
  "node_modules/lit/decorators.js"() {
    init_custom_element();
    init_property();
    init_state();
    init_event_options();
    init_query();
    init_query_all();
    init_query_async();
    init_query_assigned_elements();
    init_query_assigned_nodes();
  }
});

// node_modules/@spectrum-web-components/base/src/sizedMixin.js
function SizedMixin(r25, { validSizes: i21 = ["s", "m", "l", "xl"], noDefaultSize: s19, defaultSize: t34 = "m" } = {}) {
  class e36 extends r25 {
    constructor() {
      super(...arguments);
      this._size = t34;
    }
    get size() {
      return this._size || t34;
    }
    set size(n25) {
      const p30 = s19 ? null : t34, z3 = n25 && n25.toLocaleLowerCase(), x5 = i21.includes(z3) ? z3 : p30;
      if (x5 && this.setAttribute("size", x5), this._size === x5) return;
      const c33 = this._size;
      this._size = x5, this.requestUpdate("size", c33);
    }
    update(n25) {
      !this.hasAttribute("size") && !s19 && this.setAttribute("size", this.size), super.update(n25);
    }
  }
  return m2([n4({ type: String })], e36.prototype, "size", 1), e36;
}
var a3, u3, m2;
var init_sizedMixin = __esm({
  "node_modules/@spectrum-web-components/base/src/sizedMixin.js"() {
    "use strict";
    init_decorators();
    a3 = Object.defineProperty;
    u3 = Object.getOwnPropertyDescriptor;
    m2 = (r25, i21, s19, t34) => {
      for (var e36 = t34 > 1 ? void 0 : t34 ? u3(i21, s19) : i21, l16 = r25.length - 1, o52; l16 >= 0; l16--) (o52 = r25[l16]) && (e36 = (t34 ? o52(i21, s19, e36) : o52(e36)) || e36);
      return t34 && e36 && a3(i21, s19, e36), e36;
    };
  }
});

// node_modules/@spectrum-web-components/base/src/constants.js
var INPUT_COMPONENT_TAGS, INPUT_COMPONENT_PATTERN;
var init_constants = __esm({
  "node_modules/@spectrum-web-components/base/src/constants.js"() {
    "use strict";
    INPUT_COMPONENT_TAGS = ["SP-SEARCH", "SP-TEXTFIELD", "SP-NUMBER-FIELD", "SP-COMBOBOX", "SP-COLOR-FIELD"];
    INPUT_COMPONENT_PATTERN = new RegExp(`^(${INPUT_COMPONENT_TAGS.join("|")})$`);
  }
});

// node_modules/@spectrum-web-components/base/src/index.js
var init_src = __esm({
  "node_modules/@spectrum-web-components/base/src/index.js"() {
    "use strict";
    init_Base();
    init_sizedMixin();
    init_constants();
    init_lit();
  }
});

// node_modules/@spectrum-web-components/base/src/decorators.js
var init_decorators2 = __esm({
  "node_modules/@spectrum-web-components/base/src/decorators.js"() {
    "use strict";
    init_decorators();
  }
});

// node_modules/lit-html/directives/if-defined.js
var o9;
var init_if_defined = __esm({
  "node_modules/lit-html/directives/if-defined.js"() {
    init_lit_html();
    o9 = (o52) => o52 ?? E;
  }
});

// node_modules/lit/directives/if-defined.js
var init_if_defined2 = __esm({
  "node_modules/lit/directives/if-defined.js"() {
    init_if_defined();
  }
});

// node_modules/lit-html/directive.js
var t4, e9, i5;
var init_directive = __esm({
  "node_modules/lit-html/directive.js"() {
    t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
    e9 = (t34) => (...e36) => ({ _$litDirective$: t34, values: e36 });
    i5 = class {
      constructor(t34) {
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AT(t34, e36, i21) {
        this._$Ct = t34, this._$AM = e36, this._$Ci = i21;
      }
      _$AS(t34, e36) {
        return this.update(t34, e36);
      }
      update(t34, e36) {
        return this.render(...e36);
      }
    };
  }
});

// node_modules/lit-html/directive-helpers.js
var t5, i6, f3, r6, s4, v2, u4, m3, p4, M2;
var init_directive_helpers = __esm({
  "node_modules/lit-html/directive-helpers.js"() {
    init_lit_html();
    ({ I: t5 } = Z);
    i6 = (o52) => null === o52 || "object" != typeof o52 && "function" != typeof o52;
    f3 = (o52) => void 0 === o52.strings;
    r6 = () => document.createComment("");
    s4 = (o52, i21, n25) => {
      const e36 = o52._$AA.parentNode, l16 = void 0 === i21 ? o52._$AB : i21._$AA;
      if (void 0 === n25) {
        const i22 = e36.insertBefore(r6(), l16), d22 = e36.insertBefore(r6(), l16);
        n25 = new t5(i22, d22, o52, o52.options);
      } else {
        const t34 = n25._$AB.nextSibling, i22 = n25._$AM, d22 = i22 !== o52;
        if (d22) {
          let t35;
          n25._$AQ?.(o52), n25._$AM = o52, void 0 !== n25._$AP && (t35 = o52._$AU) !== i22._$AU && n25._$AP(t35);
        }
        if (t34 !== l16 || d22) {
          let o53 = n25._$AA;
          for (; o53 !== t34; ) {
            const t35 = o53.nextSibling;
            e36.insertBefore(o53, l16), o53 = t35;
          }
        }
      }
      return n25;
    };
    v2 = (o52, t34, i21 = o52) => (o52._$AI(t34, i21), o52);
    u4 = {};
    m3 = (o52, t34 = u4) => o52._$AH = t34;
    p4 = (o52) => o52._$AH;
    M2 = (o52) => {
      o52._$AR(), o52._$AA.remove();
    };
  }
});

// node_modules/lit-html/directives/repeat.js
var u5, c5;
var init_repeat = __esm({
  "node_modules/lit-html/directives/repeat.js"() {
    init_lit_html();
    init_directive();
    init_directive_helpers();
    u5 = (e36, s19, t34) => {
      const r25 = /* @__PURE__ */ new Map();
      for (let l16 = s19; l16 <= t34; l16++) r25.set(e36[l16], l16);
      return r25;
    };
    c5 = e9(class extends i5 {
      constructor(e36) {
        if (super(e36), e36.type !== t4.CHILD) throw Error("repeat() can only be used in text expressions");
      }
      dt(e36, s19, t34) {
        let r25;
        void 0 === t34 ? t34 = s19 : void 0 !== s19 && (r25 = s19);
        const l16 = [], o52 = [];
        let i21 = 0;
        for (const s20 of e36) l16[i21] = r25 ? r25(s20, i21) : i21, o52[i21] = t34(s20, i21), i21++;
        return { values: o52, keys: l16 };
      }
      render(e36, s19, t34) {
        return this.dt(e36, s19, t34).values;
      }
      update(s19, [t34, r25, c33]) {
        const d22 = p4(s19), { values: p30, keys: a23 } = this.dt(t34, r25, c33);
        if (!Array.isArray(d22)) return this.ut = a23, p30;
        const h16 = this.ut ??= [], v6 = [];
        let m18, y5, x5 = 0, j3 = d22.length - 1, k2 = 0, w3 = p30.length - 1;
        for (; x5 <= j3 && k2 <= w3; ) if (null === d22[x5]) x5++;
        else if (null === d22[j3]) j3--;
        else if (h16[x5] === a23[k2]) v6[k2] = v2(d22[x5], p30[k2]), x5++, k2++;
        else if (h16[j3] === a23[w3]) v6[w3] = v2(d22[j3], p30[w3]), j3--, w3--;
        else if (h16[x5] === a23[w3]) v6[w3] = v2(d22[x5], p30[w3]), s4(s19, v6[w3 + 1], d22[x5]), x5++, w3--;
        else if (h16[j3] === a23[k2]) v6[k2] = v2(d22[j3], p30[k2]), s4(s19, d22[x5], d22[j3]), j3--, k2++;
        else if (void 0 === m18 && (m18 = u5(a23, k2, w3), y5 = u5(h16, x5, j3)), m18.has(h16[x5])) if (m18.has(h16[j3])) {
          const e36 = y5.get(a23[k2]), t35 = void 0 !== e36 ? d22[e36] : null;
          if (null === t35) {
            const e37 = s4(s19, d22[x5]);
            v2(e37, p30[k2]), v6[k2] = e37;
          } else v6[k2] = v2(t35, p30[k2]), s4(s19, d22[x5], t35), d22[e36] = null;
          k2++;
        } else M2(d22[j3]), j3--;
        else M2(d22[x5]), x5++;
        for (; k2 <= w3; ) {
          const e36 = s4(s19, v6[w3 + 1]);
          v2(e36, p30[k2]), v6[k2++] = e36;
        }
        for (; x5 <= j3; ) {
          const e36 = d22[x5++];
          null !== e36 && M2(e36);
        }
        return this.ut = a23, m3(s19, v6), T;
      }
    });
  }
});

// node_modules/lit/directives/repeat.js
var init_repeat2 = __esm({
  "node_modules/lit/directives/repeat.js"() {
    init_repeat();
  }
});

// node_modules/lit-html/directives/class-map.js
var e10;
var init_class_map = __esm({
  "node_modules/lit-html/directives/class-map.js"() {
    init_lit_html();
    init_directive();
    e10 = e9(class extends i5 {
      constructor(t34) {
        if (super(t34), t34.type !== t4.ATTRIBUTE || "class" !== t34.name || t34.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
      }
      render(t34) {
        return " " + Object.keys(t34).filter((s19) => t34[s19]).join(" ") + " ";
      }
      update(s19, [i21]) {
        if (void 0 === this.st) {
          this.st = /* @__PURE__ */ new Set(), void 0 !== s19.strings && (this.nt = new Set(s19.strings.join(" ").split(/\s/).filter((t34) => "" !== t34)));
          for (const t34 in i21) i21[t34] && !this.nt?.has(t34) && this.st.add(t34);
          return this.render(i21);
        }
        const r25 = s19.element.classList;
        for (const t34 of this.st) t34 in i21 || (r25.remove(t34), this.st.delete(t34));
        for (const t34 in i21) {
          const s20 = !!i21[t34];
          s20 === this.st.has(t34) || this.nt?.has(t34) || (s20 ? (r25.add(t34), this.st.add(t34)) : (r25.remove(t34), this.st.delete(t34)));
        }
        return T;
      }
    });
  }
});

// node_modules/lit/directives/class-map.js
var init_class_map2 = __esm({
  "node_modules/lit/directives/class-map.js"() {
    init_class_map();
  }
});

// node_modules/lit-html/directives/style-map.js
var n6, i7, o10;
var init_style_map = __esm({
  "node_modules/lit-html/directives/style-map.js"() {
    init_lit_html();
    init_directive();
    n6 = "important";
    i7 = " !" + n6;
    o10 = e9(class extends i5 {
      constructor(t34) {
        if (super(t34), t34.type !== t4.ATTRIBUTE || "style" !== t34.name || t34.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
      }
      render(t34) {
        return Object.keys(t34).reduce((e36, r25) => {
          const s19 = t34[r25];
          return null == s19 ? e36 : e36 + `${r25 = r25.includes("-") ? r25 : r25.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s19};`;
        }, "");
      }
      update(e36, [r25]) {
        const { style: s19 } = e36.element;
        if (void 0 === this.ft) return this.ft = new Set(Object.keys(r25)), this.render(r25);
        for (const t34 of this.ft) null == r25[t34] && (this.ft.delete(t34), t34.includes("-") ? s19.removeProperty(t34) : s19[t34] = null);
        for (const t34 in r25) {
          const e37 = r25[t34];
          if (null != e37) {
            this.ft.add(t34);
            const r26 = "string" == typeof e37 && e37.endsWith(i7);
            t34.includes("-") || r26 ? s19.setProperty(t34, r26 ? e37.slice(0, -11) : e37, r26 ? n6 : "") : s19[t34] = e37;
          }
        }
        return T;
      }
    });
  }
});

// node_modules/lit/directives/style-map.js
var init_style_map2 = __esm({
  "node_modules/lit/directives/style-map.js"() {
    init_style_map();
  }
});

// node_modules/lit-html/async-directive.js
function h3(i21) {
  void 0 !== this._$AN ? (o11(this), this._$AM = i21, r7(this)) : this._$AM = i21;
}
function n7(i21, t34 = false, e36 = 0) {
  const r25 = this._$AH, h16 = this._$AN;
  if (void 0 !== h16 && 0 !== h16.size) if (t34) if (Array.isArray(r25)) for (let i22 = e36; i22 < r25.length; i22++) s5(r25[i22], false), o11(r25[i22]);
  else null != r25 && (s5(r25, false), o11(r25));
  else s5(this, i21);
}
var s5, o11, r7, c6, f4;
var init_async_directive = __esm({
  "node_modules/lit-html/async-directive.js"() {
    init_directive_helpers();
    init_directive();
    init_directive();
    s5 = (i21, t34) => {
      const e36 = i21._$AN;
      if (void 0 === e36) return false;
      for (const i22 of e36) i22._$AO?.(t34, false), s5(i22, t34);
      return true;
    };
    o11 = (i21) => {
      let t34, e36;
      do {
        if (void 0 === (t34 = i21._$AM)) break;
        e36 = t34._$AN, e36.delete(i21), i21 = t34;
      } while (0 === e36?.size);
    };
    r7 = (i21) => {
      for (let t34; t34 = i21._$AM; i21 = t34) {
        let e36 = t34._$AN;
        if (void 0 === e36) t34._$AN = e36 = /* @__PURE__ */ new Set();
        else if (e36.has(i21)) break;
        e36.add(i21), c6(t34);
      }
    };
    c6 = (i21) => {
      i21.type == t4.CHILD && (i21._$AP ??= n7, i21._$AQ ??= h3);
    };
    f4 = class extends i5 {
      constructor() {
        super(...arguments), this._$AN = void 0;
      }
      _$AT(i21, t34, e36) {
        super._$AT(i21, t34, e36), r7(this), this.isConnected = i21._$AU;
      }
      _$AO(i21, t34 = true) {
        i21 !== this.isConnected && (this.isConnected = i21, i21 ? this.reconnected?.() : this.disconnected?.()), t34 && (s5(this, i21), o11(this));
      }
      setValue(t34) {
        if (f3(this._$Ct)) this._$Ct._$AI(t34, this);
        else {
          const i21 = [...this._$Ct._$AH];
          i21[this._$Ci] = t34, this._$Ct._$AI(i21, this, 0);
        }
      }
      disconnected() {
      }
      reconnected() {
      }
    };
  }
});

// node_modules/lit-html/directives/private-async-helpers.js
var s6, i8;
var init_private_async_helpers = __esm({
  "node_modules/lit-html/directives/private-async-helpers.js"() {
    s6 = class {
      constructor(t34) {
        this.G = t34;
      }
      disconnect() {
        this.G = void 0;
      }
      reconnect(t34) {
        this.G = t34;
      }
      deref() {
        return this.G;
      }
    };
    i8 = class {
      constructor() {
        this.Y = void 0, this.Z = void 0;
      }
      get() {
        return this.Y;
      }
      pause() {
        this.Y ??= new Promise((t34) => this.Z = t34);
      }
      resume() {
        this.Z?.(), this.Y = this.Z = void 0;
      }
    };
  }
});

// node_modules/lit-html/directives/until.js
var n8, h4, c7, m4;
var init_until = __esm({
  "node_modules/lit-html/directives/until.js"() {
    init_lit_html();
    init_directive_helpers();
    init_async_directive();
    init_private_async_helpers();
    init_directive();
    n8 = (t34) => !i6(t34) && "function" == typeof t34.then;
    h4 = 1073741823;
    c7 = class extends f4 {
      constructor() {
        super(...arguments), this._$Cwt = h4, this._$Cbt = [], this._$CK = new s6(this), this._$CX = new i8();
      }
      render(...s19) {
        return s19.find((t34) => !n8(t34)) ?? T;
      }
      update(s19, i21) {
        const e36 = this._$Cbt;
        let r25 = e36.length;
        this._$Cbt = i21;
        const o52 = this._$CK, c33 = this._$CX;
        this.isConnected || this.disconnected();
        for (let t34 = 0; t34 < i21.length && !(t34 > this._$Cwt); t34++) {
          const s20 = i21[t34];
          if (!n8(s20)) return this._$Cwt = t34, s20;
          t34 < r25 && s20 === e36[t34] || (this._$Cwt = h4, r25 = 0, Promise.resolve(s20).then(async (t35) => {
            for (; c33.get(); ) await c33.get();
            const i22 = o52.deref();
            if (void 0 !== i22) {
              const e37 = i22._$Cbt.indexOf(s20);
              e37 > -1 && e37 < i22._$Cwt && (i22._$Cwt = e37, i22.setValue(t35));
            }
          }));
        }
        return T;
      }
      disconnected() {
        this._$CK.disconnect(), this._$CX.pause();
      }
      reconnected() {
        this._$CK.reconnect(this), this._$CX.resume();
      }
    };
    m4 = e9(c7);
  }
});

// node_modules/lit/directives/until.js
var init_until2 = __esm({
  "node_modules/lit/directives/until.js"() {
    init_until();
  }
});

// node_modules/lit-html/directives/live.js
var l3;
var init_live = __esm({
  "node_modules/lit-html/directives/live.js"() {
    init_lit_html();
    init_directive();
    init_directive_helpers();
    l3 = e9(class extends i5 {
      constructor(r25) {
        if (super(r25), r25.type !== t4.PROPERTY && r25.type !== t4.ATTRIBUTE && r25.type !== t4.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
        if (!f3(r25)) throw Error("`live` bindings can only contain a single expression");
      }
      render(r25) {
        return r25;
      }
      update(i21, [t34]) {
        if (t34 === T || t34 === E) return t34;
        const o52 = i21.element, l16 = i21.name;
        if (i21.type === t4.PROPERTY) {
          if (t34 === o52[l16]) return T;
        } else if (i21.type === t4.BOOLEAN_ATTRIBUTE) {
          if (!!t34 === o52.hasAttribute(l16)) return T;
        } else if (i21.type === t4.ATTRIBUTE && o52.getAttribute(l16) === t34 + "") return T;
        return m3(i21), t34;
      }
    });
  }
});

// node_modules/lit/directives/live.js
var init_live2 = __esm({
  "node_modules/lit/directives/live.js"() {
    init_live();
  }
});

// node_modules/lit-html/directives/when.js
function n9(n25, r25, t34) {
  return n25 ? r25(n25) : t34?.(n25);
}
var init_when = __esm({
  "node_modules/lit-html/directives/when.js"() {
  }
});

// node_modules/lit/directives/when.js
var init_when2 = __esm({
  "node_modules/lit/directives/when.js"() {
    init_when();
  }
});

// node_modules/lit-html/directives/join.js
var init_join = __esm({
  "node_modules/lit-html/directives/join.js"() {
  }
});

// node_modules/lit/directives/join.js
var init_join2 = __esm({
  "node_modules/lit/directives/join.js"() {
    init_join();
  }
});

// node_modules/lit-html/directives/unsafe-html.js
var e11, o12;
var init_unsafe_html = __esm({
  "node_modules/lit-html/directives/unsafe-html.js"() {
    init_lit_html();
    init_directive();
    e11 = class extends i5 {
      constructor(i21) {
        if (super(i21), this.it = E, i21.type !== t4.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
      }
      render(r25) {
        if (r25 === E || null == r25) return this._t = void 0, this.it = r25;
        if (r25 === T) return r25;
        if ("string" != typeof r25) throw Error(this.constructor.directiveName + "() called with a non-string value");
        if (r25 === this.it) return this._t;
        this.it = r25;
        const s19 = [r25];
        return s19.raw = s19, this._t = { _$litType$: this.constructor.resultType, strings: s19, values: [] };
      }
    };
    e11.directiveName = "unsafeHTML", e11.resultType = 1;
    o12 = e9(e11);
  }
});

// node_modules/lit/directives/unsafe-html.js
var init_unsafe_html2 = __esm({
  "node_modules/lit/directives/unsafe-html.js"() {
    init_unsafe_html();
  }
});

// node_modules/lit-html/directives/ref.js
var e12, h5, o13, n10;
var init_ref = __esm({
  "node_modules/lit-html/directives/ref.js"() {
    init_lit_html();
    init_async_directive();
    init_directive();
    e12 = () => new h5();
    h5 = class {
    };
    o13 = /* @__PURE__ */ new WeakMap();
    n10 = e9(class extends f4 {
      render(i21) {
        return E;
      }
      update(i21, [s19]) {
        const e36 = s19 !== this.G;
        return e36 && void 0 !== this.G && this.rt(void 0), (e36 || this.lt !== this.ct) && (this.G = s19, this.ht = i21.options?.host, this.rt(this.ct = i21.element)), E;
      }
      rt(t34) {
        if (this.isConnected || (t34 = void 0), "function" == typeof this.G) {
          const i21 = this.ht ?? globalThis;
          let s19 = o13.get(i21);
          void 0 === s19 && (s19 = /* @__PURE__ */ new WeakMap(), o13.set(i21, s19)), void 0 !== s19.get(this.G) && this.G.call(this.ht, void 0), s19.set(this.G, t34), void 0 !== t34 && this.G.call(this.ht, t34);
        } else this.G.value = t34;
      }
      get lt() {
        return "function" == typeof this.G ? o13.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
      }
      disconnected() {
        this.lt === this.ct && this.rt(void 0);
      }
      reconnected() {
        this.rt(this.ct);
      }
    });
  }
});

// node_modules/lit/directives/ref.js
var init_ref2 = __esm({
  "node_modules/lit/directives/ref.js"() {
    init_ref();
  }
});

// node_modules/@spectrum-web-components/base/src/directives.js
var init_directives = __esm({
  "node_modules/@spectrum-web-components/base/src/directives.js"() {
    "use strict";
    init_if_defined2();
    init_repeat2();
    init_class_map2();
    init_style_map2();
    init_until2();
    init_live2();
    init_when2();
    init_join2();
    init_unsafe_html2();
    init_ref2();
  }
});

// node_modules/@spectrum-web-components/shared/src/get-label-from-slot.js
var getLabelFromSlot;
var init_get_label_from_slot = __esm({
  "node_modules/@spectrum-web-components/shared/src/get-label-from-slot.js"() {
    "use strict";
    getLabelFromSlot = (r25, l16) => {
      if (r25) return null;
      const t34 = l16.assignedNodes().reduce((e36, n25) => n25.textContent ? e36 + n25.textContent : e36, "");
      return t34 ? t34.trim() : null;
    };
  }
});

// node_modules/@spectrum-web-components/progress-circle/src/progress-circle.css.js
var e13, progress_circle_css_default;
var init_progress_circle_css = __esm({
  "node_modules/@spectrum-web-components/progress-circle/src/progress-circle.css.js"() {
    "use strict";
    init_src();
    e13 = i`
    @media (forced-colors:active){:host{--highcontrast-progress-circle-fill-border-color:Highlight;--highcontrast-progress-circle-fill-border-color-over-background:Highlight}.track{--spectrum-progress-circle-track-border-style:double}}:host{--spectrum-progress-circle-track-border-color:var(--spectrum-gray-300);--spectrum-progress-circle-fill-border-color:var(--spectrum-accent-content-color-default);--spectrum-progress-circle-track-border-color-over-background:var(--spectrum-transparent-white-300);--spectrum-progress-circle-fill-border-color-over-background:var(--spectrum-transparent-white-900);--spectrum-progress-circle-track-border-style:solid;inline-size:var(--mod-progress-circle-size,var(--spectrum-progress-circle-size));block-size:var(--mod-progress-circle-size,var(--spectrum-progress-circle-size));position:var(--mod-progress-circle-position,relative);direction:ltr;display:inline-block;position:relative;transform:translateZ(0)}:host([size=s]){--spectrum-progress-circle-size:var(--spectrum-progress-circle-size-small);--spectrum-progress-circle-thickness:var(--spectrum-progress-circle-thickness-small)}:host{--spectrum-progress-circle-size:var(--spectrum-progress-circle-size-medium);--spectrum-progress-circle-thickness:var(--spectrum-progress-circle-thickness-medium)}:host([size=l]){--spectrum-progress-circle-size:var(--spectrum-progress-circle-size-large);--spectrum-progress-circle-thickness:var(--spectrum-progress-circle-thickness-large)}.track{box-sizing:border-box;inline-size:var(--mod-progress-circle-size,var(--spectrum-progress-circle-size));block-size:var(--mod-progress-circle-size,var(--spectrum-progress-circle-size));border-style:var(--mod-progress-circle-track-border-style,var(--spectrum-progress-circle-track-border-style));border-width:var(--mod-progress-circle-thickness,var(--spectrum-progress-circle-thickness));border-radius:var(--mod-progress-circle-size,var(--spectrum-progress-circle-size));border-color:var(--mod-progress-circle-track-border-color,var(--spectrum-progress-circle-track-border-color))}.fills{block-size:100%;inline-size:100%;position:absolute;inset-block-start:0;inset-inline-start:0}.fill{box-sizing:border-box;inline-size:var(--mod-progress-circle-size,var(--spectrum-progress-circle-size));block-size:var(--mod-progress-circle-size,var(--spectrum-progress-circle-size));border-style:solid;border-width:var(--mod-progress-circle-thickness,var(--spectrum-progress-circle-thickness));border-radius:var(--mod-progress-circle-size,var(--spectrum-progress-circle-size));border-color:var(--highcontrast-progress-circle-fill-border-color,var(--mod-progress-circle-fill-border-color,var(--spectrum-progress-circle-fill-border-color)))}:host([static-color=white]) .track{border-color:var(--mod-progress-circle-track-border-color-over-background,var(--spectrum-progress-circle-track-border-color-over-background))}:host([static-color=white]) .fill{border-color:var(--highcontrast-progress-circle-fill-border-color-over-background,var(--mod-progress-circle-fill-border-color-over-background,var(--spectrum-progress-circle-fill-border-color-over-background)))}.fillMask1,.fillMask2{transform-origin:100%;block-size:100%;inline-size:50%;position:absolute;overflow:hidden;transform:rotate(180deg)}.fillSubMask1,.fillSubMask2{transform-origin:100%;block-size:100%;inline-size:100%;overflow:hidden;transform:rotate(-180deg)}.fillMask2{transform:rotate(0)}:host([indeterminate]) .fills{will-change:transform;transform-origin:50%;animation:1s cubic-bezier(.25,.78,.48,.89) infinite spectrum-fills-rotate;transform:translateZ(0)}:host([indeterminate]) .fillSubMask1{will-change:transform;animation:1s linear infinite spectrum-fill-mask-1;transform:translateZ(0)}:host([indeterminate]) .fillSubMask2{will-change:transform;animation:1s linear infinite spectrum-fill-mask-2;transform:translateZ(0)}.fill-submask-2{animation:1s linear infinite spectrum-fill-mask-2}@keyframes spectrum-fill-mask-1{0%{transform:rotate(90deg)}1.69%{transform:rotate(72.3deg)}3.39%{transform:rotate(55.5deg)}5.08%{transform:rotate(40.3deg)}6.78%{transform:rotate(25deg)}8.47%{transform:rotate(10.6deg)}10.17%{transform:rotate(0)}11.86%{transform:rotate(0)}13.56%{transform:rotate(0)}15.25%{transform:rotate(0)}16.95%{transform:rotate(0)}18.64%{transform:rotate(0)}20.34%{transform:rotate(0)}22.03%{transform:rotate(0)}23.73%{transform:rotate(0)}25.42%{transform:rotate(0)}27.12%{transform:rotate(0)}28.81%{transform:rotate(0)}30.51%{transform:rotate(0)}32.2%{transform:rotate(0)}33.9%{transform:rotate(0)}35.59%{transform:rotate(0)}37.29%{transform:rotate(0)}38.98%{transform:rotate(0)}40.68%{transform:rotate(0)}42.37%{transform:rotate(5.3deg)}44.07%{transform:rotate(13.4deg)}45.76%{transform:rotate(20.6deg)}47.46%{transform:rotate(29deg)}49.15%{transform:rotate(36.5deg)}50.85%{transform:rotate(42.6deg)}52.54%{transform:rotate(48.8deg)}54.24%{transform:rotate(54.2deg)}55.93%{transform:rotate(59.4deg)}57.63%{transform:rotate(63.2deg)}59.32%{transform:rotate(67.2deg)}61.02%{transform:rotate(70.8deg)}62.71%{transform:rotate(73.8deg)}64.41%{transform:rotate(76.2deg)}66.1%{transform:rotate(78.7deg)}67.8%{transform:rotate(80.6deg)}69.49%{transform:rotate(82.6deg)}71.19%{transform:rotate(83.7deg)}72.88%{transform:rotate(85deg)}74.58%{transform:rotate(86.3deg)}76.27%{transform:rotate(87deg)}77.97%{transform:rotate(87.7deg)}79.66%{transform:rotate(88.3deg)}81.36%{transform:rotate(88.6deg)}83.05%{transform:rotate(89.2deg)}84.75%{transform:rotate(89.2deg)}86.44%{transform:rotate(89.5deg)}88.14%{transform:rotate(89.9deg)}89.83%{transform:rotate(89.7deg)}91.53%{transform:rotate(90.1deg)}93.22%{transform:rotate(90.2deg)}94.92%{transform:rotate(90.1deg)}96.61%{transform:rotate(90deg)}98.31%{transform:rotate(89.8deg)}to{transform:rotate(90deg)}}@keyframes spectrum-fill-mask-2{0%{transform:rotate(180deg)}1.69%{transform:rotate(180deg)}3.39%{transform:rotate(180deg)}5.08%{transform:rotate(180deg)}6.78%{transform:rotate(180deg)}8.47%{transform:rotate(180deg)}10.17%{transform:rotate(179.2deg)}11.86%{transform:rotate(164deg)}13.56%{transform:rotate(151.8deg)}15.25%{transform:rotate(140.8deg)}16.95%{transform:rotate(130.3deg)}18.64%{transform:rotate(120.4deg)}20.34%{transform:rotate(110.8deg)}22.03%{transform:rotate(101.6deg)}23.73%{transform:rotate(93.5deg)}25.42%{transform:rotate(85.4deg)}27.12%{transform:rotate(78.1deg)}28.81%{transform:rotate(71.2deg)}30.51%{transform:rotate(89.1deg)}32.2%{transform:rotate(105.5deg)}33.9%{transform:rotate(121.3deg)}35.59%{transform:rotate(135.5deg)}37.29%{transform:rotate(148.4deg)}38.98%{transform:rotate(161deg)}40.68%{transform:rotate(173.5deg)}42.37%{transform:rotate(180deg)}44.07%{transform:rotate(180deg)}45.76%{transform:rotate(180deg)}47.46%{transform:rotate(180deg)}49.15%{transform:rotate(180deg)}50.85%{transform:rotate(180deg)}52.54%{transform:rotate(180deg)}54.24%{transform:rotate(180deg)}55.93%{transform:rotate(180deg)}57.63%{transform:rotate(180deg)}59.32%{transform:rotate(180deg)}61.02%{transform:rotate(180deg)}62.71%{transform:rotate(180deg)}64.41%{transform:rotate(180deg)}66.1%{transform:rotate(180deg)}67.8%{transform:rotate(180deg)}69.49%{transform:rotate(180deg)}71.19%{transform:rotate(180deg)}72.88%{transform:rotate(180deg)}74.58%{transform:rotate(180deg)}76.27%{transform:rotate(180deg)}77.97%{transform:rotate(180deg)}79.66%{transform:rotate(180deg)}81.36%{transform:rotate(180deg)}83.05%{transform:rotate(180deg)}84.75%{transform:rotate(180deg)}86.44%{transform:rotate(180deg)}88.14%{transform:rotate(180deg)}89.83%{transform:rotate(180deg)}91.53%{transform:rotate(180deg)}93.22%{transform:rotate(180deg)}94.92%{transform:rotate(180deg)}96.61%{transform:rotate(180deg)}98.31%{transform:rotate(180deg)}to{transform:rotate(180deg)}}@keyframes spectrum-fills-rotate{0%{transform:rotate(-90deg)}to{transform:rotate(270deg)}}:host{--spectrum-progress-circle-track-border-color:var(--system-progress-circle-track-border-color);--spectrum-progress-circle-track-border-color-over-background:var(--system-progress-circle-track-border-color-over-background);--spectrum-progress-circle-fill-border-color-over-background:var(--system-progress-circle-fill-border-color-over-background)}:host{block-size:var(--mod-progress-circle-size,var(--_spectrum-progress-circle-size));inline-size:var(--mod-progress-circle-size,var(--_spectrum-progress-circle-size));--spectrum-progress-circle-size:inherit;--spectrum-progresscircle-m-over-background-track-fill-color:var(--spectrum-alias-track-fill-color-overbackground);--_spectrum-progress-circle-size:var(--spectrum-progress-circle-size,var(--spectrum-progress-circle-size-medium))}:host([size=s]){--_spectrum-progress-circle-size:var(--spectrum-progress-circle-size,var(--spectrum-progress-circle-size-small))}:host([size=l]){--_spectrum-progress-circle-size:var(--spectrum-progress-circle-size,var(--spectrum-progress-circle-size-large))}slot{display:none}.track,.fill{block-size:var(--mod-progress-circle-size,var(--_spectrum-progress-circle-size));border-radius:var(--mod-progress-circle-size,var(--_spectrum-progress-circle-size));inline-size:var(--mod-progress-circle-size,var(--_spectrum-progress-circle-size))}:host([indeterminate]) .fills,:host([indeterminate]) .fillSubMask1,:host([indeterminate]) .fillSubMask2{animation-duration:var(--spectrum-animation-duration-2000)}
`;
    progress_circle_css_default = e13;
  }
});

// node_modules/@spectrum-web-components/progress-circle/src/ProgressCircle.js
var d3, b3, l4, ProgressCircle;
var init_ProgressCircle = __esm({
  "node_modules/@spectrum-web-components/progress-circle/src/ProgressCircle.js"() {
    "use strict";
    init_src();
    init_decorators2();
    init_directives();
    init_get_label_from_slot();
    init_progress_circle_css();
    d3 = Object.defineProperty;
    b3 = Object.getOwnPropertyDescriptor;
    l4 = (o52, s19, e36, i21) => {
      for (var t34 = i21 > 1 ? void 0 : i21 ? b3(s19, e36) : s19, r25 = o52.length - 1, n25; r25 >= 0; r25--) (n25 = o52[r25]) && (t34 = (i21 ? n25(s19, e36, t34) : n25(t34)) || t34);
      return i21 && t34 && d3(s19, e36, t34), t34;
    };
    ProgressCircle = class extends SizedMixin(SpectrumElement, { validSizes: ["s", "m", "l"] }) {
      constructor() {
        super(...arguments);
        this.indeterminate = false;
        this.label = "";
        this.progress = 0;
      }
      static get styles() {
        return [progress_circle_css_default];
      }
      makeRotation(e36) {
        return this.indeterminate ? void 0 : `transform: rotate(${e36}deg);`;
      }
      render() {
        const e36 = [this.makeRotation(-180 + 3.6 * Math.min(this.progress, 50)), this.makeRotation(-180 + 3.6 * Math.max(this.progress - 50, 0))], i21 = ["Mask1", "Mask2"];
        return x`
            <slot @slotchange=${this.handleSlotchange}></slot>
            <div class="track"></div>
            <div class="fills">
                ${i21.map((t34, r25) => x`
                        <div class="fill${t34}">
                            <div
                                class="fillSub${t34}"
                                style=${o9(e36[r25])}
                            >
                                <div class="fill"></div>
                            </div>
                        </div>
                    `)}
            </div>
        `;
      }
      handleSlotchange() {
        const e36 = getLabelFromSlot(this.label, this.slotEl);
        e36 && (this.label = e36);
      }
      firstUpdated(e36) {
        super.firstUpdated(e36), this.hasAttribute("role") || this.setAttribute("role", "progressbar");
      }
      updated(e36) {
        super.updated(e36), !this.indeterminate && e36.has("progress") ? this.setAttribute("aria-valuenow", "" + this.progress) : this.hasAttribute("aria-valuenow") && this.removeAttribute("aria-valuenow"), e36.has("label") && (this.label.length ? this.setAttribute("aria-label", this.label) : e36.get("label") === this.getAttribute("aria-label") && this.removeAttribute("aria-label"));
        const i21 = () => !!(this.label || this.getAttribute("aria-label") || this.getAttribute("aria-labelledby") || this.slotEl.assignedNodes().length);
      }
    };
    l4([n4({ type: Boolean, reflect: true })], ProgressCircle.prototype, "indeterminate", 2), l4([n4({ type: String })], ProgressCircle.prototype, "label", 2), l4([n4({ reflect: true, attribute: "static-color" })], ProgressCircle.prototype, "staticColor", 2), l4([n4({ type: Number })], ProgressCircle.prototype, "progress", 2), l4([e5("slot")], ProgressCircle.prototype, "slotEl", 2);
  }
});

// node_modules/@spectrum-web-components/base/src/define-element.js
function defineElement(e36, n25) {
  window.__swc, customElements.define(e36, n25);
}
var init_define_element = __esm({
  "node_modules/@spectrum-web-components/base/src/define-element.js"() {
    "use strict";
  }
});

// node_modules/@spectrum-web-components/progress-circle/sp-progress-circle.js
var sp_progress_circle_exports = {};
var init_sp_progress_circle = __esm({
  "node_modules/@spectrum-web-components/progress-circle/sp-progress-circle.js"() {
    "use strict";
    init_ProgressCircle();
    init_define_element();
    defineElement("sp-progress-circle", ProgressCircle);
  }
});

// node_modules/@spectrum-web-components/shared/src/like-anchor.js
function LikeAnchor(s19) {
  class r25 extends s19 {
    renderAnchor({ id: i21, className: t34, ariaHidden: a23, labelledby: l16, tabindex: d22, anchorContent: g8 = x`<slot></slot>` }) {
      return x`<a
                    id=${i21}
                    class=${o9(t34)}
                    href=${o9(this.href)}
                    download=${o9(this.download)}
                    target=${o9(this.target)}
                    aria-label=${o9(this.label)}
                    aria-labelledby=${o9(l16)}
                    aria-hidden=${o9(a23 ? "true" : void 0)}
                    tabindex=${o9(d22)}
                    referrerpolicy=${o9(this.referrerpolicy)}
                    rel=${o9(this.rel)}
                >${g8}</a>`;
    }
  }
  return n12([n4()], r25.prototype, "download", 2), n12([n4()], r25.prototype, "label", 2), n12([n4()], r25.prototype, "href", 2), n12([n4()], r25.prototype, "target", 2), n12([n4()], r25.prototype, "referrerpolicy", 2), n12([n4()], r25.prototype, "rel", 2), r25;
}
var u6, f5, n12;
var init_like_anchor = __esm({
  "node_modules/@spectrum-web-components/shared/src/like-anchor.js"() {
    "use strict";
    init_src();
    init_decorators2();
    init_directives();
    u6 = Object.defineProperty;
    f5 = Object.getOwnPropertyDescriptor;
    n12 = (s19, r25, p30, i21) => {
      for (var t34 = i21 > 1 ? void 0 : i21 ? f5(r25, p30) : r25, a23 = s19.length - 1, l16; a23 >= 0; a23--) (l16 = s19[a23]) && (t34 = (i21 ? l16(r25, p30, t34) : l16(t34)) || t34);
      return i21 && t34 && u6(r25, p30, t34), t34;
    };
  }
});

// node_modules/focus-visible/dist/focus-visible.js
var require_focus_visible = __commonJS({
  "node_modules/focus-visible/dist/focus-visible.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory() : typeof define === "function" && define.amd ? define(factory) : factory();
    })(exports, function() {
      "use strict";
      function applyFocusVisiblePolyfill(scope) {
        var hadKeyboardEvent = true;
        var hadFocusVisibleRecently = false;
        var hadFocusVisibleRecentlyTimeout = null;
        var inputTypesAllowlist = {
          text: true,
          search: true,
          url: true,
          tel: true,
          email: true,
          password: true,
          number: true,
          date: true,
          month: true,
          week: true,
          time: true,
          datetime: true,
          "datetime-local": true
        };
        function isValidFocusTarget(el) {
          if (el && el !== document && el.nodeName !== "HTML" && el.nodeName !== "BODY" && "classList" in el && "contains" in el.classList) {
            return true;
          }
          return false;
        }
        function focusTriggersKeyboardModality(el) {
          var type = el.type;
          var tagName = el.tagName;
          if (tagName === "INPUT" && inputTypesAllowlist[type] && !el.readOnly) {
            return true;
          }
          if (tagName === "TEXTAREA" && !el.readOnly) {
            return true;
          }
          if (el.isContentEditable) {
            return true;
          }
          return false;
        }
        function addFocusVisibleClass(el) {
          if (el.classList.contains("focus-visible")) {
            return;
          }
          el.classList.add("focus-visible");
          el.setAttribute("data-focus-visible-added", "");
        }
        function removeFocusVisibleClass(el) {
          if (!el.hasAttribute("data-focus-visible-added")) {
            return;
          }
          el.classList.remove("focus-visible");
          el.removeAttribute("data-focus-visible-added");
        }
        function onKeyDown(e36) {
          if (e36.metaKey || e36.altKey || e36.ctrlKey) {
            return;
          }
          if (isValidFocusTarget(scope.activeElement)) {
            addFocusVisibleClass(scope.activeElement);
          }
          hadKeyboardEvent = true;
        }
        function onPointerDown(e36) {
          hadKeyboardEvent = false;
        }
        function onFocus(e36) {
          if (!isValidFocusTarget(e36.target)) {
            return;
          }
          if (hadKeyboardEvent || focusTriggersKeyboardModality(e36.target)) {
            addFocusVisibleClass(e36.target);
          }
        }
        function onBlur(e36) {
          if (!isValidFocusTarget(e36.target)) {
            return;
          }
          if (e36.target.classList.contains("focus-visible") || e36.target.hasAttribute("data-focus-visible-added")) {
            hadFocusVisibleRecently = true;
            window.clearTimeout(hadFocusVisibleRecentlyTimeout);
            hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
              hadFocusVisibleRecently = false;
            }, 100);
            removeFocusVisibleClass(e36.target);
          }
        }
        function onVisibilityChange(e36) {
          if (document.visibilityState === "hidden") {
            if (hadFocusVisibleRecently) {
              hadKeyboardEvent = true;
            }
            addInitialPointerMoveListeners();
          }
        }
        function addInitialPointerMoveListeners() {
          document.addEventListener("mousemove", onInitialPointerMove);
          document.addEventListener("mousedown", onInitialPointerMove);
          document.addEventListener("mouseup", onInitialPointerMove);
          document.addEventListener("pointermove", onInitialPointerMove);
          document.addEventListener("pointerdown", onInitialPointerMove);
          document.addEventListener("pointerup", onInitialPointerMove);
          document.addEventListener("touchmove", onInitialPointerMove);
          document.addEventListener("touchstart", onInitialPointerMove);
          document.addEventListener("touchend", onInitialPointerMove);
        }
        function removeInitialPointerMoveListeners() {
          document.removeEventListener("mousemove", onInitialPointerMove);
          document.removeEventListener("mousedown", onInitialPointerMove);
          document.removeEventListener("mouseup", onInitialPointerMove);
          document.removeEventListener("pointermove", onInitialPointerMove);
          document.removeEventListener("pointerdown", onInitialPointerMove);
          document.removeEventListener("pointerup", onInitialPointerMove);
          document.removeEventListener("touchmove", onInitialPointerMove);
          document.removeEventListener("touchstart", onInitialPointerMove);
          document.removeEventListener("touchend", onInitialPointerMove);
        }
        function onInitialPointerMove(e36) {
          if (e36.target.nodeName && e36.target.nodeName.toLowerCase() === "html") {
            return;
          }
          hadKeyboardEvent = false;
          removeInitialPointerMoveListeners();
        }
        document.addEventListener("keydown", onKeyDown, true);
        document.addEventListener("mousedown", onPointerDown, true);
        document.addEventListener("pointerdown", onPointerDown, true);
        document.addEventListener("touchstart", onPointerDown, true);
        document.addEventListener("visibilitychange", onVisibilityChange, true);
        addInitialPointerMoveListeners();
        scope.addEventListener("focus", onFocus, true);
        scope.addEventListener("blur", onBlur, true);
        if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
          scope.host.setAttribute("data-js-focus-visible", "");
        } else if (scope.nodeType === Node.DOCUMENT_NODE) {
          document.documentElement.classList.add("js-focus-visible");
          document.documentElement.setAttribute("data-js-focus-visible", "");
        }
      }
      if (typeof window !== "undefined" && typeof document !== "undefined") {
        window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;
        var event;
        try {
          event = new CustomEvent("focus-visible-polyfill-ready");
        } catch (error) {
          event = document.createEvent("CustomEvent");
          event.initCustomEvent("focus-visible-polyfill-ready", false, false, {});
        }
        window.dispatchEvent(event);
      }
      if (typeof document !== "undefined") {
        applyFocusVisiblePolyfill(document);
      }
    });
  }
});

// node_modules/@spectrum-web-components/shared/src/focus-visible.js
var i10, FocusVisiblePolyfillMixin;
var init_focus_visible = __esm({
  "node_modules/@spectrum-web-components/shared/src/focus-visible.js"() {
    "use strict";
    i10 = true;
    try {
      document.body.querySelector(":focus-visible");
    } catch (a23) {
      i10 = false, Promise.resolve().then(() => __toESM(require_focus_visible(), 1));
    }
    FocusVisiblePolyfillMixin = (a23) => {
      var s19, t34;
      const n25 = (l16) => {
        if (l16.shadowRoot == null || l16.hasAttribute("data-js-focus-visible")) return () => {
        };
        if (self.applyFocusVisiblePolyfill) self.applyFocusVisiblePolyfill(l16.shadowRoot), l16.manageAutoFocus && l16.manageAutoFocus();
        else {
          const e36 = () => {
            self.applyFocusVisiblePolyfill && l16.shadowRoot && self.applyFocusVisiblePolyfill(l16.shadowRoot), l16.manageAutoFocus && l16.manageAutoFocus();
          };
          return self.addEventListener("focus-visible-polyfill-ready", e36, { once: true }), () => {
            self.removeEventListener("focus-visible-polyfill-ready", e36);
          };
        }
        return () => {
        };
      }, o52 = Symbol("endPolyfillCoordination");
      class c33 extends (t34 = a23, s19 = o52, t34) {
        constructor() {
          super(...arguments);
          this[s19] = null;
        }
        connectedCallback() {
          super.connectedCallback && super.connectedCallback(), i10 || requestAnimationFrame(() => {
            this[o52] == null && (this[o52] = n25(this));
          });
        }
        disconnectedCallback() {
          super.disconnectedCallback && super.disconnectedCallback(), i10 || requestAnimationFrame(() => {
            this[o52] != null && (this[o52](), this[o52] = null);
          });
        }
      }
      return c33;
    };
  }
});

// node_modules/@spectrum-web-components/shared/src/focusable.js
function u7() {
  return new Promise((s19) => requestAnimationFrame(() => s19()));
}
var d4, b4, n13, Focusable;
var init_focusable = __esm({
  "node_modules/@spectrum-web-components/shared/src/focusable.js"() {
    "use strict";
    init_src();
    init_decorators2();
    init_focus_visible();
    d4 = Object.defineProperty;
    b4 = Object.getOwnPropertyDescriptor;
    n13 = (s19, a23, e36, t34) => {
      for (var i21 = t34 > 1 ? void 0 : t34 ? b4(a23, e36) : a23, o52 = s19.length - 1, r25; o52 >= 0; o52--) (r25 = s19[o52]) && (i21 = (t34 ? r25(a23, e36, i21) : r25(i21)) || i21);
      return t34 && i21 && d4(a23, e36, i21), i21;
    };
    Focusable = class extends FocusVisiblePolyfillMixin(SpectrumElement) {
      constructor() {
        super(...arguments);
        this.disabled = false;
        this.autofocus = false;
        this._tabIndex = 0;
        this.manipulatingTabindex = false;
        this.autofocusReady = Promise.resolve();
      }
      get tabIndex() {
        if (this.focusElement === this) {
          const t34 = this.hasAttribute("tabindex") ? Number(this.getAttribute("tabindex")) : NaN;
          return isNaN(t34) ? -1 : t34;
        }
        const e36 = parseFloat(this.hasAttribute("tabindex") && this.getAttribute("tabindex") || "0");
        return this.disabled || e36 < 0 ? -1 : this.focusElement ? this._tabIndex : e36;
      }
      set tabIndex(e36) {
        var t34;
        if (this.manipulatingTabindex) {
          this.manipulatingTabindex = false;
          return;
        }
        if (this.focusElement === this) {
          if (this.disabled) this._tabIndex = e36;
          else if (e36 !== this._tabIndex) {
            this._tabIndex = e36;
            const i21 = "" + e36;
            this.manipulatingTabindex = true, this.setAttribute("tabindex", i21);
          }
          return;
        }
        if (e36 === -1 ? this.addEventListener("pointerdown", this.onPointerdownManagementOfTabIndex) : (this.manipulatingTabindex = true, this.removeEventListener("pointerdown", this.onPointerdownManagementOfTabIndex)), e36 === -1 || this.disabled) {
          if (this.manipulatingTabindex = true, this.setAttribute("tabindex", "-1"), this.removeAttribute("focusable"), this.selfManageFocusElement) return;
          e36 !== -1 ? (this._tabIndex = e36, this.manageFocusElementTabindex(e36)) : (t34 = this.focusElement) == null || t34.removeAttribute("tabindex");
          return;
        }
        this.setAttribute("focusable", ""), this.hasAttribute("tabindex") ? this.removeAttribute("tabindex") : this.manipulatingTabindex = false, this._tabIndex = e36, this.manageFocusElementTabindex(e36);
      }
      onPointerdownManagementOfTabIndex() {
        this.tabIndex === -1 && setTimeout(() => {
          this.tabIndex = 0, this.focus({ preventScroll: true }), this.tabIndex = -1;
        });
      }
      async manageFocusElementTabindex(e36) {
        this.focusElement || await this.updateComplete, e36 === null ? this.focusElement.removeAttribute("tabindex") : this.focusElement !== this && (this.focusElement.tabIndex = e36);
      }
      get focusElement() {
        throw new Error("Must implement focusElement getter!");
      }
      get selfManageFocusElement() {
        return false;
      }
      focus(e36) {
        this.disabled || !this.focusElement || (this.focusElement !== this ? this.focusElement.focus(e36) : HTMLElement.prototype.focus.apply(this, [e36]));
      }
      blur() {
        const e36 = this.focusElement || this;
        e36 !== this ? e36.blur() : HTMLElement.prototype.blur.apply(this);
      }
      click() {
        if (this.disabled) return;
        const e36 = this.focusElement || this;
        e36 !== this ? e36.click() : HTMLElement.prototype.click.apply(this);
      }
      manageAutoFocus() {
        this.autofocus && (this.dispatchEvent(new KeyboardEvent("keydown", { code: "Tab" })), this.focusElement.focus());
      }
      firstUpdated(e36) {
        super.firstUpdated(e36), (!this.hasAttribute("tabindex") || this.getAttribute("tabindex") !== "-1") && this.setAttribute("focusable", "");
      }
      update(e36) {
        e36.has("disabled") && this.handleDisabledChanged(this.disabled, e36.get("disabled")), super.update(e36);
      }
      updated(e36) {
        super.updated(e36), e36.has("disabled") && this.disabled && this.blur();
      }
      async handleDisabledChanged(e36, t34) {
        const i21 = () => this.focusElement !== this && typeof this.focusElement.disabled != "undefined";
        e36 ? (this.manipulatingTabindex = true, this.setAttribute("tabindex", "-1"), await this.updateComplete, i21() ? this.focusElement.disabled = true : this.setAttribute("aria-disabled", "true")) : t34 && (this.manipulatingTabindex = true, this.focusElement === this ? this.setAttribute("tabindex", "" + this._tabIndex) : this.removeAttribute("tabindex"), await this.updateComplete, i21() ? this.focusElement.disabled = false : this.removeAttribute("aria-disabled"));
      }
      async getUpdateComplete() {
        const e36 = await super.getUpdateComplete();
        return await this.autofocusReady, e36;
      }
      connectedCallback() {
        super.connectedCallback(), this.autofocus && (this.autofocusReady = new Promise(async (e36) => {
          await u7(), await u7(), e36();
        }), this.updateComplete.then(() => {
          this.manageAutoFocus();
        }));
      }
    };
    n13([n4({ type: Boolean, reflect: true })], Focusable.prototype, "disabled", 2), n13([n4({ type: Boolean })], Focusable.prototype, "autofocus", 2), n13([n4({ type: Number })], Focusable.prototype, "tabIndex", 1);
  }
});

// node_modules/@lit-labs/observers/mutation-controller.js
var t12;
var init_mutation_controller = __esm({
  "node_modules/@lit-labs/observers/mutation-controller.js"() {
    t12 = class {
      constructor(t34, { target: s19, config: i21, callback: h16, skipInitial: o52 }) {
        this.t = /* @__PURE__ */ new Set(), this.o = false, this.i = false, this.h = t34, null !== s19 && this.t.add(s19 ?? t34), this.l = i21, this.o = o52 ?? this.o, this.callback = h16, window.MutationObserver ? (this.u = new MutationObserver((t35) => {
          this.handleChanges(t35), this.h.requestUpdate();
        }), t34.addController(this)) : console.warn("MutationController error: browser does not support MutationObserver.");
      }
      handleChanges(t34) {
        this.value = this.callback?.(t34, this.u);
      }
      hostConnected() {
        for (const t34 of this.t) this.observe(t34);
      }
      hostDisconnected() {
        this.disconnect();
      }
      async hostUpdated() {
        const t34 = this.u.takeRecords();
        (t34.length || !this.o && this.i) && this.handleChanges(t34), this.i = false;
      }
      observe(t34) {
        this.t.add(t34), this.u.observe(t34, this.l), this.i = true, this.h.requestUpdate();
      }
      disconnect() {
        this.u.disconnect();
      }
    };
  }
});

// node_modules/@spectrum-web-components/shared/src/observe-slot-text.js
function ObserveSlotText(c33, e36, s19 = []) {
  var a23, i21;
  const o52 = (f11) => (m18) => f11.matches(m18);
  class t34 extends (i21 = c33, a23 = p5, i21) {
    constructor(...n25) {
      super(n25);
      this.slotHasContent = false;
      new t12(this, { config: { characterData: true, subtree: true }, callback: (d22) => {
        for (const r25 of d22) if (r25.type === "characterData") {
          this.manageTextObservedSlot();
          return;
        }
      } });
    }
    manageTextObservedSlot() {
      if (!this[p5]) return;
      const n25 = [...this[p5]].filter((d22) => {
        const r25 = d22;
        return r25.tagName ? !s19.some(o52(r25)) : r25.textContent ? r25.textContent.trim() : false;
      });
      this.slotHasContent = n25.length > 0;
    }
    update(n25) {
      if (!this.hasUpdated) {
        const { childNodes: d22 } = this, r25 = [...d22].filter((g8) => {
          const l16 = g8;
          return l16.tagName ? s19.some(o52(l16)) ? false : e36 ? l16.getAttribute("slot") === e36 : !l16.hasAttribute("slot") : l16.textContent ? l16.textContent.trim() : false;
        });
        this.slotHasContent = r25.length > 0;
      }
      super.update(n25);
    }
    firstUpdated(n25) {
      super.firstUpdated(n25), this.updateComplete.then(() => {
        this.manageTextObservedSlot();
      });
    }
  }
  return u8([n4({ type: Boolean, attribute: false })], t34.prototype, "slotHasContent", 2), u8([n5({ slot: e36, flatten: true })], t34.prototype, a23, 2), t34;
}
var h6, x2, u8, p5;
var init_observe_slot_text = __esm({
  "node_modules/@spectrum-web-components/shared/src/observe-slot-text.js"() {
    "use strict";
    init_decorators2();
    init_mutation_controller();
    h6 = Object.defineProperty;
    x2 = Object.getOwnPropertyDescriptor;
    u8 = (c33, e36, s19, o52) => {
      for (var t34 = o52 > 1 ? void 0 : o52 ? x2(e36, s19) : e36, a23 = c33.length - 1, i21; a23 >= 0; a23--) (i21 = c33[a23]) && (t34 = (o52 ? i21(e36, s19, t34) : i21(t34)) || t34);
      return o52 && t34 && h6(e36, s19, t34), t34;
    };
    p5 = Symbol("assignedNodes");
  }
});

// node_modules/@spectrum-web-components/reactive-controllers/src/ElementResolution.js
var elementResolverUpdatedSymbol, ElementResolutionController;
var init_ElementResolution = __esm({
  "node_modules/@spectrum-web-components/reactive-controllers/src/ElementResolution.js"() {
    "use strict";
    elementResolverUpdatedSymbol = Symbol("element resolver updated");
    ElementResolutionController = class {
      constructor(e36, { selector: t34 } = { selector: "" }) {
        this._element = null;
        this._selector = "";
        this.mutationCallback = (e37) => {
          let t35 = false;
          e37.forEach((s19) => {
            if (!t35) {
              if (s19.type === "childList") {
                const r25 = this.element && [...s19.removedNodes].includes(this.element), l16 = !!this.selector && [...s19.addedNodes].some(this.elementIsSelected);
                t35 = t35 || r25 || l16;
              }
              if (s19.type === "attributes") {
                const r25 = s19.target === this.element, l16 = !!this.selector && this.elementIsSelected(s19.target);
                t35 = t35 || r25 || l16;
              }
            }
          }), t35 && this.resolveElement();
        };
        this.elementIsSelected = (e37) => {
          var t35;
          return this.selectorIsId ? (e37 == null ? void 0 : e37.id) === this.selectorAsId : (t35 = e37 == null ? void 0 : e37.matches) == null ? void 0 : t35.call(e37, this.selector);
        };
        this.host = e36, this.selector = t34, this.observer = new MutationObserver(this.mutationCallback), this.host.addController(this);
      }
      get element() {
        return this._element;
      }
      set element(e36) {
        if (e36 === this.element) return;
        const t34 = this.element;
        this._element = e36, this.host.requestUpdate(elementResolverUpdatedSymbol, t34);
      }
      get selector() {
        return this._selector;
      }
      set selector(e36) {
        e36 !== this.selector && (this.releaseElement(), this._selector = e36, this.resolveElement());
      }
      get selectorAsId() {
        return this.selector.slice(1);
      }
      get selectorIsId() {
        return !!this.selector && this.selector.startsWith("#");
      }
      hostConnected() {
        this.resolveElement(), this.observer.observe(this.host.getRootNode(), { subtree: true, childList: true, attributes: true });
      }
      hostDisconnected() {
        this.releaseElement(), this.observer.disconnect();
      }
      resolveElement() {
        if (!this.selector) {
          this.releaseElement();
          return;
        }
        const e36 = this.host.getRootNode();
        this.element = this.selectorIsId ? e36.getElementById(this.selectorAsId) : e36.querySelector(this.selector);
      }
      releaseElement() {
        this.element = null;
      }
    };
  }
});

// node_modules/@spectrum-web-components/shared/src/random-id.js
function randomID() {
  return Array.from(crypto.getRandomValues(new Uint8Array(4)), (r25) => `0${(r25 & 255).toString(16)}`.slice(-2)).join("");
}
var init_random_id = __esm({
  "node_modules/@spectrum-web-components/shared/src/random-id.js"() {
    "use strict";
  }
});

// node_modules/@spectrum-web-components/shared/src/reparent-children.js
function T2(o52, i21, l16 = []) {
  for (let e36 = 0; e36 < i21.length; ++e36) {
    const n25 = i21[e36], r25 = o52[e36], t34 = r25.parentElement || r25.getRootNode();
    l16[e36] && l16[e36](n25), t34 && t34 !== r25 && t34.replaceChild(n25, r25), delete o52[e36];
  }
  return i21;
}
var reparentChildren;
var init_reparent_children = __esm({
  "node_modules/@spectrum-web-components/shared/src/reparent-children.js"() {
    "use strict";
    reparentChildren = (o52, i21, { position: l16, prepareCallback: e36 } = { position: "beforeend" }) => {
      let { length: n25 } = o52;
      if (n25 === 0) return () => o52;
      let r25 = 1, t34 = 0;
      (l16 === "afterbegin" || l16 === "afterend") && (r25 = -1, t34 = n25 - 1);
      const a23 = new Array(n25), c33 = new Array(n25), p30 = document.createComment("placeholder for reparented element");
      do {
        const d22 = o52[t34];
        e36 && (c33[t34] = e36(d22)), a23[t34] = p30.cloneNode();
        const m18 = d22.parentElement || d22.getRootNode();
        m18 && m18 !== d22 && m18.replaceChild(a23[t34], d22), i21.insertAdjacentElement(l16, d22), t34 += r25;
      } while (--n25 > 0);
      return function() {
        return T2(a23, o52, c33);
      };
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/overlay-timer.js
var OverlayTimer;
var init_overlay_timer = __esm({
  "node_modules/@spectrum-web-components/overlay/src/overlay-timer.js"() {
    "use strict";
    OverlayTimer = class {
      constructor(e36 = {}) {
        this.warmUpDelay = 1e3;
        this.coolDownDelay = 1e3;
        this.isWarm = false;
        this.timeout = 0;
        Object.assign(this, e36);
      }
      async openTimer(e36) {
        if (this.cancelCooldownTimer(), !this.component || e36 !== this.component) return this.component && (this.close(this.component), this.cancelCooldownTimer()), this.component = e36, this.isWarm ? false : (this.promise = new Promise((o52) => {
          this.resolve = o52, this.timeout = window.setTimeout(() => {
            this.resolve && (this.resolve(false), this.isWarm = true);
          }, this.warmUpDelay);
        }), this.promise);
        if (this.promise) return this.promise;
        throw new Error("Inconsistent state");
      }
      close(e36) {
        this.component && this.component === e36 && (this.resetCooldownTimer(), this.timeout > 0 && (clearTimeout(this.timeout), this.timeout = 0), this.resolve && (this.resolve(true), delete this.resolve), delete this.promise, delete this.component);
      }
      resetCooldownTimer() {
        this.isWarm && (this.cooldownTimeout && window.clearTimeout(this.cooldownTimeout), this.cooldownTimeout = window.setTimeout(() => {
          this.isWarm = false, delete this.cooldownTimeout;
        }, this.coolDownDelay));
      }
      cancelCooldownTimer() {
        this.cooldownTimeout && window.clearTimeout(this.cooldownTimeout), delete this.cooldownTimeout;
      }
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.js
function nextFrame() {
  return new Promise((i21) => requestAnimationFrame(() => i21()));
}
var overlayTimer, noop, guaranteedAllTransitionend, AbstractOverlay;
var init_AbstractOverlay = __esm({
  "node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.js"() {
    "use strict";
    init_src();
    init_reparent_children();
    init_overlay_timer();
    overlayTimer = new OverlayTimer();
    noop = () => {
    };
    guaranteedAllTransitionend = (i21, v6, e36) => {
      const r25 = new AbortController(), n25 = /* @__PURE__ */ new Map(), a23 = () => {
        r25.abort(), e36();
      };
      let m18, l16;
      const t34 = requestAnimationFrame(() => {
        m18 = requestAnimationFrame(() => {
          l16 = requestAnimationFrame(() => {
            a23();
          });
        });
      }), p30 = (o52) => {
        o52.target === i21 && (n25.set(o52.propertyName, n25.get(o52.propertyName) - 1), n25.get(o52.propertyName) || n25.delete(o52.propertyName), n25.size === 0 && a23());
      }, d22 = (o52) => {
        o52.target === i21 && (n25.has(o52.propertyName) || n25.set(o52.propertyName, 0), n25.set(o52.propertyName, n25.get(o52.propertyName) + 1), cancelAnimationFrame(t34), cancelAnimationFrame(m18), cancelAnimationFrame(l16));
      };
      i21.addEventListener("transitionrun", d22, { signal: r25.signal }), i21.addEventListener("transitionend", p30, { signal: r25.signal }), i21.addEventListener("transitioncancel", p30, { signal: r25.signal }), v6();
    };
    AbstractOverlay = class _AbstractOverlay extends SpectrumElement {
      constructor() {
        super(...arguments);
        this.dispose = noop;
        this.offset = 0;
        this.willPreventClose = false;
      }
      async applyFocus(e36, r25) {
      }
      get delayed() {
        return false;
      }
      set delayed(e36) {
      }
      get disabled() {
        return false;
      }
      set disabled(e36) {
      }
      get elementResolver() {
        return this._elementResolver;
      }
      set elementResolver(e36) {
        this._elementResolver = e36;
      }
      async ensureOnDOM(e36) {
      }
      async makeTransition(e36) {
        return null;
      }
      async manageDelay(e36) {
      }
      async managePopoverOpen() {
      }
      managePosition() {
      }
      get open() {
        return false;
      }
      set open(e36) {
      }
      get placementController() {
        return this._placementController;
      }
      set placementController(e36) {
        this._placementController = e36;
      }
      requestSlottable() {
      }
      returnFocus() {
      }
      get state() {
        return "closed";
      }
      set state(e36) {
      }
      manuallyKeepOpen() {
      }
      static update() {
        const e36 = new CustomEvent("sp-update-overlays", { bubbles: true, composed: true, cancelable: true });
        document.dispatchEvent(e36);
      }
      static async open(e36, r25, n25, a23) {
        await Promise.resolve().then(() => (init_sp_overlay(), sp_overlay_exports));
        const m18 = arguments.length === 2, l16 = n25 || e36, t34 = new this();
        let p30 = false;
        t34.dispose = () => {
          t34.addEventListener("sp-closed", () => {
            p30 || (d22(), p30 = true), requestAnimationFrame(() => {
              t34.remove();
            });
          }), t34.open = false, t34.dispose = noop;
        };
        const d22 = reparentChildren([l16], t34, { position: "beforeend", prepareCallback: (s19) => {
          const c33 = s19.slot;
          return s19.removeAttribute("slot"), () => {
            s19.slot = c33;
          };
        } });
        if (!m18 && l16 && a23) {
          const s19 = e36, c33 = r25, u36 = a23;
          return _AbstractOverlay.applyOptions(t34, { ...u36, delayed: u36.delayed || l16.hasAttribute("delayed"), trigger: u36.virtualTrigger || s19, type: c33 === "modal" ? "modal" : c33 === "hover" ? "hint" : "auto" }), s19.insertAdjacentElement("afterend", t34), await t34.updateComplete, t34.open = true, t34.dispose;
        }
        const y5 = r25;
        return t34.append(l16), _AbstractOverlay.applyOptions(t34, { ...y5, delayed: y5.delayed || l16.hasAttribute("delayed") }), t34.updateComplete.then(() => {
          t34.open = true;
        }), t34;
      }
      static applyOptions(e36, r25) {
        var n25, a23;
        e36.delayed = !!r25.delayed, e36.receivesFocus = (n25 = r25.receivesFocus) != null ? n25 : "auto", e36.triggerElement = r25.trigger || null, e36.type = r25.type || "modal", e36.offset = (a23 = r25.offset) != null ? a23 : 0, e36.placement = r25.placement, e36.willPreventClose = !!r25.notImmediatelyClosable;
      }
      disconnectedCallback() {
        super.disconnectedCallback();
      }
    };
  }
});

// node_modules/@spectrum-web-components/shared/src/focusable-selectors.js
var t16, e18, userFocusableSelector, focusableSelector;
var init_focusable_selectors = __esm({
  "node_modules/@spectrum-web-components/shared/src/focusable-selectors.js"() {
    "use strict";
    t16 = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "label:not([inert])", "[tabindex]:not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])", '[focusable]:not([focusable="false"])'];
    e18 = ':not([tabindex="-1"])';
    userFocusableSelector = t16.join(`${e18}, `) + e18;
    focusableSelector = t16.join(", ");
  }
});

// node_modules/@spectrum-web-components/shared/src/first-focusable-in.js
var firstFocusableIn, firstFocusableSlottedIn;
var init_first_focusable_in = __esm({
  "node_modules/@spectrum-web-components/shared/src/first-focusable-in.js"() {
    "use strict";
    init_focusable_selectors();
    firstFocusableIn = (e36) => e36.querySelector(userFocusableSelector);
    firstFocusableSlottedIn = (e36) => e36.assignedElements().find((o52) => o52.matches(userFocusableSelector));
  }
});

// node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.js
var VirtualTrigger;
var init_VirtualTrigger = __esm({
  "node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.js"() {
    "use strict";
    init_AbstractOverlay();
    VirtualTrigger = class {
      constructor(t34, i21) {
        this.x = 0;
        this.y = 0;
        this.x = t34, this.y = i21;
      }
      updateBoundingClientRect(t34, i21) {
        this.x = t34, this.y = i21, AbstractOverlay.update();
      }
      getBoundingClientRect() {
        return { width: 0, height: 0, top: this.y, right: this.x, y: this.y, x: this.x, bottom: this.y, left: this.x, toJSON() {
        } };
      }
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/events.js
var BeforetoggleClosedEvent, BeforetoggleOpenEvent, OverlayStateEvent;
var init_events = __esm({
  "node_modules/@spectrum-web-components/overlay/src/events.js"() {
    "use strict";
    BeforetoggleClosedEvent = class extends Event {
      constructor() {
        super("beforetoggle", { bubbles: false, composed: false });
        this.currentState = "open";
        this.newState = "closed";
      }
    };
    BeforetoggleOpenEvent = class extends Event {
      constructor() {
        super("beforetoggle", { bubbles: false, composed: false });
        this.currentState = "closed";
        this.newState = "open";
      }
    };
    OverlayStateEvent = class extends Event {
      constructor(r25, l16, { publish: o52, interaction: s19, reason: n25 }) {
        super(r25, { bubbles: o52, composed: o52 });
        this.overlay = l16;
        this.detail = { interaction: s19, reason: n25 };
      }
    };
  }
});

// node_modules/@spectrum-web-components/shared/src/get-active-element.js
var init_get_active_element = __esm({
  "node_modules/@spectrum-web-components/shared/src/get-active-element.js"() {
    "use strict";
  }
});

// node_modules/@spectrum-web-components/shared/src/observe-slot-presence.js
function ObserveSlotPresence(l16, s19) {
  var o52, i21;
  const r25 = Array.isArray(s19) ? s19 : [s19];
  class a23 extends (i21 = l16, o52 = t17, i21) {
    constructor(...e36) {
      super(e36);
      this[o52] = /* @__PURE__ */ new Map();
      this.managePresenceObservedSlot = () => {
        let e37 = false;
        r25.forEach((n25) => {
          const c33 = !!this.querySelector(`:scope > ${n25}`), g8 = this[t17].get(n25) || false;
          e37 = e37 || g8 !== c33, this[t17].set(n25, !!this.querySelector(`:scope > ${n25}`));
        }), e37 && this.updateComplete.then(() => {
          this.requestUpdate();
        });
      };
      new t12(this, { config: { childList: true, subtree: true }, callback: () => {
        this.managePresenceObservedSlot();
      } }), this.managePresenceObservedSlot();
    }
    get slotContentIsPresent() {
      if (r25.length === 1) return this[t17].get(r25[0]) || false;
      throw new Error("Multiple selectors provided to `ObserveSlotPresence` use `getSlotContentPresence(selector: string)` instead.");
    }
    getSlotContentPresence(e36) {
      if (this[t17].has(e36)) return this[t17].get(e36) || false;
      throw new Error(`The provided selector \`${e36}\` is not being observed.`);
    }
  }
  return a23;
}
var t17;
var init_observe_slot_presence = __esm({
  "node_modules/@spectrum-web-components/shared/src/observe-slot-presence.js"() {
    "use strict";
    init_mutation_controller();
    t17 = Symbol("slotContentIsPresent");
  }
});

// node_modules/@spectrum-web-components/shared/src/platform.js
function n14(o52) {
  return typeof window != "undefined" && window.navigator != null ? o52.test(window.navigator.userAgent) : false;
}
function e19(o52) {
  return typeof window != "undefined" && window.navigator != null ? o52.test(window.navigator.platform) : false;
}
function isMac() {
  return e19(/^Mac/);
}
function isIPhone() {
  return e19(/^iPhone/);
}
function isIPad() {
  return e19(/^iPad/) || isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function isWebKit() {
  return n14(/AppleWebKit/) && !isChrome();
}
function isChrome() {
  return n14(/Chrome/);
}
function isAndroid() {
  return n14(/Android/);
}
var init_platform = __esm({
  "node_modules/@spectrum-web-components/shared/src/platform.js"() {
    "use strict";
  }
});

// node_modules/@spectrum-web-components/shared/src/index.js
var init_src2 = __esm({
  "node_modules/@spectrum-web-components/shared/src/index.js"() {
    "use strict";
    init_first_focusable_in();
    init_focus_visible();
    init_focusable();
    init_focusable_selectors();
    init_get_active_element();
    init_like_anchor();
    init_observe_slot_presence();
    init_observe_slot_text();
    init_platform();
    init_reparent_children();
    init_get_label_from_slot();
    init_random_id();
  }
});

// node_modules/@spectrum-web-components/overlay/src/OverlayPopover.js
function f7(l16) {
  let a23 = false;
  try {
    a23 = l16.matches(":popover-open");
  } catch (e36) {
  }
  let p30 = false;
  try {
    p30 = l16.matches(":open");
  } catch (e36) {
  }
  return a23 || p30;
}
function OverlayPopover(l16) {
  class a23 extends l16 {
    async manageDelay(e36) {
      if (e36 === false || e36 !== this.open) {
        overlayTimer.close(this);
        return;
      }
      this.delayed && await overlayTimer.openTimer(this) && (this.open = !e36);
    }
    async shouldHidePopover(e36) {
      if (e36 && this.open !== e36) return;
      const o52 = async ({ newState: i21 } = {}) => {
        i21 !== "open" && await this.placementController.resetOverlayPosition();
      };
      if (!f7(this.dialogEl)) {
        o52();
        return;
      }
      this.dialogEl.addEventListener("toggle", o52, { once: true });
    }
    shouldShowPopover(e36) {
      let o52 = false;
      try {
        o52 = this.dialogEl.matches(":popover-open");
      } catch (u36) {
      }
      let i21 = false;
      try {
        i21 = this.dialogEl.matches(":open");
      } catch (u36) {
      }
      e36 && this.open === e36 && !o52 && !i21 && this.isConnected && (this.dialogEl.showPopover(), this.managePosition());
    }
    async ensureOnDOM(e36) {
      C3 || await this.shouldHidePopover(e36), this.shouldShowPopover(e36), await nextFrame();
    }
    async makeTransition(e36) {
      if (this.open !== e36) return null;
      let o52 = null;
      const i21 = (t34, s19) => () => {
        if (t34.open = e36, s19 === 0) {
          const r25 = e36 ? BeforetoggleOpenEvent : BeforetoggleClosedEvent;
          this.dispatchEvent(new r25());
        }
        if (!e36 || (t34.matches(userFocusableSelector) && (o52 = t34), o52 = o52 || firstFocusableIn(t34), o52)) return;
        t34.querySelectorAll("slot").forEach((r25) => {
          o52 || (o52 = firstFocusableSlottedIn(r25));
        });
      }, u36 = (t34, s19) => async () => {
        if (this.open !== e36) return;
        const n25 = e36 ? "sp-opened" : "sp-closed";
        if (s19 > 0) {
          t34.dispatchEvent(new OverlayStateEvent(n25, this, { interaction: this.type, publish: false }));
          return;
        }
        const r25 = async () => {
          if (this.open !== e36) return;
          await nextFrame();
          const d22 = this.triggerElement instanceof VirtualTrigger;
          this.dispatchEvent(new OverlayStateEvent(n25, this, { interaction: this.type, publish: d22 })), t34.dispatchEvent(new OverlayStateEvent(n25, this, { interaction: this.type, publish: false })), this.triggerElement && !d22 && this.triggerElement.dispatchEvent(new OverlayStateEvent(n25, this, { interaction: this.type, publish: true })), this.state = e36 ? "opened" : "closed", this.returnFocus(), await nextFrame(), await nextFrame(), e36 === this.open && e36 === false && this.requestSlottable();
        };
        if (this.open !== e36) return;
        const v6 = f7(this.dialogEl);
        e36 !== true && v6 && this.isConnected ? (this.dialogEl.addEventListener("beforetoggle", () => {
          r25();
        }, { once: true }), this.dialogEl.hidePopover()) : r25();
      };
      return this.elements.forEach((t34, s19) => {
        guaranteedAllTransitionend(t34, i21(t34, s19), u36(t34, s19));
      }), o52;
    }
  }
  return a23;
}
var C3;
var init_OverlayPopover = __esm({
  "node_modules/@spectrum-web-components/overlay/src/OverlayPopover.js"() {
    "use strict";
    init_first_focusable_in();
    init_VirtualTrigger();
    init_AbstractOverlay();
    init_events();
    init_src2();
    C3 = CSS.supports("(overlay: auto)");
  }
});

// node_modules/@spectrum-web-components/overlay/src/OverlayNoPopover.js
function OverlayNoPopover(a23) {
  class m18 extends a23 {
    async managePopoverOpen() {
      await this.managePosition();
    }
    async manageDelay(e36) {
      if (e36 === false || e36 !== this.open) {
        overlayTimer.close(this);
        return;
      }
      this.delayed && await overlayTimer.openTimer(this) && (this.open = !e36);
    }
    async ensureOnDOM(e36) {
      document.body.offsetHeight;
    }
    async makeTransition(e36) {
      if (this.open !== e36) return null;
      let o52 = null;
      const h16 = (t34, r25) => () => {
        if (e36 !== this.open) return;
        if (t34.open = e36, r25 === 0) {
          const i21 = e36 ? BeforetoggleOpenEvent : BeforetoggleClosedEvent;
          this.dispatchEvent(new i21());
        }
        if (e36 !== true || (t34.matches(userFocusableSelector) && (o52 = t34), o52 = o52 || firstFocusableIn(t34), o52)) return;
        t34.querySelectorAll("slot").forEach((i21) => {
          o52 || (o52 = firstFocusableSlottedIn(i21));
        });
      }, u36 = (t34, r25) => async () => {
        if (this.open !== e36) return;
        const n25 = e36 ? "sp-opened" : "sp-closed";
        if (t34.dispatchEvent(new OverlayStateEvent(n25, this, { interaction: this.type })), r25 > 0) return;
        const i21 = this.triggerElement instanceof VirtualTrigger;
        this.dispatchEvent(new OverlayStateEvent(n25, this, { interaction: this.type, publish: i21 })), this.triggerElement && !i21 && this.triggerElement.dispatchEvent(new OverlayStateEvent(n25, this, { interaction: this.type, publish: true })), this.state = e36 ? "opened" : "closed", this.returnFocus(), await nextFrame(), await nextFrame(), e36 === this.open && e36 === false && this.requestSlottable();
      };
      return this.elements.forEach((t34, r25) => {
        guaranteedAllTransitionend(t34, h16(t34, r25), u36(t34, r25));
      }), o52;
    }
  }
  return m18;
}
var init_OverlayNoPopover = __esm({
  "node_modules/@spectrum-web-components/overlay/src/OverlayNoPopover.js"() {
    "use strict";
    init_first_focusable_in();
    init_VirtualTrigger();
    init_AbstractOverlay();
    init_events();
    init_src2();
  }
});

// node_modules/@spectrum-web-components/overlay/src/OverlayStack.js
var c11, d7, overlayStack;
var init_OverlayStack = __esm({
  "node_modules/@spectrum-web-components/overlay/src/OverlayStack.js"() {
    "use strict";
    c11 = "showPopover" in document.createElement("div");
    d7 = class {
      constructor() {
        this.root = document.body;
        this.stack = [];
        this.originalBodyOverflow = "";
        this.bodyScrollBlocked = false;
        this.handleScroll = (t34) => {
          t34.target !== document && t34.target !== document.documentElement && t34.target !== document.body || this.stack.forEach((e36) => {
            e36.open && (e36.type === "auto" && e36.triggerElement instanceof HTMLElement && e36.triggerElement.closest("sp-picker, sp-action-menu") && t34.stopPropagation(), document.dispatchEvent(new CustomEvent("sp-update-overlays", { bubbles: true, composed: true, cancelable: true })));
          });
        };
        this.handlePointerdown = (t34) => {
          this.pointerdownPath = t34.composedPath(), this.lastOverlay = this.stack[this.stack.length - 1];
        };
        this.handlePointerup = () => {
          const t34 = this.pointerdownPath;
          if (this.pointerdownPath = void 0, !this.stack.length || !(t34 != null && t34.length)) return;
          const e36 = this.lastOverlay;
          this.lastOverlay = void 0;
          const s19 = this.stack.length - 1, o52 = this.stack.filter((n25, i21) => !t34.find((r25) => r25 === n25 || r25 === (n25 == null ? void 0 : n25.triggerElement) && (n25 == null ? void 0 : n25.type) === "hint" || i21 === s19 && n25 !== e36 && n25.triggerInteraction === "longpress") && !n25.shouldPreventClose() && n25.type !== "manual" && !(n25.type === "modal" && e36 !== n25));
          o52.reverse(), o52.forEach((n25) => {
            this.closeOverlay(n25);
            let i21 = n25.parentOverlayToForceClose;
            for (; i21; ) this.closeOverlay(i21), i21 = i21.parentOverlayToForceClose;
          });
        };
        this.handleBeforetoggle = (t34) => {
          const { target: e36, newState: s19 } = t34;
          s19 !== "open" && this.closeOverlay(e36);
        };
        this.handleKeydown = (t34) => {
          if (t34.code !== "Escape" || !this.stack.length) return;
          const e36 = this.stack[this.stack.length - 1];
          if ((e36 == null ? void 0 : e36.type) === "page") {
            t34.preventDefault();
            return;
          }
          if ((e36 == null ? void 0 : e36.type) === "manual") {
            this.closeOverlay(e36);
            return;
          }
          c11 || e36 && this.closeOverlay(e36);
        };
        this.bindEvents();
      }
      get document() {
        return this.root.ownerDocument || document;
      }
      bindEvents() {
        this.document.addEventListener("pointerdown", this.handlePointerdown), this.document.addEventListener("pointerup", this.handlePointerup), this.document.addEventListener("keydown", this.handleKeydown), this.document.addEventListener("scroll", this.handleScroll, { capture: true });
      }
      closeOverlay(t34) {
        const e36 = this.stack.indexOf(t34);
        e36 > -1 && this.stack.splice(e36, 1), t34.open = false, this.manageBodyScroll();
      }
      manageBodyScroll() {
        const t34 = this.stack.some((e36) => e36.type === "modal" || e36.type === "page");
        t34 && !this.bodyScrollBlocked ? (this.originalBodyOverflow = document.body.style.overflow || "", document.body.style.overflow = "hidden", this.bodyScrollBlocked = true) : !t34 && this.bodyScrollBlocked && (document.body.style.overflow = this.originalBodyOverflow, this.bodyScrollBlocked = false);
      }
      overlaysByTriggerElement(t34) {
        return this.stack.filter((e36) => e36.triggerElement === t34);
      }
      add(t34) {
        if (this.stack.includes(t34)) {
          const e36 = this.stack.indexOf(t34);
          e36 > -1 && (this.stack.splice(e36, 1), this.stack.push(t34));
          return;
        }
        if (t34.type === "auto" || t34.type === "modal" || t34.type === "page") {
          const e36 = "sp-overlay-query-path", s19 = new Event(e36, { composed: true, bubbles: true });
          t34.addEventListener(e36, (o52) => {
            const n25 = o52.composedPath();
            this.stack.forEach((i21) => {
              !n25.find((r25) => r25 === i21) && i21.type !== "manual" && i21.type !== "modal" && this.closeOverlay(i21);
            });
          }, { once: true }), t34.dispatchEvent(s19);
        } else if (t34.type === "hint") {
          if (this.stack.some((s19) => s19.type !== "manual" && s19.triggerElement && s19.triggerElement === t34.triggerElement)) {
            t34.open = false;
            return;
          }
          this.stack.forEach((s19) => {
            s19.type === "hint" && this.closeOverlay(s19);
          });
        }
        requestAnimationFrame(() => {
          this.stack.push(t34), t34.addEventListener("beforetoggle", this.handleBeforetoggle, { once: true }), this.manageBodyScroll();
        });
      }
      remove(t34) {
        this.closeOverlay(t34);
      }
    };
    overlayStack = new d7();
  }
});

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x5,
    y: y5,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y5,
    left: x5,
    right: x5 + width,
    bottom: y5 + height,
    x: x5,
    y: y5
  };
}
var min, max, round, floor, createCoords, oppositeSideMap, oppositeAlignmentMap, yAxisSides, lrPlacement, rlPlacement, tbPlacement, btPlacement;
var init_floating_ui_utils = __esm({
  "node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs"() {
    min = Math.min;
    max = Math.max;
    round = Math.round;
    floor = Math.floor;
    createCoords = (v6) => ({
      x: v6,
      y: v6
    });
    oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
    yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
    lrPlacement = ["left", "right"];
    rlPlacement = ["right", "left"];
    tbPlacement = ["top", "bottom"];
    btPlacement = ["bottom", "top"];
  }
});

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x5,
    y: y5,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x5,
    y: y5,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var computePosition, arrow, flip, originSides, offset, shift, size;
var init_floating_ui_core = __esm({
  "node_modules/@floating-ui/core/dist/floating-ui.core.mjs"() {
    init_floating_ui_utils();
    init_floating_ui_utils();
    computePosition = async (reference, floating, config) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x5,
        y: y5
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i21 = 0; i21 < validMiddleware.length; i21++) {
        const {
          name,
          fn: fn2
        } = validMiddleware[i21];
        const {
          x: nextX,
          y: nextY,
          data,
          reset
        } = await fn2({
          x: x5,
          y: y5,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x5 = nextX != null ? nextX : x5;
        y5 = nextY != null ? nextY : y5;
        middlewareData = {
          ...middlewareData,
          [name]: {
            ...middlewareData[name],
            ...data
          }
        };
        if (reset && resetCount <= 50) {
          resetCount++;
          if (typeof reset === "object") {
            if (reset.placement) {
              statefulPlacement = reset.placement;
            }
            if (reset.rects) {
              rects = reset.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset.rects;
            }
            ({
              x: x5,
              y: y5
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i21 = -1;
        }
      }
      return {
        x: x5,
        y: y5,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    arrow = (options) => ({
      name: "arrow",
      options,
      async fn(state) {
        const {
          x: x5,
          y: y5,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element,
          padding = 0
        } = evaluate(options, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x5,
          y: y5
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform2.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
        const min$1 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset4 = clamp(min$1, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset4,
            centerOffset: center - offset4 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    flip = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "flip",
        options,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const initialSideAxis = getSideAxis(initialPlacement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
          if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements2 = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides2 = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements2[nextIndex];
            if (nextPlacement) {
              const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
              if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
              // overflows the main axis.
              overflowsData.every((d22) => getSideAxis(d22.placement) === initialSideAxis ? d22.overflows[0] > 0 : true)) {
                return {
                  data: {
                    index: nextIndex,
                    overflows: overflowsData
                  },
                  reset: {
                    placement: nextPlacement
                  }
                };
              }
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d22) => d22.overflows[0] <= 0).sort((a23, b12) => a23.overflows[1] - b12.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$filter2;
                  const placement2 = (_overflowsData$filter2 = overflowsData.filter((d22) => {
                    if (hasFallbackAxisSideDirection) {
                      const currentSideAxis = getSideAxis(d22.placement);
                      return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                      // reading directions favoring greater width.
                      currentSideAxis === "y";
                    }
                    return true;
                  }).map((d22) => [d22.placement, d22.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a23, b12) => a23[1] - b12[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    originSides = /* @__PURE__ */ new Set(["left", "top"]);
    offset = function(options) {
      if (options === void 0) {
        options = 0;
      }
      return {
        name: "offset",
        options,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x5,
            y: y5,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x5 + diffCoords.x,
            y: y5 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };
    shift = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "shift",
        options,
        async fn(state) {
          const {
            x: x5,
            y: y5,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x6,
                  y: y6
                } = _ref;
                return {
                  x: x6,
                  y: y6
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const coords = {
            x: x5,
            y: y5
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x5,
              y: limitedCoords.y - y5,
              enabled: {
                [mainAxis]: checkMainAxis,
                [crossAxis]: checkCrossAxis
              }
            }
          };
        }
      };
    };
    size = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "size",
        options,
        async fn(state) {
          var _state$middlewareData, _state$middlewareData2;
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const {
            apply: apply2 = () => {
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const maximumClippingHeight = height - overflow.top - overflow.bottom;
          const maximumClippingWidth = width - overflow.left - overflow.right;
          const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
          const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
            availableWidth = maximumClippingWidth;
          }
          if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
            availableHeight = maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
            }
          }
          await apply2({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform2.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };
  }
});

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit2 = isWebKit2();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit2() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode2 = getParentNode(node);
  if (isLastTraversableNode(parentNode2)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
var invalidOverflowDisplayValues, tableElements, topLayerSelectors, transformProperties, willChangeValues, containValues, lastTraversableNodeNames;
var init_floating_ui_utils_dom = __esm({
  "node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs"() {
    invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
    tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
    topLayerSelectors = [":popover-open", ":modal"];
    transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
    willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
    containValues = ["paint", "layout", "strict", "content"];
    lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  }
});

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $4
  } = getCssDimensions(domElement);
  let x5 = ($4 ? round(rect.width) : rect.width) / width;
  let y5 = ($4 ? round(rect.height) : rect.height) / height;
  if (!x5 || !Number.isFinite(x5)) {
    x5 = 1;
  }
  if (!y5 || !Number.isFinite(y5)) {
    y5 = 1;
  }
  return {
    x: x5,
    y: y5
  };
}
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit2() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x5 = (clientRect2.left + visualOffsets.x) / scale.x;
  let y5 = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x5 *= iframeScale.x;
      y5 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x5 += left;
      y5 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x5,
    y: y5
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x5 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y5 = htmlRect.top + scroll.scrollTop;
  return {
    x: x5,
    y: y5
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x5 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y5 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x5 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x5,
    y: y5
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x5 = 0;
  let y5 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit2();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x5 = visualViewport.offsetLeft;
      y5 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc3 = html.ownerDocument;
    const body = doc3.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc3.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x5,
    y: y5
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect2.top + element.clientTop;
  const left = clientRect2.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x5 = left * scale.x;
  const y5 = top * scale.y;
  return {
    width,
    height,
    x: x5,
    y: y5
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode2 = getParentNode(element);
  if (parentNode2 === stopNode || !isElement(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle2(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult2 = cache2.get(element);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x5 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y5 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x5,
    y: y5,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
function rectsAreEqual(a23, b12) {
  return a23.x === b12.x && a23.y === b12.y && a23.width === b12.width && a23.height === b12.height;
}
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io2) == null || _io.disconnect();
    io2 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e2) {
      io2 = new IntersectionObserver(handleObserve, options);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var noOffsets, SCROLLBAR_MAX, absoluteOrFixed, getElementRects, platform, offset2, shift2, flip2, size2, arrow2, computePosition2;
var init_floating_ui_dom = __esm({
  "node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs"() {
    init_floating_ui_core();
    init_floating_ui_utils();
    init_floating_ui_utils_dom();
    noOffsets = /* @__PURE__ */ createCoords(0);
    SCROLLBAR_MAX = 25;
    absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
    getElementRects = async function(data) {
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      const floatingDimensions = await getDimensionsFn(data.floating);
      return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
          x: 0,
          y: 0,
          width: floatingDimensions.width,
          height: floatingDimensions.height
        }
      };
    };
    platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement,
      isRTL
    };
    offset2 = offset;
    shift2 = shift;
    flip2 = flip;
    size2 = size;
    arrow2 = arrow;
    computePosition2 = (reference, floating, options) => {
      const cache2 = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache2
      };
      return computePosition(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/PlacementController.js
function c12(o52) {
  if (typeof o52 == "undefined") return 0;
  const t34 = window.devicePixelRatio || 1;
  return Math.round(o52 * t34) / t34;
}
var p8, C4, T3, placementUpdatedSymbol, PlacementController;
var init_PlacementController = __esm({
  "node_modules/@spectrum-web-components/overlay/src/PlacementController.js"() {
    "use strict";
    init_floating_ui_dom();
    p8 = 8;
    C4 = 100;
    T3 = (o52) => {
      var e36;
      return (e36 = { left: ["right", "bottom", "top"], "left-start": ["right-start", "bottom", "top"], "left-end": ["right-end", "bottom", "top"], right: ["left", "bottom", "top"], "right-start": ["left-start", "bottom", "top"], "right-end": ["left-end", "bottom", "top"], top: ["bottom", "left", "right"], "top-start": ["bottom-start", "left", "right"], "top-end": ["bottom-end", "left", "right"], bottom: ["top", "left", "right"], "bottom-start": ["top-start", "left", "right"], "bottom-end": ["top-end", "left", "right"] }[o52]) != null ? e36 : [o52];
    };
    placementUpdatedSymbol = Symbol("placement updated");
    PlacementController = class {
      constructor(t34) {
        this.originalPlacements = /* @__PURE__ */ new WeakMap();
        this.allowPlacementUpdate = false;
        this.closeForAncestorUpdate = () => {
          !this.allowPlacementUpdate && this.options.type !== "modal" && this.cleanup && this.target.dispatchEvent(new Event("close", { bubbles: true })), this.allowPlacementUpdate = false;
        };
        this.updatePlacement = () => {
          this.computePlacement();
        };
        this.resetOverlayPosition = () => {
          !this.target || !this.options || (this.clearOverlayPosition(), this.host.offsetHeight, this.computePlacement());
        };
        this.host = t34, this.host.addController(this);
      }
      async placeOverlay(t34 = this.target, e36 = this.options) {
        if (this.target = t34, this.options = e36, !t34 || !e36) return;
        const m18 = autoUpdate(e36.trigger, t34, this.closeForAncestorUpdate, { ancestorResize: false, elementResize: false, layoutShift: false }), h16 = autoUpdate(e36.trigger, t34, this.updatePlacement, { ancestorScroll: false });
        this.cleanup = () => {
          var n25;
          (n25 = this.host.elements) == null || n25.forEach((a23) => {
            a23.addEventListener("sp-closed", () => {
              const r25 = this.originalPlacements.get(a23);
              r25 && a23.setAttribute("placement", r25), this.originalPlacements.delete(a23);
            }, { once: true });
          }), m18(), h16();
        };
      }
      async computePlacement() {
        var g8, u36;
        const { options: t34, target: e36 } = this;
        await (document.fonts ? document.fonts.ready : Promise.resolve());
        const m18 = t34.trigger instanceof HTMLElement ? flip2() : flip2({ padding: p8, fallbackPlacements: T3(t34.placement) }), [h16 = 0, n25 = 0] = Array.isArray(t34 == null ? void 0 : t34.offset) ? t34.offset : [t34.offset, 0], a23 = (g8 = this.host.elements.find((i21) => i21.tipElement)) == null ? void 0 : g8.tipElement, r25 = [offset2({ mainAxis: h16, crossAxis: n25 }), shift2({ padding: p8 }), m18, size2({ padding: p8, apply: ({ availableWidth: i21, availableHeight: d22, rects: { floating: x5 } }) => {
          const b12 = Math.max(C4, Math.floor(d22)), l16 = x5.height;
          this.initialHeight = this.isConstrained && this.initialHeight || l16, this.isConstrained = l16 < this.initialHeight || b12 <= l16;
          const O2 = this.isConstrained ? `${b12}px` : "";
          Object.assign(e36.style, { maxWidth: `${Math.floor(i21)}px`, maxHeight: O2 });
        } }), ...a23 ? [arrow2({ element: a23, padding: t34.tipPadding || p8 })] : []], { x: P4, y: E3, placement: s19, middlewareData: f11 } = await computePosition2(t34.trigger, e36, { placement: t34.placement, middleware: r25, strategy: "fixed" });
        if (Object.assign(e36.style, { top: "0px", left: "0px", translate: `${c12(P4)}px ${c12(E3)}px` }), e36.setAttribute("actual-placement", s19), (u36 = this.host.elements) == null || u36.forEach((i21) => {
          this.originalPlacements.has(i21) || this.originalPlacements.set(i21, i21.getAttribute("placement")), i21.setAttribute("placement", s19);
        }), a23 && f11.arrow) {
          const { x: i21, y: d22 } = f11.arrow;
          Object.assign(a23.style, { top: s19.startsWith("right") || s19.startsWith("left") ? "0px" : "", left: s19.startsWith("bottom") || s19.startsWith("top") ? "0px" : "", translate: `${c12(i21)}px ${c12(d22)}px` });
        }
      }
      clearOverlayPosition() {
        this.target && (this.target.style.removeProperty("max-height"), this.target.style.removeProperty("max-width"), this.initialHeight = void 0, this.isConstrained = false);
      }
      hostConnected() {
        document.addEventListener("sp-update-overlays", this.resetOverlayPosition);
      }
      hostUpdated() {
        var t34;
        this.host.open || ((t34 = this.cleanup) == null || t34.call(this), this.cleanup = void 0);
      }
      hostDisconnected() {
        var t34;
        (t34 = this.cleanup) == null || t34.call(this), this.cleanup = void 0, document.removeEventListener("sp-update-overlays", this.resetOverlayPosition);
      }
    };
  }
});

// node_modules/@spectrum-web-components/base/src/condition-attribute-with-id.js
function conditionAttributeWithoutId(t34, i21, n25) {
  const e36 = t34.getAttribute(i21);
  let r25 = e36 ? e36.split(/\s+/) : [];
  r25 = r25.filter((s19) => !n25.find((o52) => s19 === o52)), r25.length ? t34.setAttribute(i21, r25.join(" ")) : t34.removeAttribute(i21);
}
function conditionAttributeWithId(t34, i21, n25) {
  const e36 = Array.isArray(n25) ? n25 : [n25], r25 = t34.getAttribute(i21), s19 = r25 ? r25.split(/\s+/) : [];
  return e36.every((d22) => s19.indexOf(d22) > -1) ? () => {
  } : (s19.push(...e36), t34.setAttribute(i21, s19.join(" ")), () => conditionAttributeWithoutId(t34, i21, e36));
}
var init_condition_attribute_with_id = __esm({
  "node_modules/@spectrum-web-components/base/src/condition-attribute-with-id.js"() {
    "use strict";
  }
});

// node_modules/@spectrum-web-components/overlay/src/InteractionController.js
var InteractionTypes, lastInteractionType, InteractionController;
var init_InteractionController = __esm({
  "node_modules/@spectrum-web-components/overlay/src/InteractionController.js"() {
    "use strict";
    InteractionTypes = ((r25) => (r25.click = "click", r25.hover = "hover", r25.longpress = "longpress", r25))(InteractionTypes || {});
    lastInteractionType = Symbol("lastInteractionType");
    InteractionController = class {
      constructor(e36, { overlay: t34, isPersistent: r25, handleOverlayReady: i21 }) {
        this.target = e36;
        this.isLazilyOpen = false;
        this.isPersistent = false;
        this.isPersistent = !!r25, this.handleOverlayReady = i21, this.isPersistent && this.init(), this.overlay = t34;
      }
      get activelyOpening() {
        return false;
      }
      get open() {
        var e36, t34;
        return (t34 = (e36 = this.overlay) == null ? void 0 : e36.open) != null ? t34 : this.isLazilyOpen;
      }
      set open(e36) {
        if (e36 !== this.open) {
          if (this.isLazilyOpen = e36, this.overlay) {
            this.overlay.open = e36, this.target[lastInteractionType] = this.type;
            return;
          }
          e36 && (customElements.whenDefined("sp-overlay").then(async () => {
            const { Overlay: t34 } = await Promise.resolve().then(() => (init_Overlay(), Overlay_exports));
            this.overlay = new t34(), this.overlay.open = true, this.target[lastInteractionType] = this.type;
          }), Promise.resolve().then(() => (init_sp_overlay(), sp_overlay_exports)));
        }
      }
      get overlay() {
        return this._overlay;
      }
      set overlay(e36) {
        var t34;
        e36 && this.overlay !== e36 && (this.overlay && this.overlay.removeController(this), this._overlay = e36, this.overlay.addController(this), this.initOverlay(), this.prepareDescription(this.target), (t34 = this.handleOverlayReady) == null || t34.call(this, this.overlay));
      }
      prepareDescription(e36) {
      }
      releaseDescription() {
      }
      shouldCompleteOpen() {
      }
      init() {
      }
      initOverlay() {
      }
      abort() {
        var e36;
        this.releaseDescription(), (e36 = this.abortController) == null || e36.abort();
      }
      hostConnected() {
        this.init();
      }
      hostDisconnected() {
        this.isPersistent || this.abort();
      }
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/LongpressController.js
var g3, LONGPRESS_INSTRUCTIONS, LongpressController;
var init_LongpressController = __esm({
  "node_modules/@spectrum-web-components/overlay/src/LongpressController.js"() {
    "use strict";
    init_platform();
    init_condition_attribute_with_id();
    init_random_id();
    init_AbstractOverlay();
    init_InteractionController();
    g3 = 300;
    LONGPRESS_INSTRUCTIONS = { touch: "Double tap and long press for additional options", keyboard: "Press Space or Alt+Down Arrow for additional options", mouse: "Click and hold for additional options" };
    LongpressController = class extends InteractionController {
      constructor() {
        super(...arguments);
        this.type = InteractionTypes.longpress;
        this.longpressState = null;
        this.releaseDescription = noop;
        this.handlePointerup = () => {
          var e36;
          clearTimeout(this.timeout), this.target && (this.longpressState = ((e36 = this.overlay) == null ? void 0 : e36.state) === "opening" ? "pressed" : null, document.removeEventListener("pointerup", this.handlePointerup), document.removeEventListener("pointercancel", this.handlePointerup));
        };
      }
      get activelyOpening() {
        return this.longpressState === "opening" || this.longpressState === "pressed";
      }
      handleLongpress() {
        this.open = true, this.longpressState = this.longpressState === "potential" ? "opening" : "pressed";
      }
      handlePointerdown(e36) {
        !this.target || e36.button !== 0 || (this.longpressState = "potential", document.addEventListener("pointerup", this.handlePointerup), document.addEventListener("pointercancel", this.handlePointerup), "holdAffordance" in this.target) || (this.timeout = setTimeout(() => {
          this.target && this.target.dispatchEvent(new CustomEvent("longpress", { bubbles: true, composed: true, detail: { source: "pointer" } }));
        }, g3));
      }
      handleKeydown(e36) {
        const { code: t34, altKey: o52 } = e36;
        o52 && t34 === "ArrowDown" && (e36.stopPropagation(), e36.stopImmediatePropagation());
      }
      handleKeyup(e36) {
        const { code: t34, altKey: o52 } = e36;
        if (t34 === "Space" || o52 && t34 === "ArrowDown") {
          if (!this.target) return;
          e36.stopPropagation(), this.target.dispatchEvent(new CustomEvent("longpress", { bubbles: true, composed: true, detail: { source: "keyboard" } })), setTimeout(() => {
            this.longpressState = null;
          });
        }
      }
      prepareDescription(e36) {
        if (this.releaseDescription !== noop || !this.overlay.elements.length) return;
        const t34 = document.createElement("div");
        t34.id = `longpress-describedby-descriptor-${randomID()}`;
        const o52 = isIOS() || isAndroid() ? "touch" : "keyboard";
        t34.textContent = LONGPRESS_INSTRUCTIONS[o52], t34.slot = "longpress-describedby-descriptor";
        const n25 = e36.getRootNode(), s19 = this.overlay.getRootNode();
        n25 === s19 ? this.overlay.append(t34) : (t34.hidden = !("host" in n25), e36.insertAdjacentElement("afterend", t34));
        const i21 = conditionAttributeWithId(e36, "aria-describedby", [t34.id]);
        this.releaseDescription = () => {
          i21(), t34.remove(), this.releaseDescription = noop;
        };
      }
      shouldCompleteOpen() {
        this.longpressState = this.longpressState === "pressed" ? null : this.longpressState;
      }
      init() {
        var t34;
        (t34 = this.abortController) == null || t34.abort(), this.abortController = new AbortController();
        const { signal: e36 } = this.abortController;
        this.target.addEventListener("longpress", () => this.handleLongpress(), { signal: e36 }), this.target.addEventListener("pointerdown", (o52) => this.handlePointerdown(o52), { signal: e36 }), this.prepareDescription(this.target), !this.target.holdAffordance && (this.target.addEventListener("keydown", (o52) => this.handleKeydown(o52), { signal: e36 }), this.target.addEventListener("keyup", (o52) => this.handleKeyup(o52), { signal: e36 }));
      }
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/ClickController.js
var ClickController;
var init_ClickController = __esm({
  "node_modules/@spectrum-web-components/overlay/src/ClickController.js"() {
    "use strict";
    init_InteractionController();
    ClickController = class extends InteractionController {
      constructor() {
        super(...arguments);
        this.type = InteractionTypes.click;
        this.preventNextToggle = false;
      }
      handleClick() {
        this.preventNextToggle || (this.open = !this.open), this.preventNextToggle = false;
      }
      handlePointerdown() {
        this.preventNextToggle = this.open;
      }
      init() {
        var t34;
        (t34 = this.abortController) == null || t34.abort(), this.abortController = new AbortController();
        const { signal: e36 } = this.abortController;
        this.target.addEventListener("click", () => this.handleClick(), { signal: e36 }), this.target.addEventListener("pointerdown", () => this.handlePointerdown(), { signal: e36 });
      }
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/HoverController.js
var p9, HoverController;
var init_HoverController = __esm({
  "node_modules/@spectrum-web-components/overlay/src/HoverController.js"() {
    "use strict";
    init_condition_attribute_with_id();
    init_src2();
    init_random_id();
    init_AbstractOverlay();
    init_InteractionController();
    p9 = 300;
    HoverController = class extends InteractionController {
      constructor() {
        super(...arguments);
        this.type = InteractionTypes.hover;
        this.elementIds = [];
        this.focusedin = false;
        this.pointerentered = false;
      }
      handleKeyup(e36) {
        (e36.code === "Tab" || e36.code === "Escape") && (this.open = true);
      }
      handleTargetFocusin() {
        this.target.matches(":focus-visible") && (isWebKit() && this.target[lastInteractionType] === InteractionTypes.click || (this.open = true, this.focusedin = true));
      }
      handleTargetFocusout() {
        this.focusedin = false, !this.pointerentered && (this.open = false);
      }
      handleTargetPointerenter() {
        var e36;
        this.hoverTimeout && (clearTimeout(this.hoverTimeout), this.hoverTimeout = void 0), !((e36 = this.overlay) != null && e36.disabled) && (this.open = true, this.pointerentered = true);
      }
      handleTargetPointerleave() {
        this.doPointerleave();
      }
      handleHostPointerenter() {
        this.hoverTimeout && (clearTimeout(this.hoverTimeout), this.hoverTimeout = void 0);
      }
      handleHostPointerleave() {
        this.doPointerleave();
      }
      prepareDescription() {
        if (!this.overlay.elements.length) return;
        const e36 = this.target.getRootNode(), t34 = this.overlay.elements[0].getRootNode(), r25 = this.overlay.getRootNode();
        e36 === r25 ? this.prepareOverlayRelativeDescription() : e36 === t34 && this.prepareContentRelativeDescription();
      }
      prepareOverlayRelativeDescription() {
        const e36 = conditionAttributeWithId(this.target, "aria-describedby", [this.overlay.id]);
        this.releaseDescription = () => {
          e36(), this.releaseDescription = noop;
        };
      }
      prepareContentRelativeDescription() {
        const e36 = [], t34 = this.overlay.elements.map((i21) => (e36.push(i21.id), i21.id || (i21.id = `${this.overlay.tagName.toLowerCase()}-helper-${randomID()}`), i21.id));
        this.elementIds = e36;
        const r25 = conditionAttributeWithId(this.target, "aria-describedby", t34);
        this.releaseDescription = () => {
          r25(), this.overlay.elements.map((i21, a23) => {
            i21.id = this.elementIds[a23];
          }), this.releaseDescription = noop;
        };
      }
      doPointerleave() {
        this.pointerentered = false;
        const e36 = this.target;
        this.focusedin && e36.matches(":focus-visible") || (this.hoverTimeout = setTimeout(() => {
          this.open = false;
        }, p9));
      }
      init() {
        var t34;
        (t34 = this.abortController) == null || t34.abort(), this.abortController = new AbortController();
        const { signal: e36 } = this.abortController;
        this.target.addEventListener("keyup", (r25) => this.handleKeyup(r25), { signal: e36 }), this.target.addEventListener("focusin", () => this.handleTargetFocusin(), { signal: e36 }), this.target.addEventListener("focusout", () => this.handleTargetFocusout(), { signal: e36 }), this.target.addEventListener("pointerenter", () => this.handleTargetPointerenter(), { signal: e36 }), this.target.addEventListener("pointerleave", () => this.handleTargetPointerleave(), { signal: e36 }), this.overlay && this.initOverlay();
      }
      initOverlay() {
        if (!this.abortController) return;
        const { signal: e36 } = this.abortController;
        this.overlay.addEventListener("pointerenter", () => this.handleHostPointerenter(), { signal: e36 }), this.overlay.addEventListener("pointerleave", () => this.handleHostPointerleave(), { signal: e36 });
      }
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/strategies.js
var strategies;
var init_strategies = __esm({
  "node_modules/@spectrum-web-components/overlay/src/strategies.js"() {
    "use strict";
    init_ClickController();
    init_HoverController();
    init_LongpressController();
    strategies = { click: ClickController, longpress: LongpressController, hover: HoverController };
  }
});

// node_modules/@spectrum-web-components/overlay/src/slottable-request-event.js
var SlottableRequestEvent, removeSlottableRequest;
var init_slottable_request_event = __esm({
  "node_modules/@spectrum-web-components/overlay/src/slottable-request-event.js"() {
    "use strict";
    SlottableRequestEvent = class extends Event {
      constructor(e36, n25, t34) {
        super("slottable-request", { bubbles: false, cancelable: true, composed: false }), this.name = e36, this.data = n25, this.slotName = t34 !== void 0 ? `${e36}.${t34}` : e36;
      }
    };
    removeSlottableRequest = Symbol("remove-slottable-request");
  }
});

// node_modules/@spectrum-web-components/overlay/src/overlay.css.js
var o21, overlay_css_default;
var init_overlay_css = __esm({
  "node_modules/@spectrum-web-components/overlay/src/overlay.css.js"() {
    "use strict";
    init_src();
    o21 = i`
    :host{pointer-events:none;--swc-overlay-animation-distance:var(--spectrum-spacing-100);display:contents}:host(:has(>sp-tooltip)){--swc-overlay-animation-distance:var(--spectrum-tooltip-animation-distance)}.dialog{box-sizing:border-box;--sp-overlay-open:true;background:0 0;border:0;max-width:calc(100vw - 16px);height:auto;max-height:calc(100dvh - 16px);margin:0;padding:0;display:flex;position:fixed;inset:0 auto auto 0;overflow:visible;opacity:1!important}.dialog:not([is-visible]){display:none}.dialog:focus{outline:none}dialog:modal{--mod-popover-filter:var(--spectrum-popover-filter)}:host(:not([open])) .dialog{--sp-overlay-open:false}.dialog::backdrop{display:none}.dialog:before{content:"";position:absolute;inset:-999em;pointer-events:auto!important}.dialog:not(.not-immediately-closable):before{display:none}.dialog>div{width:100%}::slotted(*){pointer-events:auto;visibility:visible!important}::slotted(sp-popover){position:static}.dialog:not([actual-placement])[placement*=top]{padding-block:var(--swc-overlay-animation-distance);margin-top:var(--swc-overlay-animation-distance)}.dialog:not([actual-placement])[placement*=right]{padding-inline:var(--swc-overlay-animation-distance);margin-left:calc(-1*var(--swc-overlay-animation-distance))}.dialog:not([actual-placement])[placement*=bottom]{padding-block:var(--swc-overlay-animation-distance);margin-top:calc(-1*var(--swc-overlay-animation-distance))}.dialog:not([actual-placement])[placement*=left]{padding-inline:var(--swc-overlay-animation-distance);margin-left:var(--swc-overlay-animation-distance)}.dialog[actual-placement*=top]{padding-block:var(--swc-overlay-animation-distance);margin-top:var(--swc-overlay-animation-distance)}.dialog[actual-placement*=right]{padding-inline:var(--swc-overlay-animation-distance);margin-left:calc(-1*var(--swc-overlay-animation-distance))}.dialog[actual-placement*=bottom]{padding-block:var(--swc-overlay-animation-distance);margin-top:calc(-1*var(--swc-overlay-animation-distance))}.dialog[actual-placement*=left]{padding-inline:var(--swc-overlay-animation-distance);margin-left:var(--swc-overlay-animation-distance)}slot[name=longpress-describedby-descriptor]{display:none}@supports selector(:open){.dialog{opacity:0}.dialog:open{opacity:1;--mod-popover-filter:var(--spectrum-popover-filter)}}@supports selector(:popover-open){.dialog{opacity:0}.dialog:popover-open{opacity:1;--mod-popover-filter:var(--spectrum-popover-filter)}}@supports (overlay:auto){.dialog{transition:all var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s)),translate 0s,display var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s));transition-behavior:allow-discrete;display:none}.dialog:popover-open{display:flex}}@supports (not selector(:open)) and (not selector(:popover-open)){:host:not([open]) .dialog{pointer-events:none}.dialog[actual-placement]{z-index:calc(var(--swc-overlay-z-index-base,1000) + var(--swc-overlay-open-count))}}
`;
    overlay_css_default = o21;
  }
});

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors, candidateSelector, NoElement, matches, getRootNode, isInert, isContentEditable, getCandidates, getCandidatesIteratively, hasTabIndex, getTabIndex, getSortOrderTabIndex, sortOrderedTabbables, isInput, isHiddenInput, isDetailsWithSummary, getCheckedRadio, isTabbableRadio, isRadio, isNonTabbableRadio, isNodeAttached, isZeroArea, isHidden, isDisabledFromFieldset, isNodeMatchingSelectorFocusable, isNodeMatchingSelectorTabbable, isValidShadowRootTabbable, sortByOrder, tabbable, focusable, isTabbable, focusableCandidateSelector, isFocusable;
var init_index_esm = __esm({
  "node_modules/tabbable/dist/index.esm.js"() {
    candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
      var _element$getRootNode;
      return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
    } : function(element) {
      return element === null || element === void 0 ? void 0 : element.ownerDocument;
    };
    isInert = function isInert2(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node && isInert2(node.parentNode);
      return result;
    };
    isContentEditable = function isContentEditable2(node) {
      var _node$getAttribute2;
      var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    getCandidates = function getCandidates2(el, includeContainer, filter) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter);
      return candidates;
    };
    getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element = elementsToCheck.shift();
        if (isInert(element, false)) {
          continue;
        }
        if (element.tagName === "SLOT") {
          var assigned = element.assignedElements();
          var content = assigned.length ? assigned : element.children;
          var nestedCandidates = getCandidatesIteratively2(content, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches.call(element, candidateSelector);
          if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
            candidates.push(element);
          }
          var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
          typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
            if (options.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element.children);
          }
        }
      }
      return candidates;
    };
    hasTabIndex = function hasTabIndex2(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    };
    getTabIndex = function getTabIndex2(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    };
    sortOrderedTabbables = function sortOrderedTabbables2(a23, b12) {
      return a23.tabIndex === b12.tabIndex ? a23.documentOrder - b12.documentOrder : a23.tabIndex - b12.tabIndex;
    };
    isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r25 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r25;
    };
    getCheckedRadio = function getCheckedRadio2(nodes2, form) {
      for (var i21 = 0; i21 < nodes2.length; i21++) {
        if (nodes2[i21].checked && nodes2[i21].form === form) {
          return nodes2[i21];
        }
      }
    };
    isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    isNodeAttached = function isNodeAttached2(node) {
      var _nodeRoot;
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    };
    isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (isNodeAttached(node)) {
          return !node.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode2 = node.parentElement;
        while (parentNode2) {
          if (parentNode2.tagName === "FIELDSET" && parentNode2.disabled) {
            for (var i21 = 0; i21 < parentNode2.children.length; i21++) {
              var child = parentNode2.children.item(i21);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode2, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode2 = parentNode2.parentElement;
        }
      }
      return false;
    };
    isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
      if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
      if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
        return false;
      }
      return true;
    };
    isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    };
    sortByOrder = function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i21) {
        var isScope = !!item.scopeParent;
        var element = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
        } else {
          orderedTabbables.push({
            documentOrder: i21,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    };
    tabbable = function tabbable2(container, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options),
          flatten: false,
          getShadowRoot: options.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
      }
      return sortByOrder(candidates);
    };
    focusable = function focusable2(container, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options),
          flatten: true,
          getShadowRoot: options.getShadowRoot
        });
      } else {
        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
      }
      return candidates;
    };
    isTabbable = function isTabbable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options, node);
    };
    focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    isFocusable = function isFocusable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options, node);
    };
  }
});

// node_modules/focus-trap/dist/focus-trap.esm.js
var focus_trap_esm_exports = {};
__export(focus_trap_esm_exports, {
  createFocusTrap: () => createFocusTrap
});
function _arrayLikeToArray(r25, a23) {
  (null == a23 || a23 > r25.length) && (a23 = r25.length);
  for (var e36 = 0, n25 = Array(a23); e36 < a23; e36++) n25[e36] = r25[e36];
  return n25;
}
function _arrayWithoutHoles(r25) {
  if (Array.isArray(r25)) return _arrayLikeToArray(r25);
}
function _defineProperty(e36, r25, t34) {
  return (r25 = _toPropertyKey(r25)) in e36 ? Object.defineProperty(e36, r25, {
    value: t34,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e36[r25] = t34, e36;
}
function _iterableToArray(r25) {
  if ("undefined" != typeof Symbol && null != r25[Symbol.iterator] || null != r25["@@iterator"]) return Array.from(r25);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e36, r25) {
  var t34 = Object.keys(e36);
  if (Object.getOwnPropertySymbols) {
    var o52 = Object.getOwnPropertySymbols(e36);
    r25 && (o52 = o52.filter(function(r26) {
      return Object.getOwnPropertyDescriptor(e36, r26).enumerable;
    })), t34.push.apply(t34, o52);
  }
  return t34;
}
function _objectSpread2(e36) {
  for (var r25 = 1; r25 < arguments.length; r25++) {
    var t34 = null != arguments[r25] ? arguments[r25] : {};
    r25 % 2 ? ownKeys(Object(t34), true).forEach(function(r26) {
      _defineProperty(e36, r26, t34[r26]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e36, Object.getOwnPropertyDescriptors(t34)) : ownKeys(Object(t34)).forEach(function(r26) {
      Object.defineProperty(e36, r26, Object.getOwnPropertyDescriptor(t34, r26));
    });
  }
  return e36;
}
function _toConsumableArray(r25) {
  return _arrayWithoutHoles(r25) || _iterableToArray(r25) || _unsupportedIterableToArray(r25) || _nonIterableSpread();
}
function _toPrimitive(t34, r25) {
  if ("object" != typeof t34 || !t34) return t34;
  var e36 = t34[Symbol.toPrimitive];
  if (void 0 !== e36) {
    var i21 = e36.call(t34, r25);
    if ("object" != typeof i21) return i21;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r25 ? String : Number)(t34);
}
function _toPropertyKey(t34) {
  var i21 = _toPrimitive(t34, "string");
  return "symbol" == typeof i21 ? i21 : i21 + "";
}
function _unsupportedIterableToArray(r25, a23) {
  if (r25) {
    if ("string" == typeof r25) return _arrayLikeToArray(r25, a23);
    var t34 = {}.toString.call(r25).slice(8, -1);
    return "Object" === t34 && r25.constructor && (t34 = r25.constructor.name), "Map" === t34 || "Set" === t34 ? Array.from(r25) : "Arguments" === t34 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t34) ? _arrayLikeToArray(r25, a23) : void 0;
  }
}
var activeFocusTraps, isSelectableInput, isEscapeEvent, isTabEvent, isKeyForward, isKeyBackward, delay, valueOrHandler, getActualTarget, internalTrapStack, createFocusTrap;
var init_focus_trap_esm = __esm({
  "node_modules/focus-trap/dist/focus-trap.esm.js"() {
    init_index_esm();
    activeFocusTraps = {
      activateTrap: function activateTrap(trapStack, trap) {
        if (trapStack.length > 0) {
          var activeTrap = trapStack[trapStack.length - 1];
          if (activeTrap !== trap) {
            activeTrap._setPausedState(true);
          }
        }
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
          trapStack.push(trap);
        } else {
          trapStack.splice(trapIndex, 1);
          trapStack.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trapStack, trap) {
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
          trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {
          trapStack[trapStack.length - 1]._setPausedState(false);
        }
      }
    };
    isSelectableInput = function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    };
    isEscapeEvent = function isEscapeEvent2(e36) {
      return (e36 === null || e36 === void 0 ? void 0 : e36.key) === "Escape" || (e36 === null || e36 === void 0 ? void 0 : e36.key) === "Esc" || (e36 === null || e36 === void 0 ? void 0 : e36.keyCode) === 27;
    };
    isTabEvent = function isTabEvent2(e36) {
      return (e36 === null || e36 === void 0 ? void 0 : e36.key) === "Tab" || (e36 === null || e36 === void 0 ? void 0 : e36.keyCode) === 9;
    };
    isKeyForward = function isKeyForward2(e36) {
      return isTabEvent(e36) && !e36.shiftKey;
    };
    isKeyBackward = function isKeyBackward2(e36) {
      return isTabEvent(e36) && e36.shiftKey;
    };
    delay = function delay2(fn2) {
      return setTimeout(fn2, 0);
    };
    valueOrHandler = function valueOrHandler2(value) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return typeof value === "function" ? value.apply(void 0, params) : value;
    };
    getActualTarget = function getActualTarget2(event) {
      return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
    };
    internalTrapStack = [];
    createFocusTrap = function createFocusTrap2(elements, userOptions) {
      var doc3 = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
      var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward,
        isKeyBackward
      }, userOptions);
      var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        manuallyPaused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: void 0,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: void 0
      };
      var trap;
      var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
      };
      var findContainerIndex = function findContainerIndex2(element, event) {
        var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
        return state.containerGroups.findIndex(function(_ref) {
          var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
          return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
            return node === element;
          });
        });
      };
      var getNodeForOption = function getNodeForOption2(optionName) {
        var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
        var optionValue = config[optionName];
        if (typeof optionValue === "function") {
          optionValue = optionValue.apply(void 0, _toConsumableArray(params));
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          try {
            node = doc3.querySelector(optionValue);
          } catch (err) {
            throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
          }
          if (!node) {
            if (!hasFallback) {
              throw new Error("`".concat(optionName, "` as selector refers to no known node"));
            }
          }
        }
        return node;
      };
      var getInitialFocusNode = function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus", {
          hasFallback: true
        });
        if (node === false) {
          return false;
        }
        if (node === void 0 || node && !isFocusable(node, config.tabbableOptions)) {
          if (findContainerIndex(doc3.activeElement) >= 0) {
            node = doc3.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        } else if (node === null) {
          node = getNodeForOption("fallbackFocus");
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      };
      var updateTabbableNodes = function updateTabbableNodes2() {
        state.containerGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container, config.tabbableOptions);
          var focusableNodes = focusable(container, config.tabbableOptions);
          var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
          var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
          var firstDomTabbableNode = focusableNodes.find(function(node) {
            return isTabbable(node);
          });
          var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
            return isTabbable(node);
          });
          var posTabIndexesFound = !!tabbableNodes.find(function(node) {
            return getTabIndex(node) > 0;
          });
          return {
            container,
            tabbableNodes,
            focusableNodes,
            /** True if at least one node with positive `tabindex` was found in this container. */
            posTabIndexesFound,
            /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
            firstTabbableNode,
            /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
            lastTabbableNode,
            // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
            //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
            //  because that API doesn't work with Shadow DOM as well as it should (@see
            //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
            //  to address an edge case related to positive tabindex support, this seems like a much easier,
            //  "close enough most of the time" alternative for positive tabindexes which should generally
            //  be avoided anyway...
            /** First tabbable node in container, __DOM__ order; `undefined` if none. */
            firstDomTabbableNode,
            /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
            lastDomTabbableNode,
            /**
             * Finds the __tabbable__ node that follows the given node in the specified direction,
             *  in this container, if any.
             * @param {HTMLElement} node
             * @param {boolean} [forward] True if going in forward tab order; false if going
             *  in reverse.
             * @returns {HTMLElement|undefined} The next tabbable node, if any.
             */
            nextTabbableNode: function nextTabbableNode(node) {
              var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var nodeIdx = tabbableNodes.indexOf(node);
              if (nodeIdx < 0) {
                if (forward) {
                  return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                    return isTabbable(el);
                  });
                }
                return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                  return isTabbable(el);
                });
              }
              return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
            }
          };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
          return group.tabbableNodes.length > 0;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (state.containerGroups.find(function(g8) {
          return g8.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
          throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
      };
      var _getActiveElement = function getActiveElement(el) {
        var activeElement = el.activeElement;
        if (!activeElement) {
          return;
        }
        if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
          return _getActiveElement(activeElement.shadowRoot);
        }
        return activeElement;
      };
      var _tryFocus = function tryFocus(node) {
        if (node === false) {
          return;
        }
        if (node === _getActiveElement(document)) {
          return;
        }
        if (!node || !node.focus) {
          _tryFocus(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      };
      var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", {
          params: [previousActiveElement]
        });
        return node ? node : node === false ? false : previousActiveElement;
      };
      var findNextNavNode = function findNextNavNode2(_ref3) {
        var target = _ref3.target, event = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
        target = target || getActualTarget(event);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findContainerIndex(target, event);
          var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
          if (containerIndex < 0) {
            if (isBackward) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (isBackward) {
            var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
              var firstTabbableNode = _ref4.firstTabbableNode;
              return target === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target, false);
            }
          } else {
            var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
              var lastTabbableNode = _ref5.lastTabbableNode;
              return target === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target);
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        return destinationNode;
      };
      var checkPointerDown = function checkPointerDown2(e36) {
        var target = getActualTarget(e36);
        if (findContainerIndex(target, e36) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e36)) {
          trap.deactivate({
            // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
            //  which will result in the outside click setting focus to the node
            //  that was clicked (and if not focusable, to "nothing"); by setting
            //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
            //  on activation (or the configured `setReturnFocus` node), whether the
            //  outside click was on a focusable node or not
            returnFocus: config.returnFocusOnDeactivate
          });
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e36)) {
          return;
        }
        e36.preventDefault();
      };
      var checkFocusIn = function checkFocusIn2(event) {
        var target = getActualTarget(event);
        var targetContained = findContainerIndex(target, event) >= 0;
        if (targetContained || target instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target;
          }
        } else {
          event.stopImmediatePropagation();
          var nextNode;
          var navAcrossContainers = true;
          if (state.mostRecentlyFocusedNode) {
            if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
              var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
              var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
              if (tabbableNodes.length > 0) {
                var mruTabIdx = tabbableNodes.findIndex(function(node) {
                  return node === state.mostRecentlyFocusedNode;
                });
                if (mruTabIdx >= 0) {
                  if (config.isKeyForward(state.recentNavEvent)) {
                    if (mruTabIdx + 1 < tabbableNodes.length) {
                      nextNode = tabbableNodes[mruTabIdx + 1];
                      navAcrossContainers = false;
                    }
                  } else {
                    if (mruTabIdx - 1 >= 0) {
                      nextNode = tabbableNodes[mruTabIdx - 1];
                      navAcrossContainers = false;
                    }
                  }
                }
              }
            } else {
              if (!state.containerGroups.some(function(g8) {
                return g8.tabbableNodes.some(function(n25) {
                  return getTabIndex(n25) > 0;
                });
              })) {
                navAcrossContainers = false;
              }
            }
          } else {
            navAcrossContainers = false;
          }
          if (navAcrossContainers) {
            nextNode = findNextNavNode({
              // move FROM the MRU node, not event-related node (which will be the node that is
              //  outside the trap causing the focus escape we're trying to fix)
              target: state.mostRecentlyFocusedNode,
              isBackward: config.isKeyBackward(state.recentNavEvent)
            });
          }
          if (nextNode) {
            _tryFocus(nextNode);
          } else {
            _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
          }
        }
        state.recentNavEvent = void 0;
      };
      var checkKeyNav = function checkKeyNav2(event) {
        var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.recentNavEvent = event;
        var destinationNode = findNextNavNode({
          event,
          isBackward
        });
        if (destinationNode) {
          if (isTabEvent(event)) {
            event.preventDefault();
          }
          _tryFocus(destinationNode);
        }
      };
      var checkTabKey = function checkTabKey2(event) {
        if (config.isKeyForward(event) || config.isKeyBackward(event)) {
          checkKeyNav(event, config.isKeyBackward(event));
        }
      };
      var checkEscapeKey = function checkEscapeKey2(event) {
        if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
          event.preventDefault();
          trap.deactivate();
        }
      };
      var checkClick = function checkClick2(e36) {
        var target = getActualTarget(e36);
        if (findContainerIndex(target, e36) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e36)) {
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e36)) {
          return;
        }
        e36.preventDefault();
        e36.stopImmediatePropagation();
      };
      var addListeners = function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trapStack, trap);
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
          _tryFocus(getInitialFocusNode());
        }) : _tryFocus(getInitialFocusNode());
        doc3.addEventListener("focusin", checkFocusIn, true);
        doc3.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc3.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc3.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc3.addEventListener("keydown", checkTabKey, {
          capture: true,
          passive: false
        });
        doc3.addEventListener("keydown", checkEscapeKey);
        return trap;
      };
      var removeListeners = function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc3.removeEventListener("focusin", checkFocusIn, true);
        doc3.removeEventListener("mousedown", checkPointerDown, true);
        doc3.removeEventListener("touchstart", checkPointerDown, true);
        doc3.removeEventListener("click", checkClick, true);
        doc3.removeEventListener("keydown", checkTabKey, true);
        doc3.removeEventListener("keydown", checkEscapeKey);
        return trap;
      };
      var checkDomRemoval = function checkDomRemoval2(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
          var removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some(function(node) {
            return node === state.mostRecentlyFocusedNode;
          });
        });
        if (isFocusedNodeRemoved) {
          _tryFocus(getInitialFocusNode());
        }
      };
      var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
      var updateObservedNodes = function updateObservedNodes2() {
        if (!mutationObserver) {
          return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
          state.containers.map(function(container) {
            mutationObserver.observe(container, {
              subtree: true,
              childList: true
            });
          });
        }
      };
      trap = {
        get active() {
          return state.active;
        },
        get paused() {
          return state.paused;
        },
        activate: function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = _getActiveElement(doc3);
          onActivate === null || onActivate === void 0 || onActivate();
          var finishActivation = function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 || onPostActivate();
          };
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        },
        deactivate: function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          var options = _objectSpread2({
            onDeactivate: config.onDeactivate,
            onPostDeactivate: config.onPostDeactivate,
            checkCanReturnFocus: config.checkCanReturnFocus
          }, deactivateOptions);
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          updateObservedNodes();
          activeFocusTraps.deactivateTrap(trapStack, trap);
          var onDeactivate = getOption(options, "onDeactivate");
          var onPostDeactivate = getOption(options, "onPostDeactivate");
          var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
          var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
          onDeactivate === null || onDeactivate === void 0 || onDeactivate();
          var finishDeactivation = function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
            });
          };
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        },
        pause: function pause(pauseOptions) {
          if (!state.active) {
            return this;
          }
          state.manuallyPaused = true;
          return this._setPausedState(true, pauseOptions);
        },
        unpause: function unpause(unpauseOptions) {
          if (!state.active) {
            return this;
          }
          state.manuallyPaused = false;
          if (trapStack[trapStack.length - 1] !== this) {
            return this;
          }
          return this._setPausedState(false, unpauseOptions);
        },
        updateContainerElements: function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element) {
            return typeof element === "string" ? doc3.querySelector(element) : element;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          updateObservedNodes();
          return this;
        }
      };
      Object.defineProperties(trap, {
        _isManuallyPaused: {
          value: function value() {
            return state.manuallyPaused;
          }
        },
        _setPausedState: {
          value: function value(paused, options) {
            if (state.paused === paused) {
              return this;
            }
            state.paused = paused;
            if (paused) {
              var onPause = getOption(options, "onPause");
              var onPostPause = getOption(options, "onPostPause");
              onPause === null || onPause === void 0 || onPause();
              removeListeners();
              updateObservedNodes();
              onPostPause === null || onPostPause === void 0 || onPostPause();
            } else {
              var onUnpause = getOption(options, "onUnpause");
              var onPostUnpause = getOption(options, "onPostUnpause");
              onUnpause === null || onUnpause === void 0 || onUnpause();
              updateTabbableNodes();
              addListeners();
              updateObservedNodes();
              onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
            }
            return this;
          }
        }
      });
      trap.updateContainerElements(elements);
      return trap;
    };
  }
});

// node_modules/@spectrum-web-components/overlay/src/Overlay.js
var Overlay_exports = {};
__export(Overlay_exports, {
  LONGPRESS_INSTRUCTIONS: () => LONGPRESS_INSTRUCTIONS,
  Overlay: () => Overlay
});
var y3, E2, r8, q, b6, o22, Overlay;
var init_Overlay = __esm({
  "node_modules/@spectrum-web-components/overlay/src/Overlay.js"() {
    "use strict";
    init_src();
    init_decorators2();
    init_ElementResolution();
    init_directives();
    init_random_id();
    init_AbstractOverlay();
    init_OverlayPopover();
    init_OverlayNoPopover();
    init_OverlayStack();
    init_VirtualTrigger();
    init_PlacementController();
    init_LongpressController();
    init_strategies();
    init_slottable_request_event();
    init_overlay_css();
    y3 = Object.defineProperty;
    E2 = Object.getOwnPropertyDescriptor;
    r8 = (m18, l16, e36, t34) => {
      for (var i21 = t34 > 1 ? void 0 : t34 ? E2(l16, e36) : l16, s19 = m18.length - 1, a23; s19 >= 0; s19--) (a23 = m18[s19]) && (i21 = (t34 ? a23(l16, e36, i21) : a23(i21)) || i21);
      return t34 && i21 && y3(l16, e36, i21), i21;
    };
    q = "showPopover" in document.createElement("div");
    b6 = OverlayPopover(AbstractOverlay);
    q || (b6 = OverlayNoPopover(AbstractOverlay));
    o22 = class o23 extends b6 {
      constructor() {
        super(...arguments);
        this._delayed = false;
        this._disabled = false;
        this.offset = 0;
        this._open = false;
        this.lastRequestSlottableState = false;
        this.receivesFocus = "auto";
        this.allowOutsideClick = false;
        this._state = "closed";
        this.triggerElement = null;
        this.type = "auto";
        this.wasOpen = false;
        this._focusTrap = null;
        this.closeOnFocusOut = (e36) => {
          if (!e36.relatedTarget) return;
          const t34 = new Event("overlay-relation-query", { bubbles: true, composed: true });
          e36.relatedTarget.addEventListener(t34.type, (i21) => {
            i21.composedPath().some((p30) => p30 === this) || (this.open = false);
          }), e36.relatedTarget.dispatchEvent(t34);
        };
        this.closeOnCancelEvent = () => {
          this.open = false;
        };
      }
      get delayed() {
        var e36;
        return ((e36 = this.elements.at(-1)) == null ? void 0 : e36.hasAttribute("delayed")) || this._delayed;
      }
      set delayed(e36) {
        this._delayed = e36;
      }
      get disabled() {
        return this._disabled;
      }
      set disabled(e36) {
        var t34;
        this._disabled = e36, e36 ? ((t34 = this.strategy) == null || t34.abort(), this.wasOpen = this.open, this.open = false) : (this.bindEvents(), this.open = this.open || this.wasOpen, this.wasOpen = false);
      }
      get hasNonVirtualTrigger() {
        return !!this.triggerElement && !(this.triggerElement instanceof VirtualTrigger);
      }
      get placementController() {
        return this._placementController || (this._placementController = new PlacementController(this)), this._placementController;
      }
      get open() {
        return this._open;
      }
      set open(e36) {
        var t34;
        e36 && this.disabled || e36 !== this.open && ((t34 = this.strategy) != null && t34.activelyOpening && !e36 || (this._open = e36, this.open && (o23.openCount += 1), this.requestUpdate("open", !this.open), this.open && this.requestSlottable()));
      }
      get state() {
        return this._state;
      }
      set state(e36) {
        var i21;
        if (e36 === this.state) return;
        const t34 = this.state;
        this._state = e36, (this.state === "opened" || this.state === "closed") && ((i21 = this.strategy) == null || i21.shouldCompleteOpen()), this.requestUpdate("state", t34);
      }
      get elementResolver() {
        return this._elementResolver || (this._elementResolver = new ElementResolutionController(this)), this._elementResolver;
      }
      get popoverValue() {
        if ("popover" in this) switch (this.type) {
          case "modal":
            return "auto";
          case "page":
            return "manual";
          case "hint":
            return "manual";
          default:
            return this.type;
        }
      }
      get requiresPositioning() {
        return !(this.type === "page" || !this.open || !this.triggerElement || !this.placement && this.type !== "hint");
      }
      managePosition() {
        if (!this.requiresPositioning || !this.open) return;
        const e36 = this.offset || 0, t34 = this.triggerElement, i21 = this.placement || "right", s19 = this.tipPadding;
        this.placementController.placeOverlay(this.dialogEl, { offset: e36, placement: i21, tipPadding: s19, trigger: t34, type: this.type });
      }
      async managePopoverOpen() {
        super.managePopoverOpen();
        const e36 = this.open;
        if (this.open !== e36 || (await this.manageDelay(e36), this.open !== e36) || (this.triggerInteraction === "longpress" && await nextFrame(), await this.ensureOnDOM(e36), this.open !== e36)) return;
        const t34 = await this.makeTransition(e36);
        if (this.open === e36) {
          if (e36) {
            const i21 = await Promise.resolve().then(() => (init_focus_trap_esm(), focus_trap_esm_exports));
            this._focusTrap = i21.createFocusTrap(this.dialogEl, { initialFocus: t34 || void 0, tabbableOptions: { getShadowRoot: true }, fallbackFocus: () => (this.dialogEl.setAttribute("tabIndex", "-1"), this.dialogEl), escapeDeactivates: false, allowOutsideClick: this.allowOutsideClick }), (this.type === "modal" || this.type === "page") && this._focusTrap.activate();
          }
          await this.applyFocus(e36, t34);
        }
      }
      async applyFocus(e36, t34) {
        if (!(this.receivesFocus === "false" || this.type === "hint")) {
          if (await nextFrame(), await nextFrame(), e36 === this.open && !this.open) {
            this.hasNonVirtualTrigger && this.contains(this.getRootNode().activeElement) && this.triggerElement.focus();
            return;
          }
          t34 == null || t34.focus();
        }
      }
      returnFocus() {
        var t34;
        if (this.open || this.type === "hint") return;
        const e36 = () => {
          var a23, p30;
          const i21 = [];
          let s19 = document.activeElement;
          for (; (a23 = s19 == null ? void 0 : s19.shadowRoot) != null && a23.activeElement; ) s19 = s19.shadowRoot.activeElement;
          for (; s19; ) {
            const h16 = s19.assignedSlot || s19.parentElement || ((p30 = s19.getRootNode()) == null ? void 0 : p30.host);
            h16 && i21.push(h16), s19 = h16;
          }
          return i21;
        };
        this.receivesFocus !== "false" && ((t34 = this.triggerElement) != null && t34.focus) && (this.contains(this.getRootNode().activeElement) || e36().includes(this) || document.activeElement === document.body) && this.triggerElement.focus();
      }
      async manageOpen(e36) {
        var i21;
        if (!this.isConnected && this.open) return;
        this.hasUpdated || await this.updateComplete, this.open ? (overlayStack.add(this), this.willPreventClose && (document.addEventListener("pointerup", () => {
          this.dialogEl.classList.toggle("not-immediately-closable", false), this.willPreventClose = false;
        }, { once: true }), this.dialogEl.classList.toggle("not-immediately-closable", true))) : (e36 && ((i21 = this._focusTrap) == null || i21.deactivate(), this._focusTrap = null, this.dispose()), overlayStack.remove(this)), this.open && this.state !== "opened" ? this.state = "opening" : !this.open && this.state !== "closed" && (this.state = "closing"), this.managePopoverOpen();
        const t34 = this.getRootNode();
        this.type === "auto" && (this.open ? t34.addEventListener("focusout", this.closeOnFocusOut, { capture: true }) : t34.removeEventListener("focusout", this.closeOnFocusOut, { capture: true })), (this.type === "modal" || this.type === "page") && (this.open ? t34.addEventListener("cancel", this.closeOnCancelEvent, { capture: true }) : t34.removeEventListener("cancel", this.closeOnCancelEvent, { capture: true }));
      }
      bindEvents() {
        var e36;
        (e36 = this.strategy) == null || e36.abort(), this.strategy = void 0, this.hasNonVirtualTrigger && this.triggerInteraction && (this.strategy = new strategies[this.triggerInteraction](this.triggerElement, { overlay: this }));
      }
      handleBeforetoggle(e36) {
        e36.newState !== "open" && this.handleBrowserClose(e36);
      }
      handleBrowserClose(e36) {
        var t34;
        if (e36.stopPropagation(), !((t34 = this.strategy) != null && t34.activelyOpening)) {
          this.open = false;
          return;
        }
        this.manuallyKeepOpen();
      }
      manuallyKeepOpen() {
        this.open = true, this.placementController.allowPlacementUpdate = true, this.manageOpen(false);
      }
      handleSlotchange() {
        var e36, t34;
        this.elements.length ? this.hasNonVirtualTrigger && ((t34 = this.strategy) == null || t34.prepareDescription(this.triggerElement)) : (e36 = this.strategy) == null || e36.releaseDescription();
      }
      shouldPreventClose() {
        const e36 = this.willPreventClose;
        return this.willPreventClose = false, e36;
      }
      requestSlottable() {
        this.lastRequestSlottableState !== this.open && (this.open || document.body.offsetHeight, this.dispatchEvent(new SlottableRequestEvent("overlay-content", this.open ? {} : removeSlottableRequest)), this.lastRequestSlottableState = this.open);
      }
      willUpdate(e36) {
        var i21;
        if (this.hasAttribute("id") || this.setAttribute("id", `${this.tagName.toLowerCase()}-${randomID()}`), e36.has("allowOutsideClick") && this.allowOutsideClick && console.warn(`[${this.localName}] The "allow-outside-click" attribute has been deprecated and will be removed in a future release. We do not recommend using this attribute for accessibility reasons. It allows clicks outside the overlay to close it, which can cause unexpected behavior and accessibility issues.`), e36.has("open") && (this.hasUpdated || this.open) && this.manageOpen(e36.get("open")), e36.has("trigger")) {
          const [s19, a23] = ((i21 = this.trigger) == null ? void 0 : i21.split("@")) || [];
          this.elementResolver.selector = s19 ? `#${s19}` : "", this.triggerInteraction = a23;
        }
        let t34 = false;
        e36.has(elementResolverUpdatedSymbol) && (t34 = this.triggerElement, this.triggerElement = this.elementResolver.element), e36.has("triggerElement") && (t34 = e36.get("triggerElement")), t34 !== false && this.bindEvents();
      }
      updated(e36) {
        super.updated(e36), e36.has("placement") && (this.placement ? this.dialogEl.setAttribute("actual-placement", this.placement) : this.dialogEl.removeAttribute("actual-placement"), this.open && typeof e36.get("placement") != "undefined" && this.placementController.resetOverlayPosition()), e36.has("state") && this.state === "closed" && typeof e36.get("state") != "undefined" && this.placementController.clearOverlayPosition();
      }
      renderContent() {
        return x`
            <slot @slotchange=${this.handleSlotchange}></slot>
        `;
      }
      get dialogStyleMap() {
        return { "--swc-overlay-open-count": o23.openCount.toString() };
      }
      renderPopover() {
        return x`
            <div
                class="dialog"
                part="dialog"
                role=${o9(this.type === "modal" || this.type === "page" ? "dialog" : void 0)}
                aria-modal=${o9(this.type === "modal" || this.type === "page" ? "true" : void 0)}
                placement=${o9(this.requiresPositioning ? this.placement || "right" : void 0)}
                popover=${o9(this.popoverValue)}
                style=${o10(this.dialogStyleMap)}
                @beforetoggle=${this.handleBeforetoggle}
                @close=${this.handleBrowserClose}
                ?is-visible=${this.state !== "closed"}
            >
                ${this.renderContent()}
            </div>
        `;
      }
      render() {
        return x`
            ${this.renderPopover()}
            <slot name="longpress-describedby-descriptor"></slot>
        `;
      }
      connectedCallback() {
        super.connectedCallback(), this.addEventListener("close", () => {
          this.open = false;
        }), this.hasUpdated && this.bindEvents();
      }
      disconnectedCallback() {
        var e36;
        (e36 = this.strategy) == null || e36.releaseDescription(), this.open = false, super.disconnectedCallback();
      }
    };
    o22.styles = [overlay_css_default], o22.openCount = 1, r8([n4({ type: Boolean })], o22.prototype, "delayed", 1), r8([e5(".dialog")], o22.prototype, "dialogEl", 2), r8([n4({ type: Boolean })], o22.prototype, "disabled", 1), r8([o8({ flatten: true, selector: ':not([slot="longpress-describedby-descriptor"], slot)' })], o22.prototype, "elements", 2), r8([n4({ type: Number })], o22.prototype, "offset", 2), r8([n4({ type: Boolean, reflect: true })], o22.prototype, "open", 1), r8([n4()], o22.prototype, "placement", 2), r8([n4({ attribute: "receives-focus" })], o22.prototype, "receivesFocus", 2), r8([n4({ type: Boolean, attribute: "allow-outside-click" })], o22.prototype, "allowOutsideClick", 2), r8([e5("slot")], o22.prototype, "slotEl", 2), r8([r5()], o22.prototype, "state", 1), r8([n4({ type: Number, attribute: "tip-padding" })], o22.prototype, "tipPadding", 2), r8([n4()], o22.prototype, "trigger", 2), r8([n4({ attribute: false })], o22.prototype, "triggerElement", 2), r8([n4({ attribute: false })], o22.prototype, "triggerInteraction", 2), r8([n4()], o22.prototype, "type", 2);
    Overlay = o22;
  }
});

// node_modules/@spectrum-web-components/overlay/sp-overlay.js
var sp_overlay_exports = {};
var init_sp_overlay = __esm({
  "node_modules/@spectrum-web-components/overlay/sp-overlay.js"() {
    "use strict";
    init_define_element();
    init_Overlay();
    defineElement("sp-overlay", Overlay);
  }
});

// node_modules/@spectrum-web-components/popover/src/popover.css.js
var o24, popover_css_default;
var init_popover_css = __esm({
  "node_modules/@spectrum-web-components/popover/src/popover.css.js"() {
    "use strict";
    init_src();
    o24 = i`
    :host{pointer-events:none;visibility:hidden;opacity:0;transition:transform .13s ease-in-out,opacity .13s ease-in-out,visibility 0s linear .13s;transition:transform var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s))ease-in-out,opacity var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s))ease-in-out,visibility 0s linear var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s))}:host([open]){pointer-events:auto;visibility:visible;opacity:1;transition-delay:0s;transition-delay:var(--mod-overlay-animation-duration-opened,var(--spectrum-animation-duration-0,0s))}:host{--spectrum-popover-animation-distance:var(--spectrum-spacing-100);--spectrum-popover-background-color:var(--spectrum-background-layer-2-color);--spectrum-popover-border-color:var(--spectrum-gray-400);--spectrum-popover-content-area-spacing-vertical:var(--spectrum-popover-top-to-content-area);--spectrum-popover-shadow-horizontal:var(--spectrum-drop-shadow-x);--spectrum-popover-shadow-vertical:var(--spectrum-drop-shadow-y);--spectrum-popover-shadow-blur:var(--spectrum-drop-shadow-blur);--spectrum-popover-shadow-color:var(--spectrum-drop-shadow-color);--spectrum-popover-corner-radius:var(--spectrum-corner-radius-100);--spectrum-popover-pointer-width:var(--spectrum-popover-tip-width);--spectrum-popover-pointer-height:var(--spectrum-popover-tip-height);--spectrum-popover-pointer-edge-offset:calc(var(--spectrum-corner-radius-100) + var(--spectrum-popover-tip-width)/2);--spectrum-popover-pointer-edge-spacing:calc(var(--spectrum-popover-pointer-edge-offset) - var(--spectrum-popover-tip-width)/2)}@media (forced-colors:active){:host{--highcontrast-popover-border-color:CanvasText}}:host{--spectrum-popover-filter:drop-shadow(var(--mod-popover-shadow-horizontal,var(--spectrum-popover-shadow-horizontal))var(--mod-popover-shadow-vertical,var(--spectrum-popover-shadow-vertical))var(--mod-popover-shadow-blur,var(--spectrum-popover-shadow-blur))var(--mod-popover-shadow-color,var(--spectrum-popover-shadow-color)));box-sizing:border-box;padding:var(--mod-popover-content-area-spacing-vertical,var(--spectrum-popover-content-area-spacing-vertical))0;border-radius:var(--mod-popover-corner-radius,var(--spectrum-popover-corner-radius));border-style:solid;border-color:var(--highcontrast-popover-border-color,var(--mod-popover-border-color,var(--spectrum-popover-border-color)));border-width:var(--mod-popover-border-width,var(--spectrum-popover-border-width));background-color:var(--mod-popover-background-color,var(--spectrum-popover-background-color));filter:var(--mod-popover-filter,var(--spectrum-popover-filter));outline:none;flex-direction:column;display:inline-flex;position:absolute}:host([tip]){overflow:visible}:host([tip]) #tip .triangle{stroke-linecap:square;stroke-linejoin:miter;fill:var(--mod-popover-background-color,var(--spectrum-popover-background-color));stroke:var(--highcontrast-popover-border-color,var(--mod-popover-border-color,var(--spectrum-popover-border-color)));stroke-width:var(--mod-popover-border-width,var(--spectrum-popover-border-width))}*{--mod-popover-filter:none}:host([tip]) .spectrum-Popover--top-end,:host([tip]) .spectrum-Popover--top-left,:host([tip]) .spectrum-Popover--top-right,:host([tip]) .spectrum-Popover--top-start,:host([placement*=top][tip]){margin-block-end:calc(var(--mod-popover-pointer-height,var(--spectrum-popover-pointer-height)) - var(--mod-popover-border-width,var(--spectrum-popover-border-width)))}:host([open]) .spectrum-Popover--top-end,:host([open]) .spectrum-Popover--top-left,:host([open]) .spectrum-Popover--top-right,:host([open]) .spectrum-Popover--top-start,:host([placement*=top][open]){transform:translateY(calc(var(--mod-popover-animation-distance,var(--spectrum-popover-animation-distance))*-1))translateZ(0)}:host([tip]) .spectrum-Popover--bottom-end,:host([tip]) .spectrum-Popover--bottom-left,:host([tip]) .spectrum-Popover--bottom-right,:host([tip]) .spectrum-Popover--bottom-start,:host([placement*=bottom][tip]){margin-block-start:calc(var(--mod-popover-pointer-height,var(--spectrum-popover-pointer-height)) - var(--mod-popover-border-width,var(--spectrum-popover-border-width)))}:host([open]) .spectrum-Popover--bottom-end,:host([open]) .spectrum-Popover--bottom-left,:host([open]) .spectrum-Popover--bottom-right,:host([open]) .spectrum-Popover--bottom-start,:host([placement*=bottom][open]){transform:translateY(var(--mod-popover-animation-distance,var(--spectrum-popover-animation-distance)))translateZ(0)}:host([tip]) .spectrum-Popover--right-bottom,:host([tip]) .spectrum-Popover--right-top,:host([placement*=right][tip]){margin-left:calc(var(--mod-popover-pointer-width,var(--spectrum-popover-pointer-width)) - var(--mod-popover-border-width,var(--spectrum-popover-border-width)))}:host([open]) .spectrum-Popover--right-bottom,:host([open]) .spectrum-Popover--right-top,:host([placement*=right][open]){transform:translateX(var(--mod-popover-animation-distance,var(--spectrum-popover-animation-distance)))translateZ(0)}:host([tip]) .spectrum-Popover--left-bottom,:host([tip]) .spectrum-Popover--left-top,:host([placement*=left][tip]){margin-right:calc(var(--mod-popover-pointer-width,var(--spectrum-popover-pointer-width)) - var(--mod-popover-border-width,var(--spectrum-popover-border-width)))}:host([open]) .spectrum-Popover--left-bottom,:host([open]) .spectrum-Popover--left-top,:host([placement*=left][open]){transform:translateX(calc(var(--mod-popover-animation-distance,var(--spectrum-popover-animation-distance))*-1))translateZ(0)}:host([tip]) .spectrum-Popover--start-bottom,:host([tip]) .spectrum-Popover--start-top,:host([tip]) .spectrum-Popover--start{margin-inline-end:calc(var(--mod-popover-pointer-width,var(--spectrum-popover-pointer-width)) - var(--mod-popover-border-width,var(--spectrum-popover-border-width)))}:host([open]) .spectrum-Popover--start-bottom,:host([open]) .spectrum-Popover--start-top,:host([open]) .spectrum-Popover--start{transform:translateX(calc(var(--mod-popover-animation-distance,var(--spectrum-popover-animation-distance))*-1))translateZ(0)}:host([open]) .spectrum-Popover--start-bottom:dir(rtl),:host([open]) .spectrum-Popover--start-top:dir(rtl),:host([open]) .spectrum-Popover--start:dir(rtl),:host([dir=rtl][open]) .spectrum-Popover--start-bottom,:host([dir=rtl][open]) .spectrum-Popover--start-top,:host([dir=rtl][open]) .spectrum-Popover--start{transform:translateX(var(--mod-popover-animation-distance,var(--spectrum-popover-animation-distance)))translateZ(0)}:host([tip]) .spectrum-Popover--end-bottom,:host([tip]) .spectrum-Popover--end-top,:host([tip]) .spectrum-Popover--end{margin-inline-start:calc(var(--mod-popover-pointer-width,var(--spectrum-popover-pointer-width)) - var(--mod-popover-border-width,var(--spectrum-popover-border-width)))}:host([open]) .spectrum-Popover--end-bottom,:host([open]) .spectrum-Popover--end-top,:host([open]) .spectrum-Popover--end{transform:translateX(var(--mod-popover-animation-distance,var(--spectrum-popover-animation-distance)))translateZ(0)}:host([open]) .spectrum-Popover--end-bottom:dir(rtl),:host([open]) .spectrum-Popover--end-top:dir(rtl),:host([open]) .spectrum-Popover--end:dir(rtl),:host([dir=rtl][open]) .spectrum-Popover--end-bottom,:host([dir=rtl][open]) .spectrum-Popover--end-top,:host([dir=rtl][open]) .spectrum-Popover--end{transform:translateX(calc(var(--mod-popover-animation-distance,var(--spectrum-popover-animation-distance))*-1))translateZ(0)}:host([tip]) #tip,:host([tip][placement*=bottom]) #tip,:host([tip]) .spectrum-Popover--bottom-end #tip,:host([tip]) .spectrum-Popover--bottom-left #tip,:host([tip]) .spectrum-Popover--bottom-right #tip,:host([tip]) .spectrum-Popover--bottom-start #tip,:host([tip][placement*=top]) #tip,:host([tip]) .spectrum-Popover--top-end #tip,:host([tip]) .spectrum-Popover--top-left #tip,:host([tip]) .spectrum-Popover--top-right #tip,:host([tip]) .spectrum-Popover--top-start #tip{inline-size:var(--mod-popover-pointer-width,var(--spectrum-popover-pointer-width));block-size:var(--mod-popover-pointer-height,var(--spectrum-popover-pointer-height));margin:auto;position:absolute;inset-block-start:100%;inset-inline:0;transform:translate(0)}:host([tip]) .spectrum-Popover--top-left #tip{inset-inline:var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))auto}:host([tip]) .spectrum-Popover--top-right #tip{inset-inline:auto var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))}:host([tip]) .spectrum-Popover--top-start #tip{margin-inline-start:var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))}:host([tip]) .spectrum-Popover--top-end #tip{margin-inline-end:var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))}:host([tip][placement*=bottom]) #tip,:host([tip]) .spectrum-Popover--bottom-end #tip,:host([tip]) .spectrum-Popover--bottom-left #tip,:host([tip]) .spectrum-Popover--bottom-right #tip,:host([tip]) .spectrum-Popover--bottom-start #tip{inset-block:auto 100%;transform:scaleY(-1)}:host([tip]) .spectrum-Popover--bottom-left #tip{inset-inline:var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))auto}:host([tip]) .spectrum-Popover--bottom-right #tip{inset-inline:auto var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))}:host([tip]) .spectrum-Popover--bottom-start #tip{margin-inline-start:var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))}:host([tip]) .spectrum-Popover--bottom-end #tip{margin-inline-end:var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))}:host([tip]) .spectrum-Popover--end #tip,:host([tip]) .spectrum-Popover--end-bottom #tip,:host([tip]) .spectrum-Popover--end-top #tip,:host([tip][placement*=left]) #tip,:host([tip]) .spectrum-Popover--left-bottom #tip,:host([tip]) .spectrum-Popover--left-top #tip,:host([tip][placement*=right]) #tip,:host([tip]) .spectrum-Popover--right-bottom #tip,:host([tip]) .spectrum-Popover--right-top #tip,:host([tip]) .spectrum-Popover--start #tip,:host([tip]) .spectrum-Popover--start-bottom #tip,:host([tip]) .spectrum-Popover--start-top #tip{inline-size:var(--mod-popover-pointer-height,var(--spectrum-popover-pointer-height));block-size:var(--mod-popover-pointer-width,var(--spectrum-popover-pointer-width));inset-block:0}:host([tip][placement*=left]) #tip,:host([tip]) .spectrum-Popover--left-bottom #tip,:host([tip]) .spectrum-Popover--left-top #tip{left:100%;right:auto}:host([tip][placement*=right]) #tip,:host([tip]) .spectrum-Popover--right-bottom #tip,:host([tip]) .spectrum-Popover--right-top #tip{left:auto;right:100%;transform:scaleX(-1)}:host([tip]) .spectrum-Popover--end-top #tip,:host([tip]) .spectrum-Popover--left-top #tip,:host([tip]) .spectrum-Popover--right-top #tip,:host([tip]) .spectrum-Popover--start-top #tip{inset-block:var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))auto}:host([tip]) .spectrum-Popover--end-bottom #tip,:host([tip]) .spectrum-Popover--left-bottom #tip,:host([tip]) .spectrum-Popover--right-bottom #tip,:host([tip]) .spectrum-Popover--start-bottom #tip{inset-block:auto var(--mod-popover-pointer-edge-spacing,var(--spectrum-popover-pointer-edge-spacing))}:host([tip]) .spectrum-Popover--start #tip,:host([tip]) .spectrum-Popover--start-bottom #tip,:host([tip]) .spectrum-Popover--start-top #tip{margin-inline-start:100%}:host([tip]) .spectrum-Popover--start #tip:dir(rtl),:host([tip]) .spectrum-Popover--start-bottom #tip:dir(rtl),:host([tip]) .spectrum-Popover--start-top #tip:dir(rtl),:host([dir=rtl][tip]) .spectrum-Popover--start #tip,:host([dir=rtl][tip]) .spectrum-Popover--start-bottom #tip,:host([dir=rtl][tip]) .spectrum-Popover--start-top #tip{transform:none}:host([tip]) .spectrum-Popover--end #tip,:host([tip]) .spectrum-Popover--end-bottom #tip,:host([tip]) .spectrum-Popover--end-top #tip{margin-inline-end:100%;transform:scaleX(-1)}:host([tip]) .spectrum-Popover--end #tip:dir(rtl),:host([tip]) .spectrum-Popover--end-bottom #tip:dir(rtl),:host([tip]) .spectrum-Popover--end-top #tip:dir(rtl),:host([dir=rtl][tip]) .spectrum-Popover--end #tip,:host([dir=rtl][tip]) .spectrum-Popover--end-bottom #tip,:host([dir=rtl][tip]) .spectrum-Popover--end-top #tip{transform:scaleX(1)}:host{--spectrum-popover-border-width:var(--system-popover-border-width)}:host{min-width:min-content;max-width:100%;max-height:100%;inline-size:var(--mod-popover-inline-size);clip-path:none}::slotted(*){overscroll-behavior:contain}:host([placement*=left]) #tip[style],:host([placement*=right]) #tip[style]{inset-block-end:auto}:host([placement*=top]) #tip[style],:host([placement*=bottom]) #tip[style]{inset-inline-end:auto}.block,.inline{width:100%;height:100%;display:block}:host([placement*=left]) .block,:host([placement*=right]) .block,:host([placement*=top]) .inline,:host([placement*=bottom]) .inline{display:none}::slotted(.visually-hidden){clip:rect(0,0,0,0);clip-path:inset(50%);white-space:nowrap;border:0;width:1px;height:1px;margin:0 -1px -1px 0;padding:0;position:absolute;overflow:hidden}::slotted(sp-menu){margin:0}:host([dialog]){min-width:var(--mod-popover-dialog-min-width,var(--spectrum-popover-dialog-min-width,270px));padding:var(--mod-popover-dialog-padding,var(--spectrum-popover-dialog-padding,30px 29px))}:host([tip][placement]) #tip{height:auto}
`;
    popover_css_default = o24;
  }
});

// node_modules/@spectrum-web-components/popover/src/Popover.js
var c13, m10, r9, Popover;
var init_Popover = __esm({
  "node_modules/@spectrum-web-components/popover/src/Popover.js"() {
    "use strict";
    init_src();
    init_decorators2();
    init_popover_css();
    c13 = Object.defineProperty;
    m10 = Object.getOwnPropertyDescriptor;
    r9 = (p30, t34, i21, l16) => {
      for (var e36 = l16 > 1 ? void 0 : l16 ? m10(t34, i21) : t34, s19 = p30.length - 1, a23; s19 >= 0; s19--) (a23 = p30[s19]) && (e36 = (l16 ? a23(t34, i21, e36) : a23(e36)) || e36);
      return l16 && e36 && c13(t34, i21, e36), e36;
    };
    Popover = class extends SpectrumElement {
      constructor() {
        super(...arguments);
        this.open = false;
        this.tip = false;
      }
      static get styles() {
        return [popover_css_default];
      }
      renderTip() {
        return x`
            <div id="tip" aria-hidden="true">
                <svg class="tip block" viewBox="0 -0.5 16 9">
                    <path class="triangle" d="M-1,-1 8,8 17,-1"></path>
                </svg>
                <svg class="tip inline" viewBox="0 -0.5 9 16">
                    <path class="triangle" d="M-1,-1 8,8 -1,17"></path>
                </svg>
            </div>
        `;
      }
      render() {
        return x`
            <slot></slot>
            ${this.tip ? this.renderTip() : E}
        `;
      }
    };
    r9([n4({ type: Boolean, reflect: true })], Popover.prototype, "open", 2), r9([n4({ reflect: true })], Popover.prototype, "placement", 2), r9([n4({ type: Boolean, reflect: true })], Popover.prototype, "tip", 2), r9([e5("#tip")], Popover.prototype, "tipElement", 2);
  }
});

// node_modules/@spectrum-web-components/popover/sp-popover.js
var sp_popover_exports = {};
var init_sp_popover = __esm({
  "node_modules/@spectrum-web-components/popover/sp-popover.js"() {
    "use strict";
    init_Popover();
    init_define_element();
    defineElement("sp-popover", Popover);
  }
});

// node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
var dist_default;
var init_dist = __esm({
  "node_modules/orderedmap/dist/index.js"() {
    OrderedMap.prototype = {
      constructor: OrderedMap,
      find: function(key) {
        for (var i21 = 0; i21 < this.content.length; i21 += 2)
          if (this.content[i21] === key) return i21;
        return -1;
      },
      // :: (string)  ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(key) {
        var found2 = this.find(key);
        return found2 == -1 ? void 0 : this.content[found2 + 1];
      },
      // :: (string, any, ?string)  OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(key, value, newKey) {
        var self2 = newKey && newKey != key ? this.remove(newKey) : this;
        var found2 = self2.find(key), content = self2.content.slice();
        if (found2 == -1) {
          content.push(newKey || key, value);
        } else {
          content[found2 + 1] = value;
          if (newKey) content[found2] = newKey;
        }
        return new OrderedMap(content);
      },
      // :: (string)  OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(key) {
        var found2 = this.find(key);
        if (found2 == -1) return this;
        var content = this.content.slice();
        content.splice(found2, 2);
        return new OrderedMap(content);
      },
      // :: (string, any)  OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },
      // :: (string, any)  OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content);
      },
      // :: (string, string, any)  OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(place, key, value) {
        var without = this.remove(key), content = without.content.slice();
        var found2 = without.find(place);
        content.splice(found2 == -1 ? content.length : found2, 0, key, value);
        return new OrderedMap(content);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(f11) {
        for (var i21 = 0; i21 < this.content.length; i21 += 2)
          f11(this.content[i21], this.content[i21 + 1]);
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(map2) {
        map2 = OrderedMap.from(map2);
        if (!map2.size) return this;
        return new OrderedMap(map2.content.concat(this.subtract(map2).content));
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(map2) {
        map2 = OrderedMap.from(map2);
        if (!map2.size) return this;
        return new OrderedMap(this.subtract(map2).content.concat(map2.content));
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(map2) {
        var result = this;
        map2 = OrderedMap.from(map2);
        for (var i21 = 0; i21 < map2.content.length; i21 += 2)
          result = result.remove(map2.content[i21]);
        return result;
      },
      // :: ()  Object
      // Turn ordered map into a plain object.
      toObject: function() {
        var result = {};
        this.forEach(function(key, value) {
          result[key] = value;
        });
        return result;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap) return value;
      var content = [];
      if (value) for (var prop in value) content.push(prop, value[prop]);
      return new OrderedMap(content);
    };
    dist_default = OrderedMap;
  }
});

// node_modules/prosemirror-model/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  ContentMatch: () => ContentMatch,
  DOMParser: () => DOMParser2,
  DOMSerializer: () => DOMSerializer,
  Fragment: () => Fragment,
  Mark: () => Mark,
  MarkType: () => MarkType,
  Node: () => Node2,
  NodeRange: () => NodeRange,
  NodeType: () => NodeType,
  ReplaceError: () => ReplaceError,
  ResolvedPos: () => ResolvedPos,
  Schema: () => Schema,
  Slice: () => Slice
});
function findDiffStart(a23, b12, pos) {
  for (let i21 = 0; ; i21++) {
    if (i21 == a23.childCount || i21 == b12.childCount)
      return a23.childCount == b12.childCount ? null : pos;
    let childA = a23.child(i21), childB = b12.child(i21);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j3 = 0; childA.text[j3] == childB.text[j3]; j3++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a23, b12, posA, posB) {
  for (let iA = a23.childCount, iB = b12.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a23.child(--iA), childB = b12.child(--iB), size3 = childA.nodeSize;
    if (childA == childB) {
      posA -= size3;
      posB -= size3;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size3;
    posB -= size3;
  }
}
function retIndex(index, offset4) {
  found.index = index;
  found.offset = offset4;
  return found;
}
function compareDeep(a23, b12) {
  if (a23 === b12)
    return true;
  if (!(a23 && typeof a23 == "object") || !(b12 && typeof b12 == "object"))
    return false;
  let array = Array.isArray(a23);
  if (Array.isArray(b12) != array)
    return false;
  if (array) {
    if (a23.length != b12.length)
      return false;
    for (let i21 = 0; i21 < a23.length; i21++)
      if (!compareDeep(a23[i21], b12[i21]))
        return false;
  } else {
    for (let p30 in a23)
      if (!(p30 in b12) || !compareDeep(a23[p30], b12[p30]))
        return false;
    for (let p30 in b12)
      if (!(p30 in a23))
        return false;
  }
  return true;
}
function removeRange(content, from2, to2) {
  let { index, offset: offset4 } = content.findIndex(from2), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to2);
  if (offset4 == from2 || child.isText) {
    if (offsetTo != to2 && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to2));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset4 - 1, to2 - offset4 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index, offset: offset4 } = content.findIndex(dist), child = content.maybeChild(index);
  if (offset4 == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset4 - 1, insert, child);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i21 = startIndex; i21 < endIndex; i21++)
    addNode(node.child(i21), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i21 = extra - 1; i21 >= 0; i21--)
    node = $along.node(i21).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
function wrapMarks(marks2, str) {
  for (let i21 = marks2.length - 1; i21 >= 0; i21--)
    str = marks2[i21].type.name + "(" + str + ")";
  return str;
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to2, term) {
    let edge2 = { term, to: to2 };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to2) {
    edges.forEach((edge2) => edge2.to = to2);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i21 = 0; ; i21++) {
        let next = compile(expr2.exprs[i21], from2);
        if (i21 == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from2), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i21 = 0; i21 < expr2.min; i21++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i21 = expr2.min; i21 < expr2.max; i21++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a23, b12) {
  return b12 - a23;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i21 = 0; i21 < edges.length; i21++) {
      let { term, to: to2 } = edges[i21];
      if (!term && result.indexOf(to2) == -1)
        scan(to2);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to: to2 }) => {
        if (!term)
          return;
        let set;
        for (let i21 = 0; i21 < out.length; i21++)
          if (out[i21][0] == term)
            set = out[i21][1];
        nullFrom(nfa2, to2).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i21 = 0; i21 < out.length; i21++) {
      let states2 = out[i21][1].sort(cmp);
      state.next.push({ type: out[i21][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i21 = 0, work = [match]; i21 < work.length; i21++) {
    let state = work[i21], dead = !state.validEnd, nodes2 = [];
    for (let j3 = 0; j3 < state.next.length; j3++) {
      let { type, next } = state.next[j3];
      nodes2.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
function gatherMarks(schema2, marks2) {
  let found2 = [];
  for (let i21 = 0; i21 < marks2.length; i21++) {
    let name = marks2[i21], mark = schema2.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema2.marks) {
        let mark2 = schema2.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks2[i21] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches2(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes2 = nodeType.schema.nodes;
  for (let name in nodes2) {
    let parent = nodes2[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i21 = 0; i21 < match.edgeCount; i21++) {
        let { type, next } = match.edge(i21);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i21 = 0; i21 < value.length; i21++)
            scan(value[i21]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc3, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc3.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else if (name == "style" && dom.style)
          dom.style.cssText = attrs[name];
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i21 = start; i21 < structure.length; i21++) {
    let child = structure[i21];
    if (child === 0) {
      if (i21 < structure.length - 1 || i21 > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}
var Fragment, found, Mark, ReplaceError, Slice, ResolvedPos, ResolveCache, resolveCacheSize, resolveCache, NodeRange, emptyAttrs, Node2, TextNode, ContentMatch, TokenStream, NodeType, Attribute, MarkType, Schema, DOMParser2, blockTags, ignoreTags, listTags, OPT_PRESERVE_WS, OPT_PRESERVE_WS_FULL, OPT_OPEN_LEFT, NodeContext, ParseContext, DOMSerializer, suspiciousAttributeCache;
var init_dist2 = __esm({
  "node_modules/prosemirror-model/dist/index.js"() {
    init_dist();
    Fragment = class _Fragment {
      /**
      @internal
      */
      constructor(content, size3) {
        this.content = content;
        this.size = size3 || 0;
        if (size3 == null)
          for (let i21 = 0; i21 < content.length; i21++)
            this.size += content[i21].nodeSize;
      }
      /**
      Invoke a callback for all descendant nodes between the given two
      positions (relative to start of this fragment). Doesn't descend
      into a node when the callback returns `false`.
      */
      nodesBetween(from2, to2, f11, nodeStart = 0, parent) {
        for (let i21 = 0, pos = 0; pos < to2; i21++) {
          let child = this.content[i21], end = pos + child.nodeSize;
          if (end > from2 && f11(child, nodeStart + pos, parent || null, i21) !== false && child.content.size) {
            let start = pos + 1;
            child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to2 - start), f11, nodeStart + start);
          }
          pos = end;
        }
      }
      /**
      Call the given callback for every descendant node. `pos` will be
      relative to the start of the fragment. The callback may return
      `false` to prevent traversal of a given node's children.
      */
      descendants(f11) {
        this.nodesBetween(0, this.size, f11);
      }
      /**
      Extract the text between `from` and `to`. See the same method on
      [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
      */
      textBetween(from2, to2, blockSeparator, leafText) {
        let text = "", first = true;
        this.nodesBetween(from2, to2, (node, pos) => {
          let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to2 - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
          if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
            if (first)
              first = false;
            else
              text += blockSeparator;
          }
          text += nodeText;
        }, 0);
        return text;
      }
      /**
      Create a new fragment containing the combined content of this
      fragment and the other.
      */
      append(other) {
        if (!other.size)
          return this;
        if (!this.size)
          return other;
        let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i21 = 0;
        if (last.isText && last.sameMarkup(first)) {
          content[content.length - 1] = last.withText(last.text + first.text);
          i21 = 1;
        }
        for (; i21 < other.content.length; i21++)
          content.push(other.content[i21]);
        return new _Fragment(content, this.size + other.size);
      }
      /**
      Cut out the sub-fragment between the two given positions.
      */
      cut(from2, to2 = this.size) {
        if (from2 == 0 && to2 == this.size)
          return this;
        let result = [], size3 = 0;
        if (to2 > from2)
          for (let i21 = 0, pos = 0; pos < to2; i21++) {
            let child = this.content[i21], end = pos + child.nodeSize;
            if (end > from2) {
              if (pos < from2 || end > to2) {
                if (child.isText)
                  child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to2 - pos));
                else
                  child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to2 - pos - 1));
              }
              result.push(child);
              size3 += child.nodeSize;
            }
            pos = end;
          }
        return new _Fragment(result, size3);
      }
      /**
      @internal
      */
      cutByIndex(from2, to2) {
        if (from2 == to2)
          return _Fragment.empty;
        if (from2 == 0 && to2 == this.content.length)
          return this;
        return new _Fragment(this.content.slice(from2, to2));
      }
      /**
      Create a new fragment in which the node at the given index is
      replaced by the given node.
      */
      replaceChild(index, node) {
        let current = this.content[index];
        if (current == node)
          return this;
        let copy2 = this.content.slice();
        let size3 = this.size + node.nodeSize - current.nodeSize;
        copy2[index] = node;
        return new _Fragment(copy2, size3);
      }
      /**
      Create a new fragment by prepending the given node to this
      fragment.
      */
      addToStart(node) {
        return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
      }
      /**
      Create a new fragment by appending the given node to this
      fragment.
      */
      addToEnd(node) {
        return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
      }
      /**
      Compare this fragment to another one.
      */
      eq(other) {
        if (this.content.length != other.content.length)
          return false;
        for (let i21 = 0; i21 < this.content.length; i21++)
          if (!this.content[i21].eq(other.content[i21]))
            return false;
        return true;
      }
      /**
      The first child of the fragment, or `null` if it is empty.
      */
      get firstChild() {
        return this.content.length ? this.content[0] : null;
      }
      /**
      The last child of the fragment, or `null` if it is empty.
      */
      get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
      /**
      The number of child nodes in this fragment.
      */
      get childCount() {
        return this.content.length;
      }
      /**
      Get the child node at the given index. Raise an error when the
      index is out of range.
      */
      child(index) {
        let found2 = this.content[index];
        if (!found2)
          throw new RangeError("Index " + index + " out of range for " + this);
        return found2;
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(index) {
        return this.content[index] || null;
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(f11) {
        for (let i21 = 0, p30 = 0; i21 < this.content.length; i21++) {
          let child = this.content[i21];
          f11(child, p30, i21);
          p30 += child.nodeSize;
        }
      }
      /**
      Find the first position at which this fragment and another
      fragment differ, or `null` if they are the same.
      */
      findDiffStart(other, pos = 0) {
        return findDiffStart(this, other, pos);
      }
      /**
      Find the first position, searching from the end, at which this
      fragment and the given fragment differ, or `null` if they are
      the same. Since this position will not be the same in both
      nodes, an object with two separate positions is returned.
      */
      findDiffEnd(other, pos = this.size, otherPos = other.size) {
        return findDiffEnd(this, other, pos, otherPos);
      }
      /**
      Find the index and inner offset corresponding to a given relative
      position in this fragment. The result object will be reused
      (overwritten) the next time the function is called. @internal
      */
      findIndex(pos) {
        if (pos == 0)
          return retIndex(0, pos);
        if (pos == this.size)
          return retIndex(this.content.length, pos);
        if (pos > this.size || pos < 0)
          throw new RangeError(`Position ${pos} outside of fragment (${this})`);
        for (let i21 = 0, curPos = 0; ; i21++) {
          let cur = this.child(i21), end = curPos + cur.nodeSize;
          if (end >= pos) {
            if (end == pos)
              return retIndex(i21 + 1, end);
            return retIndex(i21, curPos);
          }
          curPos = end;
        }
      }
      /**
      Return a debugging string that describes this fragment.
      */
      toString() {
        return "<" + this.toStringInner() + ">";
      }
      /**
      @internal
      */
      toStringInner() {
        return this.content.join(", ");
      }
      /**
      Create a JSON-serializeable representation of this fragment.
      */
      toJSON() {
        return this.content.length ? this.content.map((n25) => n25.toJSON()) : null;
      }
      /**
      Deserialize a fragment from its JSON representation.
      */
      static fromJSON(schema2, value) {
        if (!value)
          return _Fragment.empty;
        if (!Array.isArray(value))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new _Fragment(value.map(schema2.nodeFromJSON));
      }
      /**
      Build a fragment from an array of nodes. Ensures that adjacent
      text nodes with the same marks are joined together.
      */
      static fromArray(array) {
        if (!array.length)
          return _Fragment.empty;
        let joined, size3 = 0;
        for (let i21 = 0; i21 < array.length; i21++) {
          let node = array[i21];
          size3 += node.nodeSize;
          if (i21 && node.isText && array[i21 - 1].sameMarkup(node)) {
            if (!joined)
              joined = array.slice(0, i21);
            joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
          } else if (joined) {
            joined.push(node);
          }
        }
        return new _Fragment(joined || array, size3);
      }
      /**
      Create a fragment from something that can be interpreted as a
      set of nodes. For `null`, it returns the empty fragment. For a
      fragment, the fragment itself. For a node or array of nodes, a
      fragment containing those nodes.
      */
      static from(nodes2) {
        if (!nodes2)
          return _Fragment.empty;
        if (nodes2 instanceof _Fragment)
          return nodes2;
        if (Array.isArray(nodes2))
          return this.fromArray(nodes2);
        if (nodes2.attrs)
          return new _Fragment([nodes2], nodes2.nodeSize);
        throw new RangeError("Can not convert " + nodes2 + " to a Fragment" + (nodes2.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    };
    Fragment.empty = new Fragment([], 0);
    found = { index: 0, offset: 0 };
    Mark = class _Mark {
      /**
      @internal
      */
      constructor(type, attrs) {
        this.type = type;
        this.attrs = attrs;
      }
      /**
      Given a set of marks, create a new set which contains this one as
      well, in the right position. If this mark is already in the set,
      the set itself is returned. If any marks that are set to be
      [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
      those are replaced by this one.
      */
      addToSet(set) {
        let copy2, placed = false;
        for (let i21 = 0; i21 < set.length; i21++) {
          let other = set[i21];
          if (this.eq(other))
            return set;
          if (this.type.excludes(other.type)) {
            if (!copy2)
              copy2 = set.slice(0, i21);
          } else if (other.type.excludes(this.type)) {
            return set;
          } else {
            if (!placed && other.type.rank > this.type.rank) {
              if (!copy2)
                copy2 = set.slice(0, i21);
              copy2.push(this);
              placed = true;
            }
            if (copy2)
              copy2.push(other);
          }
        }
        if (!copy2)
          copy2 = set.slice();
        if (!placed)
          copy2.push(this);
        return copy2;
      }
      /**
      Remove this mark from the given set, returning a new set. If this
      mark is not in the set, the set itself is returned.
      */
      removeFromSet(set) {
        for (let i21 = 0; i21 < set.length; i21++)
          if (this.eq(set[i21]))
            return set.slice(0, i21).concat(set.slice(i21 + 1));
        return set;
      }
      /**
      Test whether this mark is in the given set of marks.
      */
      isInSet(set) {
        for (let i21 = 0; i21 < set.length; i21++)
          if (this.eq(set[i21]))
            return true;
        return false;
      }
      /**
      Test whether this mark has the same type and attributes as
      another mark.
      */
      eq(other) {
        return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
      }
      /**
      Convert this mark to a JSON-serializeable representation.
      */
      toJSON() {
        let obj = { type: this.type.name };
        for (let _2 in this.attrs) {
          obj.attrs = this.attrs;
          break;
        }
        return obj;
      }
      /**
      Deserialize a mark from JSON.
      */
      static fromJSON(schema2, json) {
        if (!json)
          throw new RangeError("Invalid input for Mark.fromJSON");
        let type = schema2.marks[json.type];
        if (!type)
          throw new RangeError(`There is no mark type ${json.type} in this schema`);
        let mark = type.create(json.attrs);
        type.checkAttrs(mark.attrs);
        return mark;
      }
      /**
      Test whether two sets of marks are identical.
      */
      static sameSet(a23, b12) {
        if (a23 == b12)
          return true;
        if (a23.length != b12.length)
          return false;
        for (let i21 = 0; i21 < a23.length; i21++)
          if (!a23[i21].eq(b12[i21]))
            return false;
        return true;
      }
      /**
      Create a properly sorted mark set from null, a single mark, or an
      unsorted array of marks.
      */
      static setFrom(marks2) {
        if (!marks2 || Array.isArray(marks2) && marks2.length == 0)
          return _Mark.none;
        if (marks2 instanceof _Mark)
          return [marks2];
        let copy2 = marks2.slice();
        copy2.sort((a23, b12) => a23.type.rank - b12.type.rank);
        return copy2;
      }
    };
    Mark.none = [];
    ReplaceError = class extends Error {
    };
    Slice = class _Slice {
      /**
      Create a slice. When specifying a non-zero open depth, you must
      make sure that there are nodes of at least that depth at the
      appropriate side of the fragmenti.e. if the fragment is an
      empty paragraph node, `openStart` and `openEnd` can't be greater
      than 1.
      
      It is not necessary for the content of open nodes to conform to
      the schema's content constraints, though it should be a valid
      start/end/middle for such a node, depending on which sides are
      open.
      */
      constructor(content, openStart, openEnd) {
        this.content = content;
        this.openStart = openStart;
        this.openEnd = openEnd;
      }
      /**
      The size this slice would add when inserted into a document.
      */
      get size() {
        return this.content.size - this.openStart - this.openEnd;
      }
      /**
      @internal
      */
      insertAt(pos, fragment) {
        let content = insertInto(this.content, pos + this.openStart, fragment);
        return content && new _Slice(content, this.openStart, this.openEnd);
      }
      /**
      @internal
      */
      removeBetween(from2, to2) {
        return new _Slice(removeRange(this.content, from2 + this.openStart, to2 + this.openStart), this.openStart, this.openEnd);
      }
      /**
      Tests whether this slice is equal to another slice.
      */
      eq(other) {
        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
      }
      /**
      @internal
      */
      toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
      /**
      Convert a slice to a JSON-serializable representation.
      */
      toJSON() {
        if (!this.content.size)
          return null;
        let json = { content: this.content.toJSON() };
        if (this.openStart > 0)
          json.openStart = this.openStart;
        if (this.openEnd > 0)
          json.openEnd = this.openEnd;
        return json;
      }
      /**
      Deserialize a slice from its JSON representation.
      */
      static fromJSON(schema2, json) {
        if (!json)
          return _Slice.empty;
        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
        if (typeof openStart != "number" || typeof openEnd != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new _Slice(Fragment.fromJSON(schema2, json.content), openStart, openEnd);
      }
      /**
      Create a slice from a fragment by taking the maximum possible
      open value on both side of the fragment.
      */
      static maxOpen(fragment, openIsolating = true) {
        let openStart = 0, openEnd = 0;
        for (let n25 = fragment.firstChild; n25 && !n25.isLeaf && (openIsolating || !n25.type.spec.isolating); n25 = n25.firstChild)
          openStart++;
        for (let n25 = fragment.lastChild; n25 && !n25.isLeaf && (openIsolating || !n25.type.spec.isolating); n25 = n25.lastChild)
          openEnd++;
        return new _Slice(fragment, openStart, openEnd);
      }
    };
    Slice.empty = new Slice(Fragment.empty, 0, 0);
    ResolvedPos = class _ResolvedPos {
      /**
      @internal
      */
      constructor(pos, path, parentOffset) {
        this.pos = pos;
        this.path = path;
        this.parentOffset = parentOffset;
        this.depth = path.length / 3 - 1;
      }
      /**
      @internal
      */
      resolveDepth(val) {
        if (val == null)
          return this.depth;
        if (val < 0)
          return this.depth + val;
        return val;
      }
      /**
      The parent node that the position points into. Note that even if
      a position points into a text node, that node is not considered
      the parenttext nodes are flat in this model, and have no content.
      */
      get parent() {
        return this.node(this.depth);
      }
      /**
      The root node in which the position was resolved.
      */
      get doc() {
        return this.node(0);
      }
      /**
      The ancestor node at the given level. `p.node(p.depth)` is the
      same as `p.parent`.
      */
      node(depth) {
        return this.path[this.resolveDepth(depth) * 3];
      }
      /**
      The index into the ancestor at the given level. If this points
      at the 3rd node in the 2nd paragraph on the top level, for
      example, `p.index(0)` is 1 and `p.index(1)` is 2.
      */
      index(depth) {
        return this.path[this.resolveDepth(depth) * 3 + 1];
      }
      /**
      The index pointing after this position into the ancestor at the
      given level.
      */
      indexAfter(depth) {
        depth = this.resolveDepth(depth);
        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
      }
      /**
      The (absolute) position at the start of the node at the given
      level.
      */
      start(depth) {
        depth = this.resolveDepth(depth);
        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      }
      /**
      The (absolute) position at the end of the node at the given
      level.
      */
      end(depth) {
        depth = this.resolveDepth(depth);
        return this.start(depth) + this.node(depth).content.size;
      }
      /**
      The (absolute) position directly before the wrapping node at the
      given level, or, when `depth` is `this.depth + 1`, the original
      position.
      */
      before(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
          throw new RangeError("There is no position before the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
      }
      /**
      The (absolute) position directly after the wrapping node at the
      given level, or the original position when `depth` is `this.depth + 1`.
      */
      after(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
          throw new RangeError("There is no position after the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
      }
      /**
      When this position points into a text node, this returns the
      distance between the position and the start of the text node.
      Will be zero for positions that point between nodes.
      */
      get textOffset() {
        return this.pos - this.path[this.path.length - 1];
      }
      /**
      Get the node directly after the position, if any. If the position
      points into a text node, only the part of that node after the
      position is returned.
      */
      get nodeAfter() {
        let parent = this.parent, index = this.index(this.depth);
        if (index == parent.childCount)
          return null;
        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
        return dOff ? parent.child(index).cut(dOff) : child;
      }
      /**
      Get the node directly before the position, if any. If the
      position points into a text node, only the part of that node
      before the position is returned.
      */
      get nodeBefore() {
        let index = this.index(this.depth);
        let dOff = this.pos - this.path[this.path.length - 1];
        if (dOff)
          return this.parent.child(index).cut(0, dOff);
        return index == 0 ? null : this.parent.child(index - 1);
      }
      /**
      Get the position at the given index in the parent node at the
      given depth (which defaults to `this.depth`).
      */
      posAtIndex(index, depth) {
        depth = this.resolveDepth(depth);
        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
        for (let i21 = 0; i21 < index; i21++)
          pos += node.child(i21).nodeSize;
        return pos;
      }
      /**
      Get the marks at this position, factoring in the surrounding
      marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
      position is at the start of a non-empty node, the marks of the
      node after it (if any) are returned.
      */
      marks() {
        let parent = this.parent, index = this.index();
        if (parent.content.size == 0)
          return Mark.none;
        if (this.textOffset)
          return parent.child(index).marks;
        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
        if (!main) {
          let tmp = main;
          main = other;
          other = tmp;
        }
        let marks2 = main.marks;
        for (var i21 = 0; i21 < marks2.length; i21++)
          if (marks2[i21].type.spec.inclusive === false && (!other || !marks2[i21].isInSet(other.marks)))
            marks2 = marks2[i21--].removeFromSet(marks2);
        return marks2;
      }
      /**
      Get the marks after the current position, if any, except those
      that are non-inclusive and not present at position `$end`. This
      is mostly useful for getting the set of marks to preserve after a
      deletion. Will return `null` if this position is at the end of
      its parent node or its parent node isn't a textblock (in which
      case no marks should be preserved).
      */
      marksAcross($end) {
        let after = this.parent.maybeChild(this.index());
        if (!after || !after.isInline)
          return null;
        let marks2 = after.marks, next = $end.parent.maybeChild($end.index());
        for (var i21 = 0; i21 < marks2.length; i21++)
          if (marks2[i21].type.spec.inclusive === false && (!next || !marks2[i21].isInSet(next.marks)))
            marks2 = marks2[i21--].removeFromSet(marks2);
        return marks2;
      }
      /**
      The depth up to which this position and the given (non-resolved)
      position share the same parent nodes.
      */
      sharedDepth(pos) {
        for (let depth = this.depth; depth > 0; depth--)
          if (this.start(depth) <= pos && this.end(depth) >= pos)
            return depth;
        return 0;
      }
      /**
      Returns a range based on the place where this position and the
      given position diverge around block content. If both point into
      the same textblock, for example, a range around that textblock
      will be returned. If they point into different blocks, the range
      around those blocks in their shared ancestor is returned. You can
      pass in an optional predicate that will be called with a parent
      node to see if a range into that parent is acceptable.
      */
      blockRange(other = this, pred) {
        if (other.pos < this.pos)
          return other.blockRange(this);
        for (let d22 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d22 >= 0; d22--)
          if (other.pos <= this.end(d22) && (!pred || pred(this.node(d22))))
            return new NodeRange(this, other, d22);
        return null;
      }
      /**
      Query whether the given position shares the same parent node.
      */
      sameParent(other) {
        return this.pos - this.parentOffset == other.pos - other.parentOffset;
      }
      /**
      Return the greater of this and the given position.
      */
      max(other) {
        return other.pos > this.pos ? other : this;
      }
      /**
      Return the smaller of this and the given position.
      */
      min(other) {
        return other.pos < this.pos ? other : this;
      }
      /**
      @internal
      */
      toString() {
        let str = "";
        for (let i21 = 1; i21 <= this.depth; i21++)
          str += (str ? "/" : "") + this.node(i21).type.name + "_" + this.index(i21 - 1);
        return str + ":" + this.parentOffset;
      }
      /**
      @internal
      */
      static resolve(doc3, pos) {
        if (!(pos >= 0 && pos <= doc3.content.size))
          throw new RangeError("Position " + pos + " out of range");
        let path = [];
        let start = 0, parentOffset = pos;
        for (let node = doc3; ; ) {
          let { index, offset: offset4 } = node.content.findIndex(parentOffset);
          let rem = parentOffset - offset4;
          path.push(node, index, start + offset4);
          if (!rem)
            break;
          node = node.child(index);
          if (node.isText)
            break;
          parentOffset = rem - 1;
          start += offset4 + 1;
        }
        return new _ResolvedPos(pos, path, parentOffset);
      }
      /**
      @internal
      */
      static resolveCached(doc3, pos) {
        let cache2 = resolveCache.get(doc3);
        if (cache2) {
          for (let i21 = 0; i21 < cache2.elts.length; i21++) {
            let elt = cache2.elts[i21];
            if (elt.pos == pos)
              return elt;
          }
        } else {
          resolveCache.set(doc3, cache2 = new ResolveCache());
        }
        let result = cache2.elts[cache2.i] = _ResolvedPos.resolve(doc3, pos);
        cache2.i = (cache2.i + 1) % resolveCacheSize;
        return result;
      }
    };
    ResolveCache = class {
      constructor() {
        this.elts = [];
        this.i = 0;
      }
    };
    resolveCacheSize = 12;
    resolveCache = /* @__PURE__ */ new WeakMap();
    NodeRange = class {
      /**
      Construct a node range. `$from` and `$to` should point into the
      same node until at least the given `depth`, since a node range
      denotes an adjacent set of nodes in a single parent node.
      */
      constructor($from, $to, depth) {
        this.$from = $from;
        this.$to = $to;
        this.depth = depth;
      }
      /**
      The position at the start of the range.
      */
      get start() {
        return this.$from.before(this.depth + 1);
      }
      /**
      The position at the end of the range.
      */
      get end() {
        return this.$to.after(this.depth + 1);
      }
      /**
      The parent node that the range points into.
      */
      get parent() {
        return this.$from.node(this.depth);
      }
      /**
      The start index of the range in the parent node.
      */
      get startIndex() {
        return this.$from.index(this.depth);
      }
      /**
      The end index of the range in the parent node.
      */
      get endIndex() {
        return this.$to.indexAfter(this.depth);
      }
    };
    emptyAttrs = /* @__PURE__ */ Object.create(null);
    Node2 = class _Node {
      /**
      @internal
      */
      constructor(type, attrs, content, marks2 = Mark.none) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks2;
        this.content = content || Fragment.empty;
      }
      /**
      The array of this node's child nodes.
      */
      get children() {
        return this.content.content;
      }
      /**
      The size of this node, as defined by the integer-based [indexing
      scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
      amount of characters. For other leaf nodes, it is one. For
      non-leaf nodes, it is the size of the content plus two (the
      start and end token).
      */
      get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
      /**
      The number of children that the node has.
      */
      get childCount() {
        return this.content.childCount;
      }
      /**
      Get the child node at the given index. Raises an error when the
      index is out of range.
      */
      child(index) {
        return this.content.child(index);
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(index) {
        return this.content.maybeChild(index);
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(f11) {
        this.content.forEach(f11);
      }
      /**
      Invoke a callback for all descendant nodes recursively between
      the given two positions that are relative to start of this
      node's content. The callback is invoked with the node, its
      position relative to the original node (method receiver),
      its parent node, and its child index. When the callback returns
      false for a given node, that node's children will not be
      recursed over. The last parameter can be used to specify a
      starting position to count from.
      */
      nodesBetween(from2, to2, f11, startPos = 0) {
        this.content.nodesBetween(from2, to2, f11, startPos, this);
      }
      /**
      Call the given callback for every descendant node. Doesn't
      descend into a node when the callback returns `false`.
      */
      descendants(f11) {
        this.nodesBetween(0, this.content.size, f11);
      }
      /**
      Concatenates all the text nodes found in this fragment and its
      children.
      */
      get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
      /**
      Get all text between positions `from` and `to`. When
      `blockSeparator` is given, it will be inserted to separate text
      from different block nodes. If `leafText` is given, it'll be
      inserted for every non-text leaf node encountered, otherwise
      [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
      */
      textBetween(from2, to2, blockSeparator, leafText) {
        return this.content.textBetween(from2, to2, blockSeparator, leafText);
      }
      /**
      Returns this node's first child, or `null` if there are no
      children.
      */
      get firstChild() {
        return this.content.firstChild;
      }
      /**
      Returns this node's last child, or `null` if there are no
      children.
      */
      get lastChild() {
        return this.content.lastChild;
      }
      /**
      Test whether two nodes represent the same piece of document.
      */
      eq(other) {
        return this == other || this.sameMarkup(other) && this.content.eq(other.content);
      }
      /**
      Compare the markup (type, attributes, and marks) of this node to
      those of another. Returns `true` if both have the same markup.
      */
      sameMarkup(other) {
        return this.hasMarkup(other.type, other.attrs, other.marks);
      }
      /**
      Check whether this node's markup correspond to the given type,
      attributes, and marks.
      */
      hasMarkup(type, attrs, marks2) {
        return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks2 || Mark.none);
      }
      /**
      Create a new node with the same markup as this node, containing
      the given content (or empty, if no content is given).
      */
      copy(content = null) {
        if (content == this.content)
          return this;
        return new _Node(this.type, this.attrs, content, this.marks);
      }
      /**
      Create a copy of this node, with the given set of marks instead
      of the node's own marks.
      */
      mark(marks2) {
        return marks2 == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks2);
      }
      /**
      Create a copy of this node with only the content between the
      given positions. If `to` is not given, it defaults to the end of
      the node.
      */
      cut(from2, to2 = this.content.size) {
        if (from2 == 0 && to2 == this.content.size)
          return this;
        return this.copy(this.content.cut(from2, to2));
      }
      /**
      Cut out the part of the document between the given positions, and
      return it as a `Slice` object.
      */
      slice(from2, to2 = this.content.size, includeParents = false) {
        if (from2 == to2)
          return Slice.empty;
        let $from = this.resolve(from2), $to = this.resolve(to2);
        let depth = includeParents ? 0 : $from.sharedDepth(to2);
        let start = $from.start(depth), node = $from.node(depth);
        let content = node.content.cut($from.pos - start, $to.pos - start);
        return new Slice(content, $from.depth - depth, $to.depth - depth);
      }
      /**
      Replace the part of the document between the given positions with
      the given slice. The slice must 'fit', meaning its open sides
      must be able to connect to the surrounding content, and its
      content nodes must be valid children for the node they are placed
      into. If any of this is violated, an error of type
      [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
      */
      replace(from2, to2, slice2) {
        return replace(this.resolve(from2), this.resolve(to2), slice2);
      }
      /**
      Find the node directly after the given position.
      */
      nodeAt(pos) {
        for (let node = this; ; ) {
          let { index, offset: offset4 } = node.content.findIndex(pos);
          node = node.maybeChild(index);
          if (!node)
            return null;
          if (offset4 == pos || node.isText)
            return node;
          pos -= offset4 + 1;
        }
      }
      /**
      Find the (direct) child node after the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childAfter(pos) {
        let { index, offset: offset4 } = this.content.findIndex(pos);
        return { node: this.content.maybeChild(index), index, offset: offset4 };
      }
      /**
      Find the (direct) child node before the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childBefore(pos) {
        if (pos == 0)
          return { node: null, index: 0, offset: 0 };
        let { index, offset: offset4 } = this.content.findIndex(pos);
        if (offset4 < pos)
          return { node: this.content.child(index), index, offset: offset4 };
        let node = this.content.child(index - 1);
        return { node, index: index - 1, offset: offset4 - node.nodeSize };
      }
      /**
      Resolve the given position in the document, returning an
      [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
      */
      resolve(pos) {
        return ResolvedPos.resolveCached(this, pos);
      }
      /**
      @internal
      */
      resolveNoCache(pos) {
        return ResolvedPos.resolve(this, pos);
      }
      /**
      Test whether a given mark or mark type occurs in this document
      between the two given positions.
      */
      rangeHasMark(from2, to2, type) {
        let found2 = false;
        if (to2 > from2)
          this.nodesBetween(from2, to2, (node) => {
            if (type.isInSet(node.marks))
              found2 = true;
            return !found2;
          });
        return found2;
      }
      /**
      True when this is a block (non-inline node)
      */
      get isBlock() {
        return this.type.isBlock;
      }
      /**
      True when this is a textblock node, a block node with inline
      content.
      */
      get isTextblock() {
        return this.type.isTextblock;
      }
      /**
      True when this node allows inline content.
      */
      get inlineContent() {
        return this.type.inlineContent;
      }
      /**
      True when this is an inline node (a text node or a node that can
      appear among text).
      */
      get isInline() {
        return this.type.isInline;
      }
      /**
      True when this is a text node.
      */
      get isText() {
        return this.type.isText;
      }
      /**
      True when this is a leaf node.
      */
      get isLeaf() {
        return this.type.isLeaf;
      }
      /**
      True when this is an atom, i.e. when it does not have directly
      editable content. This is usually the same as `isLeaf`, but can
      be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
      on a node's spec (typically used when the node is displayed as
      an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
      */
      get isAtom() {
        return this.type.isAtom;
      }
      /**
      Return a string representation of this node for debugging
      purposes.
      */
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        let name = this.type.name;
        if (this.content.size)
          name += "(" + this.content.toStringInner() + ")";
        return wrapMarks(this.marks, name);
      }
      /**
      Get the content match in this node at the given index.
      */
      contentMatchAt(index) {
        let match = this.type.contentMatch.matchFragment(this.content, 0, index);
        if (!match)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return match;
      }
      /**
      Test whether replacing the range between `from` and `to` (by
      child index) with the given replacement fragment (which defaults
      to the empty fragment) would leave the node's content valid. You
      can optionally pass `start` and `end` indices into the
      replacement fragment.
      */
      canReplace(from2, to2, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
        let one = this.contentMatchAt(from2).matchFragment(replacement, start, end);
        let two = one && one.matchFragment(this.content, to2);
        if (!two || !two.validEnd)
          return false;
        for (let i21 = start; i21 < end; i21++)
          if (!this.type.allowsMarks(replacement.child(i21).marks))
            return false;
        return true;
      }
      /**
      Test whether replacing the range `from` to `to` (by index) with
      a node of the given type would leave the node's content valid.
      */
      canReplaceWith(from2, to2, type, marks2) {
        if (marks2 && !this.type.allowsMarks(marks2))
          return false;
        let start = this.contentMatchAt(from2).matchType(type);
        let end = start && start.matchFragment(this.content, to2);
        return end ? end.validEnd : false;
      }
      /**
      Test whether the given node's content could be appended to this
      node. If that node is empty, this will only return true if there
      is at least one node type that can appear in both nodes (to avoid
      merging completely incompatible nodes).
      */
      canAppend(other) {
        if (other.content.size)
          return this.canReplace(this.childCount, this.childCount, other.content);
        else
          return this.type.compatibleContent(other.type);
      }
      /**
      Check whether this node and its descendants conform to the
      schema, and raise an exception when they do not.
      */
      check() {
        this.type.checkContent(this.content);
        this.type.checkAttrs(this.attrs);
        let copy2 = Mark.none;
        for (let i21 = 0; i21 < this.marks.length; i21++) {
          let mark = this.marks[i21];
          mark.type.checkAttrs(mark.attrs);
          copy2 = mark.addToSet(copy2);
        }
        if (!Mark.sameSet(copy2, this.marks))
          throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m18) => m18.type.name)}`);
        this.content.forEach((node) => node.check());
      }
      /**
      Return a JSON-serializeable representation of this node.
      */
      toJSON() {
        let obj = { type: this.type.name };
        for (let _2 in this.attrs) {
          obj.attrs = this.attrs;
          break;
        }
        if (this.content.size)
          obj.content = this.content.toJSON();
        if (this.marks.length)
          obj.marks = this.marks.map((n25) => n25.toJSON());
        return obj;
      }
      /**
      Deserialize a node from its JSON representation.
      */
      static fromJSON(schema2, json) {
        if (!json)
          throw new RangeError("Invalid input for Node.fromJSON");
        let marks2 = void 0;
        if (json.marks) {
          if (!Array.isArray(json.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          marks2 = json.marks.map(schema2.markFromJSON);
        }
        if (json.type == "text") {
          if (typeof json.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return schema2.text(json.text, marks2);
        }
        let content = Fragment.fromJSON(schema2, json.content);
        let node = schema2.nodeType(json.type).create(json.attrs, content, marks2);
        node.type.checkAttrs(node.attrs);
        return node;
      }
    };
    Node2.prototype.text = void 0;
    TextNode = class _TextNode extends Node2 {
      /**
      @internal
      */
      constructor(type, attrs, content, marks2) {
        super(type, attrs, null, marks2);
        if (!content)
          throw new RangeError("Empty text nodes are not allowed");
        this.text = content;
      }
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        return wrapMarks(this.marks, JSON.stringify(this.text));
      }
      get textContent() {
        return this.text;
      }
      textBetween(from2, to2) {
        return this.text.slice(from2, to2);
      }
      get nodeSize() {
        return this.text.length;
      }
      mark(marks2) {
        return marks2 == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks2);
      }
      withText(text) {
        if (text == this.text)
          return this;
        return new _TextNode(this.type, this.attrs, text, this.marks);
      }
      cut(from2 = 0, to2 = this.text.length) {
        if (from2 == 0 && to2 == this.text.length)
          return this;
        return this.withText(this.text.slice(from2, to2));
      }
      eq(other) {
        return this.sameMarkup(other) && this.text == other.text;
      }
      toJSON() {
        let base2 = super.toJSON();
        base2.text = this.text;
        return base2;
      }
    };
    ContentMatch = class _ContentMatch {
      /**
      @internal
      */
      constructor(validEnd) {
        this.validEnd = validEnd;
        this.next = [];
        this.wrapCache = [];
      }
      /**
      @internal
      */
      static parse(string, nodeTypes) {
        let stream = new TokenStream(string, nodeTypes);
        if (stream.next == null)
          return _ContentMatch.empty;
        let expr = parseExpr(stream);
        if (stream.next)
          stream.err("Unexpected trailing text");
        let match = dfa(nfa(expr));
        checkForDeadEnds(match, stream);
        return match;
      }
      /**
      Match a node type, returning a match after that node if
      successful.
      */
      matchType(type) {
        for (let i21 = 0; i21 < this.next.length; i21++)
          if (this.next[i21].type == type)
            return this.next[i21].next;
        return null;
      }
      /**
      Try to match a fragment. Returns the resulting match when
      successful.
      */
      matchFragment(frag, start = 0, end = frag.childCount) {
        let cur = this;
        for (let i21 = start; cur && i21 < end; i21++)
          cur = cur.matchType(frag.child(i21).type);
        return cur;
      }
      /**
      @internal
      */
      get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
      /**
      Get the first matching node type at this match position that can
      be generated.
      */
      get defaultType() {
        for (let i21 = 0; i21 < this.next.length; i21++) {
          let { type } = this.next[i21];
          if (!(type.isText || type.hasRequiredAttrs()))
            return type;
        }
        return null;
      }
      /**
      @internal
      */
      compatible(other) {
        for (let i21 = 0; i21 < this.next.length; i21++)
          for (let j3 = 0; j3 < other.next.length; j3++)
            if (this.next[i21].type == other.next[j3].type)
              return true;
        return false;
      }
      /**
      Try to match the given fragment, and if that fails, see if it can
      be made to match by inserting nodes in front of it. When
      successful, return a fragment of inserted nodes (which may be
      empty if nothing had to be inserted). When `toEnd` is true, only
      return a fragment if the resulting match goes to the end of the
      content expression.
      */
      fillBefore(after, toEnd = false, startIndex = 0) {
        let seen = [this];
        function search(match, types) {
          let finished = match.matchFragment(after, startIndex);
          if (finished && (!toEnd || finished.validEnd))
            return Fragment.from(types.map((tp) => tp.createAndFill()));
          for (let i21 = 0; i21 < match.next.length; i21++) {
            let { type, next } = match.next[i21];
            if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
              seen.push(next);
              let found2 = search(next, types.concat(type));
              if (found2)
                return found2;
            }
          }
          return null;
        }
        return search(this, []);
      }
      /**
      Find a set of wrapping node types that would allow a node of the
      given type to appear at this position. The result may be empty
      (when it fits directly) and will be null when no such wrapping
      exists.
      */
      findWrapping(target) {
        for (let i21 = 0; i21 < this.wrapCache.length; i21 += 2)
          if (this.wrapCache[i21] == target)
            return this.wrapCache[i21 + 1];
        let computed = this.computeWrapping(target);
        this.wrapCache.push(target, computed);
        return computed;
      }
      /**
      @internal
      */
      computeWrapping(target) {
        let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
        while (active.length) {
          let current = active.shift(), match = current.match;
          if (match.matchType(target)) {
            let result = [];
            for (let obj = current; obj.type; obj = obj.via)
              result.push(obj.type);
            return result.reverse();
          }
          for (let i21 = 0; i21 < match.next.length; i21++) {
            let { type, next } = match.next[i21];
            if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
              active.push({ match: type.contentMatch, type, via: current });
              seen[type.name] = true;
            }
          }
        }
        return null;
      }
      /**
      The number of outgoing edges this node has in the finite
      automaton that describes the content expression.
      */
      get edgeCount() {
        return this.next.length;
      }
      /**
      Get the _n_th outgoing edge from this node in the finite
      automaton that describes the content expression.
      */
      edge(n25) {
        if (n25 >= this.next.length)
          throw new RangeError(`There's no ${n25}th edge in this content match`);
        return this.next[n25];
      }
      /**
      @internal
      */
      toString() {
        let seen = [];
        function scan(m18) {
          seen.push(m18);
          for (let i21 = 0; i21 < m18.next.length; i21++)
            if (seen.indexOf(m18.next[i21].next) == -1)
              scan(m18.next[i21].next);
        }
        scan(this);
        return seen.map((m18, i21) => {
          let out = i21 + (m18.validEnd ? "*" : " ") + " ";
          for (let i22 = 0; i22 < m18.next.length; i22++)
            out += (i22 ? ", " : "") + m18.next[i22].type.name + "->" + seen.indexOf(m18.next[i22].next);
          return out;
        }).join("\n");
      }
    };
    ContentMatch.empty = new ContentMatch(true);
    TokenStream = class {
      constructor(string, nodeTypes) {
        this.string = string;
        this.nodeTypes = nodeTypes;
        this.inline = null;
        this.pos = 0;
        this.tokens = string.split(/\s*(?=\b|\W|$)/);
        if (this.tokens[this.tokens.length - 1] == "")
          this.tokens.pop();
        if (this.tokens[0] == "")
          this.tokens.shift();
      }
      get next() {
        return this.tokens[this.pos];
      }
      eat(tok) {
        return this.next == tok && (this.pos++ || true);
      }
      err(str) {
        throw new SyntaxError(str + " (in content expression '" + this.string + "')");
      }
    };
    NodeType = class _NodeType {
      /**
      @internal
      */
      constructor(name, schema2, spec) {
        this.name = name;
        this.schema = schema2;
        this.spec = spec;
        this.markSet = null;
        this.groups = spec.group ? spec.group.split(" ") : [];
        this.attrs = initAttrs(name, spec.attrs);
        this.defaultAttrs = defaultAttrs(this.attrs);
        this.contentMatch = null;
        this.inlineContent = null;
        this.isBlock = !(spec.inline || name == "text");
        this.isText = name == "text";
      }
      /**
      True if this is an inline type.
      */
      get isInline() {
        return !this.isBlock;
      }
      /**
      True if this is a textblock type, a block that contains inline
      content.
      */
      get isTextblock() {
        return this.isBlock && this.inlineContent;
      }
      /**
      True for node types that allow no content.
      */
      get isLeaf() {
        return this.contentMatch == ContentMatch.empty;
      }
      /**
      True when this node is an atom, i.e. when it does not have
      directly editable content.
      */
      get isAtom() {
        return this.isLeaf || !!this.spec.atom;
      }
      /**
      Return true when this node type is part of the given
      [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
      */
      isInGroup(group) {
        return this.groups.indexOf(group) > -1;
      }
      /**
      The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
      */
      get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
      /**
      Tells you whether this node type has any required attributes.
      */
      hasRequiredAttrs() {
        for (let n25 in this.attrs)
          if (this.attrs[n25].isRequired)
            return true;
        return false;
      }
      /**
      Indicates whether this node allows some of the same content as
      the given node type.
      */
      compatibleContent(other) {
        return this == other || this.contentMatch.compatible(other.contentMatch);
      }
      /**
      @internal
      */
      computeAttrs(attrs) {
        if (!attrs && this.defaultAttrs)
          return this.defaultAttrs;
        else
          return computeAttrs(this.attrs, attrs);
      }
      /**
      Create a `Node` of this type. The given attributes are
      checked and defaulted (you can pass `null` to use the type's
      defaults entirely, if no required attributes exist). `content`
      may be a `Fragment`, a node, an array of nodes, or
      `null`. Similarly `marks` may be `null` to default to the empty
      set of marks.
      */
      create(attrs = null, content, marks2) {
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new Node2(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks2));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
      against the node type's content restrictions, and throw an error
      if it doesn't match.
      */
      createChecked(attrs = null, content, marks2) {
        content = Fragment.from(content);
        this.checkContent(content);
        return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks2));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
      necessary to add nodes to the start or end of the given fragment
      to make it fit the node. If no fitting wrapping can be found,
      return null. Note that, due to the fact that required nodes can
      always be created, this will always succeed if you pass null or
      `Fragment.empty` as content.
      */
      createAndFill(attrs = null, content, marks2) {
        attrs = this.computeAttrs(attrs);
        content = Fragment.from(content);
        if (content.size) {
          let before = this.contentMatch.fillBefore(content);
          if (!before)
            return null;
          content = before.append(content);
        }
        let matched = this.contentMatch.matchFragment(content);
        let after = matched && matched.fillBefore(Fragment.empty, true);
        if (!after)
          return null;
        return new Node2(this, attrs, content.append(after), Mark.setFrom(marks2));
      }
      /**
      Returns true if the given fragment is valid content for this node
      type.
      */
      validContent(content) {
        let result = this.contentMatch.matchFragment(content);
        if (!result || !result.validEnd)
          return false;
        for (let i21 = 0; i21 < content.childCount; i21++)
          if (!this.allowsMarks(content.child(i21).marks))
            return false;
        return true;
      }
      /**
      Throws a RangeError if the given fragment is not valid content for this
      node type.
      @internal
      */
      checkContent(content) {
        if (!this.validContent(content))
          throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
      }
      /**
      @internal
      */
      checkAttrs(attrs) {
        checkAttrs(this.attrs, attrs, "node", this.name);
      }
      /**
      Check whether the given mark type is allowed in this node.
      */
      allowsMarkType(markType) {
        return this.markSet == null || this.markSet.indexOf(markType) > -1;
      }
      /**
      Test whether the given set of marks are allowed in this node.
      */
      allowsMarks(marks2) {
        if (this.markSet == null)
          return true;
        for (let i21 = 0; i21 < marks2.length; i21++)
          if (!this.allowsMarkType(marks2[i21].type))
            return false;
        return true;
      }
      /**
      Removes the marks that are not allowed in this node from the given set.
      */
      allowedMarks(marks2) {
        if (this.markSet == null)
          return marks2;
        let copy2;
        for (let i21 = 0; i21 < marks2.length; i21++) {
          if (!this.allowsMarkType(marks2[i21].type)) {
            if (!copy2)
              copy2 = marks2.slice(0, i21);
          } else if (copy2) {
            copy2.push(marks2[i21]);
          }
        }
        return !copy2 ? marks2 : copy2.length ? copy2 : Mark.none;
      }
      /**
      @internal
      */
      static compile(nodes2, schema2) {
        let result = /* @__PURE__ */ Object.create(null);
        nodes2.forEach((name, spec) => result[name] = new _NodeType(name, schema2, spec));
        let topType = schema2.spec.topNode || "doc";
        if (!result[topType])
          throw new RangeError("Schema is missing its top node type ('" + topType + "')");
        if (!result.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (let _2 in result.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return result;
      }
    };
    Attribute = class {
      constructor(typeName, attrName, options) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
        this.default = options.default;
        this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
      }
      get isRequired() {
        return !this.hasDefault;
      }
    };
    MarkType = class _MarkType {
      /**
      @internal
      */
      constructor(name, rank, schema2, spec) {
        this.name = name;
        this.rank = rank;
        this.schema = schema2;
        this.spec = spec;
        this.attrs = initAttrs(name, spec.attrs);
        this.excluded = null;
        let defaults = defaultAttrs(this.attrs);
        this.instance = defaults ? new Mark(this, defaults) : null;
      }
      /**
      Create a mark of this type. `attrs` may be `null` or an object
      containing only some of the mark's attributes. The others, if
      they have defaults, will be added.
      */
      create(attrs = null) {
        if (!attrs && this.instance)
          return this.instance;
        return new Mark(this, computeAttrs(this.attrs, attrs));
      }
      /**
      @internal
      */
      static compile(marks2, schema2) {
        let result = /* @__PURE__ */ Object.create(null), rank = 0;
        marks2.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema2, spec));
        return result;
      }
      /**
      When there is a mark of this type in the given set, a new set
      without it is returned. Otherwise, the input set is returned.
      */
      removeFromSet(set) {
        for (var i21 = 0; i21 < set.length; i21++)
          if (set[i21].type == this) {
            set = set.slice(0, i21).concat(set.slice(i21 + 1));
            i21--;
          }
        return set;
      }
      /**
      Tests whether there is a mark of this type in the given set.
      */
      isInSet(set) {
        for (let i21 = 0; i21 < set.length; i21++)
          if (set[i21].type == this)
            return set[i21];
      }
      /**
      @internal
      */
      checkAttrs(attrs) {
        checkAttrs(this.attrs, attrs, "mark", this.name);
      }
      /**
      Queries whether a given mark type is
      [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
      */
      excludes(other) {
        return this.excluded.indexOf(other) > -1;
      }
    };
    Schema = class {
      /**
      Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
      */
      constructor(spec) {
        this.linebreakReplacement = null;
        this.cached = /* @__PURE__ */ Object.create(null);
        let instanceSpec = this.spec = {};
        for (let prop in spec)
          instanceSpec[prop] = spec[prop];
        instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
        this.marks = MarkType.compile(this.spec.marks, this);
        let contentExprCache = /* @__PURE__ */ Object.create(null);
        for (let prop in this.nodes) {
          if (prop in this.marks)
            throw new RangeError(prop + " can not be both a node and a mark");
          let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
          type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
          type.inlineContent = type.contentMatch.inlineContent;
          if (type.spec.linebreakReplacement) {
            if (this.linebreakReplacement)
              throw new RangeError("Multiple linebreak nodes defined");
            if (!type.isInline || !type.isLeaf)
              throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
            this.linebreakReplacement = type;
          }
          type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
        }
        for (let prop in this.marks) {
          let type = this.marks[prop], excl = type.spec.excludes;
          type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
        }
        this.nodeFromJSON = (json) => Node2.fromJSON(this, json);
        this.markFromJSON = (json) => Mark.fromJSON(this, json);
        this.topNodeType = this.nodes[this.spec.topNode || "doc"];
        this.cached.wrappings = /* @__PURE__ */ Object.create(null);
      }
      /**
      Create a node in this schema. The `type` may be a string or a
      `NodeType` instance. Attributes will be extended with defaults,
      `content` may be a `Fragment`, `null`, a `Node`, or an array of
      nodes.
      */
      node(type, attrs = null, content, marks2) {
        if (typeof type == "string")
          type = this.nodeType(type);
        else if (!(type instanceof NodeType))
          throw new RangeError("Invalid node type: " + type);
        else if (type.schema != this)
          throw new RangeError("Node type from different schema used (" + type.name + ")");
        return type.createChecked(attrs, content, marks2);
      }
      /**
      Create a text node in the schema. Empty text nodes are not
      allowed.
      */
      text(text, marks2) {
        let type = this.nodes.text;
        return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks2));
      }
      /**
      Create a mark with the given type and attributes.
      */
      mark(type, attrs) {
        if (typeof type == "string")
          type = this.marks[type];
        return type.create(attrs);
      }
      /**
      @internal
      */
      nodeType(name) {
        let found2 = this.nodes[name];
        if (!found2)
          throw new RangeError("Unknown node type: " + name);
        return found2;
      }
    };
    DOMParser2 = class _DOMParser {
      /**
      Create a parser that targets the given schema, using the given
      parsing rules.
      */
      constructor(schema2, rules) {
        this.schema = schema2;
        this.rules = rules;
        this.tags = [];
        this.styles = [];
        let matchedStyles = this.matchedStyles = [];
        rules.forEach((rule) => {
          if (isTagRule(rule)) {
            this.tags.push(rule);
          } else if (isStyleRule(rule)) {
            let prop = /[^=]*/.exec(rule.style)[0];
            if (matchedStyles.indexOf(prop) < 0)
              matchedStyles.push(prop);
            this.styles.push(rule);
          }
        });
        this.normalizeLists = !this.tags.some((r25) => {
          if (!/^(ul|ol)\b/.test(r25.tag) || !r25.node)
            return false;
          let node = schema2.nodes[r25.node];
          return node.contentMatch.matchType(node);
        });
      }
      /**
      Parse a document from the content of a DOM node.
      */
      parse(dom, options = {}) {
        let context = new ParseContext(this, options, false);
        context.addAll(dom, Mark.none, options.from, options.to);
        return context.finish();
      }
      /**
      Parses the content of the given DOM node, like
      [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
      options. But unlike that method, which produces a whole node,
      this one returns a slice that is open at the sides, meaning that
      the schema constraints aren't applied to the start of nodes to
      the left of the input and the end of nodes at the end.
      */
      parseSlice(dom, options = {}) {
        let context = new ParseContext(this, options, true);
        context.addAll(dom, Mark.none, options.from, options.to);
        return Slice.maxOpen(context.finish());
      }
      /**
      @internal
      */
      matchTag(dom, context, after) {
        for (let i21 = after ? this.tags.indexOf(after) + 1 : 0; i21 < this.tags.length; i21++) {
          let rule = this.tags[i21];
          if (matches2(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
            if (rule.getAttrs) {
              let result = rule.getAttrs(dom);
              if (result === false)
                continue;
              rule.attrs = result || void 0;
            }
            return rule;
          }
        }
      }
      /**
      @internal
      */
      matchStyle(prop, value, context, after) {
        for (let i21 = after ? this.styles.indexOf(after) + 1 : 0; i21 < this.styles.length; i21++) {
          let rule = this.styles[i21], style = rule.style;
          if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
            continue;
          if (rule.getAttrs) {
            let result = rule.getAttrs(value);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
      /**
      @internal
      */
      static schemaRules(schema2) {
        let result = [];
        function insert(rule) {
          let priority = rule.priority == null ? 50 : rule.priority, i21 = 0;
          for (; i21 < result.length; i21++) {
            let next = result[i21], nextPriority = next.priority == null ? 50 : next.priority;
            if (nextPriority < priority)
              break;
          }
          result.splice(i21, 0, rule);
        }
        for (let name in schema2.marks) {
          let rules = schema2.marks[name].spec.parseDOM;
          if (rules)
            rules.forEach((rule) => {
              insert(rule = copy(rule));
              if (!(rule.mark || rule.ignore || rule.clearMark))
                rule.mark = name;
            });
        }
        for (let name in schema2.nodes) {
          let rules = schema2.nodes[name].spec.parseDOM;
          if (rules)
            rules.forEach((rule) => {
              insert(rule = copy(rule));
              if (!(rule.node || rule.ignore || rule.mark))
                rule.node = name;
            });
        }
        return result;
      }
      /**
      Construct a DOM parser using the parsing rules listed in a
      schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
      [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
      */
      static fromSchema(schema2) {
        return schema2.cached.domParser || (schema2.cached.domParser = new _DOMParser(schema2, _DOMParser.schemaRules(schema2)));
      }
    };
    blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    listTags = { ol: true, ul: true };
    OPT_PRESERVE_WS = 1;
    OPT_PRESERVE_WS_FULL = 2;
    OPT_OPEN_LEFT = 4;
    NodeContext = class {
      constructor(type, attrs, marks2, solid, match, options) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks2;
        this.solid = solid;
        this.options = options;
        this.content = [];
        this.activeMarks = Mark.none;
        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
      }
      findWrapping(node) {
        if (!this.match) {
          if (!this.type)
            return [];
          let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
          if (fill) {
            this.match = this.type.contentMatch.matchFragment(fill);
          } else {
            let start = this.type.contentMatch, wrap2;
            if (wrap2 = start.findWrapping(node.type)) {
              this.match = start;
              return wrap2;
            } else {
              return null;
            }
          }
        }
        return this.match.findWrapping(node.type);
      }
      finish(openEnd) {
        if (!(this.options & OPT_PRESERVE_WS)) {
          let last = this.content[this.content.length - 1], m18;
          if (last && last.isText && (m18 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
            let text = last;
            if (last.text.length == m18[0].length)
              this.content.pop();
            else
              this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m18[0].length));
          }
        }
        let content = Fragment.from(this.content);
        if (!openEnd && this.match)
          content = content.append(this.match.fillBefore(Fragment.empty, true));
        return this.type ? this.type.create(this.attrs, content, this.marks) : content;
      }
      inlineContext(node) {
        if (this.type)
          return this.type.inlineContent;
        if (this.content.length)
          return this.content[0].isInline;
        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
      }
    };
    ParseContext = class {
      constructor(parser, options, isOpen) {
        this.parser = parser;
        this.options = options;
        this.isOpen = isOpen;
        this.open = 0;
        this.localPreserveWS = false;
        let topNode = options.topNode, topContext;
        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
        if (topNode)
          topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
        else if (isOpen)
          topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
        else
          topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
        this.nodes = [topContext];
        this.find = options.findPositions;
        this.needsBlock = false;
      }
      get top() {
        return this.nodes[this.open];
      }
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      addDOM(dom, marks2) {
        if (dom.nodeType == 3)
          this.addTextNode(dom, marks2);
        else if (dom.nodeType == 1)
          this.addElement(dom, marks2);
      }
      addTextNode(dom, marks2) {
        let value = dom.nodeValue;
        let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
        if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
          if (!preserveWS) {
            value = value.replace(/[ \t\r\n\u000c]+/g, " ");
            if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
              let nodeBefore = top.content[top.content.length - 1];
              let domNodeBefore = dom.previousSibling;
              if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
                value = value.slice(1);
            }
          } else if (preserveWS !== "full") {
            value = value.replace(/\r?\n|\r/g, " ");
          } else {
            value = value.replace(/\r\n?/g, "\n");
          }
          if (value)
            this.insertNode(this.parser.schema.text(value), marks2, !/\S/.test(value));
          this.findInText(dom);
        } else {
          this.findInside(dom);
        }
      }
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      addElement(dom, marks2, matchAfter) {
        let outerWS = this.localPreserveWS, top = this.top;
        if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
          this.localPreserveWS = true;
        let name = dom.nodeName.toLowerCase(), ruleID;
        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
          normalizeList(dom);
        let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
        out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
          this.findInside(dom);
          this.ignoreFallback(dom, marks2);
        } else if (!rule || rule.skip || rule.closeParent) {
          if (rule && rule.closeParent)
            this.open = Math.max(0, this.open - 1);
          else if (rule && rule.skip.nodeType)
            dom = rule.skip;
          let sync, oldNeedsBlock = this.needsBlock;
          if (blockTags.hasOwnProperty(name)) {
            if (top.content.length && top.content[0].isInline && this.open) {
              this.open--;
              top = this.top;
            }
            sync = true;
            if (!top.type)
              this.needsBlock = true;
          } else if (!dom.firstChild) {
            this.leafFallback(dom, marks2);
            break out;
          }
          let innerMarks = rule && rule.skip ? marks2 : this.readStyles(dom, marks2);
          if (innerMarks)
            this.addAll(dom, innerMarks);
          if (sync)
            this.sync(top);
          this.needsBlock = oldNeedsBlock;
        } else {
          let innerMarks = this.readStyles(dom, marks2);
          if (innerMarks)
            this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
        }
        this.localPreserveWS = outerWS;
      }
      // Called for leaf DOM nodes that would otherwise be ignored
      leafFallback(dom, marks2) {
        if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
          this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks2);
      }
      // Called for ignored nodes
      ignoreFallback(dom, marks2) {
        if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
          this.findPlace(this.parser.schema.text("-"), marks2, true);
      }
      // Run any style parser associated with the node's styles. Either
      // return an updated array of marks, or null to indicate some of the
      // styles had a rule with `ignore` set.
      readStyles(dom, marks2) {
        let styles12 = dom.style;
        if (styles12 && styles12.length)
          for (let i21 = 0; i21 < this.parser.matchedStyles.length; i21++) {
            let name = this.parser.matchedStyles[i21], value = styles12.getPropertyValue(name);
            if (value)
              for (let after = void 0; ; ) {
                let rule = this.parser.matchStyle(name, value, this, after);
                if (!rule)
                  break;
                if (rule.ignore)
                  return null;
                if (rule.clearMark)
                  marks2 = marks2.filter((m18) => !rule.clearMark(m18));
                else
                  marks2 = marks2.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
                if (rule.consuming === false)
                  after = rule;
                else
                  break;
              }
          }
        return marks2;
      }
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      addElementByRule(dom, rule, marks2, continueAfter) {
        let sync, nodeType;
        if (rule.node) {
          nodeType = this.parser.schema.nodes[rule.node];
          if (!nodeType.isLeaf) {
            let inner = this.enter(nodeType, rule.attrs || null, marks2, rule.preserveWhitespace);
            if (inner) {
              sync = true;
              marks2 = inner;
            }
          } else if (!this.insertNode(nodeType.create(rule.attrs), marks2, dom.nodeName == "BR")) {
            this.leafFallback(dom, marks2);
          }
        } else {
          let markType = this.parser.schema.marks[rule.mark];
          marks2 = marks2.concat(markType.create(rule.attrs));
        }
        let startIn = this.top;
        if (nodeType && nodeType.isLeaf) {
          this.findInside(dom);
        } else if (continueAfter) {
          this.addElement(dom, marks2, continueAfter);
        } else if (rule.getContent) {
          this.findInside(dom);
          rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks2, false));
        } else {
          let contentDOM = dom;
          if (typeof rule.contentElement == "string")
            contentDOM = dom.querySelector(rule.contentElement);
          else if (typeof rule.contentElement == "function")
            contentDOM = rule.contentElement(dom);
          else if (rule.contentElement)
            contentDOM = rule.contentElement;
          this.findAround(dom, contentDOM, true);
          this.addAll(contentDOM, marks2);
          this.findAround(dom, contentDOM, false);
        }
        if (sync && this.sync(startIn))
          this.open--;
      }
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      addAll(parent, marks2, startIndex, endIndex) {
        let index = startIndex || 0;
        for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
          this.findAtPoint(parent, index);
          this.addDOM(dom, marks2);
        }
        this.findAtPoint(parent, index);
      }
      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      findPlace(node, marks2, cautious) {
        let route, sync;
        for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
          let cx = this.nodes[depth];
          let found2 = cx.findWrapping(node);
          if (found2 && (!route || route.length > found2.length + penalty)) {
            route = found2;
            sync = cx;
            if (!found2.length)
              break;
          }
          if (cx.solid) {
            if (cautious)
              break;
            penalty += 2;
          }
        }
        if (!route)
          return null;
        this.sync(sync);
        for (let i21 = 0; i21 < route.length; i21++)
          marks2 = this.enterInner(route[i21], null, marks2, false);
        return marks2;
      }
      // Try to insert the given node, adjusting the context when needed.
      insertNode(node, marks2, cautious) {
        if (node.isInline && this.needsBlock && !this.top.type) {
          let block = this.textblockFromContext();
          if (block)
            marks2 = this.enterInner(block, null, marks2);
        }
        let innerMarks = this.findPlace(node, marks2, cautious);
        if (innerMarks) {
          this.closeExtra();
          let top = this.top;
          if (top.match)
            top.match = top.match.matchType(node.type);
          let nodeMarks = Mark.none;
          for (let m18 of innerMarks.concat(node.marks))
            if (top.type ? top.type.allowsMarkType(m18.type) : markMayApply(m18.type, node.type))
              nodeMarks = m18.addToSet(nodeMarks);
          top.content.push(node.mark(nodeMarks));
          return true;
        }
        return false;
      }
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      enter(type, attrs, marks2, preserveWS) {
        let innerMarks = this.findPlace(type.create(attrs), marks2, false);
        if (innerMarks)
          innerMarks = this.enterInner(type, attrs, marks2, true, preserveWS);
        return innerMarks;
      }
      // Open a node of the given type
      enterInner(type, attrs, marks2, solid = false, preserveWS) {
        this.closeExtra();
        let top = this.top;
        top.match = top.match && top.match.matchType(type);
        let options = wsOptionsFor(type, preserveWS, top.options);
        if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
          options |= OPT_OPEN_LEFT;
        let applyMarks = Mark.none;
        marks2 = marks2.filter((m18) => {
          if (top.type ? top.type.allowsMarkType(m18.type) : markMayApply(m18.type, type)) {
            applyMarks = m18.addToSet(applyMarks);
            return false;
          }
          return true;
        });
        this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
        this.open++;
        return marks2;
      }
      // Make sure all nodes above this.open are finished and added to
      // their parents
      closeExtra(openEnd = false) {
        let i21 = this.nodes.length - 1;
        if (i21 > this.open) {
          for (; i21 > this.open; i21--)
            this.nodes[i21 - 1].content.push(this.nodes[i21].finish(openEnd));
          this.nodes.length = this.open + 1;
        }
      }
      finish() {
        this.open = 0;
        this.closeExtra(this.isOpen);
        return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
      }
      sync(to2) {
        for (let i21 = this.open; i21 >= 0; i21--) {
          if (this.nodes[i21] == to2) {
            this.open = i21;
            return true;
          } else if (this.localPreserveWS) {
            this.nodes[i21].options |= OPT_PRESERVE_WS;
          }
        }
        return false;
      }
      get currentPos() {
        this.closeExtra();
        let pos = 0;
        for (let i21 = this.open; i21 >= 0; i21--) {
          let content = this.nodes[i21].content;
          for (let j3 = content.length - 1; j3 >= 0; j3--)
            pos += content[j3].nodeSize;
          if (i21)
            pos++;
        }
        return pos;
      }
      findAtPoint(parent, offset4) {
        if (this.find)
          for (let i21 = 0; i21 < this.find.length; i21++) {
            if (this.find[i21].node == parent && this.find[i21].offset == offset4)
              this.find[i21].pos = this.currentPos;
          }
      }
      findInside(parent) {
        if (this.find)
          for (let i21 = 0; i21 < this.find.length; i21++) {
            if (this.find[i21].pos == null && parent.nodeType == 1 && parent.contains(this.find[i21].node))
              this.find[i21].pos = this.currentPos;
          }
      }
      findAround(parent, content, before) {
        if (parent != content && this.find)
          for (let i21 = 0; i21 < this.find.length; i21++) {
            if (this.find[i21].pos == null && parent.nodeType == 1 && parent.contains(this.find[i21].node)) {
              let pos = content.compareDocumentPosition(this.find[i21].node);
              if (pos & (before ? 2 : 4))
                this.find[i21].pos = this.currentPos;
            }
          }
      }
      findInText(textNode) {
        if (this.find)
          for (let i21 = 0; i21 < this.find.length; i21++) {
            if (this.find[i21].node == textNode)
              this.find[i21].pos = this.currentPos - (textNode.nodeValue.length - this.find[i21].offset);
          }
      }
      // Determines whether the given context string matches this context.
      matchesContext(context) {
        if (context.indexOf("|") > -1)
          return context.split(/\s*\|\s*/).some(this.matchesContext, this);
        let parts = context.split("/");
        let option = this.options.context;
        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
        let match = (i21, depth) => {
          for (; i21 >= 0; i21--) {
            let part = parts[i21];
            if (part == "") {
              if (i21 == parts.length - 1 || i21 == 0)
                continue;
              for (; depth >= minDepth; depth--)
                if (match(i21 - 1, depth))
                  return true;
              return false;
            } else {
              let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
              if (!next || next.name != part && !next.isInGroup(part))
                return false;
              depth--;
            }
          }
          return true;
        };
        return match(parts.length - 1, this.open);
      }
      textblockFromContext() {
        let $context = this.options.context;
        if ($context)
          for (let d22 = $context.depth; d22 >= 0; d22--) {
            let deflt = $context.node(d22).contentMatchAt($context.indexAfter(d22)).defaultType;
            if (deflt && deflt.isTextblock && deflt.defaultAttrs)
              return deflt;
          }
        for (let name in this.parser.schema.nodes) {
          let type = this.parser.schema.nodes[name];
          if (type.isTextblock && type.defaultAttrs)
            return type;
        }
      }
    };
    DOMSerializer = class _DOMSerializer {
      /**
      Create a serializer. `nodes` should map node names to functions
      that take a node and return a description of the corresponding
      DOM. `marks` does the same for mark names, but also gets an
      argument that tells it whether the mark's content is block or
      inline content (for typical use, it'll always be inline). A mark
      serializer may be `null` to indicate that marks of that type
      should not be serialized.
      */
      constructor(nodes2, marks2) {
        this.nodes = nodes2;
        this.marks = marks2;
      }
      /**
      Serialize the content of this fragment to a DOM fragment. When
      not in the browser, the `document` option, containing a DOM
      document, should be passed so that the serializer can create
      nodes.
      */
      serializeFragment(fragment, options = {}, target) {
        if (!target)
          target = doc(options).createDocumentFragment();
        let top = target, active = [];
        fragment.forEach((node) => {
          if (active.length || node.marks.length) {
            let keep = 0, rendered = 0;
            while (keep < active.length && rendered < node.marks.length) {
              let next = node.marks[rendered];
              if (!this.marks[next.type.name]) {
                rendered++;
                continue;
              }
              if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
                break;
              keep++;
              rendered++;
            }
            while (keep < active.length)
              top = active.pop()[1];
            while (rendered < node.marks.length) {
              let add2 = node.marks[rendered++];
              let markDOM = this.serializeMark(add2, node.isInline, options);
              if (markDOM) {
                active.push([add2, top]);
                top.appendChild(markDOM.dom);
                top = markDOM.contentDOM || markDOM.dom;
              }
            }
          }
          top.appendChild(this.serializeNodeInner(node, options));
        });
        return target;
      }
      /**
      @internal
      */
      serializeNodeInner(node, options) {
        let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);
        if (contentDOM) {
          if (node.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(node.content, options, contentDOM);
        }
        return dom;
      }
      /**
      Serialize this node to a DOM node. This can be useful when you
      need to serialize a part of a document, as opposed to the whole
      document. To serialize a whole document, use
      [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
      its [content](https://prosemirror.net/docs/ref/#model.Node.content).
      */
      serializeNode(node, options = {}) {
        let dom = this.serializeNodeInner(node, options);
        for (let i21 = node.marks.length - 1; i21 >= 0; i21--) {
          let wrap2 = this.serializeMark(node.marks[i21], node.isInline, options);
          if (wrap2) {
            (wrap2.contentDOM || wrap2.dom).appendChild(dom);
            dom = wrap2.dom;
          }
        }
        return dom;
      }
      /**
      @internal
      */
      serializeMark(mark, inline2, options = {}) {
        let toDOM = this.marks[mark.type.name];
        return toDOM && renderSpec(doc(options), toDOM(mark, inline2), null, mark.attrs);
      }
      static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {
        return renderSpec(doc3, structure, xmlNS, blockArraysIn);
      }
      /**
      Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
      properties in a schema's node and mark specs.
      */
      static fromSchema(schema2) {
        return schema2.cached.domSerializer || (schema2.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
      }
      /**
      Gather the serializers in a schema's node specs into an object.
      This can be useful as a base to build a custom serializer from.
      */
      static nodesFromSchema(schema2) {
        let result = gatherToDOM(schema2.nodes);
        if (!result.text)
          result.text = (node) => node.text;
        return result;
      }
      /**
      Gather the serializers in a schema's mark specs into an object.
      */
      static marksFromSchema(schema2) {
        return gatherToDOM(schema2.marks);
      }
    };
    suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/prosemirror-transform/dist/index.js
function makeRecover(index, offset4) {
  return index + offset4 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
function mapFragment(fragment, f11, parent) {
  let mapped = [];
  for (let i21 = 0; i21 < fragment.childCount; i21++) {
    let child = fragment.child(i21);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f11, child));
    if (child.isInline)
      child = f11(child, parent, i21);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
function contentBetween(doc3, from2, to2) {
  let $from = doc3.resolve(from2), dist = to2 - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to2, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to2, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks2 = node.marks;
    if (!mark.isInSet(marks2) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to2);
      let newSet = mark.addToSet(marks2);
      for (let i21 = 0; i21 < marks2.length; i21++) {
        if (!marks2[i21].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks2[i21]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks2[i21]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s19) => tr2.step(s19));
  added.forEach((s19) => tr2.step(s19));
}
function removeMark(tr2, from2, to2, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to2, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to2);
      for (let i21 = 0; i21 < toRemove.length; i21++) {
        let style = toRemove[i21], found2;
        for (let j3 = 0; j3 < matched.length; j3++) {
          let m18 = matched[j3];
          if (m18.step == step - 1 && style.eq(matched[j3].style))
            found2 = m18;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style, from: Math.max(pos, from2), to: end, step });
        }
      }
    }
  });
  matched.forEach((m18) => tr2.step(new RemoveMarkStep(m18.from, m18.to, m18.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i21 = 0; i21 < node.childCount; i21++) {
    let child = node.child(i21), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j3 = 0; j3 < child.marks.length; j3++)
        if (!parentType.allowsMarkType(child.marks[j3].type))
          tr2.step(new RemoveMarkStep(cur, end, child.marks[j3]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m18, newline = /\r?\n|\r/g, slice2;
        while (m18 = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m18.index, cur + m18.index + m18[0].length, slice2));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i21 = replSteps.length - 1; i21 >= 0; i21--)
    tr2.step(replSteps[i21]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
      break;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d22 = depth, splitting = false; d22 > target; d22--)
    if (splitting || $from.index(d22) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d22).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d22 = depth, splitting = false; d22 > target; d22--)
    if (splitting || $to.after(d22 + 1) < $to.end(d22)) {
      splitting = true;
      after = Fragment.from($to.node(d22).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr2.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i21 = startIndex; innerMatch && i21 < endIndex; i21++)
    innerMatch = innerMatch.matchType(parent.child(i21).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i21 = wrappers.length - 1; i21 >= 0; i21--) {
    if (content.size) {
      let match = wrappers[i21].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i21].type.create(wrappers[i21].attrs, content));
  }
  let start = range.start, end = range.end;
  tr2.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to2, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to2, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr2, node, pos, mapFrom);
      clearIncompatible(tr2, tr2.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr2, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr2, node, pos, mapFrom) {
  node.forEach((child, offset4) => {
    if (child.isText) {
      let m18, newline = /\r?\n|\r/g;
      while (m18 = newline.exec(child.text)) {
        let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset4 + m18.index);
        tr2.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr2, node, pos, mapFrom) {
  node.forEach((child, offset4) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset4);
      tr2.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks2) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks2 || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d22 = $pos.depth - 1, i21 = depth - 2; d22 > base2; d22--, i21--) {
    let node = $pos.node(d22), index2 = $pos.index(d22);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index2, node.childCount);
    let overrideChild = typesAfter && typesAfter[i21 + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i21] || node;
    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d22 = $pos.depth, e36 = $pos.depth - depth, i21 = depth - 1; d22 > e36; d22--, i21--) {
    before = Fragment.from($pos.node(d22).copy(before));
    let typeAfter = typesAfter && typesAfter[i21];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d22).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function canAppendWithSubstitutedLinebreaks(a23, b12) {
  if (!b12.content.size)
    a23.type.compatibleContent(b12.type);
  let match = a23.contentMatchAt(a23.childCount);
  let { linebreakReplacement } = a23.type.schema;
  for (let i21 = 0; i21 < b12.childCount; i21++) {
    let child = b12.child(i21);
    let type = child.type == linebreakReplacement ? a23.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a23.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable2(a23, b12) {
  return !!(a23 && b12 && !a23.isLeaf && canAppendWithSubstitutedLinebreaks(a23, b12));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d22 = $pos.depth; ; d22--) {
    let before, after, index = $pos.index(d22);
    if (d22 == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d22 + 1);
      index++;
      after = $pos.node(d22).maybeChild(index);
    } else {
      before = $pos.node(d22).maybeChild(index - 1);
      after = $pos.node(d22 + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d22).canReplace(index, index + 1))
      return pos;
    if (d22 == 0)
      break;
    pos = dir < 0 ? $pos.before(d22) : $pos.after(d22);
  }
}
function join(tr2, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr2.doc.type.schema;
  let $before = tr2.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr2.steps.length;
  if (convertNewlines === false) {
    let $after = tr2.doc.resolve(pos + depth);
    replaceLinebreaks(tr2, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr2, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr2.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr2.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr2.doc.resolve(start);
    replaceNewlines(tr2, $full.node(), $full.before(), tr2.steps.length);
  }
  return tr2;
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d22 = $pos.depth - 1; d22 >= 0; d22--) {
      let index = $pos.index(d22);
      if ($pos.node(d22).canReplaceWith(index, index, nodeType))
        return $pos.before(d22 + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d22 = $pos.depth - 1; d22 >= 0; d22--) {
      let index = $pos.indexAfter(d22);
      if ($pos.node(d22).canReplaceWith(index, index, nodeType))
        return $pos.after(d22 + 1);
      if (index < $pos.node(d22).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i21 = 0; i21 < slice2.openStart; i21++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d22 = $pos.depth; d22 >= 0; d22--) {
      let bias = d22 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d22 + 1) + $pos.end(d22 + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d22) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d22), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d22 + 1) : $pos.after(d22 + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to2 = from2, slice2 = Slice.empty) {
  if (from2 == to2 && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to2);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to2, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i21 = 0; i21 < depth; i21++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i21 = start; i21 < fragment.childCount; i21++)
    if (!type.allowsMarks(fragment.child(i21).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to2, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to2);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to2);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to2, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to2));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d22 = $from.depth, pos = $from.pos - 1; d22 > 0; d22--, pos--) {
    let spec = $from.node(d22).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d22) > -1)
      preferredTarget = d22;
    else if ($from.before(d22) == pos)
      targetDepths.splice(1, 0, -d22);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i21 = 0; ; i21++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i21 == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d22 = preferredDepth - 1; d22 >= 0; d22--) {
    let leftNode = leftNodes[d22], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d22;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j3 = slice2.openStart; j3 >= 0; j3--) {
    let openDepth = (j3 + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i21 = 0; i21 < targetDepths.length; i21++) {
      let targetDepth = targetDepths[(i21 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to2, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i21 = targetDepths.length - 1; i21 >= 0; i21--) {
    tr2.replace(from2, to2, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i21];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to2 = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to2, node) {
  if (!node.isInline && from2 == to2 && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to2 = point;
  }
  tr2.replaceRange(from2, to2, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr2, from2, to2) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to2);
  let covered = coveredDepths($from, $to);
  for (let i21 = 0; i21 < covered.length; i21++) {
    let depth = covered[i21], last = i21 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d22 = 1; d22 <= $from.depth && d22 <= $to.depth; d22++) {
    if (from2 - $from.start(d22) == $from.depth - d22 && to2 > $from.end(d22) && $to.end(d22) - to2 != $to.depth - d22 && $from.start(d22 - 1) == $to.start(d22 - 1) && $from.node(d22 - 1).canReplace($from.index(d22 - 1), $to.index(d22 - 1)))
      return tr2.delete($from.before(d22), to2);
  }
  tr2.delete(from2, to2);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d22 = minDepth; d22 >= 0; d22--) {
    let start = $from.start(d22);
    if (start < $from.pos - ($from.depth - d22) || $to.end(d22) > $to.pos + ($to.depth - d22) || $from.node(d22).type.spec.isolating || $to.node(d22).type.spec.isolating)
      break;
    if (start == $to.start(d22) || d22 == $from.depth && d22 == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d22 && $to.start(d22 - 1) == start - 1)
      result.push(d22);
  }
  return result;
}
var lower16, factor16, DEL_BEFORE, DEL_AFTER, DEL_ACROSS, DEL_SIDE, MapResult, StepMap, Mapping, stepsByID, Step, StepResult, AddMarkStep, RemoveMarkStep, AddNodeMarkStep, RemoveNodeMarkStep, ReplaceStep, ReplaceAroundStep, Fitter, AttrStep, DocAttrStep, TransformError, Transform;
var init_dist3 = __esm({
  "node_modules/prosemirror-transform/dist/index.js"() {
    init_dist2();
    lower16 = 65535;
    factor16 = Math.pow(2, 16);
    DEL_BEFORE = 1;
    DEL_AFTER = 2;
    DEL_ACROSS = 4;
    DEL_SIDE = 8;
    MapResult = class {
      /**
      @internal
      */
      constructor(pos, delInfo, recover) {
        this.pos = pos;
        this.delInfo = delInfo;
        this.recover = recover;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & DEL_SIDE) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & DEL_ACROSS) > 0;
      }
    };
    StepMap = class _StepMap {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(ranges, inverted = false) {
        this.ranges = ranges;
        this.inverted = inverted;
        if (!ranges.length && _StepMap.empty)
          return _StepMap.empty;
      }
      /**
      @internal
      */
      recover(value) {
        let diff = 0, index = recoverIndex(value);
        if (!this.inverted)
          for (let i21 = 0; i21 < index; i21++)
            diff += this.ranges[i21 * 3 + 2] - this.ranges[i21 * 3 + 1];
        return this.ranges[index * 3] + diff + recoverOffset(value);
      }
      mapResult(pos, assoc = 1) {
        return this._map(pos, assoc, false);
      }
      map(pos, assoc = 1) {
        return this._map(pos, assoc, true);
      }
      /**
      @internal
      */
      _map(pos, assoc, simple) {
        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i21 = 0; i21 < this.ranges.length; i21 += 3) {
          let start = this.ranges[i21] - (this.inverted ? diff : 0);
          if (start > pos)
            break;
          let oldSize = this.ranges[i21 + oldIndex], newSize = this.ranges[i21 + newIndex], end = start + oldSize;
          if (pos <= end) {
            let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
            let result = start + diff + (side < 0 ? 0 : newSize);
            if (simple)
              return result;
            let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i21 / 3, pos - start);
            let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
            if (assoc < 0 ? pos != start : pos != end)
              del2 |= DEL_SIDE;
            return new MapResult(result, del2, recover);
          }
          diff += newSize - oldSize;
        }
        return simple ? pos + diff : new MapResult(pos + diff, 0, null);
      }
      /**
      @internal
      */
      touches(pos, recover) {
        let diff = 0, index = recoverIndex(recover);
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i21 = 0; i21 < this.ranges.length; i21 += 3) {
          let start = this.ranges[i21] - (this.inverted ? diff : 0);
          if (start > pos)
            break;
          let oldSize = this.ranges[i21 + oldIndex], end = start + oldSize;
          if (pos <= end && i21 == index * 3)
            return true;
          diff += this.ranges[i21 + newIndex] - oldSize;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(f11) {
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i21 = 0, diff = 0; i21 < this.ranges.length; i21 += 3) {
          let start = this.ranges[i21], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
          let oldSize = this.ranges[i21 + oldIndex], newSize = this.ranges[i21 + newIndex];
          f11(oldStart, oldStart + oldSize, newStart, newStart + newSize);
          diff += newSize - oldSize;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new _StepMap(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(n25) {
        return n25 == 0 ? _StepMap.empty : new _StepMap(n25 < 0 ? [0, -n25, 0] : [0, 0, n25]);
      }
    };
    StepMap.empty = new StepMap([]);
    Mapping = class _Mapping {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(maps, mirror, from2 = 0, to2 = maps ? maps.length : 0) {
        this.mirror = mirror;
        this.from = from2;
        this.to = to2;
        this._maps = maps || [];
        this.ownData = !(maps || mirror);
      }
      /**
      The step maps in this mapping.
      */
      get maps() {
        return this._maps;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(from2 = 0, to2 = this.maps.length) {
        return new _Mapping(this._maps, this.mirror, from2, to2);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(map2, mirrors) {
        if (!this.ownData) {
          this._maps = this._maps.slice();
          this.mirror = this.mirror && this.mirror.slice();
          this.ownData = true;
        }
        this.to = this._maps.push(map2);
        if (mirrors != null)
          this.setMirror(this._maps.length - 1, mirrors);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(mapping) {
        for (let i21 = 0, startSize = this._maps.length; i21 < mapping._maps.length; i21++) {
          let mirr = mapping.getMirror(i21);
          this.appendMap(mapping._maps[i21], mirr != null && mirr < i21 ? startSize + mirr : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(n25) {
        if (this.mirror) {
          for (let i21 = 0; i21 < this.mirror.length; i21++)
            if (this.mirror[i21] == n25)
              return this.mirror[i21 + (i21 % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(n25, m18) {
        if (!this.mirror)
          this.mirror = [];
        this.mirror.push(n25, m18);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(mapping) {
        for (let i21 = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i21 >= 0; i21--) {
          let mirr = mapping.getMirror(i21);
          this.appendMap(mapping._maps[i21].invert(), mirr != null && mirr > i21 ? totalSize - mirr - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let inverse = new _Mapping();
        inverse.appendMappingInverted(this);
        return inverse;
      }
      /**
      Map a position through this mapping.
      */
      map(pos, assoc = 1) {
        if (this.mirror)
          return this._map(pos, assoc, true);
        for (let i21 = this.from; i21 < this.to; i21++)
          pos = this._maps[i21].map(pos, assoc);
        return pos;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(pos, assoc = 1) {
        return this._map(pos, assoc, false);
      }
      /**
      @internal
      */
      _map(pos, assoc, simple) {
        let delInfo = 0;
        for (let i21 = this.from; i21 < this.to; i21++) {
          let map2 = this._maps[i21], result = map2.mapResult(pos, assoc);
          if (result.recover != null) {
            let corr = this.getMirror(i21);
            if (corr != null && corr > i21 && corr < this.to) {
              i21 = corr;
              pos = this._maps[corr].recover(result.recover);
              continue;
            }
          }
          delInfo |= result.delInfo;
          pos = result.pos;
        }
        return simple ? pos : new MapResult(pos, delInfo, null);
      }
    };
    stepsByID = /* @__PURE__ */ Object.create(null);
    Step = class {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return StepMap.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(other) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(schema2, json) {
        if (!json || !json.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let type = stepsByID[json.stepType];
        if (!type)
          throw new RangeError(`No step type ${json.stepType} defined`);
        return type.fromJSON(schema2, json);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(id, stepClass) {
        if (id in stepsByID)
          throw new RangeError("Duplicate use of step JSON ID " + id);
        stepsByID[id] = stepClass;
        stepClass.prototype.jsonID = id;
        return stepClass;
      }
    };
    StepResult = class _StepResult {
      /**
      @internal
      */
      constructor(doc3, failed) {
        this.doc = doc3;
        this.failed = failed;
      }
      /**
      Create a successful step result.
      */
      static ok(doc3) {
        return new _StepResult(doc3, null);
      }
      /**
      Create a failed step result.
      */
      static fail(message) {
        return new _StepResult(null, message);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(doc3, from2, to2, slice2) {
        try {
          return _StepResult.ok(doc3.replace(from2, to2, slice2));
        } catch (e36) {
          if (e36 instanceof ReplaceError)
            return _StepResult.fail(e36.message);
          throw e36;
        }
      }
    };
    AddMarkStep = class _AddMarkStep extends Step {
      /**
      Create a mark step.
      */
      constructor(from2, to2, mark) {
        super();
        this.from = from2;
        this.to = to2;
        this.mark = mark;
      }
      apply(doc3) {
        let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
        let parent = $from.node($from.sharedDepth(this.to));
        let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
          if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
            return node;
          return node.mark(this.mark.addToSet(node.marks));
        }, parent), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc3, this.from, this.to, slice2);
      }
      invert() {
        return new RemoveMarkStep(this.from, this.to, this.mark);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
        if (from2.deleted && to2.deleted || from2.pos >= to2.pos)
          return null;
        return new _AddMarkStep(from2.pos, to2.pos, this.mark);
      }
      merge(other) {
        if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
          return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(schema2, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new _AddMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));
      }
    };
    Step.jsonID("addMark", AddMarkStep);
    RemoveMarkStep = class _RemoveMarkStep extends Step {
      /**
      Create a mark-removing step.
      */
      constructor(from2, to2, mark) {
        super();
        this.from = from2;
        this.to = to2;
        this.mark = mark;
      }
      apply(doc3) {
        let oldSlice = doc3.slice(this.from, this.to);
        let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
          return node.mark(this.mark.removeFromSet(node.marks));
        }, doc3), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc3, this.from, this.to, slice2);
      }
      invert() {
        return new AddMarkStep(this.from, this.to, this.mark);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
        if (from2.deleted && to2.deleted || from2.pos >= to2.pos)
          return null;
        return new _RemoveMarkStep(from2.pos, to2.pos, this.mark);
      }
      merge(other) {
        if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
          return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(schema2, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new _RemoveMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));
      }
    };
    Step.jsonID("removeMark", RemoveMarkStep);
    AddNodeMarkStep = class _AddNodeMarkStep extends Step {
      /**
      Create a node mark step.
      */
      constructor(pos, mark) {
        super();
        this.pos = pos;
        this.mark = mark;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at mark step's position");
        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      invert(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (node) {
          let newSet = this.mark.addToSet(node.marks);
          if (newSet.length == node.marks.length) {
            for (let i21 = 0; i21 < node.marks.length; i21++)
              if (!node.marks[i21].isInSet(newSet))
                return new _AddNodeMarkStep(this.pos, node.marks[i21]);
            return new _AddNodeMarkStep(this.pos, this.mark);
          }
        }
        return new RemoveNodeMarkStep(this.pos, this.mark);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(schema2, json) {
        if (typeof json.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new _AddNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));
      }
    };
    Step.jsonID("addNodeMark", AddNodeMarkStep);
    RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
      /**
      Create a mark-removing step.
      */
      constructor(pos, mark) {
        super();
        this.pos = pos;
        this.mark = mark;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at mark step's position");
        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      invert(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node || !this.mark.isInSet(node.marks))
          return this;
        return new AddNodeMarkStep(this.pos, this.mark);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(schema2, json) {
        if (typeof json.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new _RemoveNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));
      }
    };
    Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
    ReplaceStep = class _ReplaceStep extends Step {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(from2, to2, slice2, structure = false) {
        super();
        this.from = from2;
        this.to = to2;
        this.slice = slice2;
        this.structure = structure;
      }
      apply(doc3) {
        if (this.structure && contentBetween(doc3, this.from, this.to))
          return StepResult.fail("Structure replace would overwrite content");
        return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
      }
      getMap() {
        return new StepMap([this.from, this.to - this.from, this.slice.size]);
      }
      invert(doc3) {
        return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
        if (from2.deletedAcross && to2.deletedAcross)
          return null;
        return new _ReplaceStep(from2.pos, Math.max(from2.pos, to2.pos), this.slice, this.structure);
      }
      merge(other) {
        if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
          return null;
        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
          let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
          return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
          let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
          return new _ReplaceStep(other.from, this.to, slice2, this.structure);
        } else {
          return null;
        }
      }
      toJSON() {
        let json = { stepType: "replace", from: this.from, to: this.to };
        if (this.slice.size)
          json.slice = this.slice.toJSON();
        if (this.structure)
          json.structure = true;
        return json;
      }
      /**
      @internal
      */
      static fromJSON(schema2, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema2, json.slice), !!json.structure);
      }
    };
    Step.jsonID("replace", ReplaceStep);
    ReplaceAroundStep = class _ReplaceAroundStep extends Step {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(from2, to2, gapFrom, gapTo, slice2, insert, structure = false) {
        super();
        this.from = from2;
        this.to = to2;
        this.gapFrom = gapFrom;
        this.gapTo = gapTo;
        this.slice = slice2;
        this.insert = insert;
        this.structure = structure;
      }
      apply(doc3) {
        if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
          return StepResult.fail("Structure gap-replace would overwrite content");
        let gap = doc3.slice(this.gapFrom, this.gapTo);
        if (gap.openStart || gap.openEnd)
          return StepResult.fail("Gap is not a flat range");
        let inserted = this.slice.insertAt(this.insert, gap.content);
        if (!inserted)
          return StepResult.fail("Content does not fit in gap");
        return StepResult.fromReplace(doc3, this.from, this.to, inserted);
      }
      getMap() {
        return new StepMap([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(doc3) {
        let gap = this.gapTo - this.gapFrom;
        return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
        let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
        let gapTo = this.to == this.gapTo ? to2.pos : mapping.map(this.gapTo, 1);
        if (from2.deletedAcross && to2.deletedAcross || gapFrom < from2.pos || gapTo > to2.pos)
          return null;
        return new _ReplaceAroundStep(from2.pos, to2.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let json = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        if (this.slice.size)
          json.slice = this.slice.toJSON();
        if (this.structure)
          json.structure = true;
        return json;
      }
      /**
      @internal
      */
      static fromJSON(schema2, json) {
        if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema2, json.slice), json.insert, !!json.structure);
      }
    };
    Step.jsonID("replaceAround", ReplaceAroundStep);
    Fitter = class {
      constructor($from, $to, unplaced) {
        this.$from = $from;
        this.$to = $to;
        this.unplaced = unplaced;
        this.frontier = [];
        this.placed = Fragment.empty;
        for (let i21 = 0; i21 <= $from.depth; i21++) {
          let node = $from.node(i21);
          this.frontier.push({
            type: node.type,
            match: node.contentMatchAt($from.indexAfter(i21))
          });
        }
        for (let i21 = $from.depth; i21 > 0; i21--)
          this.placed = Fragment.from($from.node(i21).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        while (this.unplaced.size) {
          let fit = this.findFittable();
          if (fit)
            this.placeNodes(fit);
          else
            this.openMore() || this.dropNode();
        }
        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
        if (!$to)
          return null;
        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
        while (openStart && openEnd && content.childCount == 1) {
          content = content.firstChild.content;
          openStart--;
          openEnd--;
        }
        let slice2 = new Slice(content, openStart, openEnd);
        if (moveInline > -1)
          return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
        if (slice2.size || $from.pos != this.$to.pos)
          return new ReplaceStep($from.pos, $to.pos, slice2);
        return null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let startDepth = this.unplaced.openStart;
        for (let cur = this.unplaced.content, d22 = 0, openEnd = this.unplaced.openEnd; d22 < startDepth; d22++) {
          let node = cur.firstChild;
          if (cur.childCount > 1)
            openEnd = 0;
          if (node.type.spec.isolating && openEnd <= d22) {
            startDepth = d22;
            break;
          }
          cur = node.content;
        }
        for (let pass = 1; pass <= 2; pass++) {
          for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
            let fragment, parent = null;
            if (sliceDepth) {
              parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
              fragment = parent.content;
            } else {
              fragment = this.unplaced.content;
            }
            let first = fragment.firstChild;
            for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
              let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
              if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : parent && type.compatibleContent(parent.type)))
                return { sliceDepth, frontierDepth, parent, inject };
              else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))
                return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
              if (parent && match.matchType(parent.type))
                break;
            }
          }
        }
      }
      openMore() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (!inner.childCount || inner.firstChild.isLeaf)
          return false;
        this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
        return true;
      }
      dropNode() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (inner.childCount <= 1 && openStart > 0) {
          let openAtEnd = content.size - openStart <= openStart + inner.size;
          this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
        } else {
          this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
        }
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
        while (this.depth > frontierDepth)
          this.closeFrontierNode();
        if (wrap2)
          for (let i21 = 0; i21 < wrap2.length; i21++)
            this.openFrontierNode(wrap2[i21]);
        let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
        let openStart = slice2.openStart - sliceDepth;
        let taken = 0, add2 = [];
        let { match, type } = this.frontier[frontierDepth];
        if (inject) {
          for (let i21 = 0; i21 < inject.childCount; i21++)
            add2.push(inject.child(i21));
          match = match.matchFragment(inject);
        }
        let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
        while (taken < fragment.childCount) {
          let next = fragment.child(taken), matches3 = match.matchType(next.type);
          if (!matches3)
            break;
          taken++;
          if (taken > 1 || openStart == 0 || next.content.size) {
            match = matches3;
            add2.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
          }
        }
        let toEnd = taken == fragment.childCount;
        if (!toEnd)
          openEndCount = -1;
        this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));
        this.frontier[frontierDepth].match = match;
        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
          this.closeFrontierNode();
        for (let i21 = 0, cur = fragment; i21 < openEndCount; i21++) {
          let node = cur.lastChild;
          this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
          cur = node.content;
        }
        this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let top = this.frontier[this.depth], level;
        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
          return -1;
        let { depth } = this.$to, after = this.$to.after(depth);
        while (depth > 1 && after == this.$to.end(--depth))
          ++after;
        return after;
      }
      findCloseLevel($to) {
        scan: for (let i21 = Math.min(this.depth, $to.depth); i21 >= 0; i21--) {
          let { match, type } = this.frontier[i21];
          let dropInner = i21 < $to.depth && $to.end(i21 + 1) == $to.pos + ($to.depth - (i21 + 1));
          let fit = contentAfterFits($to, i21, type, match, dropInner);
          if (!fit)
            continue;
          for (let d22 = i21 - 1; d22 >= 0; d22--) {
            let { match: match2, type: type2 } = this.frontier[d22];
            let matches3 = contentAfterFits($to, d22, type2, match2, true);
            if (!matches3 || matches3.childCount)
              continue scan;
          }
          return { depth: i21, fit, move: dropInner ? $to.doc.resolve($to.after(i21 + 1)) : $to };
        }
      }
      close($to) {
        let close2 = this.findCloseLevel($to);
        if (!close2)
          return null;
        while (this.depth > close2.depth)
          this.closeFrontierNode();
        if (close2.fit.childCount)
          this.placed = addToFragment(this.placed, close2.depth, close2.fit);
        $to = close2.move;
        for (let d22 = close2.depth + 1; d22 <= $to.depth; d22++) {
          let node = $to.node(d22), add2 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d22));
          this.openFrontierNode(node.type, node.attrs, add2);
        }
        return $to;
      }
      openFrontierNode(type, attrs = null, content) {
        let top = this.frontier[this.depth];
        top.match = top.match.matchType(type);
        this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
        this.frontier.push({ type, match: type.contentMatch });
      }
      closeFrontierNode() {
        let open = this.frontier.pop();
        let add2 = open.match.fillBefore(Fragment.empty, true);
        if (add2.childCount)
          this.placed = addToFragment(this.placed, this.frontier.length, add2);
      }
    };
    AttrStep = class _AttrStep extends Step {
      /**
      Construct an attribute step.
      */
      constructor(pos, attr, value) {
        super();
        this.pos = pos;
        this.attr = attr;
        this.value = value;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at attribute step's position");
        let attrs = /* @__PURE__ */ Object.create(null);
        for (let name in node.attrs)
          attrs[name] = node.attrs[name];
        attrs[this.attr] = this.value;
        let updated = node.type.create(attrs, null, node.marks);
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      getMap() {
        return StepMap.empty;
      }
      invert(doc3) {
        return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(schema2, json) {
        if (typeof json.pos != "number" || typeof json.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new _AttrStep(json.pos, json.attr, json.value);
      }
    };
    Step.jsonID("attr", AttrStep);
    DocAttrStep = class _DocAttrStep extends Step {
      /**
      Construct an attribute step.
      */
      constructor(attr, value) {
        super();
        this.attr = attr;
        this.value = value;
      }
      apply(doc3) {
        let attrs = /* @__PURE__ */ Object.create(null);
        for (let name in doc3.attrs)
          attrs[name] = doc3.attrs[name];
        attrs[this.attr] = this.value;
        let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
        return StepResult.ok(updated);
      }
      getMap() {
        return StepMap.empty;
      }
      invert(doc3) {
        return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
      }
      map(mapping) {
        return this;
      }
      toJSON() {
        return { stepType: "docAttr", attr: this.attr, value: this.value };
      }
      static fromJSON(schema2, json) {
        if (typeof json.attr != "string")
          throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new _DocAttrStep(json.attr, json.value);
      }
    };
    Step.jsonID("docAttr", DocAttrStep);
    TransformError = class extends Error {
    };
    TransformError = function TransformError2(message) {
      let err = Error.call(this, message);
      err.__proto__ = TransformError2.prototype;
      return err;
    };
    TransformError.prototype = Object.create(Error.prototype);
    TransformError.prototype.constructor = TransformError;
    TransformError.prototype.name = "TransformError";
    Transform = class {
      /**
      Create a transform that starts with the given document.
      */
      constructor(doc3) {
        this.doc = doc3;
        this.steps = [];
        this.docs = [];
        this.mapping = new Mapping();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(step) {
        let result = this.maybeStep(step);
        if (result.failed)
          throw new TransformError(result.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(step) {
        let result = step.apply(this.doc);
        if (!result.failed)
          this.addStep(step, result.doc);
        return result;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(step, doc3) {
        this.docs.push(this.doc);
        this.steps.push(step);
        this.mapping.appendMap(step.getMap());
        this.doc = doc3;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(from2, to2 = from2, slice2 = Slice.empty) {
        let step = replaceStep(this.doc, from2, to2, slice2);
        if (step)
          this.step(step);
        return this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(from2, to2, content) {
        return this.replace(from2, to2, new Slice(Fragment.from(content), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(from2, to2) {
        return this.replace(from2, to2, Slice.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(pos, content) {
        return this.replaceWith(pos, pos, content);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(from2, to2, slice2) {
        replaceRange(this, from2, to2, slice2);
        return this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(from2, to2, node) {
        replaceRangeWith(this, from2, to2, node);
        return this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(from2, to2) {
        deleteRange(this, from2, to2);
        return this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(range, target) {
        lift(this, range, target);
        return this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(pos, depth = 1) {
        join(this, pos, depth);
        return this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(range, wrappers) {
        wrap(this, range, wrappers);
        return this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(from2, to2 = from2, type, attrs = null) {
        setBlockType(this, from2, to2, type, attrs);
        return this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(pos, type, attrs = null, marks2) {
        setNodeMarkup(this, pos, type, attrs, marks2);
        return this;
      }
      /**
      Set a single attribute on a given node to a new value.
      The `pos` addresses the document content. Use `setDocAttribute`
      to set attributes on the document itself.
      */
      setNodeAttribute(pos, attr, value) {
        this.step(new AttrStep(pos, attr, value));
        return this;
      }
      /**
      Set a single attribute on the document to a new value.
      */
      setDocAttribute(attr, value) {
        this.step(new DocAttrStep(attr, value));
        return this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(pos, mark) {
        this.step(new AddNodeMarkStep(pos, mark));
        return this;
      }
      /**
      Remove a mark (or all marks of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(pos, mark) {
        let node = this.doc.nodeAt(pos);
        if (!node)
          throw new RangeError("No node at position " + pos);
        if (mark instanceof Mark) {
          if (mark.isInSet(node.marks))
            this.step(new RemoveNodeMarkStep(pos, mark));
        } else {
          let set = node.marks, found2, steps = [];
          while (found2 = mark.isInSet(set)) {
            steps.push(new RemoveNodeMarkStep(pos, found2));
            set = found2.removeFromSet(set);
          }
          for (let i21 = steps.length - 1; i21 >= 0; i21--)
            this.step(steps[i21]);
        }
        return this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split (with the outermost nodes coming first).
      */
      split(pos, depth = 1, typesAfter) {
        split(this, pos, depth, typesAfter);
        return this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(from2, to2, mark) {
        addMark(this, from2, to2, mark);
        return this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(from2, to2, mark) {
        removeMark(this, from2, to2, mark);
        return this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(pos, parentType, match) {
        clearIncompatible(this, pos, parentType, match);
        return this;
      }
    };
  }
});

// node_modules/prosemirror-state/dist/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  AllSelection: () => AllSelection,
  EditorState: () => EditorState,
  NodeSelection: () => NodeSelection,
  Plugin: () => Plugin,
  PluginKey: () => PluginKey,
  Selection: () => Selection,
  SelectionRange: () => SelectionRange,
  TextSelection: () => TextSelection,
  Transaction: () => Transaction
});
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
function findSelectionIn(doc3, node, pos, index, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i21 = index - (dir > 0 ? 0 : 1); dir > 0 ? i21 < node.childCount : i21 >= 0; i21 += dir) {
    let child = node.child(i21);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last = tr2.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last], end;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
function bind(f11, self2) {
  return !self2 || !f11 ? f11 : f11.bind(self2);
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var classesById, Selection, SelectionRange, warnedAboutTextSelection, TextSelection, TextBookmark, NodeSelection, NodeBookmark, AllSelection, AllBookmark, UPDATED_SEL, UPDATED_MARKS, UPDATED_SCROLL, Transaction, FieldDesc, baseFields, Configuration, EditorState, Plugin, keys, PluginKey;
var init_dist4 = __esm({
  "node_modules/prosemirror-state/dist/index.js"() {
    init_dist2();
    init_dist3();
    classesById = /* @__PURE__ */ Object.create(null);
    Selection = class {
      /**
      Initialize a selection with the head and anchor and ranges. If no
      ranges are given, constructs a single range across `$anchor` and
      `$head`.
      */
      constructor($anchor, $head, ranges) {
        this.$anchor = $anchor;
        this.$head = $head;
        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      }
      /**
      The selection's anchor, as an unresolved position.
      */
      get anchor() {
        return this.$anchor.pos;
      }
      /**
      The selection's head.
      */
      get head() {
        return this.$head.pos;
      }
      /**
      The lower bound of the selection's main range.
      */
      get from() {
        return this.$from.pos;
      }
      /**
      The upper bound of the selection's main range.
      */
      get to() {
        return this.$to.pos;
      }
      /**
      The resolved lower  bound of the selection's main range.
      */
      get $from() {
        return this.ranges[0].$from;
      }
      /**
      The resolved upper bound of the selection's main range.
      */
      get $to() {
        return this.ranges[0].$to;
      }
      /**
      Indicates whether the selection contains any content.
      */
      get empty() {
        let ranges = this.ranges;
        for (let i21 = 0; i21 < ranges.length; i21++)
          if (ranges[i21].$from.pos != ranges[i21].$to.pos)
            return false;
        return true;
      }
      /**
      Get the content of this selection as a slice.
      */
      content() {
        return this.$from.doc.slice(this.from, this.to, true);
      }
      /**
      Replace the selection with a slice or, if no slice is given,
      delete the selection. Will append to the given transaction.
      */
      replace(tr2, content = Slice.empty) {
        let lastNode = content.content.lastChild, lastParent = null;
        for (let i21 = 0; i21 < content.openEnd; i21++) {
          lastParent = lastNode;
          lastNode = lastNode.lastChild;
        }
        let mapFrom = tr2.steps.length, ranges = this.ranges;
        for (let i21 = 0; i21 < ranges.length; i21++) {
          let { $from, $to } = ranges[i21], mapping = tr2.mapping.slice(mapFrom);
          tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i21 ? Slice.empty : content);
          if (i21 == 0)
            selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
        }
      }
      /**
      Replace the selection with the given node, appending the changes
      to the given transaction.
      */
      replaceWith(tr2, node) {
        let mapFrom = tr2.steps.length, ranges = this.ranges;
        for (let i21 = 0; i21 < ranges.length; i21++) {
          let { $from, $to } = ranges[i21], mapping = tr2.mapping.slice(mapFrom);
          let from2 = mapping.map($from.pos), to2 = mapping.map($to.pos);
          if (i21) {
            tr2.deleteRange(from2, to2);
          } else {
            tr2.replaceRangeWith(from2, to2, node);
            selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
          }
        }
      }
      /**
      Find a valid cursor or leaf node selection starting at the given
      position and searching back if `dir` is negative, and forward if
      positive. When `textOnly` is true, only consider cursor
      selections. Will return null when no valid selection position is
      found.
      */
      static findFrom($pos, dir, textOnly = false) {
        let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
        if (inner)
          return inner;
        for (let depth = $pos.depth - 1; depth >= 0; depth--) {
          let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
          if (found2)
            return found2;
        }
        return null;
      }
      /**
      Find a valid cursor or leaf node selection near the given
      position. Searches forward first by default, but if `bias` is
      negative, it will search backwards first.
      */
      static near($pos, bias = 1) {
        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
      }
      /**
      Find the cursor or leaf node selection closest to the start of
      the given document. Will return an
      [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
      exists.
      */
      static atStart(doc3) {
        return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
      }
      /**
      Find the cursor or leaf node selection closest to the end of the
      given document.
      */
      static atEnd(doc3) {
        return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
      }
      /**
      Deserialize the JSON representation of a selection. Must be
      implemented for custom classes (as a static class method).
      */
      static fromJSON(doc3, json) {
        if (!json || !json.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        let cls = classesById[json.type];
        if (!cls)
          throw new RangeError(`No selection type ${json.type} defined`);
        return cls.fromJSON(doc3, json);
      }
      /**
      To be able to deserialize selections from JSON, custom selection
      classes must register themselves with an ID string, so that they
      can be disambiguated. Try to pick something that's unlikely to
      clash with classes from other modules.
      */
      static jsonID(id, selectionClass) {
        if (id in classesById)
          throw new RangeError("Duplicate use of selection JSON ID " + id);
        classesById[id] = selectionClass;
        selectionClass.prototype.jsonID = id;
        return selectionClass;
      }
      /**
      Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
      which is a value that can be mapped without having access to a
      current document, and later resolved to a real selection for a
      given document again. (This is used mostly by the history to
      track and restore old selections.) The default implementation of
      this method just converts the selection to a text selection and
      returns the bookmark for that.
      */
      getBookmark() {
        return TextSelection.between(this.$anchor, this.$head).getBookmark();
      }
    };
    Selection.prototype.visible = true;
    SelectionRange = class {
      /**
      Create a range.
      */
      constructor($from, $to) {
        this.$from = $from;
        this.$to = $to;
      }
    };
    warnedAboutTextSelection = false;
    TextSelection = class _TextSelection extends Selection {
      /**
      Construct a text selection between the given points.
      */
      constructor($anchor, $head = $anchor) {
        checkTextSelection($anchor);
        checkTextSelection($head);
        super($anchor, $head);
      }
      /**
      Returns a resolved position if this is a cursor selection (an
      empty text selection), and null otherwise.
      */
      get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
      map(doc3, mapping) {
        let $head = doc3.resolve(mapping.map(this.head));
        if (!$head.parent.inlineContent)
          return Selection.near($head);
        let $anchor = doc3.resolve(mapping.map(this.anchor));
        return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
      }
      replace(tr2, content = Slice.empty) {
        super.replace(tr2, content);
        if (content == Slice.empty) {
          let marks2 = this.$from.marksAcross(this.$to);
          if (marks2)
            tr2.ensureMarks(marks2);
        }
      }
      eq(other) {
        return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
      }
      getBookmark() {
        return new TextBookmark(this.anchor, this.head);
      }
      toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      }
      /**
      @internal
      */
      static fromJSON(doc3, json) {
        if (typeof json.anchor != "number" || typeof json.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
      }
      /**
      Create a text selection from non-resolved positions.
      */
      static create(doc3, anchor, head = anchor) {
        let $anchor = doc3.resolve(anchor);
        return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
      }
      /**
      Return a text selection that spans the given positions or, if
      they aren't text positions, find a text selection near them.
      `bias` determines whether the method searches forward (default)
      or backwards (negative number) first. Will fall back to calling
      [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
      doesn't contain a valid text position.
      */
      static between($anchor, $head, bias) {
        let dPos = $anchor.pos - $head.pos;
        if (!bias || dPos)
          bias = dPos >= 0 ? 1 : -1;
        if (!$head.parent.inlineContent) {
          let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
          if (found2)
            $head = found2.$head;
          else
            return Selection.near($head, bias);
        }
        if (!$anchor.parent.inlineContent) {
          if (dPos == 0) {
            $anchor = $head;
          } else {
            $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
            if ($anchor.pos < $head.pos != dPos < 0)
              $anchor = $head;
          }
        }
        return new _TextSelection($anchor, $head);
      }
    };
    Selection.jsonID("text", TextSelection);
    TextBookmark = class _TextBookmark {
      constructor(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      }
      map(mapping) {
        return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
      }
      resolve(doc3) {
        return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
      }
    };
    NodeSelection = class _NodeSelection extends Selection {
      /**
      Create a node selection. Does not verify the validity of its
      argument.
      */
      constructor($pos) {
        let node = $pos.nodeAfter;
        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        super($pos, $end);
        this.node = node;
      }
      map(doc3, mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        let $pos = doc3.resolve(pos);
        if (deleted)
          return Selection.near($pos);
        return new _NodeSelection($pos);
      }
      content() {
        return new Slice(Fragment.from(this.node), 0, 0);
      }
      eq(other) {
        return other instanceof _NodeSelection && other.anchor == this.anchor;
      }
      toJSON() {
        return { type: "node", anchor: this.anchor };
      }
      getBookmark() {
        return new NodeBookmark(this.anchor);
      }
      /**
      @internal
      */
      static fromJSON(doc3, json) {
        if (typeof json.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new _NodeSelection(doc3.resolve(json.anchor));
      }
      /**
      Create a node selection from non-resolved positions.
      */
      static create(doc3, from2) {
        return new _NodeSelection(doc3.resolve(from2));
      }
      /**
      Determines whether the given node may be selected as a node
      selection.
      */
      static isSelectable(node) {
        return !node.isText && node.type.spec.selectable !== false;
      }
    };
    NodeSelection.prototype.visible = false;
    Selection.jsonID("node", NodeSelection);
    NodeBookmark = class _NodeBookmark {
      constructor(anchor) {
        this.anchor = anchor;
      }
      map(mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
      }
      resolve(doc3) {
        let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
        if (node && NodeSelection.isSelectable(node))
          return new NodeSelection($pos);
        return Selection.near($pos);
      }
    };
    AllSelection = class _AllSelection extends Selection {
      /**
      Create an all-selection over the given document.
      */
      constructor(doc3) {
        super(doc3.resolve(0), doc3.resolve(doc3.content.size));
      }
      replace(tr2, content = Slice.empty) {
        if (content == Slice.empty) {
          tr2.delete(0, tr2.doc.content.size);
          let sel = Selection.atStart(tr2.doc);
          if (!sel.eq(tr2.selection))
            tr2.setSelection(sel);
        } else {
          super.replace(tr2, content);
        }
      }
      toJSON() {
        return { type: "all" };
      }
      /**
      @internal
      */
      static fromJSON(doc3) {
        return new _AllSelection(doc3);
      }
      map(doc3) {
        return new _AllSelection(doc3);
      }
      eq(other) {
        return other instanceof _AllSelection;
      }
      getBookmark() {
        return AllBookmark;
      }
    };
    Selection.jsonID("all", AllSelection);
    AllBookmark = {
      map() {
        return this;
      },
      resolve(doc3) {
        return new AllSelection(doc3);
      }
    };
    UPDATED_SEL = 1;
    UPDATED_MARKS = 2;
    UPDATED_SCROLL = 4;
    Transaction = class extends Transform {
      /**
      @internal
      */
      constructor(state) {
        super(state.doc);
        this.curSelectionFor = 0;
        this.updated = 0;
        this.meta = /* @__PURE__ */ Object.create(null);
        this.time = Date.now();
        this.curSelection = state.selection;
        this.storedMarks = state.storedMarks;
      }
      /**
      The transaction's current selection. This defaults to the editor
      selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
      transaction, but can be overwritten with
      [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
      */
      get selection() {
        if (this.curSelectionFor < this.steps.length) {
          this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
          this.curSelectionFor = this.steps.length;
        }
        return this.curSelection;
      }
      /**
      Update the transaction's current selection. Will determine the
      selection that the editor gets when the transaction is applied.
      */
      setSelection(selection) {
        if (selection.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        this.curSelection = selection;
        this.curSelectionFor = this.steps.length;
        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
        this.storedMarks = null;
        return this;
      }
      /**
      Whether the selection was explicitly updated by this transaction.
      */
      get selectionSet() {
        return (this.updated & UPDATED_SEL) > 0;
      }
      /**
      Set the current stored marks.
      */
      setStoredMarks(marks2) {
        this.storedMarks = marks2;
        this.updated |= UPDATED_MARKS;
        return this;
      }
      /**
      Make sure the current stored marks or, if that is null, the marks
      at the selection, match the given set of marks. Does nothing if
      this is already the case.
      */
      ensureMarks(marks2) {
        if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks2))
          this.setStoredMarks(marks2);
        return this;
      }
      /**
      Add a mark to the set of stored marks.
      */
      addStoredMark(mark) {
        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Remove a mark or mark type from the set of stored marks.
      */
      removeStoredMark(mark) {
        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Whether the stored marks were explicitly set for this transaction.
      */
      get storedMarksSet() {
        return (this.updated & UPDATED_MARKS) > 0;
      }
      /**
      @internal
      */
      addStep(step, doc3) {
        super.addStep(step, doc3);
        this.updated = this.updated & ~UPDATED_MARKS;
        this.storedMarks = null;
      }
      /**
      Update the timestamp for the transaction.
      */
      setTime(time) {
        this.time = time;
        return this;
      }
      /**
      Replace the current selection with the given slice.
      */
      replaceSelection(slice2) {
        this.selection.replace(this, slice2);
        return this;
      }
      /**
      Replace the selection with the given node. When `inheritMarks` is
      true and the content is inline, it inherits the marks from the
      place where it is inserted.
      */
      replaceSelectionWith(node, inheritMarks = true) {
        let selection = this.selection;
        if (inheritMarks)
          node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
        selection.replaceWith(this, node);
        return this;
      }
      /**
      Delete the selection.
      */
      deleteSelection() {
        this.selection.replace(this);
        return this;
      }
      /**
      Replace the given range, or the selection if no range is given,
      with a text node containing the given string.
      */
      insertText(text, from2, to2) {
        let schema2 = this.doc.type.schema;
        if (from2 == null) {
          if (!text)
            return this.deleteSelection();
          return this.replaceSelectionWith(schema2.text(text), true);
        } else {
          if (to2 == null)
            to2 = from2;
          to2 = to2 == null ? from2 : to2;
          if (!text)
            return this.deleteRange(from2, to2);
          let marks2 = this.storedMarks;
          if (!marks2) {
            let $from = this.doc.resolve(from2);
            marks2 = to2 == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to2));
          }
          this.replaceRangeWith(from2, to2, schema2.text(text, marks2));
          if (!this.selection.empty)
            this.setSelection(Selection.near(this.selection.$to));
          return this;
        }
      }
      /**
      Store a metadata property in this transaction, keyed either by
      name or by plugin.
      */
      setMeta(key, value) {
        this.meta[typeof key == "string" ? key : key.key] = value;
        return this;
      }
      /**
      Retrieve a metadata property for a given name or plugin.
      */
      getMeta(key) {
        return this.meta[typeof key == "string" ? key : key.key];
      }
      /**
      Returns true if this transaction doesn't contain any metadata,
      and can thus safely be extended.
      */
      get isGeneric() {
        for (let _2 in this.meta)
          return false;
        return true;
      }
      /**
      Indicate that the editor should scroll the selection into view
      when updated to the state produced by this transaction.
      */
      scrollIntoView() {
        this.updated |= UPDATED_SCROLL;
        return this;
      }
      /**
      True when this transaction has had `scrollIntoView` called on it.
      */
      get scrolledIntoView() {
        return (this.updated & UPDATED_SCROLL) > 0;
      }
    };
    FieldDesc = class {
      constructor(name, desc, self2) {
        this.name = name;
        this.init = bind(desc.init, self2);
        this.apply = bind(desc.apply, self2);
      }
    };
    baseFields = [
      new FieldDesc("doc", {
        init(config) {
          return config.doc || config.schema.topNodeType.createAndFill();
        },
        apply(tr2) {
          return tr2.doc;
        }
      }),
      new FieldDesc("selection", {
        init(config, instance) {
          return config.selection || Selection.atStart(instance.doc);
        },
        apply(tr2) {
          return tr2.selection;
        }
      }),
      new FieldDesc("storedMarks", {
        init(config) {
          return config.storedMarks || null;
        },
        apply(tr2, _marks, _old, state) {
          return state.selection.$cursor ? tr2.storedMarks : null;
        }
      }),
      new FieldDesc("scrollToSelection", {
        init() {
          return 0;
        },
        apply(tr2, prev) {
          return tr2.scrolledIntoView ? prev + 1 : prev;
        }
      })
    ];
    Configuration = class {
      constructor(schema2, plugins) {
        this.schema = schema2;
        this.plugins = [];
        this.pluginsByKey = /* @__PURE__ */ Object.create(null);
        this.fields = baseFields.slice();
        if (plugins)
          plugins.forEach((plugin) => {
            if (this.pluginsByKey[plugin.key])
              throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
            this.plugins.push(plugin);
            this.pluginsByKey[plugin.key] = plugin;
            if (plugin.spec.state)
              this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
          });
      }
    };
    EditorState = class _EditorState {
      /**
      @internal
      */
      constructor(config) {
        this.config = config;
      }
      /**
      The schema of the state's document.
      */
      get schema() {
        return this.config.schema;
      }
      /**
      The plugins that are active in this state.
      */
      get plugins() {
        return this.config.plugins;
      }
      /**
      Apply the given transaction to produce a new state.
      */
      apply(tr2) {
        return this.applyTransaction(tr2).state;
      }
      /**
      @internal
      */
      filterTransaction(tr2, ignore = -1) {
        for (let i21 = 0; i21 < this.config.plugins.length; i21++)
          if (i21 != ignore) {
            let plugin = this.config.plugins[i21];
            if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
              return false;
          }
        return true;
      }
      /**
      Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
      returns the precise transactions that were applied (which might
      be influenced by the [transaction
      hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
      plugins) along with the new state.
      */
      applyTransaction(rootTr) {
        if (!this.filterTransaction(rootTr))
          return { state: this, transactions: [] };
        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
        for (; ; ) {
          let haveNew = false;
          for (let i21 = 0; i21 < this.config.plugins.length; i21++) {
            let plugin = this.config.plugins[i21];
            if (plugin.spec.appendTransaction) {
              let n25 = seen ? seen[i21].n : 0, oldState = seen ? seen[i21].state : this;
              let tr2 = n25 < trs.length && plugin.spec.appendTransaction.call(plugin, n25 ? trs.slice(n25) : trs, oldState, newState);
              if (tr2 && newState.filterTransaction(tr2, i21)) {
                tr2.setMeta("appendedTransaction", rootTr);
                if (!seen) {
                  seen = [];
                  for (let j3 = 0; j3 < this.config.plugins.length; j3++)
                    seen.push(j3 < i21 ? { state: newState, n: trs.length } : { state: this, n: 0 });
                }
                trs.push(tr2);
                newState = newState.applyInner(tr2);
                haveNew = true;
              }
              if (seen)
                seen[i21] = { state: newState, n: trs.length };
            }
          }
          if (!haveNew)
            return { state: newState, transactions: trs };
        }
      }
      /**
      @internal
      */
      applyInner(tr2) {
        if (!tr2.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        let newInstance = new _EditorState(this.config), fields = this.config.fields;
        for (let i21 = 0; i21 < fields.length; i21++) {
          let field = fields[i21];
          newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
        }
        return newInstance;
      }
      /**
      Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
      */
      get tr() {
        return new Transaction(this);
      }
      /**
      Create a new state.
      */
      static create(config) {
        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
        let instance = new _EditorState($config);
        for (let i21 = 0; i21 < $config.fields.length; i21++)
          instance[$config.fields[i21].name] = $config.fields[i21].init(config, instance);
        return instance;
      }
      /**
      Create a new state based on this one, but with an adjusted set
      of active plugins. State fields that exist in both sets of
      plugins are kept unchanged. Those that no longer exist are
      dropped, and those that are new are initialized using their
      [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
      configuration object..
      */
      reconfigure(config) {
        let $config = new Configuration(this.schema, config.plugins);
        let fields = $config.fields, instance = new _EditorState($config);
        for (let i21 = 0; i21 < fields.length; i21++) {
          let name = fields[i21].name;
          instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i21].init(config, instance);
        }
        return instance;
      }
      /**
      Serialize this state to JSON. If you want to serialize the state
      of plugins, pass an object mapping property names to use in the
      resulting JSON object to plugin objects. The argument may also be
      a string or number, in which case it is ignored, to support the
      way `JSON.stringify` calls `toString` methods.
      */
      toJSON(pluginFields) {
        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
        if (this.storedMarks)
          result.storedMarks = this.storedMarks.map((m18) => m18.toJSON());
        if (pluginFields && typeof pluginFields == "object")
          for (let prop in pluginFields) {
            if (prop == "doc" || prop == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (state && state.toJSON)
              result[prop] = state.toJSON.call(plugin, this[plugin.key]);
          }
        return result;
      }
      /**
      Deserialize a JSON representation of a state. `config` should
      have at least a `schema` field, and should contain array of
      plugins to initialize the state with. `pluginFields` can be used
      to deserialize the state of plugins, by associating plugin
      instances with the property names they use in the JSON object.
      */
      static fromJSON(config, json, pluginFields) {
        if (!json)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!config.schema)
          throw new RangeError("Required config field 'schema' missing");
        let $config = new Configuration(config.schema, config.plugins);
        let instance = new _EditorState($config);
        $config.fields.forEach((field) => {
          if (field.name == "doc") {
            instance.doc = Node2.fromJSON(config.schema, json.doc);
          } else if (field.name == "selection") {
            instance.selection = Selection.fromJSON(instance.doc, json.selection);
          } else if (field.name == "storedMarks") {
            if (json.storedMarks)
              instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
          } else {
            if (pluginFields)
              for (let prop in pluginFields) {
                let plugin = pluginFields[prop], state = plugin.spec.state;
                if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                  instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                  return;
                }
              }
            instance[field.name] = field.init(config, instance);
          }
        });
        return instance;
      }
    };
    Plugin = class {
      /**
      Create a plugin.
      */
      constructor(spec) {
        this.spec = spec;
        this.props = {};
        if (spec.props)
          bindProps(spec.props, this, this.props);
        this.key = spec.key ? spec.key.key : createKey("plugin");
      }
      /**
      Extract the plugin's state field from an editor state.
      */
      getState(state) {
        return state[this.key];
      }
    };
    keys = /* @__PURE__ */ Object.create(null);
    PluginKey = class {
      /**
      Create a plugin key.
      */
      constructor(name = "key") {
        this.key = createKey(name);
      }
      /**
      Get the active plugin with this key, if any, from an editor
      state.
      */
      get(state) {
        return state.config.pluginsByKey[this.key];
      }
      /**
      Get the plugin's state from an editor state.
      */
      getState(state) {
        return state[this.key];
      }
    };
  }
});

// node_modules/prosemirror-schema-list/dist/index.js
var dist_exports3 = {};
__export(dist_exports3, {
  addListNodes: () => addListNodes,
  bulletList: () => bulletList,
  liftListItem: () => liftListItem,
  listItem: () => listItem,
  orderedList: () => orderedList,
  sinkListItem: () => sinkListItem,
  splitListItem: () => splitListItem,
  splitListItemKeepMarks: () => splitListItemKeepMarks,
  wrapInList: () => wrapInList,
  wrapRangeInList: () => wrapRangeInList
});
function add(obj, props) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  for (let prop in props)
    copy2[prop] = props[prop];
  return copy2;
}
function addListNodes(nodes2, itemContent, listGroup) {
  return nodes2.append({
    ordered_list: add(orderedList, { content: "list_item+", group: listGroup }),
    bullet_list: add(bulletList, { content: "list_item+", group: listGroup }),
    list_item: add(listItem, { content: itemContent })
  });
}
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr2 = dispatch ? state.tr : null;
    if (!wrapRangeInList(tr2, range, listType, attrs))
      return false;
    if (dispatch)
      dispatch(tr2.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr2, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc3 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc3.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs, range);
  if (!wrap2)
    return false;
  if (tr2)
    doWrapInList(tr2, range, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i21 = wrappers.length - 1; i21 >= 0; i21--)
    content = Fragment.from(wrappers[i21].type.create(wrappers[i21].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i21 = 0; i21 < wrappers.length; i21++)
    if (wrappers[i21].type == listType)
      found2 = i21 + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i21 = range.startIndex, e36 = range.endIndex, first = true; i21 < e36; i21++, first = false) {
    if (!first && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i21).nodeSize;
  }
  return tr2;
}
function splitListItem(itemType, itemAttrs) {
  return function(state, dispatch) {
    let { $from, $to, node } = state.selection;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to))
      return false;
    let grandParent = $from.node(-1);
    if (grandParent.type != itemType)
      return false;
    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1)
        return false;
      if (dispatch) {
        let wrap2 = Fragment.empty;
        let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d22 = $from.depth - depthBefore; d22 >= $from.depth - 3; d22--)
          wrap2 = Fragment.from($from.node(d22).copy(wrap2));
        let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        wrap2 = wrap2.append(Fragment.from(itemType.createAndFill()));
        let start = $from.before($from.depth - (depthBefore - 1));
        let tr3 = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
        let sel = -1;
        tr3.doc.nodesBetween(start, tr3.doc.content.size, (node2, pos) => {
          if (sel > -1)
            return false;
          if (node2.isTextblock && node2.content.size == 0)
            sel = pos + 1;
        });
        if (sel > -1)
          tr3.setSelection(Selection.near(tr3.doc.resolve(sel)));
        dispatch(tr3.scrollIntoView());
      }
      return true;
    }
    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    let tr2 = state.tr.delete($from.pos, $to.pos);
    let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : void 0;
    if (!canSplit(tr2.doc, $from.pos, 2, types))
      return false;
    if (dispatch)
      dispatch(tr2.split($from.pos, 2, types).scrollIntoView());
    return true;
  };
}
function splitListItemKeepMarks(itemType, itemAttrs) {
  let split2 = splitListItem(itemType, itemAttrs);
  return (state, dispatch) => {
    return split2(state, dispatch && ((tr2) => {
      let marks2 = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
      if (marks2)
        tr2.ensureMarks(marks2);
      dispatch(tr2);
    }));
  };
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr2 = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let $after = tr2.doc.resolve(tr2.mapping.map(end, -1) - 1);
  if (canJoin(tr2.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr2.join($after.pos);
  dispatch(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i21 = range.endIndex - 1, e36 = range.startIndex; i21 > e36; i21--) {
    pos -= list.child(i21).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
var olDOM, ulDOM, liDOM, orderedList, bulletList, listItem;
var init_dist5 = __esm({
  "node_modules/prosemirror-schema-list/dist/index.js"() {
    init_dist3();
    init_dist2();
    init_dist4();
    olDOM = ["ol", 0];
    ulDOM = ["ul", 0];
    liDOM = ["li", 0];
    orderedList = {
      attrs: { order: { default: 1, validate: "number" } },
      parseDOM: [{ tag: "ol", getAttrs(dom) {
        return { order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1 };
      } }],
      toDOM(node) {
        return node.attrs.order == 1 ? olDOM : ["ol", { start: node.attrs.order }, 0];
      }
    };
    bulletList = {
      parseDOM: [{ tag: "ul" }],
      toDOM() {
        return ulDOM;
      }
    };
    listItem = {
      parseDOM: [{ tag: "li" }],
      toDOM() {
        return liDOM;
      },
      defining: true
    };
  }
});

// node_modules/prosemirror-schema-basic/dist/index.js
var dist_exports4 = {};
__export(dist_exports4, {
  marks: () => marks,
  nodes: () => nodes,
  schema: () => schema
});
var pDOM, blockquoteDOM, hrDOM, preDOM, brDOM, nodes, emDOM, strongDOM, codeDOM, marks, schema;
var init_dist6 = __esm({
  "node_modules/prosemirror-schema-basic/dist/index.js"() {
    init_dist2();
    pDOM = ["p", 0];
    blockquoteDOM = ["blockquote", 0];
    hrDOM = ["hr"];
    preDOM = ["pre", ["code", 0]];
    brDOM = ["br"];
    nodes = {
      /**
      NodeSpec The top level document node.
      */
      doc: {
        content: "block+"
      },
      /**
      A plain paragraph textblock. Represented in the DOM
      as a `<p>` element.
      */
      paragraph: {
        content: "inline*",
        group: "block",
        parseDOM: [{ tag: "p" }],
        toDOM() {
          return pDOM;
        }
      },
      /**
      A blockquote (`<blockquote>`) wrapping one or more blocks.
      */
      blockquote: {
        content: "block+",
        group: "block",
        defining: true,
        parseDOM: [{ tag: "blockquote" }],
        toDOM() {
          return blockquoteDOM;
        }
      },
      /**
      A horizontal rule (`<hr>`).
      */
      horizontal_rule: {
        group: "block",
        parseDOM: [{ tag: "hr" }],
        toDOM() {
          return hrDOM;
        }
      },
      /**
      A heading textblock, with a `level` attribute that
      should hold the number 1 to 6. Parsed and serialized as `<h1>` to
      `<h6>` elements.
      */
      heading: {
        attrs: { level: { default: 1, validate: "number" } },
        content: "inline*",
        group: "block",
        defining: true,
        parseDOM: [
          { tag: "h1", attrs: { level: 1 } },
          { tag: "h2", attrs: { level: 2 } },
          { tag: "h3", attrs: { level: 3 } },
          { tag: "h4", attrs: { level: 4 } },
          { tag: "h5", attrs: { level: 5 } },
          { tag: "h6", attrs: { level: 6 } }
        ],
        toDOM(node) {
          return ["h" + node.attrs.level, 0];
        }
      },
      /**
      A code listing. Disallows marks or non-text inline
      nodes by default. Represented as a `<pre>` element with a
      `<code>` element inside of it.
      */
      code_block: {
        content: "text*",
        marks: "",
        group: "block",
        code: true,
        defining: true,
        parseDOM: [{ tag: "pre", preserveWhitespace: "full" }],
        toDOM() {
          return preDOM;
        }
      },
      /**
      The text node.
      */
      text: {
        group: "inline"
      },
      /**
      An inline image (`<img>`) node. Supports `src`,
      `alt`, and `href` attributes. The latter two default to the empty
      string.
      */
      image: {
        inline: true,
        attrs: {
          src: { validate: "string" },
          alt: { default: null, validate: "string|null" },
          title: { default: null, validate: "string|null" }
        },
        group: "inline",
        draggable: true,
        parseDOM: [{ tag: "img[src]", getAttrs(dom) {
          return {
            src: dom.getAttribute("src"),
            title: dom.getAttribute("title"),
            alt: dom.getAttribute("alt")
          };
        } }],
        toDOM(node) {
          let { src, alt, title } = node.attrs;
          return ["img", { src, alt, title }];
        }
      },
      /**
      A hard line break, represented in the DOM as `<br>`.
      */
      hard_break: {
        inline: true,
        group: "inline",
        selectable: false,
        parseDOM: [{ tag: "br" }],
        toDOM() {
          return brDOM;
        }
      }
    };
    emDOM = ["em", 0];
    strongDOM = ["strong", 0];
    codeDOM = ["code", 0];
    marks = {
      /**
      A link. Has `href` and `title` attributes. `title`
      defaults to the empty string. Rendered and parsed as an `<a>`
      element.
      */
      link: {
        attrs: {
          href: { validate: "string" },
          title: { default: null, validate: "string|null" }
        },
        inclusive: false,
        parseDOM: [{ tag: "a[href]", getAttrs(dom) {
          return { href: dom.getAttribute("href"), title: dom.getAttribute("title") };
        } }],
        toDOM(node) {
          let { href, title } = node.attrs;
          return ["a", { href, title }, 0];
        }
      },
      /**
      An emphasis mark. Rendered as an `<em>` element. Has parse rules
      that also match `<i>` and `font-style: italic`.
      */
      em: {
        parseDOM: [
          { tag: "i" },
          { tag: "em" },
          { style: "font-style=italic" },
          { style: "font-style=normal", clearMark: (m18) => m18.type.name == "em" }
        ],
        toDOM() {
          return emDOM;
        }
      },
      /**
      A strong mark. Rendered as `<strong>`, parse rules also match
      `<b>` and `font-weight: bold`.
      */
      strong: {
        parseDOM: [
          { tag: "strong" },
          // This works around a Google Docs misbehavior where
          // pasted content will be inexplicably wrapped in `<b>`
          // tags with a font-weight normal.
          { tag: "b", getAttrs: (node) => node.style.fontWeight != "normal" && null },
          { style: "font-weight=400", clearMark: (m18) => m18.type.name == "strong" },
          { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
        ],
        toDOM() {
          return strongDOM;
        }
      },
      /**
      Code font mark. Represented as a `<code>` element.
      */
      code: {
        code: true,
        parseDOM: [{ tag: "code" }],
        toDOM() {
          return codeDOM;
        }
      }
    };
    schema = new Schema({ nodes, marks });
  }
});

// node_modules/prosemirror-view/dist/index.js
var dist_exports5 = {};
__export(dist_exports5, {
  Decoration: () => Decoration,
  DecorationSet: () => DecorationSet,
  EditorView: () => EditorView,
  __endComposition: () => __endComposition,
  __parseFromClipboard: () => __parseFromClipboard
});
function scanFor(node, off, targetNode, targetOff, dir) {
  var _a;
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)
          off += dir;
        else
          return false;
      } else {
        node = child;
        off = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset4) {
  for (; ; ) {
    if (node.nodeType == 3 && offset4)
      return node;
    if (node.nodeType == 1 && offset4 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset4 - 1];
      offset4 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset4 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset4) {
  for (; ; ) {
    if (node.nodeType == 3 && offset4 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset4 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset4];
      offset4 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset4 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset4, parent) {
  for (let atStart = offset4 == 0, atEnd = offset4 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x5, y5) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x5, y5);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_2) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x5, y5);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
function windowRect(doc3) {
  let vp = doc3.defaultView && doc3.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide2(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide2(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide2(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide2(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide2(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide2(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide2(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide2(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide2(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide2(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x5 = (rect.left + rect.right) / 2, y5 = startY + 1; y5 < Math.min(innerHeight, rect.bottom); y5 += 5) {
    let dom = view.root.elementFromPoint(x5, y5);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i21 = 0; i21 < stack.length; i21++) {
    let { dom, top, left } = stack[i21];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset4 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i21 = 0; i21 < rects.length; i21++) {
      let rect = rects[i21];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset4 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset4 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset4 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i21 = 0; i21 < len; i21++) {
    range.setEnd(node, i21 + 1);
    range.setStart(node, i21);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i21 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset4 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset4, bias);
}
function posFromCaret(view, node, offset4, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset4, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i21 = startI; ; ) {
      let child = element.childNodes[i21];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j3 = 0; j3 < rects.length; j3++) {
          let rect = rects[j3];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i21 = (i21 + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset4 = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset4 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p30 = elt; node && p30; p30 = parentNode(p30))
      if (p30.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset4 = Math.min(offset4, node.childNodes.length);
      if (offset4 < node.childNodes.length) {
        let next = node.childNodes[offset4], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset4++;
      }
    }
    let prev;
    if (webkit && offset4 && node.nodeType == 1 && (prev = node.childNodes[offset4 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset4--;
    if (node == view.dom && offset4 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset4 == 0 || node.nodeType != 1 || node.childNodes[offset4 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset4, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first))
      return first;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
function coordsAtPos(view, pos, side) {
  let { node, offset: offset4, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset4 : offset4 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset4, offset4), side);
      if (gecko && offset4 && /\s/.test(node.nodeValue[offset4 - 1]) && offset4 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset4 - 1, offset4 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset4, offset4 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset4, to2 = offset4, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset4) {
        to2++;
        takeSide = -1;
      } else if (side >= 0 && offset4 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to2++;
      }
      return flattenV(singleRect(textRange(node, from2, to2), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset4 && (side < 0 || offset4 == nodeSize(node))) {
      let before = node.childNodes[offset4 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset4 < nodeSize(node)) {
      let after = node.childNodes[offset4];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset4 && (side < 0 || offset4 == nodeSize(node))) {
    let before = node.childNodes[offset4 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset4 < nodeSize(node)) {
    let after = node.childNodes[offset4];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x5 = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x5, right: x5 };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y5 = top ? rect.top : rect.bottom;
  return { top: y5, bottom: y5, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f11) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f11();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i21 = 0; i21 < boxes.length; i21++) {
        let box = boxes[i21];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset4 = $head.parentOffset, atStart = !offset4, atEnd = offset4 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_2) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i21 = 0; i21 < descs.length; i21++) {
    let desc = descs[i21], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
  for (let i21 = 0; i21 < outerDeco.length; i21++) {
    let attrs = outerDeco[i21].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i21 = 0; i21 < curComputed.length; i21++) {
    let deco = curComputed[i21], prev = prevComputed[i21];
    if (i21) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i21 = 0; i21 < prevList.length; i21++)
      if (curList.indexOf(prevList[i21]) == -1)
        dom.classList.remove(prevList[i21]);
    for (let i21 = 0; i21 < curList.length; i21++)
      if (prevList.indexOf(curList[i21]) == -1)
        dom.classList.add(curList[i21]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m18;
      while (m18 = prop.exec(prev.style))
        dom.style.removeProperty(m18[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a23, b12) {
  if (a23.length != b12.length)
    return false;
  for (let i21 = 0; i21 < a23.length; i21++)
    if (!a23[i21].type.eq(b12[i21].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches3 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches3.push(desc);
  }
  return { index: fI, matched, matches: matches3.reverse() };
}
function compareSide(a23, b12) {
  return a23.type.side - b12.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset4 = 0;
  if (locals.length == 0) {
    for (let i21 = 0; i21 < parent.childCount; i21++) {
      let child = parent.child(i21);
      onNode(child, locals, deco.forChild(offset4, child), i21);
      offset4 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset4) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i21 = 0; i21 < widgets.length; i21++)
          onWidget(widgets[i21], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i21 = 0; i21 < active.length; i21++)
      if (active[i21].to <= offset4)
        active.splice(i21--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset4 && locals[decoIndex].to > offset4)
      active.push(locals[decoIndex++]);
    let end = offset4 + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i21 = 0; i21 < active.length; i21++)
        if (active[i21].to < cutAt)
          cutAt = active[i21].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset4);
        child = child.cut(0, cutAt - offset4);
        end = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d22) => !d22.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset4, child), index);
    offset4 = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to2) {
  for (let i21 = 0, pos = 0; i21 < frag.childCount && pos <= to2; ) {
    let child = frag.child(i21++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i21 < frag.childCount) {
      let next = frag.child(i21++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to2 && str.slice(to2 - text.length - childStart, to2 - childStart) == text)
        return to2 - text.length;
      let found2 = childStart < to2 ? str.lastIndexOf(text, to2 - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to2 && str.length >= to2 + text.length - childStart && str.slice(to2 - childStart, to2 - childStart + text.length) == text)
        return to2;
    }
  }
  return -1;
}
function replaceNodes(nodes2, from2, to2, view, replacement) {
  let result = [];
  for (let i21 = 0, off = 0; i21 < nodes2.length; i21++) {
    let child = nodes2[i21], start = off, end = off += child.size;
    if (start >= to2 || end <= from2) {
      result.push(child);
    } else {
      if (start < from2)
        result.push(child.slice(0, from2 - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end > to2)
        result.push(child.slice(to2 - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i21 = 0; i21 < domSel.rangeCount; i21++) {
        let range = domSel.getRangeAt(i21);
        min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc3.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc3.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset4 } = view.docView.domFromPos(pos, 0);
  let after = offset4 < node.childNodes.length ? node.childNodes[offset4] : null;
  let before = offset4 ? node.childNodes[offset4 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset4 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset4) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    domSel.collapse(node.parentNode, domIndex(node) + 1);
  else
    domSel.collapse(node, 0);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f11) => f11(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset4 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset4 < nodeLen(node) && isIgnorable(node.childNodes[offset4], -1))
    force = true;
  for (; ; ) {
    if (offset4 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset4 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset4;
        } else if (before.nodeType == 3) {
          node = before;
          offset4 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset4 = 0;
      } else {
        node = prev;
        offset4 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset4);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset4 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset4 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset4];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset4;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset4 = len = 0;
      } else {
        node = next;
        offset4 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset4) {
  while (node && offset4 == node.childNodes.length && !hasBlockDesc(node)) {
    offset4 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset4 < node.childNodes.length) {
    let next = node.childNodes[offset4];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset4 = 0;
  }
}
function textNodeBefore(node, offset4) {
  while (node && !offset4 && !hasBlockDesc(node)) {
    offset4 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset4) {
    let next = node.childNodes[offset4 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset4 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset4) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset4)) {
      node = after;
      offset4 = 0;
    } else if (before = textNodeBefore(node, offset4)) {
      node = before;
      offset4 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset4);
    range.setStart(node, offset4);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset4);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f11) => {
    slice2 = f11(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i21 = needsWrap.length - 1; i21 >= 0; i21--) {
      let wrapper = doc3.createElement(needsWrap[i21]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f11) => f11(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = !!text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f11) => {
      text = f11(text, inCode || plainText, view);
    });
    if (inCode) {
      slice2 = new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0);
      view.someProp("transformPasted", (f11) => {
        slice2 = f11(slice2, view, true);
      });
      return slice2;
    }
    let parsed = view.someProp("clipboardTextParser", (f11) => f11(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks2 = $context.marks();
      let { schema: schema2 } = view.state, serializer = DOMSerializer.fromSchema(schema2);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p30 = dom.appendChild(document.createElement("p"));
        if (block)
          p30.appendChild(serializer.serializeNode(schema2.text(block, marks2)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f11) => {
      html = f11(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i21 = +sliceData[3]; i21 > 0; i21--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f11) => {
    slice2 = f11(slice2, view, asText);
  });
  return slice2;
}
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d22 = $context.depth; d22 >= 0; d22--) {
    let parent = $context.node(d22);
    let match = parent.contentMatchAt($context.index(d22));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i21 = wrap2.length - 1; i21 >= from2; i21--)
    node = wrap2[i21].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to2, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to2 - 1)
    inner = closeRange(inner, side, from2, to2, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s19) => s19 });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n25) => "<" + n25 + ">").join("") + html + wrap2.map((n25) => "</" + n25 + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap2)
    for (let i21 = 0; i21 < wrap2.length; i21++)
      elt = elt.querySelector(wrap2[i21]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes2 = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i21 = 0; i21 < nodes2.length; i21++) {
    let node = nodes2[i21];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema2 = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e36) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i21 = array.length - 2; i21 >= 0; i21 -= 2) {
    let type = schema2.nodes[array[i21]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i21 + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i21 = $pos.depth + 1; i21 > 0; i21--) {
    if (view.someProp(propName, (f11) => i21 > $pos.depth ? f11(view, pos, $pos.nodeAfter, $pos.before(i21), event, true) : f11(view, pos, $pos.node(i21), $pos.before(i21), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i21 = $pos.depth + 1; i21 > 0; i21--) {
    let node = i21 > $pos.depth ? $pos.nodeAfter : $pos.node(i21);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i21 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i21);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f11) => f11(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f11) => f11(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f11) => f11(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i21 = $pos.depth + 1; i21 > 0; i21--) {
    let node = i21 > $pos.depth ? $pos.nodeAfter : $pos.node(i21);
    let nodePos = $pos.before(i21);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
function scheduleComposeEnd(view, delay3) {
  clearTimeout(view.input.composingTimeout);
  if (delay3 > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay3);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f11) => f11(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
function compareObjs(a23, b12) {
  if (a23 == b12)
    return true;
  for (let p30 in a23)
    if (a23[p30] !== b12[p30])
      return false;
  for (let p30 in b12)
    if (!(p30 in a23))
      return false;
  return true;
}
function mapChildren(oldChildren, newLocal, mapping, node, offset4, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i21 = 0, baseOffset = oldOffset; i21 < mapping.maps.length; i21++) {
    let moved = 0;
    mapping.maps[i21].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i22 = 0; i22 < children.length; i22 += 3) {
        let end = children[i22 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i22] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i22 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i22] += dSize;
          children[i22 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i21].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i21 = 0; i21 < children.length; i21 += 3)
    if (children[i21 + 1] < 0) {
      if (children[i21 + 1] == -2) {
        mustRebuild = true;
        children[i21 + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i21] + oldOffset), fromLocal = from2 - offset4;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to2 = mapping.map(oldChildren[i21 + 1] + oldOffset, -1), toLocal = to2 - offset4;
      let { index, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i21 + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i21] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i21] = fromLocal;
          children[i21 + 1] = toLocal;
          children[i21 + 2] = mapped;
        } else {
          children[i21 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset4, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i21 = 0; i21 < children.length; i21 += 3)
      if (children[i21 + 1] < 0) {
        children.splice(i21, 3);
        i21 -= 3;
      }
    for (let i21 = 0, j3 = 0; i21 < built.children.length; i21 += 3) {
      let from2 = built.children[i21];
      while (j3 < children.length && children[j3] < from2)
        j3 += 3;
      children.splice(j3, 0, built.children[i21], built.children[i21 + 1], built.children[i21 + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset4) {
  if (!offset4 || !spans.length)
    return spans;
  let result = [];
  for (let i21 = 0; i21 < spans.length; i21++) {
    let span = spans[i21];
    result.push(new Decoration(span.from + offset4, span.to + offset4, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset4, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i21 = 0; i21 < set.local.length; i21++) {
      let mapped = set.local[i21].map(mapping, offset4, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i21].spec);
    }
    for (let i21 = 0; i21 < set.children.length; i21 += 3)
      gather(set.children[i21 + 2], set.children[i21] + oldOffset2 + 1);
  }
  for (let i21 = 0; i21 < children.length; i21 += 3)
    if (children[i21 + 1] == -1)
      gather(children[i21 + 2], oldChildren[i21] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset4) {
  if (node.isLeaf)
    return null;
  let end = offset4 + node.nodeSize, found2 = null;
  for (let i21 = 0, span; i21 < spans.length; i21++) {
    if ((span = spans[i21]) && span.from > offset4 && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i21] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i21 = 0; i21 < array.length; i21++)
    if (array[i21] != null)
      result.push(array[i21]);
  return result;
}
function buildTree(spans, node, offset4, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset4);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset4 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset4).sort(byPos);
  for (let i21 = 0; i21 < locals.length; i21++)
    if (!locals[i21].type.valid(node, locals[i21])) {
      if (options.onRemove)
        options.onRemove(locals[i21].spec);
      locals.splice(i21--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a23, b12) {
  return a23.from - b12.from || a23.to - b12.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i21 = 0; i21 < working.length - 1; i21++) {
    let span = working[i21];
    if (span.from != span.to)
      for (let j3 = i21 + 1; j3 < working.length; j3++) {
        let next = working[j3];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j3] = next.copy(next.from, span.to);
            insertAhead(working, j3 + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i21] = span.copy(span.from, next.from);
            insertAhead(working, j3, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i21, deco) {
  while (i21 < array.length && byPos(deco, array[i21]) > 0)
    i21++;
  array.splice(i21, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f11) => {
    let result = f11(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p30 = node.parentNode; p30 && p30 != view.dom; p30 = p30.parentNode) {
    let desc = view.docView.nearestDesc(p30, true);
    if (desc && desc.node.isBlock)
      return p30;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to: to2 } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    let anchor2 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to: to2 };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
function readDOMChange(view, from2, to2, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f11) => f11(view, keyEvent(13, "Enter"))))
        return;
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      if (compositionID)
        tr2.setMeta("composition", compositionID);
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to2);
  from2 = $before.before(shared + 1);
  to2 = view.state.doc.resolve(to2).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from2, to2);
  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n25) => n25.nodeType == 1 && !isInline.test(n25.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f11) => f11(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr2 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr2.setMeta("composition", compositionID);
          view.dispatch(tr2);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n25) => n25.nodeName == "DIV" || n25.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", ""))) && view.someProp("handleKeyDown", (f11) => f11(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f11) => f11(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f11) {
        return f11(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr2 = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr2.doc, parse.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
        tr2.setSelection(sel2);
    }
    if (compositionID)
      tr2.setMeta("composition", compositionID);
    return tr2.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr2 = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks2 = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
      if (marks2)
        tr2.ensureMarks(marks2);
      view.dispatch(tr2);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr2 = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr2);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f11) => f11(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    } else {
      view.dispatch(mkTr());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i21 = 0; i21 < prevMarks.length; i21++)
    added = prevMarks[i21].removeFromSet(added);
  for (let i21 = 0; i21 < curMarks.length; i21++)
    removed = curMarks[i21].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i21 = 0; i21 < prev.childCount; i21++)
    updated.push(update(prev.child(i21)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a23, b12, pos, preferredPos, preferredSide) {
  let start = a23.findDiffStart(b12, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a23.findDiffEnd(b12, pos + a23.size, pos + b12.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a23.size < b12.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b12.size && isSurrogatePair(b12.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a23.size && isSurrogatePair(a23.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a23 = str.charCodeAt(0), b12 = str.charCodeAt(1);
  return a23 >= 56320 && a23 <= 57343 && b12 >= 55296 && b12 <= 56319;
}
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add2(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add2);
  view.someProp("markViews", add2);
  return result;
}
function changedNodeViews(a23, b12) {
  let nA = 0, nB = 0;
  for (let prop in a23) {
    if (a23[prop] != b12[prop])
      return true;
    nA++;
  }
  for (let _2 in b12)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var domIndex, parentNode, reusedRange, textRange, clearReusedRange, isEquivalentPosition, atomElements, selectionCollapsed, nav, doc2, agent, ie_edge, ie_upto10, ie_11up, ie, ie_version, gecko, _chrome, chrome, chrome_version, safari, ios, mac, windows, android, webkit, webkit_version, preventScrollSupported, BIDI, maybeRTL, cachedState, cachedDir, cachedResult, NOT_DIRTY, CHILD_DIRTY, CONTENT_DIRTY, NODE_DIRTY, ViewDesc, WidgetViewDesc, CompositionViewDesc, MarkViewDesc, NodeViewDesc, TextViewDesc, TrailingHackViewDesc, CustomNodeViewDesc, OuterDecoLevel, noDeco, ViewTreeUpdater, brokenSelectBetweenUneditable, inlineParents, wrapMap, _detachedDoc, _policy, handlers, editHandlers, passiveHandlers, InputState, selectNodeModifier, MouseDown, timeoutComposition, brokenClipboardAPI, Dragging, dragCopyModifier, WidgetType, InlineType, NodeType2, Decoration, none, noSpec, DecorationSet, empty, DecorationGroup, observeOptions, useCharData, SelectionState, DOMObserver, cssChecked, cssCheckWarned, isInline, __parseFromClipboard, __endComposition, EditorView;
var init_dist7 = __esm({
  "node_modules/prosemirror-view/dist/index.js"() {
    init_dist4();
    init_dist2();
    init_dist3();
    domIndex = function(node) {
      for (var index = 0; ; index++) {
        node = node.previousSibling;
        if (!node)
          return index;
      }
    };
    parentNode = function(node) {
      let parent = node.assignedSlot || node.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent;
    };
    reusedRange = null;
    textRange = function(node, from2, to2) {
      let range = reusedRange || (reusedRange = document.createRange());
      range.setEnd(node, to2 == null ? node.nodeValue.length : to2);
      range.setStart(node, from2 || 0);
      return range;
    };
    clearReusedRange = function() {
      reusedRange = null;
    };
    isEquivalentPosition = function(node, off, targetNode, targetOff) {
      return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
    };
    atomElements = /^(img|br|input|textarea|hr)$/i;
    selectionCollapsed = function(domSel) {
      return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
    };
    nav = typeof navigator != "undefined" ? navigator : null;
    doc2 = typeof document != "undefined" ? document : null;
    agent = nav && nav.userAgent || "";
    ie_edge = /Edge\/(\d+)/.exec(agent);
    ie_upto10 = /MSIE \d/.exec(agent);
    ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
    ie = !!(ie_upto10 || ie_11up || ie_edge);
    ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
    gecko = !ie && /gecko\/(\d+)/i.test(agent);
    gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
    _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
    chrome = !!_chrome;
    chrome_version = _chrome ? +_chrome[1] : 0;
    safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
    ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
    mac = ios || (nav ? /Mac/.test(nav.platform) : false);
    windows = nav ? /Win/.test(nav.platform) : false;
    android = /Android \d/.test(agent);
    webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
    webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    preventScrollSupported = null;
    BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    maybeRTL = /[\u0590-\u08ac]/;
    cachedState = null;
    cachedDir = null;
    cachedResult = false;
    NOT_DIRTY = 0;
    CHILD_DIRTY = 1;
    CONTENT_DIRTY = 2;
    NODE_DIRTY = 3;
    ViewDesc = class {
      constructor(parent, children, dom, contentDOM) {
        this.parent = parent;
        this.children = children;
        this.dom = dom;
        this.contentDOM = contentDOM;
        this.dirty = NOT_DIRTY;
        dom.pmViewDesc = this;
      }
      // Used to check whether a given description corresponds to a
      // widget/mark/node.
      matchesWidget(widget) {
        return false;
      }
      matchesMark(mark) {
        return false;
      }
      matchesNode(node, outerDeco, innerDeco) {
        return false;
      }
      matchesHack(nodeName) {
        return false;
      }
      // When parsing in-editor content (in domchange.js), we allow
      // descriptions to determine the parse rules that should be used to
      // parse them.
      parseRule() {
        return null;
      }
      // Used by the editor's event handler to ignore events that come
      // from certain descs.
      stopEvent(event) {
        return false;
      }
      // The size of the content represented by this desc.
      get size() {
        let size3 = 0;
        for (let i21 = 0; i21 < this.children.length; i21++)
          size3 += this.children[i21].size;
        return size3;
      }
      // For block nodes, this represents the space taken up by their
      // start/end tokens.
      get border() {
        return 0;
      }
      destroy() {
        this.parent = void 0;
        if (this.dom.pmViewDesc == this)
          this.dom.pmViewDesc = void 0;
        for (let i21 = 0; i21 < this.children.length; i21++)
          this.children[i21].destroy();
      }
      posBeforeChild(child) {
        for (let i21 = 0, pos = this.posAtStart; ; i21++) {
          let cur = this.children[i21];
          if (cur == child)
            return pos;
          pos += cur.size;
        }
      }
      get posBefore() {
        return this.parent.posBeforeChild(this);
      }
      get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
      get posAfter() {
        return this.posBefore + this.size;
      }
      get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border;
      }
      localPosFromDOM(dom, offset4, bias) {
        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
          if (bias < 0) {
            let domBefore, desc;
            if (dom == this.contentDOM) {
              domBefore = dom.childNodes[offset4 - 1];
            } else {
              while (dom.parentNode != this.contentDOM)
                dom = dom.parentNode;
              domBefore = dom.previousSibling;
            }
            while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
              domBefore = domBefore.previousSibling;
            return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
          } else {
            let domAfter, desc;
            if (dom == this.contentDOM) {
              domAfter = dom.childNodes[offset4];
            } else {
              while (dom.parentNode != this.contentDOM)
                dom = dom.parentNode;
              domAfter = dom.nextSibling;
            }
            while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
              domAfter = domAfter.nextSibling;
            return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
          }
        }
        let atEnd;
        if (dom == this.dom && this.contentDOM) {
          atEnd = offset4 > domIndex(this.contentDOM);
        } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
          atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
        } else if (this.dom.firstChild) {
          if (offset4 == 0)
            for (let search = dom; ; search = search.parentNode) {
              if (search == this.dom) {
                atEnd = false;
                break;
              }
              if (search.previousSibling)
                break;
            }
          if (atEnd == null && offset4 == dom.childNodes.length)
            for (let search = dom; ; search = search.parentNode) {
              if (search == this.dom) {
                atEnd = true;
                break;
              }
              if (search.nextSibling)
                break;
            }
        }
        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
      }
      nearestDesc(dom, onlyNodes = false) {
        for (let first = true, cur = dom; cur; cur = cur.parentNode) {
          let desc = this.getDesc(cur), nodeDOM;
          if (desc && (!onlyNodes || desc.node)) {
            if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
              first = false;
            else
              return desc;
          }
        }
      }
      getDesc(dom) {
        let desc = dom.pmViewDesc;
        for (let cur = desc; cur; cur = cur.parent)
          if (cur == this)
            return desc;
      }
      posFromDOM(dom, offset4, bias) {
        for (let scan = dom; scan; scan = scan.parentNode) {
          let desc = this.getDesc(scan);
          if (desc)
            return desc.localPosFromDOM(dom, offset4, bias);
        }
        return -1;
      }
      // Find the desc for the node after the given pos, if any. (When a
      // parent node overrode rendering, there might not be one.)
      descAt(pos) {
        for (let i21 = 0, offset4 = 0; i21 < this.children.length; i21++) {
          let child = this.children[i21], end = offset4 + child.size;
          if (offset4 == pos && end != offset4) {
            while (!child.border && child.children.length) {
              for (let i22 = 0; i22 < child.children.length; i22++) {
                let inner = child.children[i22];
                if (inner.size) {
                  child = inner;
                  break;
                }
              }
            }
            return child;
          }
          if (pos < end)
            return child.descAt(pos - offset4 - child.border);
          offset4 = end;
        }
      }
      domFromPos(pos, side) {
        if (!this.contentDOM)
          return { node: this.dom, offset: 0, atom: pos + 1 };
        let i21 = 0, offset4 = 0;
        for (let curPos = 0; i21 < this.children.length; i21++) {
          let child = this.children[i21], end = curPos + child.size;
          if (end > pos || child instanceof TrailingHackViewDesc) {
            offset4 = pos - curPos;
            break;
          }
          curPos = end;
        }
        if (offset4)
          return this.children[i21].domFromPos(offset4 - this.children[i21].border, side);
        for (let prev; i21 && !(prev = this.children[i21 - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i21--) {
        }
        if (side <= 0) {
          let prev, enter = true;
          for (; ; i21--, enter = false) {
            prev = i21 ? this.children[i21 - 1] : null;
            if (!prev || prev.dom.parentNode == this.contentDOM)
              break;
          }
          if (prev && side && enter && !prev.border && !prev.domAtom)
            return prev.domFromPos(prev.size, side);
          return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
        } else {
          let next, enter = true;
          for (; ; i21++, enter = false) {
            next = i21 < this.children.length ? this.children[i21] : null;
            if (!next || next.dom.parentNode == this.contentDOM)
              break;
          }
          if (next && enter && !next.border && !next.domAtom)
            return next.domFromPos(0, side);
          return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
        }
      }
      // Used to find a DOM range in a single parent for a given changed
      // range.
      parseRange(from2, to2, base2 = 0) {
        if (this.children.length == 0)
          return { node: this.contentDOM, from: from2, to: to2, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
        let fromOffset = -1, toOffset = -1;
        for (let offset4 = base2, i21 = 0; ; i21++) {
          let child = this.children[i21], end = offset4 + child.size;
          if (fromOffset == -1 && from2 <= end) {
            let childBase = offset4 + child.border;
            if (from2 >= childBase && to2 <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
              return child.parseRange(from2, to2, childBase);
            from2 = offset4;
            for (let j3 = i21; j3 > 0; j3--) {
              let prev = this.children[j3 - 1];
              if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
                fromOffset = domIndex(prev.dom) + 1;
                break;
              }
              from2 -= prev.size;
            }
            if (fromOffset == -1)
              fromOffset = 0;
          }
          if (fromOffset > -1 && (end > to2 || i21 == this.children.length - 1)) {
            to2 = end;
            for (let j3 = i21 + 1; j3 < this.children.length; j3++) {
              let next = this.children[j3];
              if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
                toOffset = domIndex(next.dom);
                break;
              }
              to2 += next.size;
            }
            if (toOffset == -1)
              toOffset = this.contentDOM.childNodes.length;
            break;
          }
          offset4 = end;
        }
        return { node: this.contentDOM, from: from2, to: to2, fromOffset, toOffset };
      }
      emptyChildAt(side) {
        if (this.border || !this.contentDOM || !this.children.length)
          return false;
        let child = this.children[side < 0 ? 0 : this.children.length - 1];
        return child.size == 0 || child.emptyChildAt(side);
      }
      domAfterPos(pos) {
        let { node, offset: offset4 } = this.domFromPos(pos, 0);
        if (node.nodeType != 1 || offset4 == node.childNodes.length)
          throw new RangeError("No node after pos " + pos);
        return node.childNodes[offset4];
      }
      // View descs are responsible for setting any selection that falls
      // entirely inside of them, so that custom implementations can do
      // custom things with the selection. Note that this falls apart when
      // a selection starts in such a node and ends in another, in which
      // case we just use whatever domFromPos produces as a best effort.
      setSelection(anchor, head, view, force = false) {
        let from2 = Math.min(anchor, head), to2 = Math.max(anchor, head);
        for (let i21 = 0, offset4 = 0; i21 < this.children.length; i21++) {
          let child = this.children[i21], end = offset4 + child.size;
          if (from2 > offset4 && to2 < end)
            return child.setSelection(anchor - offset4 - child.border, head - offset4 - child.border, view, force);
          offset4 = end;
        }
        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
        let domSel = view.root.getSelection();
        let selRange = view.domSelectionRange();
        let brKludge = false;
        if ((gecko || safari) && anchor == head) {
          let { node, offset: offset4 } = anchorDOM;
          if (node.nodeType == 3) {
            brKludge = !!(offset4 && node.nodeValue[offset4 - 1] == "\n");
            if (brKludge && offset4 == node.nodeValue.length) {
              for (let scan = node, after; scan; scan = scan.parentNode) {
                if (after = scan.nextSibling) {
                  if (after.nodeName == "BR")
                    anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                  break;
                }
                let desc = scan.pmViewDesc;
                if (desc && desc.node && desc.node.isBlock)
                  break;
              }
            }
          } else {
            let prev = node.childNodes[offset4 - 1];
            brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
          }
        }
        if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
          let after = selRange.focusNode.childNodes[selRange.focusOffset];
          if (after && after.contentEditable == "false")
            force = true;
        }
        if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
          return;
        let domSelExtended = false;
        if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {
          domSel.collapse(anchorDOM.node, anchorDOM.offset);
          try {
            if (anchor != head)
              domSel.extend(headDOM.node, headDOM.offset);
            domSelExtended = true;
          } catch (_2) {
          }
        }
        if (!domSelExtended) {
          if (anchor > head) {
            let tmp = anchorDOM;
            anchorDOM = headDOM;
            headDOM = tmp;
          }
          let range = document.createRange();
          range.setEnd(headDOM.node, headDOM.offset);
          range.setStart(anchorDOM.node, anchorDOM.offset);
          domSel.removeAllRanges();
          domSel.addRange(range);
        }
      }
      ignoreMutation(mutation) {
        return !this.contentDOM && mutation.type != "selection";
      }
      get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
      // Remove a subtree of the element tree that has been touched
      // by a DOM change, so that the next update will redraw it.
      markDirty(from2, to2) {
        for (let offset4 = 0, i21 = 0; i21 < this.children.length; i21++) {
          let child = this.children[i21], end = offset4 + child.size;
          if (offset4 == end ? from2 <= end && to2 >= offset4 : from2 < end && to2 > offset4) {
            let startInside = offset4 + child.border, endInside = end - child.border;
            if (from2 >= startInside && to2 <= endInside) {
              this.dirty = from2 == offset4 || to2 == end ? CONTENT_DIRTY : CHILD_DIRTY;
              if (from2 == startInside && to2 == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
                child.dirty = NODE_DIRTY;
              else
                child.markDirty(from2 - startInside, to2 - startInside);
              return;
            } else {
              child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
            }
          }
          offset4 = end;
        }
        this.dirty = CONTENT_DIRTY;
      }
      markParentsDirty() {
        let level = 1;
        for (let node = this.parent; node; node = node.parent, level++) {
          let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (node.dirty < dirty)
            node.dirty = dirty;
        }
      }
      get domAtom() {
        return false;
      }
      get ignoreForCoords() {
        return false;
      }
      get ignoreForSelection() {
        return false;
      }
      isText(text) {
        return false;
      }
    };
    WidgetViewDesc = class extends ViewDesc {
      constructor(parent, widget, view, pos) {
        let self2, dom = widget.type.toDOM;
        if (typeof dom == "function")
          dom = dom(view, () => {
            if (!self2)
              return pos;
            if (self2.parent)
              return self2.parent.posBeforeChild(self2);
          });
        if (!widget.type.spec.raw) {
          if (dom.nodeType != 1) {
            let wrap2 = document.createElement("span");
            wrap2.appendChild(dom);
            dom = wrap2;
          }
          dom.contentEditable = "false";
          dom.classList.add("ProseMirror-widget");
        }
        super(parent, [], dom, null);
        this.widget = widget;
        this.widget = widget;
        self2 = this;
      }
      matchesWidget(widget) {
        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
      }
      parseRule() {
        return { ignore: true };
      }
      stopEvent(event) {
        let stop = this.widget.spec.stopEvent;
        return stop ? stop(event) : false;
      }
      ignoreMutation(mutation) {
        return mutation.type != "selection" || this.widget.spec.ignoreSelection;
      }
      destroy() {
        this.widget.type.destroy(this.dom);
        super.destroy();
      }
      get domAtom() {
        return true;
      }
      get ignoreForSelection() {
        return !!this.widget.type.spec.relaxedSide;
      }
      get side() {
        return this.widget.type.side;
      }
    };
    CompositionViewDesc = class extends ViewDesc {
      constructor(parent, dom, textDOM, text) {
        super(parent, [], dom, null);
        this.textDOM = textDOM;
        this.text = text;
      }
      get size() {
        return this.text.length;
      }
      localPosFromDOM(dom, offset4) {
        if (dom != this.textDOM)
          return this.posAtStart + (offset4 ? this.size : 0);
        return this.posAtStart + offset4;
      }
      domFromPos(pos) {
        return { node: this.textDOM, offset: pos };
      }
      ignoreMutation(mut) {
        return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
      }
    };
    MarkViewDesc = class _MarkViewDesc extends ViewDesc {
      constructor(parent, mark, dom, contentDOM, spec) {
        super(parent, [], dom, contentDOM);
        this.mark = mark;
        this.spec = spec;
      }
      static create(parent, mark, inline2, view) {
        let custom = view.nodeViews[mark.type.name];
        let spec = custom && custom(mark, view, inline2);
        if (!spec || !spec.dom)
          spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline2), null, mark.attrs);
        return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
      }
      parseRule() {
        if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
          return null;
        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      }
      matchesMark(mark) {
        return this.dirty != NODE_DIRTY && this.mark.eq(mark);
      }
      markDirty(from2, to2) {
        super.markDirty(from2, to2);
        if (this.dirty != NOT_DIRTY) {
          let parent = this.parent;
          while (!parent.node)
            parent = parent.parent;
          if (parent.dirty < this.dirty)
            parent.dirty = this.dirty;
          this.dirty = NOT_DIRTY;
        }
      }
      slice(from2, to2, view) {
        let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
        let nodes2 = this.children, size3 = this.size;
        if (to2 < size3)
          nodes2 = replaceNodes(nodes2, to2, size3, view);
        if (from2 > 0)
          nodes2 = replaceNodes(nodes2, 0, from2, view);
        for (let i21 = 0; i21 < nodes2.length; i21++)
          nodes2[i21].parent = copy2;
        copy2.children = nodes2;
        return copy2;
      }
      ignoreMutation(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
      }
      destroy() {
        if (this.spec.destroy)
          this.spec.destroy();
        super.destroy();
      }
    };
    NodeViewDesc = class _NodeViewDesc extends ViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
        super(parent, [], dom, contentDOM);
        this.node = node;
        this.outerDeco = outerDeco;
        this.innerDeco = innerDeco;
        this.nodeDOM = nodeDOM;
      }
      // By default, a node is rendered using the `toDOM` method from the
      // node type spec. But client code can use the `nodeViews` spec to
      // supply a custom node view, which can influence various aspects of
      // the way the node works.
      //
      // (Using subclassing for this was intentionally decided against,
      // since it'd require exposing a whole slew of finicky
      // implementation details to the user code that they probably will
      // never need.)
      static create(parent, node, outerDeco, innerDeco, view, pos) {
        let custom = view.nodeViews[node.type.name], descObj;
        let spec = custom && custom(node, view, () => {
          if (!descObj)
            return pos;
          if (descObj.parent)
            return descObj.parent.posBeforeChild(descObj);
        }, outerDeco, innerDeco);
        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
        if (node.isText) {
          if (!dom)
            dom = document.createTextNode(node.text);
          else if (dom.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else if (!dom) {
          let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
          ({ dom, contentDOM } = spec2);
        }
        if (!contentDOM && !node.isText && dom.nodeName != "BR") {
          if (!dom.hasAttribute("contenteditable"))
            dom.contentEditable = "false";
          if (node.type.spec.draggable)
            dom.draggable = true;
        }
        let nodeDOM = dom;
        dom = applyOuterDeco(dom, outerDeco, node);
        if (spec)
          return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
        else if (node.isText)
          return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
        else
          return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
      }
      parseRule() {
        if (this.node.type.spec.reparseInView)
          return null;
        let rule = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.whitespace == "pre")
          rule.preserveWhitespace = "full";
        if (!this.contentDOM) {
          rule.getContent = () => this.node.content;
        } else if (!this.contentLost) {
          rule.contentElement = this.contentDOM;
        } else {
          for (let i21 = this.children.length - 1; i21 >= 0; i21--) {
            let child = this.children[i21];
            if (this.dom.contains(child.dom.parentNode)) {
              rule.contentElement = child.dom.parentNode;
              break;
            }
          }
          if (!rule.contentElement)
            rule.getContent = () => Fragment.empty;
        }
        return rule;
      }
      matchesNode(node, outerDeco, innerDeco) {
        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
      }
      get size() {
        return this.node.nodeSize;
      }
      get border() {
        return this.node.isLeaf ? 0 : 1;
      }
      // Syncs `this.children` to match `this.node.content` and the local
      // decorations, possibly introducing nesting for marks. Then, in a
      // separate step, syncs the DOM inside `this.contentDOM` to
      // `this.children`.
      updateChildren(view, pos) {
        let inline2 = this.node.inlineContent, off = pos;
        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
        let localComposition = composition && composition.pos > -1 ? composition : null;
        let compositionInChild = composition && composition.pos < 0;
        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
        iterDeco(this.node, this.innerDeco, (widget, i21, insideNode) => {
          if (widget.spec.marks)
            updater.syncToMarks(widget.spec.marks, inline2, view);
          else if (widget.type.side >= 0 && !insideNode)
            updater.syncToMarks(i21 == this.node.childCount ? Mark.none : this.node.child(i21).marks, inline2, view);
          updater.placeWidget(widget, view, off);
        }, (child, outerDeco, innerDeco, i21) => {
          updater.syncToMarks(child.marks, inline2, view);
          let compIndex;
          if (updater.findNodeMatch(child, outerDeco, innerDeco, i21)) ;
          else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
          else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i21, off)) ;
          else {
            updater.addNode(child, outerDeco, innerDeco, view, off);
          }
          off += child.nodeSize;
        });
        updater.syncToMarks([], inline2, view);
        if (this.node.isTextblock)
          updater.addTextblockHacks();
        updater.destroyRest();
        if (updater.changed || this.dirty == CONTENT_DIRTY) {
          if (localComposition)
            this.protectLocalComposition(view, localComposition);
          renderDescs(this.contentDOM, this.children, view);
          if (ios)
            iosHacks(this.dom);
        }
      }
      localCompositionInfo(view, pos) {
        let { from: from2, to: to2 } = view.state.selection;
        if (!(view.state.selection instanceof TextSelection) || from2 < pos || to2 > pos + this.node.content.size)
          return null;
        let textNode = view.input.compositionNode;
        if (!textNode || !this.dom.contains(textNode.parentNode))
          return null;
        if (this.node.inlineContent) {
          let text = textNode.nodeValue;
          let textPos = findTextInFragment(this.node.content, text, from2 - pos, to2 - pos);
          return textPos < 0 ? null : { node: textNode, pos: textPos, text };
        } else {
          return { node: textNode, pos: -1, text: "" };
        }
      }
      protectLocalComposition(view, { node, pos, text }) {
        if (this.getDesc(node))
          return;
        let topNode = node;
        for (; ; topNode = topNode.parentNode) {
          if (topNode.parentNode == this.contentDOM)
            break;
          while (topNode.previousSibling)
            topNode.parentNode.removeChild(topNode.previousSibling);
          while (topNode.nextSibling)
            topNode.parentNode.removeChild(topNode.nextSibling);
          if (topNode.pmViewDesc)
            topNode.pmViewDesc = void 0;
        }
        let desc = new CompositionViewDesc(this, topNode, node, text);
        view.input.compositionNodes.push(desc);
        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
      }
      // If this desc must be updated to match the given node decoration,
      // do so and return true.
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
          return false;
        this.updateInner(node, outerDeco, innerDeco, view);
        return true;
      }
      updateInner(node, outerDeco, innerDeco, view) {
        this.updateOuterDeco(outerDeco);
        this.node = node;
        this.innerDeco = innerDeco;
        if (this.contentDOM)
          this.updateChildren(view, this.posAtStart);
        this.dirty = NOT_DIRTY;
      }
      updateOuterDeco(outerDeco) {
        if (sameOuterDeco(outerDeco, this.outerDeco))
          return;
        let needsWrap = this.nodeDOM.nodeType != 1;
        let oldDOM = this.dom;
        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
        if (this.dom != oldDOM) {
          oldDOM.pmViewDesc = void 0;
          this.dom.pmViewDesc = this;
        }
        this.outerDeco = outerDeco;
      }
      // Mark this node as being the selected node.
      selectNode() {
        if (this.nodeDOM.nodeType == 1) {
          this.nodeDOM.classList.add("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable)
            this.nodeDOM.draggable = true;
        }
      }
      // Remove selected node marking from this node.
      deselectNode() {
        if (this.nodeDOM.nodeType == 1) {
          this.nodeDOM.classList.remove("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable)
            this.nodeDOM.removeAttribute("draggable");
        }
      }
      get domAtom() {
        return this.node.isAtom;
      }
    };
    TextViewDesc = class _TextViewDesc extends NodeViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
      }
      parseRule() {
        let skip = this.nodeDOM.parentNode;
        while (skip && skip != this.dom && !skip.pmIsDeco)
          skip = skip.parentNode;
        return { skip: skip || true };
      }
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
          return false;
        this.updateOuterDeco(outerDeco);
        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
          this.nodeDOM.nodeValue = node.text;
          if (view.trackWrites == this.nodeDOM)
            view.trackWrites = null;
        }
        this.node = node;
        this.dirty = NOT_DIRTY;
        return true;
      }
      inParent() {
        let parentDOM = this.parent.contentDOM;
        for (let n25 = this.nodeDOM; n25; n25 = n25.parentNode)
          if (n25 == parentDOM)
            return true;
        return false;
      }
      domFromPos(pos) {
        return { node: this.nodeDOM, offset: pos };
      }
      localPosFromDOM(dom, offset4, bias) {
        if (dom == this.nodeDOM)
          return this.posAtStart + Math.min(offset4, this.node.text.length);
        return super.localPosFromDOM(dom, offset4, bias);
      }
      ignoreMutation(mutation) {
        return mutation.type != "characterData" && mutation.type != "selection";
      }
      slice(from2, to2, view) {
        let node = this.node.cut(from2, to2), dom = document.createTextNode(node.text);
        return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
      }
      markDirty(from2, to2) {
        super.markDirty(from2, to2);
        if (this.dom != this.nodeDOM && (from2 == 0 || to2 == this.nodeDOM.nodeValue.length))
          this.dirty = NODE_DIRTY;
      }
      get domAtom() {
        return false;
      }
      isText(text) {
        return this.node.text == text;
      }
    };
    TrailingHackViewDesc = class extends ViewDesc {
      parseRule() {
        return { ignore: true };
      }
      matchesHack(nodeName) {
        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
      }
      get domAtom() {
        return true;
      }
      get ignoreForCoords() {
        return this.dom.nodeName == "IMG";
      }
    };
    CustomNodeViewDesc = class extends NodeViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
        this.spec = spec;
      }
      // A custom `update` method gets to decide whether the update goes
      // through. If it does, and there's a `contentDOM` node, our logic
      // updates the children.
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY)
          return false;
        if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
          let result = this.spec.update(node, outerDeco, innerDeco);
          if (result)
            this.updateInner(node, outerDeco, innerDeco, view);
          return result;
        } else if (!this.contentDOM && !node.isLeaf) {
          return false;
        } else {
          return super.update(node, outerDeco, innerDeco, view);
        }
      }
      selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
      }
      deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
      }
      setSelection(anchor, head, view, force) {
        this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
      }
      destroy() {
        if (this.spec.destroy)
          this.spec.destroy();
        super.destroy();
      }
      stopEvent(event) {
        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
      }
      ignoreMutation(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
      }
    };
    OuterDecoLevel = function(nodeName) {
      if (nodeName)
        this.nodeName = nodeName;
    };
    OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
    noDeco = [new OuterDecoLevel()];
    ViewTreeUpdater = class {
      constructor(top, lock, view) {
        this.lock = lock;
        this.view = view;
        this.index = 0;
        this.stack = [];
        this.changed = false;
        this.top = top;
        this.preMatch = preMatch(top.node.content, top);
      }
      // Destroy and remove the children between the given indices in
      // `this.top`.
      destroyBetween(start, end) {
        if (start == end)
          return;
        for (let i21 = start; i21 < end; i21++)
          this.top.children[i21].destroy();
        this.top.children.splice(start, end - start);
        this.changed = true;
      }
      // Destroy all remaining children in `this.top`.
      destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
      }
      // Sync the current stack of mark descs with the given array of
      // marks, reusing existing mark descs when possible.
      syncToMarks(marks2, inline2, view) {
        let keep = 0, depth = this.stack.length >> 1;
        let maxKeep = Math.min(depth, marks2.length);
        while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks2[keep]) && marks2[keep].type.spec.spanning !== false)
          keep++;
        while (keep < depth) {
          this.destroyRest();
          this.top.dirty = NOT_DIRTY;
          this.index = this.stack.pop();
          this.top = this.stack.pop();
          depth--;
        }
        while (depth < marks2.length) {
          this.stack.push(this.top, this.index + 1);
          let found2 = -1;
          for (let i21 = this.index; i21 < Math.min(this.index + 3, this.top.children.length); i21++) {
            let next = this.top.children[i21];
            if (next.matchesMark(marks2[depth]) && !this.isLocked(next.dom)) {
              found2 = i21;
              break;
            }
          }
          if (found2 > -1) {
            if (found2 > this.index) {
              this.changed = true;
              this.destroyBetween(this.index, found2);
            }
            this.top = this.top.children[this.index];
          } else {
            let markDesc = MarkViewDesc.create(this.top, marks2[depth], inline2, view);
            this.top.children.splice(this.index, 0, markDesc);
            this.top = markDesc;
            this.changed = true;
          }
          this.index = 0;
          depth++;
        }
      }
      // Try to find a node desc matching the given data. Skip over it and
      // return true when successful.
      findNodeMatch(node, outerDeco, innerDeco, index) {
        let found2 = -1, targetDesc;
        if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
          found2 = this.top.children.indexOf(targetDesc, this.index);
        } else {
          for (let i21 = this.index, e36 = Math.min(this.top.children.length, i21 + 5); i21 < e36; i21++) {
            let child = this.top.children[i21];
            if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
              found2 = i21;
              break;
            }
          }
        }
        if (found2 < 0)
          return false;
        this.destroyBetween(this.index, found2);
        this.index++;
        return true;
      }
      updateNodeAt(node, outerDeco, innerDeco, index, view) {
        let child = this.top.children[index];
        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
          child.dirty = CONTENT_DIRTY;
        if (!child.update(node, outerDeco, innerDeco, view))
          return false;
        this.destroyBetween(this.index, index);
        this.index++;
        return true;
      }
      findIndexWithChild(domNode) {
        for (; ; ) {
          let parent = domNode.parentNode;
          if (!parent)
            return -1;
          if (parent == this.top.contentDOM) {
            let desc = domNode.pmViewDesc;
            if (desc)
              for (let i21 = this.index; i21 < this.top.children.length; i21++) {
                if (this.top.children[i21] == desc)
                  return i21;
              }
            return -1;
          }
          domNode = parent;
        }
      }
      // Try to update the next node, if any, to the given data. Checks
      // pre-matches to avoid overwriting nodes that could still be used.
      updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
        for (let i21 = this.index; i21 < this.top.children.length; i21++) {
          let next = this.top.children[i21];
          if (next instanceof NodeViewDesc) {
            let preMatch2 = this.preMatch.matched.get(next);
            if (preMatch2 != null && preMatch2 != index)
              return false;
            let nextDOM = next.dom, updated;
            let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
            if (!locked && next.update(node, outerDeco, innerDeco, view)) {
              this.destroyBetween(this.index, i21);
              if (next.dom != nextDOM)
                this.changed = true;
              this.index++;
              return true;
            } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
              this.destroyBetween(this.index, i21);
              this.top.children[this.index] = updated;
              if (updated.contentDOM) {
                updated.dirty = CONTENT_DIRTY;
                updated.updateChildren(view, pos + 1);
                updated.dirty = NOT_DIRTY;
              }
              this.changed = true;
              this.index++;
              return true;
            }
            break;
          }
        }
        return false;
      }
      // When a node with content is replaced by a different node with
      // identical content, move over its children.
      recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
        if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
          return null;
        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
        if (wrapper.contentDOM) {
          wrapper.children = next.children;
          next.children = [];
          for (let ch of wrapper.children)
            ch.parent = wrapper;
        }
        next.destroy();
        return wrapper;
      }
      // Insert the node as a newly created node desc.
      addNode(node, outerDeco, innerDeco, view, pos) {
        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
        if (desc.contentDOM)
          desc.updateChildren(view, pos + 1);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
      placeWidget(widget, view, pos) {
        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
          this.index++;
        } else {
          let desc = new WidgetViewDesc(this.top, widget, view, pos);
          this.top.children.splice(this.index++, 0, desc);
          this.changed = true;
        }
      }
      // Make sure a textblock looks and behaves correctly in
      // contentEditable.
      addTextblockHacks() {
        let lastChild = this.top.children[this.index - 1], parent = this.top;
        while (lastChild instanceof MarkViewDesc) {
          parent = lastChild;
          lastChild = parent.children[parent.children.length - 1];
        }
        if (!lastChild || // Empty textblock
        !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
          if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
            this.addHackNode("IMG", parent);
          this.addHackNode("BR", this.top);
        }
      }
      addHackNode(nodeName, parent) {
        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
          this.index++;
        } else {
          let dom = document.createElement(nodeName);
          if (nodeName == "IMG") {
            dom.className = "ProseMirror-separator";
            dom.alt = "";
          }
          if (nodeName == "BR")
            dom.className = "ProseMirror-trailingBreak";
          let hack = new TrailingHackViewDesc(this.top, [], dom, null);
          if (parent != this.top)
            parent.children.push(hack);
          else
            parent.children.splice(this.index++, 0, hack);
          this.changed = true;
        }
      }
      isLocked(node) {
        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
      }
    };
    brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
    inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    _detachedDoc = null;
    _policy = null;
    handlers = {};
    editHandlers = {};
    passiveHandlers = { touchstart: true, touchmove: true };
    InputState = class {
      constructor() {
        this.shiftKey = false;
        this.mouseDown = null;
        this.lastKeyCode = null;
        this.lastKeyCodeTime = 0;
        this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastIOSEnter = 0;
        this.lastIOSEnterFallbackTimeout = -1;
        this.lastFocus = 0;
        this.lastTouch = 0;
        this.lastChromeDelete = 0;
        this.composing = false;
        this.compositionNode = null;
        this.composingTimeout = -1;
        this.compositionNodes = [];
        this.compositionEndedAt = -2e8;
        this.compositionID = 1;
        this.compositionPendingChanges = 0;
        this.domChangeCount = 0;
        this.eventHandlers = /* @__PURE__ */ Object.create(null);
        this.hideSelectionGuard = null;
      }
    };
    editHandlers.keydown = (view, _event) => {
      let event = _event;
      view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event))
        return;
      view.input.lastKeyCode = event.keyCode;
      view.input.lastKeyCodeTime = Date.now();
      if (android && chrome && event.keyCode == 13)
        return;
      if (event.keyCode != 229)
        view.domObserver.forceFlush();
      if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        let now = Date.now();
        view.input.lastIOSEnter = now;
        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          if (view.input.lastIOSEnter == now) {
            view.someProp("handleKeyDown", (f11) => f11(view, keyEvent(13, "Enter")));
            view.input.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", (f11) => f11(view, event)) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = (view, event) => {
      if (event.keyCode == 16)
        view.input.shiftKey = false;
    };
    editHandlers.keypress = (view, _event) => {
      let event = _event;
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
        return;
      if (view.someProp("handleKeyPress", (f11) => f11(view, event))) {
        event.preventDefault();
        return;
      }
      let sel = view.state.selection;
      if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
        let text = String.fromCharCode(event.charCode);
        let deflt = () => view.state.tr.insertText(text).scrollIntoView();
        if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f11) => f11(view, sel.$from.pos, sel.$to.pos, text, deflt)))
          view.dispatch(deflt());
        event.preventDefault();
      }
    };
    selectNodeModifier = mac ? "metaKey" : "ctrlKey";
    handlers.mousedown = (view, _event) => {
      let event = _event;
      view.input.shiftKey = event.shiftKey;
      let flushed = forceDOMFlush(view);
      let now = Date.now(), type = "singleClick";
      if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
        if (view.input.lastClick.type == "singleClick")
          type = "doubleClick";
        else if (view.input.lastClick.type == "doubleClick")
          type = "tripleClick";
      }
      view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
      let pos = view.posAtCoords(eventCoords(event));
      if (!pos)
        return;
      if (type == "singleClick") {
        if (view.input.mouseDown)
          view.input.mouseDown.done();
        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
      } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    MouseDown = class {
      constructor(view, pos, event, flushed) {
        this.view = view;
        this.pos = pos;
        this.event = event;
        this.flushed = flushed;
        this.delayedSelectionSync = false;
        this.mightDrag = null;
        this.startDoc = view.state.doc;
        this.selectNode = !!event[selectNodeModifier];
        this.allowDefault = event.shiftKey;
        let targetNode, targetPos;
        if (pos.inside > -1) {
          targetNode = view.state.doc.nodeAt(pos.inside);
          targetPos = pos.inside;
        } else {
          let $pos = view.state.doc.resolve(pos.pos);
          targetNode = $pos.parent;
          targetPos = $pos.depth ? $pos.before() : 0;
        }
        const target = flushed ? null : event.target;
        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
        this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;
        let { selection } = view.state;
        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
          this.mightDrag = {
            node: targetNode,
            pos: targetPos,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
          };
        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.draggable = true;
          if (this.mightDrag.setUneditable)
            setTimeout(() => {
              if (this.view.input.mouseDown == this)
                this.target.setAttribute("contentEditable", "false");
            }, 20);
          this.view.domObserver.start();
        }
        view.root.addEventListener("mouseup", this.up = this.up.bind(this));
        view.root.addEventListener("mousemove", this.move = this.move.bind(this));
        setSelectionOrigin(view, "pointer");
      }
      done() {
        this.view.root.removeEventListener("mouseup", this.up);
        this.view.root.removeEventListener("mousemove", this.move);
        if (this.mightDrag && this.target) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.removeAttribute("draggable");
          if (this.mightDrag.setUneditable)
            this.target.removeAttribute("contentEditable");
          this.view.domObserver.start();
        }
        if (this.delayedSelectionSync)
          setTimeout(() => selectionToDOM(this.view));
        this.view.input.mouseDown = null;
      }
      up(event) {
        this.done();
        if (!this.view.dom.contains(event.target))
          return;
        let pos = this.pos;
        if (this.view.state.doc != this.startDoc)
          pos = this.view.posAtCoords(eventCoords(event));
        this.updateAllowDefault(event);
        if (this.allowDefault || !pos) {
          setSelectionOrigin(this.view, "pointer");
        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
          event.preventDefault();
        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
          updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
          event.preventDefault();
        } else {
          setSelectionOrigin(this.view, "pointer");
        }
      }
      move(event) {
        this.updateAllowDefault(event);
        setSelectionOrigin(this.view, "pointer");
        if (event.buttons == 0)
          this.done();
      }
      updateAllowDefault(event) {
        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
          this.allowDefault = true;
      }
    };
    handlers.touchstart = (view) => {
      view.input.lastTouch = Date.now();
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.touchmove = (view) => {
      view.input.lastTouch = Date.now();
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = (view) => forceDOMFlush(view);
    timeoutComposition = android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
      if (!view.composing) {
        view.domObserver.flush();
        let { state } = view, $pos = state.selection.$to;
        if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m18) => m18.type.spec.inclusive === false))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view, !state.selection.empty);
          if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            let sel = view.domSelectionRange();
            for (let node = sel.focusNode, offset4 = sel.focusOffset; node && node.nodeType == 1 && offset4 != 0; ) {
              let before = offset4 < 0 ? node.lastChild : node.childNodes[offset4 - 1];
              if (!before)
                break;
              if (before.nodeType == 3) {
                let sel2 = view.domSelection();
                if (sel2)
                  sel2.collapse(before, before.nodeValue.length);
                break;
              } else {
                node = before;
                offset4 = -1;
              }
            }
          }
        }
        view.input.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = (view, event) => {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = event.timeStamp;
        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
        view.input.compositionNode = null;
        if (view.input.compositionPendingChanges)
          Promise.resolve().then(() => view.domObserver.flush());
        view.input.compositionID++;
        scheduleComposeEnd(view, 20);
      }
    };
    brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
    handlers.copy = editHandlers.cut = (view, _event) => {
      let event = _event;
      let sel = view.state.selection, cut = event.type == "cut";
      if (sel.empty)
        return;
      let data = brokenClipboardAPI ? null : event.clipboardData;
      let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
      if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
      } else {
        captureCopy(view, dom);
      }
      if (cut)
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    editHandlers.paste = (view, _event) => {
      let event = _event;
      if (view.composing && !android)
        return;
      let data = brokenClipboardAPI ? null : event.clipboardData;
      let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
      if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
        event.preventDefault();
      else
        capturePaste(view, event);
    };
    Dragging = class {
      constructor(slice2, move, node) {
        this.slice = slice2;
        this.move = move;
        this.node = node;
      }
    };
    dragCopyModifier = mac ? "altKey" : "ctrlKey";
    handlers.dragstart = (view, _event) => {
      let event = _event;
      let mouseDown = view.input.mouseDown;
      if (mouseDown)
        mouseDown.done();
      if (!event.dataTransfer)
        return;
      let sel = view.state.selection;
      let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
      let node;
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
      else if (mouseDown && mouseDown.mightDrag) {
        node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
      } else if (event.target && event.target.nodeType == 1) {
        let desc = view.docView.nearestDesc(event.target, true);
        if (desc && desc.node.type.spec.draggable && desc != view.docView)
          node = NodeSelection.create(view.state.doc, desc.posBefore);
      }
      let draggedSlice = (node || view.state.selection).content();
      let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
      if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
        event.dataTransfer.clearData();
      event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      event.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI)
        event.dataTransfer.setData("text/plain", text);
      view.dragging = new Dragging(slice2, dragMoves(view, event), node);
    };
    handlers.dragend = (view) => {
      let dragging = view.dragging;
      window.setTimeout(() => {
        if (view.dragging == dragging)
          view.dragging = null;
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = (_2, e36) => e36.preventDefault();
    editHandlers.drop = (view, _event) => {
      let event = _event;
      let dragging = view.dragging;
      view.dragging = null;
      if (!event.dataTransfer)
        return;
      let eventPos = view.posAtCoords(eventCoords(event));
      if (!eventPos)
        return;
      let $mouse = view.state.doc.resolve(eventPos.pos);
      let slice2 = dragging && dragging.slice;
      if (slice2) {
        view.someProp("transformPasted", (f11) => {
          slice2 = f11(slice2, view, false);
        });
      } else {
        slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
      }
      let move = !!(dragging && dragMoves(view, event));
      if (view.someProp("handleDrop", (f11) => f11(view, event, slice2 || Slice.empty, move))) {
        event.preventDefault();
        return;
      }
      if (!slice2)
        return;
      event.preventDefault();
      let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
      if (insertPos == null)
        insertPos = $mouse.pos;
      let tr2 = view.state.tr;
      if (move) {
        let { node } = dragging;
        if (node)
          node.replace(tr2);
        else
          tr2.deleteSelection();
      }
      let pos = tr2.mapping.map(insertPos);
      let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
      let beforeInsert = tr2.doc;
      if (isNode2)
        tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
      else
        tr2.replaceRange(pos, pos, slice2);
      if (tr2.doc.eq(beforeInsert))
        return;
      let $pos = tr2.doc.resolve(pos);
      if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
        tr2.setSelection(new NodeSelection($pos));
      } else {
        let end = tr2.mapping.map(insertPos);
        tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
        tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr2.setMeta("uiEvent", "drop"));
    };
    handlers.focus = (view) => {
      view.input.lastFocus = Date.now();
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(() => {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
            selectionToDOM(view);
        }, 20);
      }
    };
    handlers.blur = (view, _event) => {
      let event = _event;
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        if (event.relatedTarget && view.dom.contains(event.relatedTarget))
          view.domObserver.currentSelection.clear();
        view.focused = false;
      }
    };
    handlers.beforeinput = (view, _event) => {
      let event = _event;
      if (chrome && android && event.inputType == "deleteContentBackward") {
        view.domObserver.flushSoon();
        let { domChangeCount } = view.input;
        setTimeout(() => {
          if (view.input.domChangeCount != domChangeCount)
            return;
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", (f11) => f11(view, keyEvent(8, "Backspace"))))
            return;
          let { $cursor } = view.state.selection;
          if ($cursor && $cursor.pos > 0)
            view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
        }, 50);
      }
    };
    for (let prop in editHandlers)
      handlers[prop] = editHandlers[prop];
    WidgetType = class _WidgetType {
      constructor(toDOM, spec) {
        this.toDOM = toDOM;
        this.spec = spec || noSpec;
        this.side = this.spec.side || 0;
      }
      map(mapping, span, offset4, oldOffset) {
        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
        return deleted ? null : new Decoration(pos - offset4, pos - offset4, this);
      }
      valid() {
        return true;
      }
      eq(other) {
        return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
      }
      destroy(node) {
        if (this.spec.destroy)
          this.spec.destroy(node);
      }
    };
    InlineType = class _InlineType {
      constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      map(mapping, span, offset4, oldOffset) {
        let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset4;
        let to2 = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset4;
        return from2 >= to2 ? null : new Decoration(from2, to2, this);
      }
      valid(_2, span) {
        return span.from < span.to;
      }
      eq(other) {
        return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      }
      static is(span) {
        return span.type instanceof _InlineType;
      }
      destroy() {
      }
    };
    NodeType2 = class _NodeType {
      constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      map(mapping, span, offset4, oldOffset) {
        let from2 = mapping.mapResult(span.from + oldOffset, 1);
        if (from2.deleted)
          return null;
        let to2 = mapping.mapResult(span.to + oldOffset, -1);
        if (to2.deleted || to2.pos <= from2.pos)
          return null;
        return new Decoration(from2.pos - offset4, to2.pos - offset4, this);
      }
      valid(node, span) {
        let { index, offset: offset4 } = node.content.findIndex(span.from), child;
        return offset4 == span.from && !(child = node.child(index)).isText && offset4 + child.nodeSize == span.to;
      }
      eq(other) {
        return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      }
      destroy() {
      }
    };
    Decoration = class _Decoration {
      /**
      @internal
      */
      constructor(from2, to2, type) {
        this.from = from2;
        this.to = to2;
        this.type = type;
      }
      /**
      @internal
      */
      copy(from2, to2) {
        return new _Decoration(from2, to2, this.type);
      }
      /**
      @internal
      */
      eq(other, offset4 = 0) {
        return this.type.eq(other.type) && this.from + offset4 == other.from && this.to + offset4 == other.to;
      }
      /**
      @internal
      */
      map(mapping, offset4, oldOffset) {
        return this.type.map(mapping, this, offset4, oldOffset);
      }
      /**
      Creates a widget decoration, which is a DOM node that's shown in
      the document at the given position. It is recommended that you
      delay rendering the widget by passing a function that will be
      called when the widget is actually drawn in a view, but you can
      also directly pass a DOM node. `getPos` can be used to find the
      widget's current document position.
      */
      static widget(pos, toDOM, spec) {
        return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
      }
      /**
      Creates an inline decoration, which adds the given attributes to
      each inline node between `from` and `to`.
      */
      static inline(from2, to2, attrs, spec) {
        return new _Decoration(from2, to2, new InlineType(attrs, spec));
      }
      /**
      Creates a node decoration. `from` and `to` should point precisely
      before and after a node in the document. That node, and only that
      node, will receive the given attributes.
      */
      static node(from2, to2, attrs, spec) {
        return new _Decoration(from2, to2, new NodeType2(attrs, spec));
      }
      /**
      The spec provided when creating this decoration. Can be useful
      if you've stored extra information in that object.
      */
      get spec() {
        return this.type.spec;
      }
      /**
      @internal
      */
      get inline() {
        return this.type instanceof InlineType;
      }
      /**
      @internal
      */
      get widget() {
        return this.type instanceof WidgetType;
      }
    };
    none = [];
    noSpec = {};
    DecorationSet = class _DecorationSet {
      /**
      @internal
      */
      constructor(local, children) {
        this.local = local.length ? local : none;
        this.children = children.length ? children : none;
      }
      /**
      Create a set of decorations, using the structure of the given
      document. This will consume (modify) the `decorations` array, so
      you must make a copy if you want need to preserve that.
      */
      static create(doc3, decorations) {
        return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
      }
      /**
      Find all decorations in this set which touch the given range
      (including decorations that start or end directly at the
      boundaries) and match the given predicate on their spec. When
      `start` and `end` are omitted, all decorations in the set are
      considered. When `predicate` isn't given, all decorations are
      assumed to match.
      */
      find(start, end, predicate) {
        let result = [];
        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
        return result;
      }
      findInner(start, end, result, offset4, predicate) {
        for (let i21 = 0; i21 < this.local.length; i21++) {
          let span = this.local[i21];
          if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
            result.push(span.copy(span.from + offset4, span.to + offset4));
        }
        for (let i21 = 0; i21 < this.children.length; i21 += 3) {
          if (this.children[i21] < end && this.children[i21 + 1] > start) {
            let childOff = this.children[i21] + 1;
            this.children[i21 + 2].findInner(start - childOff, end - childOff, result, offset4 + childOff, predicate);
          }
        }
      }
      /**
      Map the set of decorations in response to a change in the
      document.
      */
      map(mapping, doc3, options) {
        if (this == empty || mapping.maps.length == 0)
          return this;
        return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
      }
      /**
      @internal
      */
      mapInner(mapping, node, offset4, oldOffset, options) {
        let newLocal;
        for (let i21 = 0; i21 < this.local.length; i21++) {
          let mapped = this.local[i21].map(mapping, offset4, oldOffset);
          if (mapped && mapped.type.valid(node, mapped))
            (newLocal || (newLocal = [])).push(mapped);
          else if (options.onRemove)
            options.onRemove(this.local[i21].spec);
        }
        if (this.children.length)
          return mapChildren(this.children, newLocal || [], mapping, node, offset4, oldOffset, options);
        else
          return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
      }
      /**
      Add the given array of decorations to the ones in the set,
      producing a new set. Consumes the `decorations` array. Needs
      access to the current document to create the appropriate tree
      structure.
      */
      add(doc3, decorations) {
        if (!decorations.length)
          return this;
        if (this == empty)
          return _DecorationSet.create(doc3, decorations);
        return this.addInner(doc3, decorations, 0);
      }
      addInner(doc3, decorations, offset4) {
        let children, childIndex = 0;
        doc3.forEach((childNode, childOffset) => {
          let baseOffset = childOffset + offset4, found2;
          if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
            return;
          if (!children)
            children = this.children.slice();
          while (childIndex < children.length && children[childIndex] < childOffset)
            childIndex += 3;
          if (children[childIndex] == childOffset)
            children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
          else
            children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
          childIndex += 3;
        });
        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset4);
        for (let i21 = 0; i21 < local.length; i21++)
          if (!local[i21].type.valid(doc3, local[i21]))
            local.splice(i21--, 1);
        return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
      }
      /**
      Create a new set that contains the decorations in this set, minus
      the ones in the given array.
      */
      remove(decorations) {
        if (decorations.length == 0 || this == empty)
          return this;
        return this.removeInner(decorations, 0);
      }
      removeInner(decorations, offset4) {
        let children = this.children, local = this.local;
        for (let i21 = 0; i21 < children.length; i21 += 3) {
          let found2;
          let from2 = children[i21] + offset4, to2 = children[i21 + 1] + offset4;
          for (let j3 = 0, span; j3 < decorations.length; j3++)
            if (span = decorations[j3]) {
              if (span.from > from2 && span.to < to2) {
                decorations[j3] = null;
                (found2 || (found2 = [])).push(span);
              }
            }
          if (!found2)
            continue;
          if (children == this.children)
            children = this.children.slice();
          let removed = children[i21 + 2].removeInner(found2, from2 + 1);
          if (removed != empty) {
            children[i21 + 2] = removed;
          } else {
            children.splice(i21, 3);
            i21 -= 3;
          }
        }
        if (local.length) {
          for (let i21 = 0, span; i21 < decorations.length; i21++)
            if (span = decorations[i21]) {
              for (let j3 = 0; j3 < local.length; j3++)
                if (local[j3].eq(span, offset4)) {
                  if (local == this.local)
                    local = this.local.slice();
                  local.splice(j3--, 1);
                }
            }
        }
        if (children == this.children && local == this.local)
          return this;
        return local.length || children.length ? new _DecorationSet(local, children) : empty;
      }
      forChild(offset4, node) {
        if (this == empty)
          return this;
        if (node.isLeaf)
          return _DecorationSet.empty;
        let child, local;
        for (let i21 = 0; i21 < this.children.length; i21 += 3)
          if (this.children[i21] >= offset4) {
            if (this.children[i21] == offset4)
              child = this.children[i21 + 2];
            break;
          }
        let start = offset4 + 1, end = start + node.content.size;
        for (let i21 = 0; i21 < this.local.length; i21++) {
          let dec = this.local[i21];
          if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
            let from2 = Math.max(start, dec.from) - start, to2 = Math.min(end, dec.to) - start;
            if (from2 < to2)
              (local || (local = [])).push(dec.copy(from2, to2));
          }
        }
        if (local) {
          let localSet = new _DecorationSet(local.sort(byPos), none);
          return child ? new DecorationGroup([localSet, child]) : localSet;
        }
        return child || empty;
      }
      /**
      @internal
      */
      eq(other) {
        if (this == other)
          return true;
        if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
          return false;
        for (let i21 = 0; i21 < this.local.length; i21++)
          if (!this.local[i21].eq(other.local[i21]))
            return false;
        for (let i21 = 0; i21 < this.children.length; i21 += 3)
          if (this.children[i21] != other.children[i21] || this.children[i21 + 1] != other.children[i21 + 1] || !this.children[i21 + 2].eq(other.children[i21 + 2]))
            return false;
        return true;
      }
      /**
      @internal
      */
      locals(node) {
        return removeOverlap(this.localsInner(node));
      }
      /**
      @internal
      */
      localsInner(node) {
        if (this == empty)
          return none;
        if (node.inlineContent || !this.local.some(InlineType.is))
          return this.local;
        let result = [];
        for (let i21 = 0; i21 < this.local.length; i21++) {
          if (!(this.local[i21].type instanceof InlineType))
            result.push(this.local[i21]);
        }
        return result;
      }
      forEachSet(f11) {
        f11(this);
      }
    };
    DecorationSet.empty = new DecorationSet([], []);
    DecorationSet.removeOverlap = removeOverlap;
    empty = DecorationSet.empty;
    DecorationGroup = class _DecorationGroup {
      constructor(members) {
        this.members = members;
      }
      map(mapping, doc3) {
        const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
        return _DecorationGroup.from(mappedDecos);
      }
      forChild(offset4, child) {
        if (child.isLeaf)
          return DecorationSet.empty;
        let found2 = [];
        for (let i21 = 0; i21 < this.members.length; i21++) {
          let result = this.members[i21].forChild(offset4, child);
          if (result == empty)
            continue;
          if (result instanceof _DecorationGroup)
            found2 = found2.concat(result.members);
          else
            found2.push(result);
        }
        return _DecorationGroup.from(found2);
      }
      eq(other) {
        if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
          return false;
        for (let i21 = 0; i21 < this.members.length; i21++)
          if (!this.members[i21].eq(other.members[i21]))
            return false;
        return true;
      }
      locals(node) {
        let result, sorted = true;
        for (let i21 = 0; i21 < this.members.length; i21++) {
          let locals = this.members[i21].localsInner(node);
          if (!locals.length)
            continue;
          if (!result) {
            result = locals;
          } else {
            if (sorted) {
              result = result.slice();
              sorted = false;
            }
            for (let j3 = 0; j3 < locals.length; j3++)
              result.push(locals[j3]);
          }
        }
        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
      }
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      static from(members) {
        switch (members.length) {
          case 0:
            return empty;
          case 1:
            return members[0];
          default:
            return new _DecorationGroup(members.every((m18) => m18 instanceof DecorationSet) ? members : members.reduce((r25, m18) => r25.concat(m18 instanceof DecorationSet ? m18 : m18.members), []));
        }
      }
      forEachSet(f11) {
        for (let i21 = 0; i21 < this.members.length; i21++)
          this.members[i21].forEachSet(f11);
      }
    };
    observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    useCharData = ie && ie_version <= 11;
    SelectionState = class {
      constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
      }
      set(sel) {
        this.anchorNode = sel.anchorNode;
        this.anchorOffset = sel.anchorOffset;
        this.focusNode = sel.focusNode;
        this.focusOffset = sel.focusOffset;
      }
      clear() {
        this.anchorNode = this.focusNode = null;
      }
      eq(sel) {
        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
      }
    };
    DOMObserver = class {
      constructor(view, handleDOMChange) {
        this.view = view;
        this.handleDOMChange = handleDOMChange;
        this.queue = [];
        this.flushingSoon = -1;
        this.observer = null;
        this.currentSelection = new SelectionState();
        this.onCharData = null;
        this.suppressingSelectionUpdates = false;
        this.lastChangedTextNode = null;
        this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
          for (let i21 = 0; i21 < mutations.length; i21++)
            this.queue.push(mutations[i21]);
          if (ie && ie_version <= 11 && mutations.some((m18) => m18.type == "childList" && m18.removedNodes.length || m18.type == "characterData" && m18.oldValue.length > m18.target.nodeValue.length))
            this.flushSoon();
          else
            this.flush();
        });
        if (useCharData) {
          this.onCharData = (e36) => {
            this.queue.push({ target: e36.target, type: "characterData", oldValue: e36.prevValue });
            this.flushSoon();
          };
        }
        this.onSelectionChange = this.onSelectionChange.bind(this);
      }
      flushSoon() {
        if (this.flushingSoon < 0)
          this.flushingSoon = window.setTimeout(() => {
            this.flushingSoon = -1;
            this.flush();
          }, 20);
      }
      forceFlush() {
        if (this.flushingSoon > -1) {
          window.clearTimeout(this.flushingSoon);
          this.flushingSoon = -1;
          this.flush();
        }
      }
      start() {
        if (this.observer) {
          this.observer.takeRecords();
          this.observer.observe(this.view.dom, observeOptions);
        }
        if (this.onCharData)
          this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.connectSelection();
      }
      stop() {
        if (this.observer) {
          let take = this.observer.takeRecords();
          if (take.length) {
            for (let i21 = 0; i21 < take.length; i21++)
              this.queue.push(take[i21]);
            window.setTimeout(() => this.flush(), 20);
          }
          this.observer.disconnect();
        }
        if (this.onCharData)
          this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
        this.disconnectSelection();
      }
      connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
      disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
      suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = true;
        setTimeout(() => this.suppressingSelectionUpdates = false, 50);
      }
      onSelectionChange() {
        if (!hasFocusAndSelection(this.view))
          return;
        if (this.suppressingSelectionUpdates)
          return selectionToDOM(this.view);
        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
          let sel = this.view.domSelectionRange();
          if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            return this.flushSoon();
        }
        this.flush();
      }
      setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
      ignoreSelectionChange(sel) {
        if (!sel.focusNode)
          return true;
        let ancestors = /* @__PURE__ */ new Set(), container;
        for (let scan = sel.focusNode; scan; scan = parentNode(scan))
          ancestors.add(scan);
        for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
          if (ancestors.has(scan)) {
            container = scan;
            break;
          }
        let desc = container && this.view.docView.nearestDesc(container);
        if (desc && desc.ignoreMutation({
          type: "selection",
          target: container.nodeType == 3 ? container.parentNode : container
        })) {
          this.setCurSelection();
          return true;
        }
      }
      pendingRecords() {
        if (this.observer)
          for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
        return this.queue;
      }
      flush() {
        let { view } = this;
        if (!view.docView || this.flushingSoon > -1)
          return;
        let mutations = this.pendingRecords();
        if (mutations.length)
          this.queue = [];
        let sel = view.domSelectionRange();
        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
        let from2 = -1, to2 = -1, typeOver = false, added = [];
        if (view.editable) {
          for (let i21 = 0; i21 < mutations.length; i21++) {
            let result = this.registerMutation(mutations[i21], added);
            if (result) {
              from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
              to2 = to2 < 0 ? result.to : Math.max(result.to, to2);
              if (result.typeOver)
                typeOver = true;
            }
          }
        }
        if (gecko && added.length) {
          let brs = added.filter((n25) => n25.nodeName == "BR");
          if (brs.length == 2) {
            let [a23, b12] = brs;
            if (a23.parentNode && a23.parentNode.parentNode == b12.parentNode)
              b12.remove();
            else
              a23.remove();
          } else {
            let { focusNode } = this.currentSelection;
            for (let br2 of brs) {
              let parent = br2.parentNode;
              if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
                br2.remove();
            }
          }
        }
        let readSel = null;
        if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
          view.input.lastFocus = 0;
          selectionToDOM(view);
          this.currentSelection.set(sel);
          view.scrollToSelection();
        } else if (from2 > -1 || newSel) {
          if (from2 > -1) {
            view.docView.markDirty(from2, to2);
            checkCSS(view);
          }
          this.handleDOMChange(from2, to2, typeOver, added);
          if (view.docView && view.docView.dirty)
            view.updateState(view.state);
          else if (!this.currentSelection.eq(sel))
            selectionToDOM(view);
          this.currentSelection.set(sel);
        }
      }
      registerMutation(mut, added) {
        if (added.indexOf(mut.target) > -1)
          return null;
        let desc = this.view.docView.nearestDesc(mut.target);
        if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
        mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
          return null;
        if (!desc || desc.ignoreMutation(mut))
          return null;
        if (mut.type == "childList") {
          for (let i21 = 0; i21 < mut.addedNodes.length; i21++) {
            let node = mut.addedNodes[i21];
            added.push(node);
            if (node.nodeType == 3)
              this.lastChangedTextNode = node;
          }
          if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
            return { from: desc.posBefore, to: desc.posAfter };
          let prev = mut.previousSibling, next = mut.nextSibling;
          if (ie && ie_version <= 11 && mut.addedNodes.length) {
            for (let i21 = 0; i21 < mut.addedNodes.length; i21++) {
              let { previousSibling, nextSibling } = mut.addedNodes[i21];
              if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
                prev = previousSibling;
              if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
                next = nextSibling;
            }
          }
          let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
          let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
          let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
          let to2 = desc.localPosFromDOM(mut.target, toOffset, 1);
          return { from: from2, to: to2 };
        } else if (mut.type == "attributes") {
          return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
        } else {
          this.lastChangedTextNode = mut.target;
          return {
            from: desc.posAtStart,
            to: desc.posAtEnd,
            // An event was generated for a text change that didn't change
            // any text. Mark the dom change to fall back to assuming the
            // selection was typed over with an identical value if it can't
            // find another change.
            typeOver: mut.target.nodeValue == mut.oldValue
          };
        }
      }
    };
    cssChecked = /* @__PURE__ */ new WeakMap();
    cssCheckWarned = false;
    isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
    __parseFromClipboard = parseFromClipboard;
    __endComposition = endComposition;
    EditorView = class {
      /**
      Create a view. `place` may be a DOM node that the editor should
      be appended to, a function that will place it into the document,
      or an object whose `mount` property holds the node to use as the
      document container. If it is `null`, the editor will not be
      added to the document.
      */
      constructor(place, props) {
        this._root = null;
        this.focused = false;
        this.trackWrites = null;
        this.mounted = false;
        this.markCursor = null;
        this.cursorWrapper = null;
        this.lastSelectedViewDesc = void 0;
        this.input = new InputState();
        this.prevDirectPlugins = [];
        this.pluginViews = [];
        this.requiresGeckoHackNode = false;
        this.dragging = null;
        this._props = props;
        this.state = props.state;
        this.directPlugins = props.plugins || [];
        this.directPlugins.forEach(checkStateComponent);
        this.dispatch = this.dispatch.bind(this);
        this.dom = place && place.mount || document.createElement("div");
        if (place) {
          if (place.appendChild)
            place.appendChild(this.dom);
          else if (typeof place == "function")
            place(this.dom);
          else if (place.mount)
            this.mounted = true;
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        this.nodeViews = buildNodeViews(this);
        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
        this.domObserver = new DOMObserver(this, (from2, to2, typeOver, added) => readDOMChange(this, from2, to2, typeOver, added));
        this.domObserver.start();
        initInput(this);
        this.updatePluginViews();
      }
      /**
      Holds `true` when a
      [composition](https://w3c.github.io/uievents/#events-compositionevents)
      is active.
      */
      get composing() {
        return this.input.composing;
      }
      /**
      The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
      */
      get props() {
        if (this._props.state != this.state) {
          let prev = this._props;
          this._props = {};
          for (let name in prev)
            this._props[name] = prev[name];
          this._props.state = this.state;
        }
        return this._props;
      }
      /**
      Update the view's props. Will immediately cause an update to
      the DOM.
      */
      update(props) {
        if (props.handleDOMEvents != this._props.handleDOMEvents)
          ensureListeners(this);
        let prevProps = this._props;
        this._props = props;
        if (props.plugins) {
          props.plugins.forEach(checkStateComponent);
          this.directPlugins = props.plugins;
        }
        this.updateStateInner(props.state, prevProps);
      }
      /**
      Update the view by updating existing props object with the object
      given as argument. Equivalent to `view.update(Object.assign({},
      view.props, props))`.
      */
      setProps(props) {
        let updated = {};
        for (let name in this._props)
          updated[name] = this._props[name];
        updated.state = this.state;
        for (let name in props)
          updated[name] = props[name];
        this.update(updated);
      }
      /**
      Update the editor's `state` prop, without touching any of the
      other props.
      */
      updateState(state) {
        this.updateStateInner(state, this._props);
      }
      updateStateInner(state, prevProps) {
        var _a;
        let prev = this.state, redraw = false, updateSel = false;
        if (state.storedMarks && this.composing) {
          clearComposition(this);
          updateSel = true;
        }
        this.state = state;
        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
          let nodeViews = buildNodeViews(this);
          if (changedNodeViews(nodeViews, this.nodeViews)) {
            this.nodeViews = nodeViews;
            redraw = true;
          }
        }
        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
          ensureListeners(this);
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
        if (updateDoc || !state.selection.eq(prev.selection))
          updateSel = true;
        let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
        if (updateSel) {
          this.domObserver.stop();
          let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
          if (updateDoc) {
            let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
            if (this.composing)
              this.input.compositionNode = findCompositionNode(this);
            if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
              this.docView.updateOuterDeco(outerDeco);
              this.docView.destroy();
              this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
            }
            if (chromeKludge && !this.trackWrites)
              forceSelUpdate = true;
          }
          if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
            selectionToDOM(this, forceSelUpdate);
          } else {
            syncNodeSelection(this, state.selection);
            this.domObserver.setCurSelection();
          }
          this.domObserver.start();
        }
        this.updatePluginViews(prev);
        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
          this.updateDraggedNode(this.dragging, prev);
        if (scroll == "reset") {
          this.dom.scrollTop = 0;
        } else if (scroll == "to selection") {
          this.scrollToSelection();
        } else if (oldScrollPos) {
          resetScrollPos(oldScrollPos);
        }
      }
      /**
      @internal
      */
      scrollToSelection() {
        let startDOM = this.domSelectionRange().focusNode;
        if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
        else if (this.someProp("handleScrollToSelection", (f11) => f11(this))) ;
        else if (this.state.selection instanceof NodeSelection) {
          let target = this.docView.domAfterPos(this.state.selection.from);
          if (target.nodeType == 1)
            scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
        } else {
          scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
        }
      }
      destroyPluginViews() {
        let view;
        while (view = this.pluginViews.pop())
          if (view.destroy)
            view.destroy();
      }
      updatePluginViews(prevState) {
        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins;
          this.destroyPluginViews();
          for (let i21 = 0; i21 < this.directPlugins.length; i21++) {
            let plugin = this.directPlugins[i21];
            if (plugin.spec.view)
              this.pluginViews.push(plugin.spec.view(this));
          }
          for (let i21 = 0; i21 < this.state.plugins.length; i21++) {
            let plugin = this.state.plugins[i21];
            if (plugin.spec.view)
              this.pluginViews.push(plugin.spec.view(this));
          }
        } else {
          for (let i21 = 0; i21 < this.pluginViews.length; i21++) {
            let pluginView = this.pluginViews[i21];
            if (pluginView.update)
              pluginView.update(this, prevState);
          }
        }
      }
      updateDraggedNode(dragging, prev) {
        let sel = dragging.node, found2 = -1;
        if (this.state.doc.nodeAt(sel.from) == sel.node) {
          found2 = sel.from;
        } else {
          let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
          let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
          if (moved == sel.node)
            found2 = movedPos;
        }
        this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
      }
      someProp(propName, f11) {
        let prop = this._props && this._props[propName], value;
        if (prop != null && (value = f11 ? f11(prop) : prop))
          return value;
        for (let i21 = 0; i21 < this.directPlugins.length; i21++) {
          let prop2 = this.directPlugins[i21].props[propName];
          if (prop2 != null && (value = f11 ? f11(prop2) : prop2))
            return value;
        }
        let plugins = this.state.plugins;
        if (plugins)
          for (let i21 = 0; i21 < plugins.length; i21++) {
            let prop2 = plugins[i21].props[propName];
            if (prop2 != null && (value = f11 ? f11(prop2) : prop2))
              return value;
          }
      }
      /**
      Query whether the view has focus.
      */
      hasFocus() {
        if (ie) {
          let node = this.root.activeElement;
          if (node == this.dom)
            return true;
          if (!node || !this.dom.contains(node))
            return false;
          while (node && this.dom != node && this.dom.contains(node)) {
            if (node.contentEditable == "false")
              return false;
            node = node.parentElement;
          }
          return true;
        }
        return this.root.activeElement == this.dom;
      }
      /**
      Focus the editor.
      */
      focus() {
        this.domObserver.stop();
        if (this.editable)
          focusPreventScroll(this.dom);
        selectionToDOM(this);
        this.domObserver.start();
      }
      /**
      Get the document root in which the editor exists. This will
      usually be the top-level `document`, but might be a [shadow
      DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
      root if the editor is inside one.
      */
      get root() {
        let cached = this._root;
        if (cached == null)
          for (let search = this.dom.parentNode; search; search = search.parentNode) {
            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
              if (!search.getSelection)
                Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
              return this._root = search;
            }
          }
        return cached || document;
      }
      /**
      When an existing editor view is moved to a new document or
      shadow tree, call this to make it recompute its root.
      */
      updateRoot() {
        this._root = null;
      }
      /**
      Given a pair of viewport coordinates, return the document
      position that corresponds to them. May return null if the given
      coordinates aren't inside of the editor. When an object is
      returned, its `pos` property is the position nearest to the
      coordinates, and its `inside` property holds the position of the
      inner node that the position falls inside of, or -1 if it is at
      the top level, not in any node.
      */
      posAtCoords(coords) {
        return posAtCoords(this, coords);
      }
      /**
      Returns the viewport rectangle at a given document position.
      `left` and `right` will be the same number, as this returns a
      flat cursor-ish rectangle. If the position is between two things
      that aren't directly adjacent, `side` determines which element
      is used. When < 0, the element before the position is used,
      otherwise the element after.
      */
      coordsAtPos(pos, side = 1) {
        return coordsAtPos(this, pos, side);
      }
      /**
      Find the DOM position that corresponds to the given document
      position. When `side` is negative, find the position as close as
      possible to the content before the position. When positive,
      prefer positions close to the content after the position. When
      zero, prefer as shallow a position as possible.
      
      Note that you should **not** mutate the editor's internal DOM,
      only inspect it (and even that is usually not necessary).
      */
      domAtPos(pos, side = 0) {
        return this.docView.domFromPos(pos, side);
      }
      /**
      Find the DOM node that represents the document node after the
      given position. May return `null` when the position doesn't point
      in front of a node or if the node is inside an opaque node view.
      
      This is intended to be able to call things like
      `getBoundingClientRect` on that DOM node. Do **not** mutate the
      editor DOM directly, or add styling this way, since that will be
      immediately overriden by the editor as it redraws the node.
      */
      nodeDOM(pos) {
        let desc = this.docView.descAt(pos);
        return desc ? desc.nodeDOM : null;
      }
      /**
      Find the document position that corresponds to a given DOM
      position. (Whenever possible, it is preferable to inspect the
      document structure directly, rather than poking around in the
      DOM, but sometimesfor example when interpreting an event
      targetyou don't have a choice.)
      
      The `bias` parameter can be used to influence which side of a DOM
      node to use when the position is inside a leaf node.
      */
      posAtDOM(node, offset4, bias = -1) {
        let pos = this.docView.posFromDOM(node, offset4, bias);
        if (pos == null)
          throw new RangeError("DOM position not inside the editor");
        return pos;
      }
      /**
      Find out whether the selection is at the end of a textblock when
      moving in a given direction. When, for example, given `"left"`,
      it will return true if moving left from the current cursor
      position would leave that position's parent textblock. Will apply
      to the view's current state by default, but it is possible to
      pass a different state.
      */
      endOfTextblock(dir, state) {
        return endOfTextblock(this, state || this.state, dir);
      }
      /**
      Run the editor's paste logic with the given HTML string. The
      `event`, if given, will be passed to the
      [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
      */
      pasteHTML(html, event) {
        return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
      }
      /**
      Run the editor's paste logic with the given plain-text input.
      */
      pasteText(text, event) {
        return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
      }
      /**
      Serialize the given slice as it would be if it was copied from
      this editor. Returns a DOM element that contains a
      representation of the slice as its children, a textual
      representation, and the transformed slice (which can be
      different from the given input due to hooks like
      [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
      */
      serializeForClipboard(slice2) {
        return serializeForClipboard(this, slice2);
      }
      /**
      Removes the editor from the DOM and destroys all [node
      views](https://prosemirror.net/docs/ref/#view.NodeView).
      */
      destroy() {
        if (!this.docView)
          return;
        destroyInput(this);
        this.destroyPluginViews();
        if (this.mounted) {
          this.docView.update(this.state.doc, [], viewDecorations(this), this);
          this.dom.textContent = "";
        } else if (this.dom.parentNode) {
          this.dom.parentNode.removeChild(this.dom);
        }
        this.docView.destroy();
        this.docView = null;
        clearReusedRange();
      }
      /**
      This is true when the view has been
      [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
      used anymore).
      */
      get isDestroyed() {
        return this.docView == null;
      }
      /**
      Used for testing.
      */
      dispatchEvent(event) {
        return dispatchEvent(this, event);
      }
      /**
      @internal
      */
      domSelectionRange() {
        let sel = this.domSelection();
        if (!sel)
          return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
      }
      /**
      @internal
      */
      domSelection() {
        return this.root.getSelection();
      }
    };
    EditorView.prototype.dispatch = function(tr2) {
      let dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction)
        dispatchTransaction.call(this, tr2);
      else
        this.updateState(this.state.apply(tr2));
    };
  }
});

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE, RopeSequence, Leaf, Append, dist_default2;
var init_dist8 = __esm({
  "node_modules/rope-sequence/dist/index.js"() {
    GOOD_LEAF_SIZE = 200;
    RopeSequence = function RopeSequence2() {
    };
    RopeSequence.prototype.append = function append(other) {
      if (!other.length) {
        return this;
      }
      other = RopeSequence.from(other);
      return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
    };
    RopeSequence.prototype.prepend = function prepend(other) {
      if (!other.length) {
        return this;
      }
      return RopeSequence.from(other).append(this);
    };
    RopeSequence.prototype.appendInner = function appendInner(other) {
      return new Append(this, other);
    };
    RopeSequence.prototype.slice = function slice(from2, to2) {
      if (from2 === void 0) from2 = 0;
      if (to2 === void 0) to2 = this.length;
      if (from2 >= to2) {
        return RopeSequence.empty;
      }
      return this.sliceInner(Math.max(0, from2), Math.min(this.length, to2));
    };
    RopeSequence.prototype.get = function get(i21) {
      if (i21 < 0 || i21 >= this.length) {
        return void 0;
      }
      return this.getInner(i21);
    };
    RopeSequence.prototype.forEach = function forEach(f11, from2, to2) {
      if (from2 === void 0) from2 = 0;
      if (to2 === void 0) to2 = this.length;
      if (from2 <= to2) {
        this.forEachInner(f11, from2, to2, 0);
      } else {
        this.forEachInvertedInner(f11, from2, to2, 0);
      }
    };
    RopeSequence.prototype.map = function map(f11, from2, to2) {
      if (from2 === void 0) from2 = 0;
      if (to2 === void 0) to2 = this.length;
      var result = [];
      this.forEach(function(elt, i21) {
        return result.push(f11(elt, i21));
      }, from2, to2);
      return result;
    };
    RopeSequence.from = function from(values) {
      if (values instanceof RopeSequence) {
        return values;
      }
      return values && values.length ? new Leaf(values) : RopeSequence.empty;
    };
    Leaf = /* @__PURE__ */ function(RopeSequence3) {
      function Leaf2(values) {
        RopeSequence3.call(this);
        this.values = values;
      }
      if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
      Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
      Leaf2.prototype.constructor = Leaf2;
      var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
      Leaf2.prototype.flatten = function flatten() {
        return this.values;
      };
      Leaf2.prototype.sliceInner = function sliceInner(from2, to2) {
        if (from2 == 0 && to2 == this.length) {
          return this;
        }
        return new Leaf2(this.values.slice(from2, to2));
      };
      Leaf2.prototype.getInner = function getInner(i21) {
        return this.values[i21];
      };
      Leaf2.prototype.forEachInner = function forEachInner(f11, from2, to2, start) {
        for (var i21 = from2; i21 < to2; i21++) {
          if (f11(this.values[i21], start + i21) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f11, from2, to2, start) {
        for (var i21 = from2 - 1; i21 >= to2; i21--) {
          if (f11(this.values[i21], start + i21) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.leafAppend = function leafAppend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(this.values.concat(other.flatten()));
        }
      };
      Leaf2.prototype.leafPrepend = function leafPrepend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(other.flatten().concat(this.values));
        }
      };
      prototypeAccessors.length.get = function() {
        return this.values.length;
      };
      prototypeAccessors.depth.get = function() {
        return 0;
      };
      Object.defineProperties(Leaf2.prototype, prototypeAccessors);
      return Leaf2;
    }(RopeSequence);
    RopeSequence.empty = new Leaf([]);
    Append = /* @__PURE__ */ function(RopeSequence3) {
      function Append2(left, right) {
        RopeSequence3.call(this);
        this.left = left;
        this.right = right;
        this.length = left.length + right.length;
        this.depth = Math.max(left.depth, right.depth) + 1;
      }
      if (RopeSequence3) Append2.__proto__ = RopeSequence3;
      Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
      Append2.prototype.constructor = Append2;
      Append2.prototype.flatten = function flatten() {
        return this.left.flatten().concat(this.right.flatten());
      };
      Append2.prototype.getInner = function getInner(i21) {
        return i21 < this.left.length ? this.left.get(i21) : this.right.get(i21 - this.left.length);
      };
      Append2.prototype.forEachInner = function forEachInner(f11, from2, to2, start) {
        var leftLen = this.left.length;
        if (from2 < leftLen && this.left.forEachInner(f11, from2, Math.min(to2, leftLen), start) === false) {
          return false;
        }
        if (to2 > leftLen && this.right.forEachInner(f11, Math.max(from2 - leftLen, 0), Math.min(this.length, to2) - leftLen, start + leftLen) === false) {
          return false;
        }
      };
      Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f11, from2, to2, start) {
        var leftLen = this.left.length;
        if (from2 > leftLen && this.right.forEachInvertedInner(f11, from2 - leftLen, Math.max(to2, leftLen) - leftLen, start + leftLen) === false) {
          return false;
        }
        if (to2 < leftLen && this.left.forEachInvertedInner(f11, Math.min(from2, leftLen), to2, start) === false) {
          return false;
        }
      };
      Append2.prototype.sliceInner = function sliceInner(from2, to2) {
        if (from2 == 0 && to2 == this.length) {
          return this;
        }
        var leftLen = this.left.length;
        if (to2 <= leftLen) {
          return this.left.slice(from2, to2);
        }
        if (from2 >= leftLen) {
          return this.right.slice(from2 - leftLen, to2 - leftLen);
        }
        return this.left.slice(from2, leftLen).append(this.right.slice(0, to2 - leftLen));
      };
      Append2.prototype.leafAppend = function leafAppend(other) {
        var inner = this.right.leafAppend(other);
        if (inner) {
          return new Append2(this.left, inner);
        }
      };
      Append2.prototype.leafPrepend = function leafPrepend(other) {
        var inner = this.left.leafPrepend(other);
        if (inner) {
          return new Append2(inner, this.right);
        }
      };
      Append2.prototype.appendInner = function appendInner2(other) {
        if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
          return new Append2(this.left, new Append2(this.right, other));
        }
        return new Append2(this, other);
      };
      return Append2;
    }(RopeSequence);
    dist_default2 = RopeSequence;
  }
});

// node_modules/prosemirror-history/dist/index.js
var dist_exports6 = {};
__export(dist_exports6, {
  closeHistory: () => closeHistory,
  history: () => history2,
  redo: () => redo,
  redoDepth: () => redoDepth,
  redoNoScroll: () => redoNoScroll,
  undo: () => undo,
  undoDepth: () => undoDepth,
  undoNoScroll: () => undoNoScroll
});
function cutOffEvents(items, n25) {
  let cutPoint;
  items.forEach((item, i21) => {
    if (item.selection && n25-- == 0) {
      cutPoint = i21;
      return false;
    }
  });
  return items.slice(cutPoint);
}
function applyTransaction(history3, state, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history3 = new HistoryState(history3.done, history3.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history3;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history3.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history3.undone, rangesFor(tr2.mapping.maps), history3.prevTime, history3.prevComposition);
    else
      return new HistoryState(history3.done, history3.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history3.prevTime, history3.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history3.prevTime == 0 || !appended && history3.prevComposition != composition && (history3.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history3.prevRanges));
    let prevRanges = appended ? mapRanges(history3.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps);
    return new HistoryState(history3.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history3.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history3.done.rebased(tr2, rebased), history3.undone.rebased(tr2, rebased), mapRanges(history3.prevRanges, tr2.mapping), history3.prevTime, history3.prevComposition);
  } else {
    return new HistoryState(history3.done.addMaps(tr2.mapping.maps), history3.undone.addMaps(tr2.mapping.maps), mapRanges(history3.prevRanges, tr2.mapping), history3.prevTime, history3.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i21 = 0; i21 < prevRanges.length; i21 += 2)
      if (start <= prevRanges[i21 + 1] && end >= prevRanges[i21])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i21 = maps.length - 1; i21 >= 0 && result.length == 0; i21--)
    maps[i21].forEach((_from, _to, from2, to2) => result.push(from2, to2));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i21 = 0; i21 < ranges.length; i21 += 2) {
    let from2 = mapping.map(ranges[i21], 1), to2 = mapping.map(ranges[i21 + 1], -1);
    if (from2 <= to2)
      result.push(from2, to2);
  }
  return result;
}
function histTransaction(history3, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history3.undone : history3.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history3.done : history3.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i21 = 0; i21 < plugins.length; i21++)
      if (plugins[i21].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
function closeHistory(tr2) {
  return tr2.setMeta(closeHistoryKey, true);
}
function history2(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e36) {
          let inputType = e36.inputType;
          let command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command)
            return false;
          e36.preventDefault();
          return command(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr2 = histTransaction(hist, state, redo2);
      if (tr2)
        dispatch(scroll ? tr2.scrollIntoView() : tr2);
    }
    return true;
  };
}
function undoDepth(state) {
  let hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}
function redoDepth(state) {
  let hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0;
}
var max_empty_items, Branch, Item, HistoryState, DEPTH_OVERFLOW, cachedPreserveItems, cachedPreserveItemsPlugins, historyKey, closeHistoryKey, undo, redo, undoNoScroll, redoNoScroll;
var init_dist9 = __esm({
  "node_modules/prosemirror-history/dist/index.js"() {
    init_dist8();
    init_dist3();
    init_dist4();
    max_empty_items = 500;
    Branch = class _Branch {
      constructor(items, eventCount) {
        this.items = items;
        this.eventCount = eventCount;
      }
      // Pop the latest event off the branch's history and apply it
      // to a document transform.
      popEvent(state, preserveItems) {
        if (this.eventCount == 0)
          return null;
        let end = this.items.length;
        for (; ; end--) {
          let next = this.items.get(end - 1);
          if (next.selection) {
            --end;
            break;
          }
        }
        let remap, mapFrom;
        if (preserveItems) {
          remap = this.remapping(end, this.items.length);
          mapFrom = remap.maps.length;
        }
        let transform = state.tr;
        let selection, remaining;
        let addAfter = [], addBefore = [];
        this.items.forEach((item, i21) => {
          if (!item.step) {
            if (!remap) {
              remap = this.remapping(end, i21 + 1);
              mapFrom = remap.maps.length;
            }
            mapFrom--;
            addBefore.push(item);
            return;
          }
          if (remap) {
            addBefore.push(new Item(item.map));
            let step = item.step.map(remap.slice(mapFrom)), map2;
            if (step && transform.maybeStep(step).doc) {
              map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
              addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
            }
            mapFrom--;
            if (map2)
              remap.appendMap(map2, mapFrom);
          } else {
            transform.maybeStep(item.step);
          }
          if (item.selection) {
            selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
            remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
            return false;
          }
        }, this.items.length, 0);
        return { remaining, transform, selection };
      }
      // Create a new branch with the given transform added.
      addTransform(transform, selection, histOptions, preserveItems) {
        let newItems = [], eventCount = this.eventCount;
        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
        for (let i21 = 0; i21 < transform.steps.length; i21++) {
          let step = transform.steps[i21].invert(transform.docs[i21]);
          let item = new Item(transform.mapping.maps[i21], step, selection), merged;
          if (merged = lastItem && lastItem.merge(item)) {
            item = merged;
            if (i21)
              newItems.pop();
            else
              oldItems = oldItems.slice(0, oldItems.length - 1);
          }
          newItems.push(item);
          if (selection) {
            eventCount++;
            selection = void 0;
          }
          if (!preserveItems)
            lastItem = item;
        }
        let overflow = eventCount - histOptions.depth;
        if (overflow > DEPTH_OVERFLOW) {
          oldItems = cutOffEvents(oldItems, overflow);
          eventCount -= overflow;
        }
        return new _Branch(oldItems.append(newItems), eventCount);
      }
      remapping(from2, to2) {
        let maps = new Mapping();
        this.items.forEach((item, i21) => {
          let mirrorPos = item.mirrorOffset != null && i21 - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
          maps.appendMap(item.map, mirrorPos);
        }, from2, to2);
        return maps;
      }
      addMaps(array) {
        if (this.eventCount == 0)
          return this;
        return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
      }
      // When the collab module receives remote changes, the history has
      // to know about those, so that it can adjust the steps that were
      // rebased on top of the remote changes, and include the position
      // maps for the remote changes in its array of items.
      rebased(rebasedTransform, rebasedCount) {
        if (!this.eventCount)
          return this;
        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
        let mapping = rebasedTransform.mapping;
        let newUntil = rebasedTransform.steps.length;
        let eventCount = this.eventCount;
        this.items.forEach((item) => {
          if (item.selection)
            eventCount--;
        }, start);
        let iRebased = rebasedCount;
        this.items.forEach((item) => {
          let pos = mapping.getMirror(--iRebased);
          if (pos == null)
            return;
          newUntil = Math.min(newUntil, pos);
          let map2 = mapping.maps[pos];
          if (item.step) {
            let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
            let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
            if (selection)
              eventCount++;
            rebasedItems.push(new Item(map2, step, selection));
          } else {
            rebasedItems.push(new Item(map2));
          }
        }, start);
        let newMaps = [];
        for (let i21 = rebasedCount; i21 < newUntil; i21++)
          newMaps.push(new Item(mapping.maps[i21]));
        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
        let branch = new _Branch(items, eventCount);
        if (branch.emptyItemCount() > max_empty_items)
          branch = branch.compress(this.items.length - rebasedItems.length);
        return branch;
      }
      emptyItemCount() {
        let count = 0;
        this.items.forEach((item) => {
          if (!item.step)
            count++;
        });
        return count;
      }
      // Compressing a branch means rewriting it to push the air (map-only
      // items) out. During collaboration, these naturally accumulate
      // because each remote change adds one. The `upto` argument is used
      // to ensure that only the items below a given level are compressed,
      // because `rebased` relies on a clean, untouched set of items in
      // order to associate old items with rebased steps.
      compress(upto = this.items.length) {
        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
        let items = [], events = 0;
        this.items.forEach((item, i21) => {
          if (i21 >= upto) {
            items.push(item);
            if (item.selection)
              events++;
          } else if (item.step) {
            let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
            mapFrom--;
            if (map2)
              remap.appendMap(map2, mapFrom);
            if (step) {
              let selection = item.selection && item.selection.map(remap.slice(mapFrom));
              if (selection)
                events++;
              let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
              if (merged = items.length && items[last].merge(newItem))
                items[last] = merged;
              else
                items.push(newItem);
            }
          } else if (item.map) {
            mapFrom--;
          }
        }, this.items.length, 0);
        return new _Branch(dist_default2.from(items.reverse()), events);
      }
    };
    Branch.empty = new Branch(dist_default2.empty, 0);
    Item = class _Item {
      constructor(map2, step, selection, mirrorOffset) {
        this.map = map2;
        this.step = step;
        this.selection = selection;
        this.mirrorOffset = mirrorOffset;
      }
      merge(other) {
        if (this.step && other.step && !other.selection) {
          let step = other.step.merge(this.step);
          if (step)
            return new _Item(step.getMap().invert(), step, this.selection);
        }
      }
    };
    HistoryState = class {
      constructor(done, undone, prevRanges, prevTime, prevComposition) {
        this.done = done;
        this.undone = undone;
        this.prevRanges = prevRanges;
        this.prevTime = prevTime;
        this.prevComposition = prevComposition;
      }
    };
    DEPTH_OVERFLOW = 20;
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = null;
    historyKey = new PluginKey("history");
    closeHistoryKey = new PluginKey("closeHistory");
    undo = buildCommand(false, true);
    redo = buildCommand(true, true);
    undoNoScroll = buildCommand(false, false);
    redoNoScroll = buildCommand(true, false);
  }
});

// node_modules/w3c-keyname/index.js
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift3 : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
var base, shift3, mac2, ie2, i21, i21, i21, code;
var init_w3c_keyname = __esm({
  "node_modules/w3c-keyname/index.js"() {
    base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    shift3 = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    };
    mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (i21 = 0; i21 < 10; i21++) base[48 + i21] = base[96 + i21] = String(i21);
    for (i21 = 1; i21 <= 24; i21++) base[i21 + 111] = "F" + i21;
    for (i21 = 65; i21 <= 90; i21++) {
      base[i21] = String.fromCharCode(i21 + 32);
      shift3[i21] = String.fromCharCode(i21);
    }
    for (code in base) if (!shift3.hasOwnProperty(code)) shift3[code] = base[code];
  }
});

// node_modules/prosemirror-keymap/dist/index.js
var dist_exports7 = {};
__export(dist_exports7, {
  keydownHandler: () => keydownHandler,
  keymap: () => keymap
});
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift4, meta;
  for (let i21 = 0; i21 < parts.length - 1; i21++) {
    let mod = parts[i21];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift4 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift4)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift4 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift4 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
var mac3, windows2;
var init_dist10 = __esm({
  "node_modules/prosemirror-keymap/dist/index.js"() {
    init_w3c_keyname();
    init_dist4();
    mac3 = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
    windows2 = typeof navigator != "undefined" && /Win/.test(navigator.platform);
  }
});

// node_modules/prosemirror-commands/dist/index.js
var dist_exports8 = {};
__export(dist_exports8, {
  autoJoin: () => autoJoin,
  baseKeymap: () => baseKeymap,
  chainCommands: () => chainCommands,
  createParagraphNear: () => createParagraphNear,
  deleteSelection: () => deleteSelection,
  exitCode: () => exitCode,
  joinBackward: () => joinBackward,
  joinDown: () => joinDown,
  joinForward: () => joinForward,
  joinTextblockBackward: () => joinTextblockBackward,
  joinTextblockForward: () => joinTextblockForward,
  joinUp: () => joinUp,
  lift: () => lift2,
  liftEmptyBlock: () => liftEmptyBlock,
  macBaseKeymap: () => macBaseKeymap,
  newlineInCode: () => newlineInCode,
  pcBaseKeymap: () => pcBaseKeymap,
  selectAll: () => selectAll,
  selectNodeBackward: () => selectNodeBackward,
  selectNodeForward: () => selectNodeForward,
  selectParentNode: () => selectParentNode,
  selectTextblockEnd: () => selectTextblockEnd,
  selectTextblockStart: () => selectTextblockStart,
  setBlockType: () => setBlockType2,
  splitBlock: () => splitBlock,
  splitBlockAs: () => splitBlockAs,
  splitBlockKeepMarks: () => splitBlockKeepMarks,
  toggleMark: () => toggleMark,
  wrapIn: () => wrapIn
});
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i21 = $pos.depth - 1; i21 >= 0; i21--) {
      if ($pos.index(i21) > 0)
        return $pos.doc.resolve($pos.before(i21 + 1));
      if ($pos.node(i21).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i21 = $pos.depth - 1; i21 >= 0; i21--) {
      let parent = $pos.node(i21);
      if ($pos.index(i21) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i21 + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
function defaultBlockAt(match) {
  for (let i21 = 0; i21 < match.edgeCount; i21++) {
    let { type } = match.edge(i21);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d22 = $from.depth; ; d22--) {
      let node = $from.node(d22);
      if (node.isBlock) {
        atEnd = $from.end(d22) == $from.pos + ($from.depth - d22);
        atStart = $from.start(d22) == $from.pos - ($from.depth - d22);
        deflt = defaultBlockAt($from.node(d22 - 1).contentMatchAt($from.indexAfter(d22 - 1)));
        let splitType = splitNode && splitNode($to.parent, atEnd, $from);
        types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
        splitDepth = d22;
        break;
      } else {
        if (d22 == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr2 = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr2.deleteSelection();
    let splitPos = tr2.mapping.map($from.pos);
    let can = canSplit(tr2.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr2.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr2.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first = tr2.mapping.map($from.before(splitDepth)), $first = tr2.doc.resolve(first);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr2.setNodeMarkup(tr2.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr2.scrollIntoView());
    return true;
  };
}
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i21 = conn.length - 1; i21 >= 0; i21--)
        wrap2 = Fragment.from(conn[i21].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr2.doc.resolve(end + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr2.doc, $joinAt.pos))
        tr2.join($joinAt.pos);
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end = Fragment.empty;
        for (let i21 = wrap2.length - 1; i21 >= 0; i21--)
          end = Fragment.from(wrap2[i21].copy(end));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i21 = 0; i21 < state.selection.ranges.length && !applicable; i21++) {
      let { $from: { pos: from2 }, $to: { pos: to2 } } = state.selection.ranges[i21];
      state.doc.nodesBetween(from2, to2, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr2 = state.tr;
      for (let i21 = 0; i21 < state.selection.ranges.length; i21++) {
        let { $from: { pos: from2 }, $to: { pos: to2 } } = state.selection.ranges[i21];
        tr2.setBlockType(from2, to2, nodeType, attrs);
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
function markApplies(doc3, ranges, type, enterAtoms) {
  for (let i21 = 0; i21 < ranges.length; i21++) {
    let { $from, $to } = ranges[i21];
    let can = $from.depth == 0 ? doc3.inlineContent && doc3.type.allowsMarkType(type) : false;
    doc3.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos)
        return false;
      can = node.inlineContent && node.type.allowsMarkType(type);
    });
    if (can)
      return true;
  }
  return false;
}
function removeInlineAtoms(ranges) {
  let result = [];
  for (let i21 = 0; i21 < ranges.length; i21++) {
    let { $from, $to } = ranges[i21];
    $from.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {
        if (pos + 1 > $from.pos)
          result.push(new SelectionRange($from, $from.doc.resolve(pos + 1)));
        $from = $from.doc.resolve(pos + 1 + node.content.size);
        return false;
      }
    });
    if ($from.pos < $to.pos)
      result.push(new SelectionRange($from, $to));
  }
  return result;
}
function toggleMark(markType, attrs = null, options) {
  let removeWhenPresent = (options && options.removeWhenPresent) !== false;
  let enterAtoms = (options && options.enterInlineAtoms) !== false;
  let dropSpace = !(options && options.includeWhitespace);
  return function(state, dispatch) {
    let { empty: empty2, $cursor, ranges } = state.selection;
    if (empty2 && !$cursor || !markApplies(state.doc, ranges, markType, enterAtoms))
      return false;
    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks()))
          dispatch(state.tr.removeStoredMark(markType));
        else
          dispatch(state.tr.addStoredMark(markType.create(attrs)));
      } else {
        let add2, tr2 = state.tr;
        if (!enterAtoms)
          ranges = removeInlineAtoms(ranges);
        if (removeWhenPresent) {
          add2 = !ranges.some((r25) => state.doc.rangeHasMark(r25.$from.pos, r25.$to.pos, markType));
        } else {
          add2 = !ranges.every((r25) => {
            let missing = false;
            tr2.doc.nodesBetween(r25.$from.pos, r25.$to.pos, (node, pos, parent) => {
              if (missing)
                return false;
              missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) && !(node.isText && /^\s*$/.test(node.textBetween(Math.max(0, r25.$from.pos - pos), Math.min(node.nodeSize, r25.$to.pos - pos))));
            });
            return !missing;
          });
        }
        for (let i21 = 0; i21 < ranges.length; i21++) {
          let { $from, $to } = ranges[i21];
          if (!add2) {
            tr2.removeMark($from.pos, $to.pos, markType);
          } else {
            let from2 = $from.pos, to2 = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;
            let spaceStart = dropSpace && start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
            let spaceEnd = dropSpace && end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
            if (from2 + spaceStart < to2) {
              from2 += spaceStart;
              to2 -= spaceEnd;
            }
            tr2.addMark(from2, to2, markType.create(attrs));
          }
        }
        dispatch(tr2.scrollIntoView());
      }
    }
    return true;
  };
}
function wrapDispatchForJoin(dispatch, isJoinable) {
  return (tr2) => {
    if (!tr2.isGeneric)
      return dispatch(tr2);
    let ranges = [];
    for (let i21 = 0; i21 < tr2.mapping.maps.length; i21++) {
      let map2 = tr2.mapping.maps[i21];
      for (let j3 = 0; j3 < ranges.length; j3++)
        ranges[j3] = map2.map(ranges[j3]);
      map2.forEach((_s2, _e2, from2, to2) => ranges.push(from2, to2));
    }
    let joinable3 = [];
    for (let i21 = 0; i21 < ranges.length; i21 += 2) {
      let from2 = ranges[i21], to2 = ranges[i21 + 1];
      let $from = tr2.doc.resolve(from2), depth = $from.sharedDepth(to2), parent = $from.node(depth);
      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to2; ++index) {
        let after = parent.maybeChild(index);
        if (!after)
          break;
        if (index && joinable3.indexOf(pos) == -1) {
          let before = parent.child(index - 1);
          if (before.type == after.type && isJoinable(before, after))
            joinable3.push(pos);
        }
        pos += after.nodeSize;
      }
    }
    joinable3.sort((a23, b12) => a23 - b12);
    for (let i21 = joinable3.length - 1; i21 >= 0; i21--) {
      if (canJoin(tr2.doc, joinable3[i21]))
        tr2.join(joinable3[i21]);
    }
    dispatch(tr2);
  };
}
function autoJoin(command, isJoinable) {
  let canJoin2 = Array.isArray(isJoinable) ? (node) => isJoinable.indexOf(node.type.name) > -1 : isJoinable;
  return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin2), view);
}
function chainCommands(...commands) {
  return function(state, dispatch, view) {
    for (let i21 = 0; i21 < commands.length; i21++)
      if (commands[i21](state, dispatch, view))
        return true;
    return false;
  };
}
var deleteSelection, joinBackward, joinTextblockBackward, joinTextblockForward, selectNodeBackward, joinForward, selectNodeForward, joinUp, joinDown, lift2, newlineInCode, exitCode, createParagraphNear, liftEmptyBlock, splitBlock, splitBlockKeepMarks, selectParentNode, selectAll, selectTextblockStart, selectTextblockEnd, backspace, del, pcBaseKeymap, macBaseKeymap, mac4, baseKeymap;
var init_dist11 = __esm({
  "node_modules/prosemirror-commands/dist/index.js"() {
    init_dist3();
    init_dist2();
    init_dist4();
    deleteSelection = (state, dispatch) => {
      if (state.selection.empty)
        return false;
      if (dispatch)
        dispatch(state.tr.deleteSelection().scrollIntoView());
      return true;
    };
    joinBackward = (state, dispatch, view) => {
      let $cursor = atBlockStart(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutBefore($cursor);
      if (!$cut) {
        let range = $cursor.blockRange(), target = range && liftTarget(range);
        if (target == null)
          return false;
        if (dispatch)
          dispatch(state.tr.lift(range, target).scrollIntoView());
        return true;
      }
      let before = $cut.nodeBefore;
      if (deleteBarrier(state, $cut, dispatch, -1))
        return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
        for (let depth = $cursor.depth; ; depth--) {
          let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
          if (delStep && delStep.slice.size < delStep.to - delStep.from) {
            if (dispatch) {
              let tr2 = state.tr.step(delStep);
              tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
              dispatch(tr2.scrollIntoView());
            }
            return true;
          }
          if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
            break;
        }
      }
      if (before.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
          dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
        return true;
      }
      return false;
    };
    joinTextblockBackward = (state, dispatch, view) => {
      let $cursor = atBlockStart(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutBefore($cursor);
      return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
    };
    joinTextblockForward = (state, dispatch, view) => {
      let $cursor = atBlockEnd(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutAfter($cursor);
      return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
    };
    selectNodeBackward = (state, dispatch, view) => {
      let { $head, empty: empty2 } = state.selection, $cut = $head;
      if (!empty2)
        return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
          return false;
        $cut = findCutBefore($head);
      }
      let node = $cut && $cut.nodeBefore;
      if (!node || !NodeSelection.isSelectable(node))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
      return true;
    };
    joinForward = (state, dispatch, view) => {
      let $cursor = atBlockEnd(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutAfter($cursor);
      if (!$cut)
        return false;
      let after = $cut.nodeAfter;
      if (deleteBarrier(state, $cut, dispatch, 1))
        return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            let tr2 = state.tr.step(delStep);
            tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
            dispatch(tr2.scrollIntoView());
          }
          return true;
        }
      }
      if (after.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
          dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
        return true;
      }
      return false;
    };
    selectNodeForward = (state, dispatch, view) => {
      let { $head, empty: empty2 } = state.selection, $cut = $head;
      if (!empty2)
        return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
          return false;
        $cut = findCutAfter($head);
      }
      let node = $cut && $cut.nodeAfter;
      if (!node || !NodeSelection.isSelectable(node))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
      return true;
    };
    joinUp = (state, dispatch) => {
      let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
      if (nodeSel) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
          return false;
        point = sel.from;
      } else {
        point = joinPoint(state.doc, sel.from, -1);
        if (point == null)
          return false;
      }
      if (dispatch) {
        let tr2 = state.tr.join(point);
        if (nodeSel)
          tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    joinDown = (state, dispatch) => {
      let sel = state.selection, point;
      if (sel instanceof NodeSelection) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
          return false;
        point = sel.to;
      } else {
        point = joinPoint(state.doc, sel.to, 1);
        if (point == null)
          return false;
      }
      if (dispatch)
        dispatch(state.tr.join(point).scrollIntoView());
      return true;
    };
    lift2 = (state, dispatch) => {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    };
    newlineInCode = (state, dispatch) => {
      let { $head, $anchor } = state.selection;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
      if (dispatch)
        dispatch(state.tr.insertText("\n").scrollIntoView());
      return true;
    };
    exitCode = (state, dispatch) => {
      let { $head, $anchor } = state.selection;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
      let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
      if (!type || !above.canReplaceWith(after, after, type))
        return false;
      if (dispatch) {
        let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
        tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    createParagraphNear = (state, dispatch) => {
      let sel = state.selection, { $from, $to } = sel;
      if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
        return false;
      let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
      if (!type || !type.isTextblock)
        return false;
      if (dispatch) {
        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
        let tr2 = state.tr.insert(side, type.createAndFill());
        tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    liftEmptyBlock = (state, dispatch) => {
      let { $cursor } = state.selection;
      if (!$cursor || $cursor.parent.content.size)
        return false;
      if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
        let before = $cursor.before();
        if (canSplit(state.doc, before)) {
          if (dispatch)
            dispatch(state.tr.split(before).scrollIntoView());
          return true;
        }
      }
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    };
    splitBlock = splitBlockAs();
    splitBlockKeepMarks = (state, dispatch) => {
      return splitBlock(state, dispatch && ((tr2) => {
        let marks2 = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
        if (marks2)
          tr2.ensureMarks(marks2);
        dispatch(tr2);
      }));
    };
    selectParentNode = (state, dispatch) => {
      let { $from, to: to2 } = state.selection, pos;
      let same = $from.sharedDepth(to2);
      if (same == 0)
        return false;
      pos = $from.before(same);
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
      return true;
    };
    selectAll = (state, dispatch) => {
      if (dispatch)
        dispatch(state.tr.setSelection(new AllSelection(state.doc)));
      return true;
    };
    selectTextblockStart = selectTextblockSide(-1);
    selectTextblockEnd = selectTextblockSide(1);
    backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
    del = chainCommands(deleteSelection, joinForward, selectNodeForward);
    pcBaseKeymap = {
      "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
      "Mod-Enter": exitCode,
      "Backspace": backspace,
      "Mod-Backspace": backspace,
      "Shift-Backspace": backspace,
      "Delete": del,
      "Mod-Delete": del,
      "Mod-a": selectAll
    };
    macBaseKeymap = {
      "Ctrl-h": pcBaseKeymap["Backspace"],
      "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
      "Ctrl-d": pcBaseKeymap["Delete"],
      "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
      "Alt-Delete": pcBaseKeymap["Mod-Delete"],
      "Alt-d": pcBaseKeymap["Mod-Delete"],
      "Ctrl-a": selectTextblockStart,
      "Ctrl-e": selectTextblockEnd
    };
    for (let key in pcBaseKeymap)
      macBaseKeymap[key] = pcBaseKeymap[key];
    mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
    baseKeymap = mac4 ? macBaseKeymap : pcBaseKeymap;
  }
});

// node_modules/prosemirror-dropcursor/dist/index.js
var dist_exports9 = {};
__export(dist_exports9, {
  dropCursor: () => dropCursor
});
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView;
var init_dist12 = __esm({
  "node_modules/prosemirror-dropcursor/dist/index.js"() {
    init_dist4();
    init_dist3();
    DropCursorView = class {
      constructor(editorView, options) {
        var _a;
        this.editorView = editorView;
        this.cursorPos = null;
        this.element = null;
        this.timeout = -1;
        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
        this.color = options.color === false ? void 0 : options.color || "black";
        this.class = options.class;
        this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
          let handler = (e36) => {
            this[name](e36);
          };
          editorView.dom.addEventListener(name, handler);
          return { name, handler };
        });
      }
      destroy() {
        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
      }
      update(editorView, prevState) {
        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
          if (this.cursorPos > editorView.state.doc.content.size)
            this.setCursor(null);
          else
            this.updateOverlay();
        }
      }
      setCursor(pos) {
        if (pos == this.cursorPos)
          return;
        this.cursorPos = pos;
        if (pos == null) {
          this.element.parentNode.removeChild(this.element);
          this.element = null;
        } else {
          this.updateOverlay();
        }
      }
      updateOverlay() {
        let $pos = this.editorView.state.doc.resolve(this.cursorPos);
        let isBlock = !$pos.parent.inlineContent, rect;
        let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
        let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
        if (isBlock) {
          let before = $pos.nodeBefore, after = $pos.nodeAfter;
          if (before || after) {
            let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
            if (node) {
              let nodeRect = node.getBoundingClientRect();
              let top = before ? nodeRect.bottom : nodeRect.top;
              if (before && after)
                top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
              let halfWidth = this.width / 2 * scaleY;
              rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
            }
          }
        }
        if (!rect) {
          let coords = this.editorView.coordsAtPos(this.cursorPos);
          let halfWidth = this.width / 2 * scaleX;
          rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
        }
        let parent = this.editorView.dom.offsetParent;
        if (!this.element) {
          this.element = parent.appendChild(document.createElement("div"));
          if (this.class)
            this.element.className = this.class;
          this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
          if (this.color) {
            this.element.style.backgroundColor = this.color;
          }
        }
        this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
        this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
        let parentLeft, parentTop;
        if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
          parentLeft = -pageXOffset;
          parentTop = -pageYOffset;
        } else {
          let rect2 = parent.getBoundingClientRect();
          let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
          parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
          parentTop = rect2.top - parent.scrollTop * parentScaleY;
        }
        this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
        this.element.style.top = (rect.top - parentTop) / scaleY + "px";
        this.element.style.width = (rect.right - rect.left) / scaleX + "px";
        this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
      }
      scheduleRemoval(timeout) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => this.setCursor(null), timeout);
      }
      dragover(event) {
        if (!this.editorView.editable)
          return;
        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
        let disableDropCursor = node && node.type.spec.disableDropCursor;
        let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
        if (pos && !disabled) {
          let target = pos.pos;
          if (this.editorView.dragging && this.editorView.dragging.slice) {
            let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
            if (point != null)
              target = point;
          }
          this.setCursor(target);
          this.scheduleRemoval(5e3);
        }
      }
      dragend() {
        this.scheduleRemoval(20);
      }
      drop() {
        this.scheduleRemoval(20);
      }
      dragleave(event) {
        if (!this.editorView.dom.contains(event.relatedTarget))
          this.setCursor(null);
      }
    };
  }
});

// node_modules/prosemirror-gapcursor/dist/index.js
var dist_exports10 = {};
__export(dist_exports10, {
  GapCursor: () => GapCursor,
  gapCursor: () => gapCursor
});
function closedBefore($pos) {
  for (let d22 = $pos.depth; d22 >= 0; d22--) {
    let index = $pos.index(d22), parent = $pos.node(d22);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d22 = $pos.depth; d22 >= 0; d22--) {
    let index = $pos.indexAfter(d22), parent = $pos.node(d22);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
function arrow3(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i21 = insert.length - 1; i21 >= 0; i21--)
    frag = Fragment.from(insert[i21].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
var GapCursor, GapBookmark, handleKeyDown;
var init_dist13 = __esm({
  "node_modules/prosemirror-gapcursor/dist/index.js"() {
    init_dist10();
    init_dist4();
    init_dist2();
    init_dist7();
    GapCursor = class _GapCursor extends Selection {
      /**
      Create a gap cursor.
      */
      constructor($pos) {
        super($pos, $pos);
      }
      map(doc3, mapping) {
        let $pos = doc3.resolve(mapping.map(this.head));
        return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
      }
      content() {
        return Slice.empty;
      }
      eq(other) {
        return other instanceof _GapCursor && other.head == this.head;
      }
      toJSON() {
        return { type: "gapcursor", pos: this.head };
      }
      /**
      @internal
      */
      static fromJSON(doc3, json) {
        if (typeof json.pos != "number")
          throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new _GapCursor(doc3.resolve(json.pos));
      }
      /**
      @internal
      */
      getBookmark() {
        return new GapBookmark(this.anchor);
      }
      /**
      @internal
      */
      static valid($pos) {
        let parent = $pos.parent;
        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
          return false;
        let override = parent.type.spec.allowGapCursor;
        if (override != null)
          return override;
        let deflt = parent.contentMatchAt($pos.index()).defaultType;
        return deflt && deflt.isTextblock;
      }
      /**
      @internal
      */
      static findGapCursorFrom($pos, dir, mustMove = false) {
        search: for (; ; ) {
          if (!mustMove && _GapCursor.valid($pos))
            return $pos;
          let pos = $pos.pos, next = null;
          for (let d22 = $pos.depth; ; d22--) {
            let parent = $pos.node(d22);
            if (dir > 0 ? $pos.indexAfter(d22) < parent.childCount : $pos.index(d22) > 0) {
              next = parent.child(dir > 0 ? $pos.indexAfter(d22) : $pos.index(d22) - 1);
              break;
            } else if (d22 == 0) {
              return null;
            }
            pos += dir;
            let $cur = $pos.doc.resolve(pos);
            if (_GapCursor.valid($cur))
              return $cur;
          }
          for (; ; ) {
            let inside = dir > 0 ? next.firstChild : next.lastChild;
            if (!inside) {
              if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                mustMove = false;
                continue search;
              }
              break;
            }
            next = inside;
            pos += dir;
            let $cur = $pos.doc.resolve(pos);
            if (_GapCursor.valid($cur))
              return $cur;
          }
          return null;
        }
      }
    };
    GapCursor.prototype.visible = false;
    GapCursor.findFrom = GapCursor.findGapCursorFrom;
    Selection.jsonID("gapcursor", GapCursor);
    GapBookmark = class _GapBookmark {
      constructor(pos) {
        this.pos = pos;
      }
      map(mapping) {
        return new _GapBookmark(mapping.map(this.pos));
      }
      resolve(doc3) {
        let $pos = doc3.resolve(this.pos);
        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
      }
    };
    handleKeyDown = keydownHandler({
      "ArrowLeft": arrow3("horiz", -1),
      "ArrowRight": arrow3("horiz", 1),
      "ArrowUp": arrow3("vert", -1),
      "ArrowDown": arrow3("vert", 1)
    });
  }
});

// node_modules/prosemirror-inputrules/dist/index.js
var dist_exports11 = {};
__export(dist_exports11, {
  InputRule: () => InputRule,
  closeDoubleQuote: () => closeDoubleQuote,
  closeSingleQuote: () => closeSingleQuote,
  ellipsis: () => ellipsis,
  emDash: () => emDash,
  inputRules: () => inputRules,
  openDoubleQuote: () => openDoubleQuote,
  openSingleQuote: () => openSingleQuote,
  smartQuotes: () => smartQuotes,
  textblockTypeInputRule: () => textblockTypeInputRule,
  undoInputRule: () => undoInputRule,
  wrappingInputRule: () => wrappingInputRule
});
function stringHandler(string) {
  return function(state, match, start, end) {
    let insert = string;
    if (match[1]) {
      let offset4 = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset4 + match[1].length);
      start += offset4;
      let cutOff = start - end;
      if (cutOff > 0) {
        insert = match[0].slice(offset4 - cutOff, offset4) + insert;
        start = end;
      }
    }
    return state.tr.insertText(insert, start, end);
  };
}
function inputRules({ rules }) {
  let plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev) {
        let stored = tr2.getMeta(this);
        if (stored)
          return stored;
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to2, text) {
        return run(view, from2, to2, text, rules, plugin);
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            let { $cursor } = view.state.selection;
            if ($cursor)
              run(view, $cursor.pos, $cursor.pos, "", rules, plugin);
          });
        }
      }
    },
    isInputRules: true
  });
  return plugin;
}
function run(view, from2, to2, text, rules, plugin) {
  if (view.composing)
    return false;
  let state = view.state, $from = state.doc.resolve(from2);
  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, "\uFFFC") + text;
  for (let i21 = 0; i21 < rules.length; i21++) {
    let rule = rules[i21];
    if (!rule.inCodeMark && $from.marks().some((m18) => m18.type.spec.code))
      continue;
    if ($from.parent.type.spec.code) {
      if (!rule.inCode)
        continue;
    } else if (rule.inCode === "only") {
      continue;
    }
    let match = rule.match.exec(textBefore);
    let tr2 = match && match[0].length >= text.length && rule.handler(state, match, from2 - (match[0].length - text.length), to2);
    if (!tr2)
      continue;
    if (rule.undoable)
      tr2.setMeta(plugin, { transform: tr2, from: from2, to: to2, text });
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {
  return new InputRule(regexp, (state, match, start, end) => {
    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    let tr2 = state.tr.delete(start, end);
    let $start = tr2.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return null;
    tr2.wrap(range, wrapping);
    let before = tr2.doc.resolve(start - 1).nodeBefore;
    if (before && before.type == nodeType && canJoin(tr2.doc, start - 1) && (!joinPredicate || joinPredicate(match, before)))
      tr2.join(start - 1);
    return tr2;
  });
}
function textblockTypeInputRule(regexp, nodeType, getAttrs = null) {
  return new InputRule(regexp, (state, match, start, end) => {
    let $start = state.doc.resolve(start);
    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))
      return null;
    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);
  });
}
var InputRule, MAX_MATCH, undoInputRule, emDash, ellipsis, openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote, smartQuotes;
var init_dist14 = __esm({
  "node_modules/prosemirror-inputrules/dist/index.js"() {
    init_dist4();
    init_dist3();
    InputRule = class {
      /**
      Create an input rule. The rule applies when the user typed
      something and the text directly in front of the cursor matches
      `match`, which should end with `$`.
      
      The `handler` can be a string, in which case the matched text, or
      the first matched group in the regexp, is replaced by that
      string.
      
      Or a it can be a function, which will be called with the match
      array produced by
      [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
      as well as the start and end of the matched range, and which can
      return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
      rule's effect, or null to indicate the input was not handled.
      */
      constructor(match, handler, options = {}) {
        this.match = match;
        this.match = match;
        this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
        this.undoable = options.undoable !== false;
        this.inCode = options.inCode || false;
        this.inCodeMark = options.inCodeMark !== false;
      }
    };
    MAX_MATCH = 500;
    undoInputRule = (state, dispatch) => {
      let plugins = state.plugins;
      for (let i21 = 0; i21 < plugins.length; i21++) {
        let plugin = plugins[i21], undoable;
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
          if (dispatch) {
            let tr2 = state.tr, toUndo = undoable.transform;
            for (let j3 = toUndo.steps.length - 1; j3 >= 0; j3--)
              tr2.step(toUndo.steps[j3].invert(toUndo.docs[j3]));
            if (undoable.text) {
              let marks2 = tr2.doc.resolve(undoable.from).marks();
              tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks2));
            } else {
              tr2.delete(undoable.from, undoable.to);
            }
            dispatch(tr2);
          }
          return true;
        }
      }
      return false;
    };
    emDash = new InputRule(/--$/, "\u2014", { inCodeMark: false });
    ellipsis = new InputRule(/\.\.\.$/, "\u2026", { inCodeMark: false });
    openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "\u201C", { inCodeMark: false });
    closeDoubleQuote = new InputRule(/"$/, "\u201D", { inCodeMark: false });
    openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "\u2018", { inCodeMark: false });
    closeSingleQuote = new InputRule(/'$/, "\u2019", { inCodeMark: false });
    smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];
  }
});

// node_modules/@spectrum-web-components/reactive-controllers/src/MatchMedia.js
var IS_MOBILE, MatchMediaController;
var init_MatchMedia = __esm({
  "node_modules/@spectrum-web-components/reactive-controllers/src/MatchMedia.js"() {
    "use strict";
    IS_MOBILE = "(max-width: 743px) and (hover: none) and (pointer: coarse)";
    MatchMediaController = class {
      constructor(e36, t34) {
        this.key = Symbol("match-media-key");
        this.matches = false;
        this.host = e36, this.host.addController(this), this.media = window.matchMedia(t34), this.matches = this.media.matches, this.onChange = this.onChange.bind(this), e36.addController(this);
      }
      hostConnected() {
        var e36;
        (e36 = this.media) == null || e36.addEventListener("change", this.onChange);
      }
      hostDisconnected() {
        var e36;
        (e36 = this.media) == null || e36.removeEventListener("change", this.onChange);
      }
      onChange(e36) {
        this.matches !== e36.matches && (this.matches = e36.matches, this.host.requestUpdate(this.key, !this.matches));
      }
    };
  }
});

// node_modules/@spectrum-web-components/underlay/src/underlay.css.js
var n18, underlay_css_default;
var init_underlay_css = __esm({
  "node_modules/@spectrum-web-components/underlay/src/underlay.css.js"() {
    "use strict";
    init_src();
    n18 = i`
    :host{--spectrum-underlay-background-exit-animation-duration:var(--mod-underlay-background-exit-animation-duration,var(--spectrum-animation-duration-300));--spectrum-underlay-background-exit-animation-ease:var(--mod-underlay-background-exit-animation-ease,var(--spectrum-animation-ease-in));--spectrum-underlay-background-exit-animation-delay:var(--mod-underlay-background-exit-animation-delay,var(--spectrum-animation-duration-200));--spectrum-underlay-background-entry-animation-duration:var(--mod-underlay-background-entry-animation-duration,var(--spectrum-animation-duration-600));--spectrum-underlay-background-entry-animation-ease:var(--mod-underlay-background-entry-animation-ease,var(--spectrum-animation-ease-out));--spectrum-underlay-background-entry-animation-delay:var(--mod-underlay-background-entry-animation-delay,var(--mod-overlay-animation-duration-opened,var(--spectrum-animation-duration-0)));--spectrum-underlay-background-color:var(--mod-underlay-background-color,rgba(var(--spectrum-black-rgb),var(--spectrum-overlay-opacity)));pointer-events:none;visibility:hidden;opacity:0;background-color:var(--spectrum-underlay-background-color);z-index:1;transition:opacity var(--spectrum-underlay-background-exit-animation-duration)var(--spectrum-underlay-background-exit-animation-ease)var(--spectrum-underlay-background-exit-animation-delay),visibility 0s linear calc(var(--spectrum-underlay-background-exit-animation-delay) + var(--spectrum-underlay-background-exit-animation-duration));position:fixed;inset-block:0;inset-inline:0;overflow:hidden}:host([open]){pointer-events:auto;visibility:visible;opacity:1;transition:opacity var(--spectrum-underlay-background-entry-animation-duration)var(--spectrum-underlay-background-entry-animation-ease)var(--spectrum-underlay-background-entry-animation-delay);transition-delay:var(--spectrum-underlay-background-entry-animation-delay)}
`;
    underlay_css_default = n18;
  }
});

// node_modules/@spectrum-web-components/underlay/src/Underlay.js
var d10, p13, s10, Underlay;
var init_Underlay = __esm({
  "node_modules/@spectrum-web-components/underlay/src/Underlay.js"() {
    "use strict";
    init_src();
    init_decorators2();
    init_underlay_css();
    d10 = Object.defineProperty;
    p13 = Object.getOwnPropertyDescriptor;
    s10 = (i21, t34, o52, r25) => {
      for (var e36 = r25 > 1 ? void 0 : r25 ? p13(t34, o52) : t34, n25 = i21.length - 1, l16; n25 >= 0; n25--) (l16 = i21[n25]) && (e36 = (r25 ? l16(t34, o52, e36) : l16(e36)) || e36);
      return r25 && e36 && d10(t34, o52, e36), e36;
    };
    Underlay = class extends SpectrumElement {
      constructor() {
        super(...arguments);
        this.canClick = false;
        this.open = false;
      }
      static get styles() {
        return [underlay_css_default];
      }
      click() {
        this.dispatchEvent(new Event("close"));
      }
      handlePointerdown() {
        this.canClick = true;
      }
      handlePointerup() {
        this.canClick && this.click(), this.canClick = false;
      }
      render() {
        return x``;
      }
      firstUpdated() {
        this.addEventListener("pointerdown", this.handlePointerdown), this.addEventListener("pointerup", this.handlePointerup);
      }
    };
    s10([n4({ type: Boolean, reflect: true })], Underlay.prototype, "open", 2);
  }
});

// node_modules/@spectrum-web-components/underlay/sp-underlay.js
var init_sp_underlay = __esm({
  "node_modules/@spectrum-web-components/underlay/sp-underlay.js"() {
    "use strict";
    init_Underlay();
    init_define_element();
    defineElement("sp-underlay", Underlay);
  }
});

// node_modules/@spectrum-web-components/modal/src/modal.css.js
var i14, modal_css_default;
var init_modal_css = __esm({
  "node_modules/@spectrum-web-components/modal/src/modal.css.js"() {
    "use strict";
    init_src();
    i14 = i`
    :host{--spectrum-modal-confirm-entry-animation-duration:var(--mod-modal-confirm-entry-animation-duration,var(--spectrum-animation-duration-500));--spectrum-modal-confirm-entry-animation-delay:var(--mod-overlay-animation-duration-opened,var(--mod-modal-confirm-entry-animation-delay,var(--spectrum-animation-duration-200)));--spectrum-modal-confirm-exit-animation-duration:var(--mod-overlay-animation-duration,var(--mod-modal-confirm-exit-animation-duration,var(--spectrum-animation-duration-100)));--spectrum-modal-confirm-exit-animation-delay:var(--mod-modal-confirm-exit-animation-delay,var(--spectrum-animation-duration-0));--spectrum-modal-fullscreen-margin:var(--mod-modal-fullscreen-margin,32px)}.modal{visibility:hidden;opacity:0;transform:translateY(var(--mod-modal-confirm-entry-animation-distance,var(--spectrum-dialog-confirm-entry-animation-distance)));z-index:1;max-block-size:90vh;max-block-size:var(--mod-modal-max-height,90vh);max-inline-size:90%;max-inline-size:var(--mod-modal-max-width,90%);background:var(--mod-modal-background-color,var(--spectrum-modal-background-color));border-radius:var(--mod-modal-confirm-border-radius,var(--spectrum-corner-radius-100));pointer-events:auto;transition:opacity var(--spectrum-modal-confirm-exit-animation-duration)var(--spectrum-animation-ease-in)var(--spectrum-modal-confirm-exit-animation-delay),visibility var(--spectrum-animation-duration-0)var(--spectrum-animation-linear)calc(var(--spectrum-modal-confirm-exit-animation-delay) + var(--spectrum-modal-confirm-exit-animation-duration)),transform var(--spectrum-animation-duration-0)var(--spectrum-animation-linear)calc(var(--spectrum-modal-confirm-exit-animation-delay) + var(--spectrum-modal-confirm-exit-animation-duration));outline:none;overflow:hidden}:host([open]) .modal{pointer-events:auto;visibility:visible;opacity:1;transition:transform var(--spectrum-modal-confirm-entry-animation-duration)var(--spectrum-animation-ease-out)var(--spectrum-modal-confirm-entry-animation-delay),opacity var(--spectrum-modal-confirm-entry-animation-duration)var(--spectrum-animation-ease-out)var(--spectrum-modal-confirm-entry-animation-delay);transform:translateY(0)}@media only screen and (device-height<=350px),only screen and (device-width<=400px){:host([responsive]) .modal{border-radius:0;block-size:100%;max-block-size:100%;inline-size:100%;max-inline-size:100%}}.fullscreen{max-block-size:none;max-inline-size:none;position:fixed;inset-block-start:var(--spectrum-modal-fullscreen-margin);inset-block-end:var(--spectrum-modal-fullscreen-margin);inset-inline-start:var(--spectrum-modal-fullscreen-margin);inset-inline-end:var(--spectrum-modal-fullscreen-margin)}.fullscreenTakeover{box-sizing:border-box;border:none;border-radius:0;max-block-size:none;max-inline-size:none;position:fixed;inset:0}.fullscreenTakeover,:host([open]) .fullscreenTakeover{transform:none}:host{--spectrum-modal-background-color:var(--system-modal-background-color)}:host{--spectrum-dialog-confirm-exit-animation-duration:var(--swc-test-duration);--spectrum-dialog-confirm-entry-animation-duration:var(--swc-test-duration);--spectrum-modal-confirm-entry-animation-distance:var(--spectrum-dialog-confirm-entry-animation-distance);height:100dvh}.modal{overflow:visible}
`;
    modal_css_default = i14;
  }
});

// node_modules/@spectrum-web-components/tray/src/tray.css.js
var r13, tray_css_default;
var init_tray_css = __esm({
  "node_modules/@spectrum-web-components/tray/src/tray.css.js"() {
    "use strict";
    init_src();
    r13 = i`
    :host{justify-content:center;inline-size:100%;display:flex;position:fixed;inset-block-end:0;inset-inline-start:0}.tray{--spectrum-tray-max-inline-size:var(--mod-tray-max-inline-size,375px);--spectrum-tray-spacing-edge-to-tray-safe-zone:var(--mod-tray-spacing-edge-to-tray-safe-zone,64px);--spectrum-tray-entry-animation-delay:var(--mod-tray-entry-animation-delay,.16s);--spectrum-tray-entry-animation-duration:var(--mod-tray-entry-animation-duration,var(--spectrum-animation-duration-500));--spectrum-tray-exit-animation-delay:var(--mod-tray-exit-animation-delay,0s);--spectrum-tray-exit-animation-duration:var(--mod-tray-exit-animation-duration,var(--spectrum-animation-duration-100));--spectrum-tray-corner-radius:var(--mod-tray-corner-radius,var(--spectrum-corner-radius-100));--spectrum-tray-background-color:var(--highcontrast-tray-background-color,var(--mod-tray-background-color,var(--spectrum-background-layer-2-color)));--mod-modal-max-width:100%;max-block-size:calc(100vh - 64px);inline-size:100%;max-inline-size:100%;max-block-size:calc(100vh - var(--spectrum-tray-spacing-edge-to-tray-safe-zone));box-sizing:border-box;border-radius:0;border-radius:var(--mod-tray-corner-radius-portrait,0)var(--mod-tray-corner-radius-portrait,0)0 0;transition:opacity var(--spectrum-tray-exit-animation-duration)cubic-bezier(.5,0,1,1)0s,visibility var(--spectrum-tray-exit-animation-duration)linear calc(var(--spectrum-tray-exit-animation-duration)),transform var(--spectrum-tray-exit-animation-duration)cubic-bezier(.5,0,1,1)0s;transition:opacity var(--spectrum-tray-exit-animation-duration)cubic-bezier(.5,0,1,1)var(--spectrum-tray-exit-animation-delay),visibility var(--spectrum-tray-exit-animation-duration)linear calc(var(--spectrum-tray-exit-animation-delay) + var(--spectrum-tray-exit-animation-duration)),transform var(--spectrum-tray-exit-animation-duration)cubic-bezier(.5,0,1,1)var(--spectrum-tray-exit-animation-delay);background-color:var(--spectrum-tray-background-color);outline:none;margin-block-start:var(--spectrum-tray-spacing-edge-to-tray-safe-zone);padding-block-start:var(--mod-tray-top-to-content-area,var(--spectrum-tray-top-to-content-area));padding-block-end:var(--mod-tray-bottom-to-content-area,var(--spectrum-tray-top-to-content-area));overflow:auto;transform:translateY(100%)}:host([open]) .tray{transition:transform var(--spectrum-tray-entry-animation-duration)cubic-bezier(0,0,.4,1)var(--spectrum-tray-entry-animation-delay),opacity var(--spectrum-tray-entry-animation-duration)cubic-bezier(0,0,.4,1)var(--spectrum-tray-entry-animation-delay);transform:translateY(0)}@media screen and (orientation:landscape){.tray{max-inline-size:var(--spectrum-tray-max-inline-size);border-start-start-radius:var(--spectrum-tray-corner-radius);border-start-end-radius:var(--spectrum-tray-corner-radius)}}@media (forced-colors:active){.tray{--highcontrast-tray-background-color:Canvas;border:solid}.tray ::slotted(*){border:none}}:host{align-items:flex-end;max-height:100dvh;position:fixed!important}sp-underlay{touch-action:none}.tray{overscroll-behavior:contain;display:inline-flex}::slotted(.visually-hidden){clip:rect(0,0,0,0);clip-path:inset(50%);white-space:nowrap;border:0;width:1px;height:1px;margin:0 -1px -1px 0;padding:0;position:absolute;overflow:hidden}
`;
    tray_css_default = r13;
  }
});

// node_modules/@spectrum-web-components/tray/src/Tray.js
var l10, p14, a9, Tray;
var init_Tray = __esm({
  "node_modules/@spectrum-web-components/tray/src/Tray.js"() {
    "use strict";
    init_src();
    init_decorators2();
    init_sp_underlay();
    init_first_focusable_in();
    init_MatchMedia();
    init_modal_css();
    init_tray_css();
    l10 = Object.defineProperty;
    p14 = Object.getOwnPropertyDescriptor;
    a9 = (s19, r25, e36, i21) => {
      for (var t34 = i21 > 1 ? void 0 : i21 ? p14(r25, e36) : r25, o52 = s19.length - 1, n25; o52 >= 0; o52--) (n25 = s19[o52]) && (t34 = (i21 ? n25(r25, e36, t34) : n25(t34)) || t34);
      return i21 && t34 && l10(r25, e36, t34), t34;
    };
    Tray = class extends SpectrumElement {
      constructor() {
        super(...arguments);
        this.open = false;
        this.prefersMotion = new MatchMediaController(this, "(prefers-reduced-motion: no-preference)");
        this.transitionPromise = Promise.resolve();
        this.resolveTransitionPromise = () => {
        };
        this.animating = false;
      }
      static get styles() {
        return [modal_css_default, tray_css_default];
      }
      focus() {
        const e36 = firstFocusableIn(this);
        e36 ? e36.focus() : this.children.length === 1 ? this.tray.focus() : super.focus();
      }
      overlayWillCloseCallback() {
        return this.open ? (this.close(), true) : this.animating;
      }
      close() {
        this.open = false, this.prefersMotion.matches || this.dispatchClosed();
      }
      dispatchClosed() {
        this.dispatchEvent(new Event("close", { bubbles: true }));
      }
      handleUnderlayTransitionend() {
        this.open || (this.resolveTransitionPromise(), this.dispatchClosed());
      }
      handleTrayTransitionend() {
        this.open && this.resolveTransitionPromise();
      }
      update(e36) {
        e36.has("open") && e36.get("open") !== void 0 && this.prefersMotion.matches && (this.animating = true, this.transitionPromise = new Promise((i21) => {
          this.resolveTransitionPromise = () => {
            this.animating = false, i21();
          };
        })), super.update(e36);
      }
      render() {
        return x`
            <sp-underlay
                ?open=${this.open}
                @close=${this.close}
                @transitionend=${this.handleUnderlayTransitionend}
            ></sp-underlay>
            <div
                class="tray modal"
                tabindex="-1"
                @transitionend=${this.handleTrayTransitionend}
            >
                <slot></slot>
            </div>
        `;
      }
      async getUpdateComplete() {
        const e36 = await super.getUpdateComplete();
        return await this.transitionPromise, e36;
      }
    };
    a9([n4({ type: Boolean, reflect: true })], Tray.prototype, "open", 2), a9([e5(".tray")], Tray.prototype, "tray", 2);
  }
});

// node_modules/@spectrum-web-components/tray/sp-tray.js
var sp_tray_exports = {};
var init_sp_tray = __esm({
  "node_modules/@spectrum-web-components/tray/sp-tray.js"() {
    "use strict";
    init_Tray();
    init_define_element();
    defineElement("sp-tray", Tray);
  }
});

// node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js
var SizeCache;
var init_SizeCache = __esm({
  "node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js"() {
    SizeCache = class {
      constructor(config) {
        this._map = /* @__PURE__ */ new Map();
        this._roundAverageSize = false;
        this.totalSize = 0;
        if (config?.roundAverageSize === true) {
          this._roundAverageSize = true;
        }
      }
      set(index, value) {
        const prev = this._map.get(index) || 0;
        this._map.set(index, value);
        this.totalSize += value - prev;
      }
      get averageSize() {
        if (this._map.size > 0) {
          const average = this.totalSize / this._map.size;
          return this._roundAverageSize ? Math.round(average) : average;
        }
        return 0;
      }
      getSize(index) {
        return this._map.get(index);
      }
      clear() {
        this._map.clear();
        this.totalSize = 0;
      }
    };
  }
});

// node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js
function dim1(direction) {
  return direction === "horizontal" ? "width" : "height";
}
var BaseLayout;
var init_BaseLayout = __esm({
  "node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js"() {
    BaseLayout = class {
      _getDefaultConfig() {
        return {
          direction: "vertical"
        };
      }
      constructor(hostSink, config) {
        this._latestCoords = { left: 0, top: 0 };
        this._direction = null;
        this._viewportSize = { width: 0, height: 0 };
        this.totalScrollSize = { width: 0, height: 0 };
        this.offsetWithinScroller = { left: 0, top: 0 };
        this._pendingReflow = false;
        this._pendingLayoutUpdate = false;
        this._pin = null;
        this._firstVisible = 0;
        this._lastVisible = 0;
        this._physicalMin = 0;
        this._physicalMax = 0;
        this._first = -1;
        this._last = -1;
        this._sizeDim = "height";
        this._secondarySizeDim = "width";
        this._positionDim = "top";
        this._secondaryPositionDim = "left";
        this._scrollPosition = 0;
        this._scrollError = 0;
        this._items = [];
        this._scrollSize = 1;
        this._overhang = 1e3;
        this._hostSink = hostSink;
        Promise.resolve().then(() => this.config = config || this._getDefaultConfig());
      }
      set config(config) {
        Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));
      }
      get config() {
        return {
          direction: this.direction
        };
      }
      /**
       * Maximum index of children + 1, to help estimate total height of the scroll
       * space.
       */
      get items() {
        return this._items;
      }
      set items(items) {
        this._setItems(items);
      }
      _setItems(items) {
        if (items !== this._items) {
          this._items = items;
          this._scheduleReflow();
        }
      }
      /**
       * Primary scrolling direction.
       */
      get direction() {
        return this._direction;
      }
      set direction(dir) {
        dir = dir === "horizontal" ? dir : "vertical";
        if (dir !== this._direction) {
          this._direction = dir;
          this._sizeDim = dir === "horizontal" ? "width" : "height";
          this._secondarySizeDim = dir === "horizontal" ? "height" : "width";
          this._positionDim = dir === "horizontal" ? "left" : "top";
          this._secondaryPositionDim = dir === "horizontal" ? "top" : "left";
          this._triggerReflow();
        }
      }
      /**
       * Height and width of the viewport.
       */
      get viewportSize() {
        return this._viewportSize;
      }
      set viewportSize(dims) {
        const { _viewDim1, _viewDim2 } = this;
        Object.assign(this._viewportSize, dims);
        if (_viewDim2 !== this._viewDim2) {
          this._scheduleLayoutUpdate();
        } else if (_viewDim1 !== this._viewDim1) {
          this._checkThresholds();
        }
      }
      /**
       * Scroll offset of the viewport.
       */
      get viewportScroll() {
        return this._latestCoords;
      }
      set viewportScroll(coords) {
        Object.assign(this._latestCoords, coords);
        const oldPos = this._scrollPosition;
        this._scrollPosition = this._latestCoords[this._positionDim];
        const change = Math.abs(oldPos - this._scrollPosition);
        if (change >= 1) {
          this._checkThresholds();
        }
      }
      /**
       * Perform a reflow if one has been scheduled.
       */
      reflowIfNeeded(force = false) {
        if (force || this._pendingReflow) {
          this._pendingReflow = false;
          this._reflow();
        }
      }
      set pin(options) {
        this._pin = options;
        this._triggerReflow();
      }
      get pin() {
        if (this._pin !== null) {
          const { index, block } = this._pin;
          return {
            index: Math.max(0, Math.min(index, this.items.length - 1)),
            block
          };
        }
        return null;
      }
      _clampScrollPosition(val) {
        return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));
      }
      unpin() {
        if (this._pin !== null) {
          this._sendUnpinnedMessage();
          this._pin = null;
        }
      }
      _updateLayout() {
      }
      // protected _viewDim2Changed(): void {
      //   this._scheduleLayoutUpdate();
      // }
      /**
       * The height or width of the viewport, whichever corresponds to the scrolling direction.
       */
      get _viewDim1() {
        return this._viewportSize[this._sizeDim];
      }
      /**
       * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.
       */
      get _viewDim2() {
        return this._viewportSize[this._secondarySizeDim];
      }
      _scheduleReflow() {
        this._pendingReflow = true;
      }
      _scheduleLayoutUpdate() {
        this._pendingLayoutUpdate = true;
        this._scheduleReflow();
      }
      // For triggering a reflow based on incoming changes to
      // the layout config.
      _triggerReflow() {
        this._scheduleLayoutUpdate();
        Promise.resolve().then(() => this.reflowIfNeeded());
      }
      _reflow() {
        if (this._pendingLayoutUpdate) {
          this._updateLayout();
          this._pendingLayoutUpdate = false;
        }
        this._updateScrollSize();
        this._setPositionFromPin();
        this._getActiveItems();
        this._updateVisibleIndices();
        this._sendStateChangedMessage();
      }
      /**
       * If we are supposed to be pinned to a particular
       * item or set of coordinates, we set `_scrollPosition`
       * accordingly and adjust `_scrollError` as needed
       * so that the virtualizer can keep the scroll
       * position in the DOM in sync
       */
      _setPositionFromPin() {
        if (this.pin !== null) {
          const lastScrollPosition = this._scrollPosition;
          const { index, block } = this.pin;
          this._scrollPosition = this._calculateScrollIntoViewPosition({
            index,
            block: block || "start"
          }) - this.offsetWithinScroller[this._positionDim];
          this._scrollError = lastScrollPosition - this._scrollPosition;
        }
      }
      /**
       * Calculate the coordinates to scroll to, given
       * a request to scroll to the element at a specific
       * index.
       *
       * Supports the same positioning options (`start`,
       * `center`, `end`, `nearest`) as the standard
       * `Element.scrollIntoView()` method, but currently
       * only considers the provided value in the `block`
       * dimension, since we don't yet have any layouts
       * that support virtualization in two dimensions.
       */
      _calculateScrollIntoViewPosition(options) {
        const { block } = options;
        const index = Math.min(this.items.length, Math.max(0, options.index));
        const itemStartPosition = this._getItemPosition(index)[this._positionDim];
        let scrollPosition = itemStartPosition;
        if (block !== "start") {
          const itemSize = this._getItemSize(index)[this._sizeDim];
          if (block === "center") {
            scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;
          } else {
            const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;
            if (block === "end") {
              scrollPosition = itemEndPosition;
            } else {
              const currentScrollPosition = this._scrollPosition;
              scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;
            }
          }
        }
        scrollPosition += this.offsetWithinScroller[this._positionDim];
        return this._clampScrollPosition(scrollPosition);
      }
      getScrollIntoViewCoordinates(options) {
        return {
          [this._positionDim]: this._calculateScrollIntoViewPosition(options)
        };
      }
      _sendUnpinnedMessage() {
        this._hostSink({
          type: "unpinned"
        });
      }
      _sendVisibilityChangedMessage() {
        this._hostSink({
          type: "visibilityChanged",
          firstVisible: this._firstVisible,
          lastVisible: this._lastVisible
        });
      }
      _sendStateChangedMessage() {
        const childPositions = /* @__PURE__ */ new Map();
        if (this._first !== -1 && this._last !== -1) {
          for (let idx = this._first; idx <= this._last; idx++) {
            childPositions.set(idx, this._getItemPosition(idx));
          }
        }
        const message = {
          type: "stateChanged",
          scrollSize: {
            [this._sizeDim]: this._scrollSize,
            [this._secondarySizeDim]: null
          },
          range: {
            first: this._first,
            last: this._last,
            firstVisible: this._firstVisible,
            lastVisible: this._lastVisible
          },
          childPositions
        };
        if (this._scrollError) {
          message.scrollError = {
            [this._positionDim]: this._scrollError,
            [this._secondaryPositionDim]: 0
          };
          this._scrollError = 0;
        }
        this._hostSink(message);
      }
      /**
       * Number of items to display.
       */
      get _num() {
        if (this._first === -1 || this._last === -1) {
          return 0;
        }
        return this._last - this._first + 1;
      }
      _checkThresholds() {
        if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {
          this._scheduleReflow();
        } else {
          const min2 = Math.max(0, this._scrollPosition - this._overhang);
          const max2 = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);
          if (this._physicalMin > min2 || this._physicalMax < max2) {
            this._scheduleReflow();
          } else {
            this._updateVisibleIndices({ emit: true });
          }
        }
      }
      /**
       * Find the indices of the first and last items to intersect the viewport.
       * Emit a visibleindiceschange event when either index changes.
       */
      _updateVisibleIndices(options) {
        if (this._first === -1 || this._last === -1)
          return;
        let firstVisible = this._first;
        while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {
          firstVisible++;
        }
        let lastVisible = this._last;
        while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {
          lastVisible--;
        }
        if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {
          this._firstVisible = firstVisible;
          this._lastVisible = lastVisible;
          if (options && options.emit) {
            this._sendVisibilityChangedMessage();
          }
        }
      }
    };
  }
});

// node_modules/@lit-labs/virtualizer/layouts/flow.js
var flow_exports = {};
__export(flow_exports, {
  FlowLayout: () => FlowLayout,
  flow: () => flow
});
function leadingMargin(direction) {
  return direction === "horizontal" ? "marginLeft" : "marginTop";
}
function trailingMargin(direction) {
  return direction === "horizontal" ? "marginRight" : "marginBottom";
}
function offset3(direction) {
  return direction === "horizontal" ? "xOffset" : "yOffset";
}
function collapseMargins(a23, b12) {
  const m18 = [a23, b12].sort();
  return m18[1] <= 0 ? Math.min(...m18) : m18[0] >= 0 ? Math.max(...m18) : m18[0] + m18[1];
}
var flow, MetricsCache, FlowLayout;
var init_flow = __esm({
  "node_modules/@lit-labs/virtualizer/layouts/flow.js"() {
    init_SizeCache();
    init_BaseLayout();
    flow = (config) => Object.assign({
      type: FlowLayout
    }, config);
    MetricsCache = class {
      constructor() {
        this._childSizeCache = new SizeCache();
        this._marginSizeCache = new SizeCache();
        this._metricsCache = /* @__PURE__ */ new Map();
      }
      update(metrics, direction) {
        const marginsToUpdate = /* @__PURE__ */ new Set();
        Object.keys(metrics).forEach((key) => {
          const k2 = Number(key);
          this._metricsCache.set(k2, metrics[k2]);
          this._childSizeCache.set(k2, metrics[k2][dim1(direction)]);
          marginsToUpdate.add(k2);
          marginsToUpdate.add(k2 + 1);
        });
        for (const k2 of marginsToUpdate) {
          const a23 = this._metricsCache.get(k2)?.[leadingMargin(direction)] || 0;
          const b12 = this._metricsCache.get(k2 - 1)?.[trailingMargin(direction)] || 0;
          this._marginSizeCache.set(k2, collapseMargins(a23, b12));
        }
      }
      get averageChildSize() {
        return this._childSizeCache.averageSize;
      }
      get totalChildSize() {
        return this._childSizeCache.totalSize;
      }
      get averageMarginSize() {
        return this._marginSizeCache.averageSize;
      }
      get totalMarginSize() {
        return this._marginSizeCache.totalSize;
      }
      getLeadingMarginValue(index, direction) {
        return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;
      }
      getChildSize(index) {
        return this._childSizeCache.getSize(index);
      }
      getMarginSize(index) {
        return this._marginSizeCache.getSize(index);
      }
      clear() {
        this._childSizeCache.clear();
        this._marginSizeCache.clear();
        this._metricsCache.clear();
      }
    };
    FlowLayout = class extends BaseLayout {
      constructor() {
        super(...arguments);
        this._itemSize = { width: 100, height: 100 };
        this._physicalItems = /* @__PURE__ */ new Map();
        this._newPhysicalItems = /* @__PURE__ */ new Map();
        this._metricsCache = new MetricsCache();
        this._anchorIdx = null;
        this._anchorPos = null;
        this._stable = true;
        this._measureChildren = true;
        this._estimate = true;
      }
      // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {
      // })
      // constructor(config: Layout1dConfig) {
      //   super(config);
      // }
      get measureChildren() {
        return this._measureChildren;
      }
      /**
       * Determine the average size of all children represented in the sizes
       * argument.
       */
      updateItemSizes(sizes) {
        this._metricsCache.update(sizes, this.direction);
        this._scheduleReflow();
      }
      /**
       * Set the average item size based on the total length and number of children
       * in range.
       */
      // _updateItemSize() {
      //   // Keep integer values.
      //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;
      // }
      _getPhysicalItem(idx) {
        return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);
      }
      _getSize(idx) {
        const item = this._getPhysicalItem(idx);
        return item && this._metricsCache.getChildSize(idx);
      }
      _getAverageSize() {
        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];
      }
      _estimatePosition(idx) {
        const c33 = this._metricsCache;
        if (this._first === -1 || this._last === -1) {
          return c33.averageMarginSize + idx * (c33.averageMarginSize + this._getAverageSize());
        } else {
          if (idx < this._first) {
            const delta = this._first - idx;
            const refItem = this._getPhysicalItem(this._first);
            return refItem.pos - (c33.getMarginSize(this._first - 1) || c33.averageMarginSize) - (delta * c33.averageChildSize + (delta - 1) * c33.averageMarginSize);
          } else {
            const delta = idx - this._last;
            const refItem = this._getPhysicalItem(this._last);
            return refItem.pos + (c33.getChildSize(this._last) || c33.averageChildSize) + (c33.getMarginSize(this._last) || c33.averageMarginSize) + delta * (c33.averageChildSize + c33.averageMarginSize);
          }
        }
      }
      /**
       * Returns the position in the scrolling direction of the item at idx.
       * Estimates it if the item at idx is not in the DOM.
       */
      _getPosition(idx) {
        const item = this._getPhysicalItem(idx);
        const { averageMarginSize } = this._metricsCache;
        return idx === 0 ? this._metricsCache.getMarginSize(0) ?? averageMarginSize : item ? item.pos : this._estimatePosition(idx);
      }
      _calculateAnchor(lower, upper) {
        if (lower <= 0) {
          return 0;
        }
        if (upper > this._scrollSize - this._viewDim1) {
          return this.items.length - 1;
        }
        return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));
      }
      _getAnchor(lower, upper) {
        if (this._physicalItems.size === 0) {
          return this._calculateAnchor(lower, upper);
        }
        if (this._first < 0) {
          return this._calculateAnchor(lower, upper);
        }
        if (this._last < 0) {
          return this._calculateAnchor(lower, upper);
        }
        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);
        if (lastMax < lower) {
          return this._calculateAnchor(lower, upper);
        }
        if (firstMin > upper) {
          return this._calculateAnchor(lower, upper);
        }
        let candidateIdx = this._firstVisible - 1;
        let cMax = -Infinity;
        while (cMax < lower) {
          const candidate = this._getPhysicalItem(++candidateIdx);
          cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);
        }
        return candidateIdx;
      }
      /**
       * Updates _first and _last based on items that should be in the current
       * viewed range.
       */
      _getActiveItems() {
        if (this._viewDim1 === 0 || this.items.length === 0) {
          this._clearItems();
        } else {
          this._getItems();
        }
      }
      /**
       * Sets the range to empty.
       */
      _clearItems() {
        this._first = -1;
        this._last = -1;
        this._physicalMin = 0;
        this._physicalMax = 0;
        const items = this._newPhysicalItems;
        this._newPhysicalItems = this._physicalItems;
        this._newPhysicalItems.clear();
        this._physicalItems = items;
        this._stable = true;
      }
      /*
       * Updates _first and _last based on items that should be in the given range.
       */
      _getItems() {
        const items = this._newPhysicalItems;
        this._stable = true;
        let lower, upper;
        if (this.pin !== null) {
          const { index } = this.pin;
          this._anchorIdx = index;
          this._anchorPos = this._getPosition(index);
        }
        lower = this._scrollPosition - this._overhang;
        upper = this._scrollPosition + this._viewDim1 + this._overhang;
        if (upper < 0 || lower > this._scrollSize) {
          this._clearItems();
          return;
        }
        if (this._anchorIdx === null || this._anchorPos === null) {
          this._anchorIdx = this._getAnchor(lower, upper);
          this._anchorPos = this._getPosition(this._anchorIdx);
        }
        let anchorSize = this._getSize(this._anchorIdx);
        if (anchorSize === void 0) {
          this._stable = false;
          anchorSize = this._getAverageSize();
        }
        const anchorLeadingMargin = this._metricsCache.getMarginSize(this._anchorIdx) ?? this._metricsCache.averageMarginSize;
        const anchorTrailingMargin = this._metricsCache.getMarginSize(this._anchorIdx + 1) ?? this._metricsCache.averageMarginSize;
        if (this._anchorIdx === 0) {
          this._anchorPos = anchorLeadingMargin;
        }
        if (this._anchorIdx === this.items.length - 1) {
          this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;
        }
        let anchorErr = 0;
        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {
          anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);
        }
        if (this._anchorPos - anchorLeadingMargin > upper) {
          anchorErr = upper - (this._anchorPos - anchorLeadingMargin);
        }
        if (anchorErr) {
          this._scrollPosition -= anchorErr;
          lower -= anchorErr;
          upper -= anchorErr;
          this._scrollError += anchorErr;
        }
        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });
        this._first = this._last = this._anchorIdx;
        this._physicalMin = this._anchorPos - anchorLeadingMargin;
        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;
        while (this._physicalMin > lower && this._first > 0) {
          let size3 = this._getSize(--this._first);
          if (size3 === void 0) {
            this._stable = false;
            size3 = this._getAverageSize();
          }
          let margin = this._metricsCache.getMarginSize(this._first);
          if (margin === void 0) {
            this._stable = false;
            margin = this._metricsCache.averageMarginSize;
          }
          this._physicalMin -= size3;
          const pos = this._physicalMin;
          items.set(this._first, { pos, size: size3 });
          this._physicalMin -= margin;
          if (this._stable === false && this._estimate === false) {
            break;
          }
        }
        while (this._physicalMax < upper && this._last < this.items.length - 1) {
          let size3 = this._getSize(++this._last);
          if (size3 === void 0) {
            this._stable = false;
            size3 = this._getAverageSize();
          }
          let margin = this._metricsCache.getMarginSize(this._last);
          if (margin === void 0) {
            this._stable = false;
            margin = this._metricsCache.averageMarginSize;
          }
          const pos = this._physicalMax;
          items.set(this._last, { pos, size: size3 });
          this._physicalMax += size3 + margin;
          if (!this._stable && !this._estimate) {
            break;
          }
        }
        const extentErr = this._calculateError();
        if (extentErr) {
          this._physicalMin -= extentErr;
          this._physicalMax -= extentErr;
          this._anchorPos -= extentErr;
          this._scrollPosition -= extentErr;
          items.forEach((item) => item.pos -= extentErr);
          this._scrollError += extentErr;
        }
        if (this._stable) {
          this._newPhysicalItems = this._physicalItems;
          this._newPhysicalItems.clear();
          this._physicalItems = items;
        }
      }
      _calculateError() {
        if (this._first === 0) {
          return this._physicalMin;
        } else if (this._physicalMin <= 0) {
          return this._physicalMin - this._first * this._delta;
        } else if (this._last === this.items.length - 1) {
          return this._physicalMax - this._scrollSize;
        } else if (this._physicalMax >= this._scrollSize) {
          return this._physicalMax - this._scrollSize + (this.items.length - 1 - this._last) * this._delta;
        }
        return 0;
      }
      _reflow() {
        const { _first, _last } = this;
        super._reflow();
        if (this._first === -1 && this._last == -1 || this._first === _first && this._last === _last) {
          this._resetReflowState();
        }
      }
      _resetReflowState() {
        this._anchorIdx = null;
        this._anchorPos = null;
        this._stable = true;
      }
      _updateScrollSize() {
        const { averageMarginSize } = this._metricsCache;
        this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) + averageMarginSize);
      }
      /**
       * Returns the average size (precise or estimated) of an item in the scrolling direction,
       * including any surrounding space.
       */
      get _delta() {
        const { averageMarginSize } = this._metricsCache;
        return this._getAverageSize() + averageMarginSize;
      }
      /**
       * Returns the top and left positioning of the item at idx.
       */
      _getItemPosition(idx) {
        return {
          [this._positionDim]: this._getPosition(idx),
          [this._secondaryPositionDim]: 0,
          [offset3(this.direction)]: -(this._metricsCache.getLeadingMarginValue(idx, this.direction) ?? this._metricsCache.averageMarginSize)
        };
      }
      /**
       * Returns the height and width of the item at idx.
       */
      _getItemSize(idx) {
        return {
          [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),
          [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim]
        };
      }
      _viewDim2Changed() {
        this._metricsCache.clear();
        this._scheduleReflow();
      }
    };
  }
});

// node_modules/picosm/dist/picosm.js
function instrumentAction(prototype, methodName) {
  const descriptor = Object.getOwnPropertyDescriptor(prototype, methodName);
  if (descriptor && typeof descriptor.value === "function") {
    const originalMethod = descriptor.value;
    descriptor.value = originalMethod.constructor.name === "AsyncFunction" ? async function(...args) {
      const response = await originalMethod.call(this, ...args);
      this.__resetComputedProperties();
      this.__notifyObservers();
      return response;
    } : function(...args) {
      const response = originalMethod.call(this, ...args);
      this.__resetComputedProperties();
      this.__notifyObservers();
      return response;
    };
    Object.defineProperty(prototype, methodName, descriptor);
  }
}
function instrumentComputed(prototype, getterName) {
  const descriptor = Object.getOwnPropertyDescriptor(prototype, getterName);
  if (descriptor && typeof descriptor.get === "function") {
    const originalGetter = descriptor.get;
    descriptor.get = function() {
      if (!this.__computedProperties) {
        Object.defineProperty(this, "__computedProperties", {
          value: /* @__PURE__ */ new Map(),
          enumerable: false,
          writable: false
        });
      }
      if (this.__computedProperties.has(getterName)) {
        return this.__computedProperties.get(getterName);
      }
      const cachedValue = originalGetter.call(this);
      this.__computedProperties.set(getterName, cachedValue);
      return cachedValue;
    };
    Object.defineProperty(prototype, getterName, descriptor);
  }
}
function definePrivateProperty(instance, propertyName, initialValue) {
  Object.defineProperty(instance, propertyName, {
    value: initialValue,
    enumerable: false,
    writable: false
  });
}
function makeObservable(constructor) {
  Object.assign(constructor.prototype, {
    __notifyObservers() {
      this.__observers?.forEach((listener) => listener());
    },
    __resetComputedProperties() {
      this.__computedProperties?.clear();
    },
    __observe(callback) {
      if (!this.__observers) {
        definePrivateProperty(this, "__observers", /* @__PURE__ */ new Set());
      }
      this.__observers.add(callback);
      return () => this.__observers.delete(callback);
    },
    __subscribe(onMessageCallback) {
      if (!this.__subscribers) {
        definePrivateProperty(this, "__subscribers", /* @__PURE__ */ new Set());
      }
      this.__subscribers.add(onMessageCallback);
      return () => this.__subscribers.delete(onMessageCallback);
    }
  });
  const observableActions = constructor.observableActions ?? [];
  observableActions.forEach(
    (methodName) => instrumentAction(constructor.prototype, methodName)
  );
  const computedProperties = constructor.computedProperties ?? [];
  computedProperties.forEach(
    (propertyName) => instrumentComputed(constructor.prototype, propertyName)
  );
}
function observeSlow(target, callback, timeout) {
  let isThrottled = false;
  let pendingCallback = false;
  const listener = () => {
    if (isThrottled) {
      pendingCallback = true;
      return;
    }
    callback();
    isThrottled = true;
    setTimeout(() => {
      isThrottled = false;
      if (pendingCallback) {
        pendingCallback = false;
        callback();
      }
    }, timeout);
  };
  return target.__observe(listener);
}
function observe(target, callback, timeout) {
  return timeout ? observeSlow(target, callback, timeout) : target.__observe(callback);
}
function subscribe(target, onMessageCallback) {
  return target.__subscribe(onMessageCallback);
}
function notify(target, message) {
  target.__subscribers?.forEach((listener) => listener(message));
}
function reaction(targetOrTargets, callback, execute, timeout) {
  let lastProps = [];
  const targets = Array.isArray(targetOrTargets) ? targetOrTargets : [targetOrTargets];
  const runner = () => {
    const props = targets.length === 1 ? callback(targets[0]) : callback(...targets);
    if (lastProps === props) return;
    let shouldExecute = false;
    for (let i21 = 0; i21 < props.length; i21++) {
      if (lastProps[i21] !== props[i21]) {
        shouldExecute = true;
        break;
      }
    }
    if (shouldExecute) {
      lastProps = props;
      execute(...props);
    }
  };
  const disposers = targets.map((t34) => observe(t34, runner, timeout));
  return () => disposers.forEach((d22) => d22());
}
function track(target, source) {
  const disposer = source.__observe?.(() => {
    target.__resetComputedProperties();
    target.__notifyObservers();
  });
  target.__resetComputedProperties();
  target.__notifyObservers();
  return disposer;
}
var ObserverController = class {
  constructor(host) {
    this.host = host;
    this.disposers = /* @__PURE__ */ new Map();
    host.addController(this);
    const constructor = this.host.constructor;
    const descriptor = Object.getOwnPropertyDescriptor(
      constructor,
      "properties"
    );
    this.getProperties = () => {
      if (descriptor && descriptor.get) {
        return constructor.properties || {};
      }
      return constructor.hasOwnProperty("properties") ? constructor.properties : {};
    };
  }
  hostConnected() {
    const props = this.getProperties();
    for (const [propName, config] of Object.entries(props)) {
      this.setupObserver(propName, this.host[propName], config);
    }
  }
  hostDisconnected() {
    for (const disposer of this.disposers.values()) {
      disposer();
    }
    this.disposers.clear();
  }
  hostUpdate() {
    const props = this.getProperties();
    for (const [propName, config] of Object.entries(props)) {
      if (config && config.observe !== false) {
        const currentValue = this.host[propName];
        this.setupObserver(propName, currentValue, config);
      }
    }
  }
  setupObserver(propName, value, config) {
    const oldDisposer = this.disposers.get(propName);
    const shouldObserve = config?.observe === true && value !== null && value !== void 0 && typeof value === "object";
    if (oldDisposer && !shouldObserve) {
      oldDisposer();
      this.disposers.delete(propName);
    }
    if (shouldObserve && !this.disposers.has(propName)) {
      const callback = () => this.host.requestUpdate();
      const disposer = observe(value, callback, config.throttle);
      this.disposers.set(propName, disposer);
    }
  }
};
function makeLitObserver(constructor) {
  const originalConnectedCallback = constructor.prototype.connectedCallback;
  constructor.prototype.connectedCallback = function() {
    if (!this.__observer) {
      this.__observer = new ObserverController(this);
    }
    if (originalConnectedCallback) {
      originalConnectedCallback.call(this);
    }
  };
  return constructor;
}

// node_modules/@spectrum-web-components/theme/src/Theme.js
init_version();

// node_modules/@spectrum-web-components/theme/src/theme-interfaces.js
var SYSTEM_VARIANT_VALUES = ["spectrum", "express", "spectrum-two"];
var SCALE_VALUES = ["medium", "large", "medium-express", "large-express", "medium-spectrum-two", "large-spectrum-two"];
var COLOR_VALUES = ["light", "lightest", "dark", "darkest", "light-express", "lightest-express", "dark-express", "darkest-express", "light-spectrum-two", "lightest-spectrum-two", "dark-spectrum-two", "darkest-spectrum-two"];

// node_modules/@spectrum-web-components/theme/src/Theme.js
var o = class o2 extends HTMLElement {
  constructor() {
    super();
    this._dir = "";
    this._system = "spectrum";
    this._color = "";
    this._scale = "";
    this._systemContextConsumers = /* @__PURE__ */ new Map();
    this.trackedChildren = /* @__PURE__ */ new Set();
    this._updateRequested = false;
    this._contextConsumers = /* @__PURE__ */ new Map();
    this.attachShadow({ mode: "open" });
    const e36 = document.importNode(o2.template.content, true);
    this.shadowRoot.appendChild(e36), this.shouldAdoptStyles(), this.addEventListener("sp-language-context", this._handleContextPresence), this.addEventListener("sp-system-context", this._handleSystemContext), this.updateComplete = this.__createDeferredPromise();
  }
  static get observedAttributes() {
    return ["color", "scale", "lang", "dir", "system"];
  }
  set dir(e36) {
    if (e36 === this.dir) return;
    this.setAttribute("dir", e36), this._dir = e36;
    const t34 = e36 === "rtl" ? e36 : "ltr";
    this.trackedChildren.forEach((s19) => {
      s19.setAttribute("dir", t34);
    });
  }
  get dir() {
    return this._dir;
  }
  attributeChangedCallback(e36, t34, s19) {
    t34 !== s19 && (e36 === "color" ? this.color = s19 : e36 === "scale" ? this.scale = s19 : e36 === "lang" && s19 ? (this.lang = s19, this._provideContext()) : e36 === "system" ? (this.system = s19, this._provideSystemContext()) : e36 === "dir" && (this.dir = s19));
  }
  requestUpdate() {
    this.shouldAdoptStyles();
  }
  get system() {
    const e36 = o2.themeFragmentsByKind.get("system"), { name: t34 } = e36 && e36.get("default") || {};
    return this._system || t34 || "";
  }
  set system(e36) {
    if (e36 === this._system) return;
    const t34 = e36 && SYSTEM_VARIANT_VALUES.includes(e36) ? e36 : this.system;
    t34 !== this._system && (this._system = t34, this.requestUpdate()), t34 ? this.setAttribute("system", t34) : this.removeAttribute("system");
  }
  get color() {
    const e36 = o2.themeFragmentsByKind.get("color"), { name: t34 } = e36 && e36.get("default") || {};
    return this._color || t34 || "";
  }
  set color(e36) {
    if (e36 === this._color) return;
    const t34 = e36 && COLOR_VALUES.includes(e36) ? e36 : this.color;
    t34 !== this._color && (this._color = t34, this.requestUpdate()), t34 ? this.setAttribute("color", t34) : this.removeAttribute("color");
  }
  get scale() {
    const e36 = o2.themeFragmentsByKind.get("scale"), { name: t34 } = e36 && e36.get("default") || {};
    return this._scale || t34 || "";
  }
  set scale(e36) {
    if (e36 === this._scale) return;
    const t34 = e36 && SCALE_VALUES.includes(e36) ? e36 : this.scale;
    t34 !== this._scale && (this._scale = t34, this.requestUpdate()), t34 ? this.setAttribute("scale", t34) : this.removeAttribute("scale");
  }
  get styles() {
    const e36 = [...o2.themeFragmentsByKind.keys()], t34 = (a23, i21, n25) => {
      const l16 = n25 && n25 !== "system" && this.system !== "spectrum" ? a23.get(`${i21}-${this.system}`) : a23.get(i21), m18 = i21 === "spectrum" || !n25 || this.hasAttribute(n25);
      if (l16 && m18) return l16.styles;
    }, s19 = e36.reduce((a23, i21) => {
      const n25 = o2.themeFragmentsByKind.get(i21);
      let l16;
      if (i21 === "app" || i21 === "core") l16 = t34(n25, i21);
      else {
        const { [i21]: m18 } = this;
        l16 = t34(n25, m18, i21);
      }
      return l16 && a23.push(l16), a23;
    }, []), r25 = o2.themeFragmentsByKind;
    return this.system, this.color, this.scale, [...s19];
  }
  static get template() {
    return this.templateElement || (this.templateElement = document.createElement("template"), this.templateElement.innerHTML = "<slot></slot>"), this.templateElement;
  }
  _handleSystemContext(e36) {
    e36.stopPropagation();
    const t34 = e36.composedPath()[0];
    if (this._systemContextConsumers.has(t34)) return;
    const s19 = () => this._systemContextConsumers.delete(t34);
    this._systemContextConsumers.set(t34, [e36.detail.callback, s19]);
    const [r25] = this._systemContextConsumers.get(t34) || [];
    r25 && r25(this.system, s19);
  }
  __createDeferredPromise() {
    return new Promise((e36) => {
      this.__resolve = e36;
    });
  }
  connectedCallback() {
    if (this.shouldAdoptStyles(), o2.instances.add(this), !this.hasAttribute("dir")) {
      let e36 = this.assignedSlot || this.parentNode;
      for (; e36 !== document.documentElement && !(e36 instanceof o2); ) e36 = e36.assignedSlot || e36.parentNode || e36.host;
      this.dir = e36.dir === "rtl" ? e36.dir : "ltr";
    }
  }
  disconnectedCallback() {
    o2.instances.delete(this);
  }
  startManagingContentDirection(e36) {
    this.trackedChildren.add(e36);
  }
  stopManagingContentDirection(e36) {
    this.trackedChildren.delete(e36);
  }
  async shouldAdoptStyles() {
    this._updateRequested || (this.updateComplete = this.__createDeferredPromise(), this._updateRequested = true, this._updateRequested = await false, this.adoptStyles(), this.__resolve(true));
  }
  adoptStyles() {
    const e36 = this.styles, t34 = [];
    for (const s19 of e36) t34.push(s19.styleSheet);
    this.shadowRoot.adoptedStyleSheets = t34;
  }
  static registerThemeFragment(e36, t34, s19) {
    const r25 = o2.themeFragmentsByKind.get(t34) || /* @__PURE__ */ new Map();
    r25.size === 0 && (o2.themeFragmentsByKind.set(t34, r25), r25.set("default", { name: e36, styles: s19 }), o2.defaultFragments.add(e36)), r25.set(e36, { name: e36, styles: s19 }), o2.instances.forEach((a23) => a23.shouldAdoptStyles());
  }
  _provideContext() {
    this._contextConsumers.forEach(([e36, t34]) => e36(this.lang, t34));
  }
  _provideSystemContext() {
    this._systemContextConsumers.forEach(([e36, t34]) => e36(this.system, t34));
  }
  _handleContextPresence(e36) {
    e36.stopPropagation();
    const t34 = e36.composedPath()[0];
    if (this._contextConsumers.has(t34)) return;
    this._contextConsumers.set(t34, [e36.detail.callback, () => this._contextConsumers.delete(t34)]);
    const [s19, r25] = this._contextConsumers.get(t34) || [];
    s19 && r25 && s19(this.lang || document.documentElement.lang || navigator.language, r25);
  }
};
o.themeFragmentsByKind = /* @__PURE__ */ new Map(), o.defaultFragments = /* @__PURE__ */ new Set(["spectrum"]), o.instances = /* @__PURE__ */ new Set(), o.VERSION = version;
var Theme = o;

// node_modules/@spectrum-web-components/theme/sp-theme.js
customElements.define("sp-theme", Theme);

// node_modules/@spectrum-web-components/theme/src/spectrum-two/scale-medium.css.js
init_src();
var e6 = i`
    :root,:host{--spectrum-global-dimension-scale-factor:1;--spectrum-global-dimension-size-0:0px;--spectrum-global-dimension-size-10:1px;--spectrum-global-dimension-size-25:2px;--spectrum-global-dimension-size-30:2px;--spectrum-global-dimension-size-40:3px;--spectrum-global-dimension-size-50:4px;--spectrum-global-dimension-size-65:5px;--spectrum-global-dimension-size-75:6px;--spectrum-global-dimension-size-85:7px;--spectrum-global-dimension-size-100:8px;--spectrum-global-dimension-size-115:9px;--spectrum-global-dimension-size-125:10px;--spectrum-global-dimension-size-130:11px;--spectrum-global-dimension-size-150:12px;--spectrum-global-dimension-size-160:13px;--spectrum-global-dimension-size-175:14px;--spectrum-global-dimension-size-185:15px;--spectrum-global-dimension-size-200:16px;--spectrum-global-dimension-size-225:18px;--spectrum-global-dimension-size-250:20px;--spectrum-global-dimension-size-275:22px;--spectrum-global-dimension-size-300:24px;--spectrum-global-dimension-size-325:26px;--spectrum-global-dimension-size-350:28px;--spectrum-global-dimension-size-400:32px;--spectrum-global-dimension-size-450:36px;--spectrum-global-dimension-size-500:40px;--spectrum-global-dimension-size-550:44px;--spectrum-global-dimension-size-600:48px;--spectrum-global-dimension-size-650:52px;--spectrum-global-dimension-size-675:54px;--spectrum-global-dimension-size-700:56px;--spectrum-global-dimension-size-750:60px;--spectrum-global-dimension-size-800:64px;--spectrum-global-dimension-size-900:72px;--spectrum-global-dimension-size-1000:80px;--spectrum-global-dimension-size-1125:90px;--spectrum-global-dimension-size-1200:96px;--spectrum-global-dimension-size-1250:100px;--spectrum-global-dimension-size-1600:128px;--spectrum-global-dimension-size-1700:136px;--spectrum-global-dimension-size-1800:144px;--spectrum-global-dimension-size-2000:160px;--spectrum-global-dimension-size-2400:192px;--spectrum-global-dimension-size-2500:200px;--spectrum-global-dimension-size-3000:240px;--spectrum-global-dimension-size-3400:272px;--spectrum-global-dimension-size-3600:288px;--spectrum-global-dimension-size-4600:368px;--spectrum-global-dimension-size-5000:400px;--spectrum-global-dimension-size-6000:480px;--spectrum-global-dimension-font-size-25:10px;--spectrum-global-dimension-font-size-50:11px;--spectrum-global-dimension-font-size-75:12px;--spectrum-global-dimension-font-size-100:14px;--spectrum-global-dimension-font-size-150:15px;--spectrum-global-dimension-font-size-200:16px;--spectrum-global-dimension-font-size-300:18px;--spectrum-global-dimension-font-size-400:20px;--spectrum-global-dimension-font-size-500:22px;--spectrum-global-dimension-font-size-600:25px;--spectrum-global-dimension-font-size-700:28px;--spectrum-global-dimension-font-size-800:32px;--spectrum-global-dimension-font-size-900:36px;--spectrum-global-dimension-font-size-1000:40px;--spectrum-global-dimension-font-size-1100:45px;--spectrum-global-dimension-font-size-1200:50px;--spectrum-global-dimension-font-size-1300:60px;--spectrum-alias-item-text-padding-top-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-text-padding-bottom-s:var(--spectrum-global-dimension-static-size-65);--spectrum-alias-item-workflow-padding-left-m:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-rounded-workflow-padding-left-m:var(--spectrum-global-dimension-size-175);--spectrum-alias-item-rounded-workflow-padding-left-xl:21px;--spectrum-alias-item-mark-padding-top-m:var(--spectrum-global-dimension-static-size-75);--spectrum-alias-item-mark-padding-bottom-m:var(--spectrum-global-dimension-static-size-75);--spectrum-alias-item-mark-padding-left-m:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-control-1-size-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-control-1-size-xl:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-control-2-size-s:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-control-3-height-s:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-control-3-width-s:23px;--spectrum-alias-item-control-3-width-m:var(--spectrum-global-dimension-static-size-325);--spectrum-alias-item-control-3-width-l:29px;--spectrum-alias-item-control-3-width-xl:33px;--spectrum-alias-item-mark-size-m:var(--spectrum-global-dimension-size-250);--spectrum-alias-component-focusring-border-radius:var(--spectrum-global-dimension-static-size-65);--spectrum-alias-control-two-size-s:var(--spectrum-global-dimension-size-150);--spectrum-alias-control-three-height-s:var(--spectrum-global-dimension-size-150);--spectrum-alias-control-three-width-s:23px;--spectrum-alias-control-three-width-m:var(--spectrum-global-dimension-static-size-325);--spectrum-alias-control-three-width-l:29px;--spectrum-alias-control-three-width-xl:33px;--spectrum-alias-search-padding-left-m:var(--spectrum-global-dimension-size-125);--spectrum-alias-focus-ring-border-radius-regular:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-focus-ring-radius-default:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-workflow-icon-size-l:var(--spectrum-global-dimension-static-size-250);--spectrum-alias-ui-icon-chevron-size-75:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-chevron-size-100:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-chevron-size-200:var(--spectrum-global-dimension-static-size-150);--spectrum-alias-ui-icon-chevron-size-300:var(--spectrum-global-dimension-static-size-175);--spectrum-alias-ui-icon-chevron-size-400:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-ui-icon-chevron-size-500:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-ui-icon-checkmark-size-50:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-checkmark-size-75:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-checkmark-size-100:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-checkmark-size-200:var(--spectrum-global-dimension-static-size-150);--spectrum-alias-ui-icon-checkmark-size-300:var(--spectrum-global-dimension-static-size-175);--spectrum-alias-ui-icon-checkmark-size-400:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-ui-icon-checkmark-size-500:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-ui-icon-checkmark-size-600:var(--spectrum-global-dimension-static-size-225);--spectrum-alias-ui-icon-dash-size-50:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-ui-icon-dash-size-75:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-ui-icon-dash-size-100:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-dash-size-200:var(--spectrum-global-dimension-static-size-150);--spectrum-alias-ui-icon-dash-size-300:var(--spectrum-global-dimension-static-size-150);--spectrum-alias-ui-icon-dash-size-400:var(--spectrum-global-dimension-static-size-175);--spectrum-alias-ui-icon-dash-size-500:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-ui-icon-dash-size-600:var(--spectrum-global-dimension-static-size-225);--spectrum-alias-ui-icon-cross-size-75:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-ui-icon-cross-size-100:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-ui-icon-cross-size-200:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-cross-size-300:var(--spectrum-global-dimension-static-size-150);--spectrum-alias-ui-icon-cross-size-400:var(--spectrum-global-dimension-static-size-150);--spectrum-alias-ui-icon-cross-size-500:var(--spectrum-global-dimension-static-size-175);--spectrum-alias-ui-icon-cross-size-600:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-ui-icon-arrow-size-75:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-arrow-size-100:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-arrow-size-200:var(--spectrum-global-dimension-static-size-150);--spectrum-alias-ui-icon-arrow-size-300:var(--spectrum-global-dimension-static-size-175);--spectrum-alias-ui-icon-arrow-size-400:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-ui-icon-arrow-size-500:var(--spectrum-global-dimension-static-size-225);--spectrum-alias-ui-icon-arrow-size-600:var(--spectrum-global-dimension-static-size-250);--spectrum-alias-ui-icon-triplegripper-size-100-width:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-doublegripper-size-100-height:var(--spectrum-global-dimension-static-size-50);--spectrum-alias-ui-icon-singlegripper-size-100-height:var(--spectrum-global-dimension-static-size-25);--spectrum-alias-ui-icon-cornertriangle-size-100:var(--spectrum-global-dimension-static-size-65);--spectrum-alias-ui-icon-cornertriangle-size-300:var(--spectrum-global-dimension-static-size-85);--spectrum-alias-ui-icon-asterisk-size-200:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-ui-icon-asterisk-size-300:var(--spectrum-global-dimension-static-size-125);--spectrum-alias-avatar-size-100:var(--spectrum-global-dimension-size-250);--spectrum-alias-avatar-size-400:var(--spectrum-global-dimension-size-350);--spectrum-alias-avatar-size-600:var(--spectrum-global-dimension-size-450);--spectrum-alias-tag-icon-size-l:var(--spectrum-global-dimension-static-size-250);--spectrum-alias-tag-focusring-border-radius:var(--spectrum-global-dimension-static-size-65);--spectrum-dialog-confirm-title-text-size:var(--spectrum-alias-heading-s-text-size);--spectrum-dialog-confirm-description-text-size:var(--spectrum-global-dimension-font-size-100)}:host,:root{--spectrum-global-alias-appframe-border-size:2px;--swc-scale-factor:1;--spectrum-workflow-icon-size-50:14px;--spectrum-workflow-icon-size-75:16px;--spectrum-workflow-icon-size-100:20px;--spectrum-workflow-icon-size-200:22px;--spectrum-workflow-icon-size-300:26px;--spectrum-arrow-icon-size-75:10px;--spectrum-arrow-icon-size-100:10px;--spectrum-arrow-icon-size-200:12px;--spectrum-arrow-icon-size-300:14px;--spectrum-arrow-icon-size-400:16px;--spectrum-arrow-icon-size-500:18px;--spectrum-arrow-icon-size-600:20px;--spectrum-asterisk-icon-size-100:8px;--spectrum-asterisk-icon-size-200:10px;--spectrum-asterisk-icon-size-300:10px;--spectrum-checkmark-icon-size-50:10px;--spectrum-checkmark-icon-size-75:10px;--spectrum-checkmark-icon-size-100:10px;--spectrum-checkmark-icon-size-200:12px;--spectrum-checkmark-icon-size-300:14px;--spectrum-checkmark-icon-size-400:16px;--spectrum-checkmark-icon-size-500:16px;--spectrum-checkmark-icon-size-600:18px;--spectrum-chevron-icon-size-50:6px;--spectrum-chevron-icon-size-75:10px;--spectrum-chevron-icon-size-100:10px;--spectrum-chevron-icon-size-200:12px;--spectrum-chevron-icon-size-300:14px;--spectrum-chevron-icon-size-400:16px;--spectrum-chevron-icon-size-500:16px;--spectrum-chevron-icon-size-600:18px;--spectrum-corner-triangle-icon-size-75:5px;--spectrum-corner-triangle-icon-size-100:5px;--spectrum-corner-triangle-icon-size-200:6px;--spectrum-corner-triangle-icon-size-300:7px;--spectrum-cross-icon-size-75:8px;--spectrum-cross-icon-size-100:8px;--spectrum-cross-icon-size-200:10px;--spectrum-cross-icon-size-300:12px;--spectrum-cross-icon-size-400:12px;--spectrum-cross-icon-size-500:14px;--spectrum-cross-icon-size-600:16px;--spectrum-dash-icon-size-50:8px;--spectrum-dash-icon-size-75:8px;--spectrum-dash-icon-size-100:10px;--spectrum-dash-icon-size-200:12px;--spectrum-dash-icon-size-300:12px;--spectrum-dash-icon-size-400:14px;--spectrum-dash-icon-size-500:16px;--spectrum-dash-icon-size-600:18px;--spectrum-checkbox-control-size-small:12px;--spectrum-checkbox-control-size-medium:14px;--spectrum-checkbox-control-size-large:16px;--spectrum-checkbox-control-size-extra-large:18px;--spectrum-checkbox-top-to-control-small:6px;--spectrum-checkbox-top-to-control-medium:9px;--spectrum-checkbox-top-to-control-large:12px;--spectrum-checkbox-top-to-control-extra-large:15px;--spectrum-switch-control-width-small:23px;--spectrum-switch-control-width-medium:26px;--spectrum-switch-control-width-large:29px;--spectrum-switch-control-width-extra-large:33px;--spectrum-switch-control-height-small:12px;--spectrum-switch-control-height-medium:14px;--spectrum-switch-control-height-large:16px;--spectrum-switch-control-height-extra-large:18px;--spectrum-switch-top-to-control-small:6px;--spectrum-switch-top-to-control-medium:9px;--spectrum-switch-top-to-control-large:12px;--spectrum-switch-top-to-control-extra-large:15px;--spectrum-radio-button-control-size-small:12px;--spectrum-radio-button-control-size-medium:14px;--spectrum-radio-button-control-size-large:16px;--spectrum-radio-button-control-size-extra-large:18px;--spectrum-radio-button-top-to-control-small:6px;--spectrum-radio-button-top-to-control-medium:9px;--spectrum-radio-button-top-to-control-large:12px;--spectrum-radio-button-top-to-control-extra-large:15px;--spectrum-field-label-text-to-asterisk-small:4px;--spectrum-field-label-text-to-asterisk-medium:4px;--spectrum-field-label-text-to-asterisk-large:5px;--spectrum-field-label-text-to-asterisk-extra-large:5px;--spectrum-field-label-top-to-asterisk-small:8px;--spectrum-field-label-top-to-asterisk-medium:12px;--spectrum-field-label-top-to-asterisk-large:15px;--spectrum-field-label-top-to-asterisk-extra-large:19px;--spectrum-field-label-top-margin-medium:4px;--spectrum-field-label-top-margin-large:5px;--spectrum-field-label-top-margin-extra-large:5px;--spectrum-field-label-to-component-quiet-small:-8px;--spectrum-field-label-to-component-quiet-medium:-8px;--spectrum-field-label-to-component-quiet-large:-12px;--spectrum-field-label-to-component-quiet-extra-large:-15px;--spectrum-help-text-top-to-workflow-icon-small:4px;--spectrum-help-text-top-to-workflow-icon-medium:3px;--spectrum-help-text-top-to-workflow-icon-large:6px;--spectrum-help-text-top-to-workflow-icon-extra-large:9px;--spectrum-status-light-dot-size-medium:8px;--spectrum-status-light-dot-size-large:10px;--spectrum-status-light-dot-size-extra-large:10px;--spectrum-status-light-top-to-dot-small:8px;--spectrum-status-light-top-to-dot-medium:12px;--spectrum-status-light-top-to-dot-large:15px;--spectrum-status-light-top-to-dot-extra-large:19px;--spectrum-action-button-edge-to-hold-icon-medium:4px;--spectrum-action-button-edge-to-hold-icon-large:5px;--spectrum-action-button-edge-to-hold-icon-extra-large:6px;--spectrum-tooltip-tip-width:8px;--spectrum-tooltip-tip-height:4px;--spectrum-tooltip-maximum-width:160px;--spectrum-progress-circle-size-small:16px;--spectrum-progress-circle-size-medium:32px;--spectrum-progress-circle-size-large:64px;--spectrum-progress-circle-thickness-small:2px;--spectrum-progress-circle-thickness-medium:3px;--spectrum-progress-circle-thickness-large:4px;--spectrum-toast-height:48px;--spectrum-toast-maximum-width:336px;--spectrum-toast-top-to-workflow-icon:15px;--spectrum-toast-top-to-text:14px;--spectrum-toast-bottom-to-text:17px;--spectrum-action-bar-height:48px;--spectrum-action-bar-top-to-item-counter:14px;--spectrum-swatch-size-extra-small:16px;--spectrum-swatch-size-small:24px;--spectrum-swatch-size-medium:32px;--spectrum-swatch-size-large:40px;--spectrum-progress-bar-thickness-small:4px;--spectrum-progress-bar-thickness-medium:6px;--spectrum-progress-bar-thickness-large:8px;--spectrum-progress-bar-thickness-extra-large:10px;--spectrum-meter-width:192px;--spectrum-meter-thickness-small:4px;--spectrum-meter-thickness-large:6px;--spectrum-tag-top-to-avatar-small:4px;--spectrum-tag-top-to-avatar-medium:6px;--spectrum-tag-top-to-avatar-large:9px;--spectrum-tag-top-to-cross-icon-small:8px;--spectrum-tag-top-to-cross-icon-medium:12px;--spectrum-tag-top-to-cross-icon-large:15px;--spectrum-popover-top-to-content-area:4px;--spectrum-menu-item-edge-to-content-not-selected-small:28px;--spectrum-menu-item-edge-to-content-not-selected-medium:32px;--spectrum-menu-item-edge-to-content-not-selected-large:38px;--spectrum-menu-item-edge-to-content-not-selected-extra-large:45px;--spectrum-menu-item-top-to-disclosure-icon-small:7px;--spectrum-menu-item-top-to-disclosure-icon-medium:11px;--spectrum-menu-item-top-to-disclosure-icon-large:14px;--spectrum-menu-item-top-to-disclosure-icon-extra-large:17px;--spectrum-menu-item-top-to-selected-icon-small:7px;--spectrum-menu-item-top-to-selected-icon-medium:11px;--spectrum-menu-item-top-to-selected-icon-large:14px;--spectrum-menu-item-top-to-selected-icon-extra-large:17px;--spectrum-slider-control-height-small:14px;--spectrum-slider-control-height-medium:16px;--spectrum-slider-control-height-large:18px;--spectrum-slider-control-height-extra-large:20px;--spectrum-slider-handle-size-small:14px;--spectrum-slider-handle-size-medium:16px;--spectrum-slider-handle-size-large:18px;--spectrum-slider-handle-size-extra-large:20px;--spectrum-slider-handle-border-width-down-small:5px;--spectrum-slider-handle-border-width-down-medium:6px;--spectrum-slider-handle-border-width-down-large:7px;--spectrum-slider-handle-border-width-down-extra-large:8px;--spectrum-slider-bottom-to-handle-small:5px;--spectrum-slider-bottom-to-handle-medium:8px;--spectrum-slider-bottom-to-handle-large:11px;--spectrum-slider-bottom-to-handle-extra-large:14px;--spectrum-slider-control-to-field-label-small:5px;--spectrum-slider-control-to-field-label-medium:8px;--spectrum-slider-control-to-field-label-large:11px;--spectrum-slider-control-to-field-label-extra-large:14px;--spectrum-picker-visual-to-disclosure-icon-small:7px;--spectrum-picker-visual-to-disclosure-icon-medium:8px;--spectrum-picker-visual-to-disclosure-icon-large:9px;--spectrum-picker-visual-to-disclosure-icon-extra-large:10px;--spectrum-text-area-minimum-width:112px;--spectrum-text-area-minimum-height:56px;--spectrum-combo-box-visual-to-field-button-small:7px;--spectrum-combo-box-visual-to-field-button-medium:8px;--spectrum-combo-box-visual-to-field-button-large:9px;--spectrum-combo-box-visual-to-field-button-extra-large:10px;--spectrum-thumbnail-size-50:16px;--spectrum-thumbnail-size-75:18px;--spectrum-thumbnail-size-100:20px;--spectrum-thumbnail-size-200:22px;--spectrum-thumbnail-size-300:26px;--spectrum-thumbnail-size-400:28px;--spectrum-thumbnail-size-500:32px;--spectrum-thumbnail-size-600:36px;--spectrum-thumbnail-size-700:40px;--spectrum-thumbnail-size-800:44px;--spectrum-thumbnail-size-900:50px;--spectrum-thumbnail-size-1000:56px;--spectrum-alert-dialog-title-size:var(--spectrum-heading-size-s);--spectrum-alert-dialog-description-size:var(--spectrum-body-size-s);--spectrum-opacity-checkerboard-square-size:8px;--spectrum-contextual-help-title-size:var(--spectrum-heading-size-xs);--spectrum-contextual-help-body-size:var(--spectrum-body-size-s);--spectrum-breadcrumbs-height-multiline:72px;--spectrum-breadcrumbs-top-to-text:13px;--spectrum-breadcrumbs-top-to-text-compact:11px;--spectrum-breadcrumbs-top-to-text-multiline:12px;--spectrum-breadcrumbs-bottom-to-text:15px;--spectrum-breadcrumbs-bottom-to-text-compact:12px;--spectrum-breadcrumbs-bottom-to-text-multiline:9px;--spectrum-breadcrumbs-start-edge-to-text:8px;--spectrum-breadcrumbs-top-text-to-bottom-text:9px;--spectrum-breadcrumbs-top-to-separator-icon:19px;--spectrum-breadcrumbs-top-to-separator-icon-compact:15px;--spectrum-breadcrumbs-top-to-separator-icon-multiline:15px;--spectrum-breadcrumbs-separator-icon-to-bottom-text-multiline:11px;--spectrum-breadcrumbs-top-to-truncated-menu:8px;--spectrum-breadcrumbs-top-to-truncated-menu-compact:4px;--spectrum-avatar-size-50:16px;--spectrum-avatar-size-75:18px;--spectrum-avatar-size-100:20px;--spectrum-avatar-size-200:22px;--spectrum-avatar-size-300:26px;--spectrum-avatar-size-400:28px;--spectrum-avatar-size-500:32px;--spectrum-avatar-size-600:36px;--spectrum-avatar-size-700:40px;--spectrum-alert-banner-minimum-height:48px;--spectrum-alert-banner-width:832px;--spectrum-alert-banner-top-to-workflow-icon:15px;--spectrum-alert-banner-top-to-text:14px;--spectrum-alert-banner-bottom-to-text:17px;--spectrum-rating-indicator-width:18px;--spectrum-rating-indicator-to-icon:4px;--spectrum-color-area-width:192px;--spectrum-color-area-minimum-width:64px;--spectrum-color-area-height:192px;--spectrum-color-area-minimum-height:64px;--spectrum-color-wheel-width:192px;--spectrum-color-wheel-minimum-width:175px;--spectrum-color-slider-length:192px;--spectrum-color-slider-minimum-length:80px;--spectrum-illustrated-message-title-size:var(--spectrum-heading-size-m);--spectrum-illustrated-message-cjk-title-size:var(--spectrum-heading-cjk-size-m);--spectrum-illustrated-message-body-size:var(--spectrum-body-size-s);--spectrum-coach-mark-width:296px;--spectrum-coach-mark-minimum-width:296px;--spectrum-coach-mark-maximum-width:380px;--spectrum-coach-mark-edge-to-content:var(--spectrum-spacing-400);--spectrum-coach-mark-pagination-text-to-bottom-edge:33px;--spectrum-coach-mark-media-height:222px;--spectrum-coach-mark-media-minimum-height:166px;--spectrum-coach-mark-title-size:var(--spectrum-heading-size-xs);--spectrum-coach-mark-body-size:var(--spectrum-body-size-s);--spectrum-coach-mark-pagination-body-size:var(--spectrum-body-size-s);--spectrum-accordion-top-to-text-regular-small:5px;--spectrum-accordion-small-top-to-text-spacious:9px;--spectrum-accordion-top-to-text-regular-medium:8px;--spectrum-accordion-top-to-text-spacious-medium:12px;--spectrum-accordion-top-to-text-compact-large:4px;--spectrum-accordion-top-to-text-regular-large:9px;--spectrum-accordion-top-to-text-spacious-large:12px;--spectrum-accordion-top-to-text-compact-extra-large:5px;--spectrum-accordion-top-to-text-regular-extra-large:9px;--spectrum-accordion-top-to-text-spacious-extra-large:13px;--spectrum-accordion-bottom-to-text-compact-small:2px;--spectrum-accordion-bottom-to-text-regular-small:7px;--spectrum-accordion-bottom-to-text-spacious-small:11px;--spectrum-accordion-bottom-to-text-compact-medium:5px;--spectrum-accordion-bottom-to-text-regular-medium:9px;--spectrum-accordion-bottom-to-text-spacious-medium:13px;--spectrum-accordion-bottom-to-text-compact-large:8px;--spectrum-accordion-bottom-to-text-regular-large:11px;--spectrum-accordion-bottom-to-text-spacious-large:16px;--spectrum-accordion-bottom-to-text-compact-extra-large:8px;--spectrum-accordion-bottom-to-text-regular-extra-large:12px;--spectrum-accordion-bottom-to-text-spacious-extra-large:16px;--spectrum-accordion-minimum-width:200px;--spectrum-accordion-content-area-top-to-content:8px;--spectrum-accordion-content-area-bottom-to-content:16px;--spectrum-color-handle-size:16px;--spectrum-color-handle-size-key-focus:32px;--spectrum-table-column-header-row-top-to-text-small:8px;--spectrum-table-column-header-row-top-to-text-medium:7px;--spectrum-table-column-header-row-top-to-text-large:10px;--spectrum-table-column-header-row-top-to-text-extra-large:13px;--spectrum-table-column-header-row-bottom-to-text-small:9px;--spectrum-table-column-header-row-bottom-to-text-medium:8px;--spectrum-table-column-header-row-bottom-to-text-large:10px;--spectrum-table-column-header-row-bottom-to-text-extra-large:13px;--spectrum-table-row-height-small-regular:32px;--spectrum-table-row-height-medium-regular:40px;--spectrum-table-row-height-large-regular:48px;--spectrum-table-row-height-extra-large-regular:56px;--spectrum-table-row-height-small-spacious:40px;--spectrum-table-row-height-medium-spacious:48px;--spectrum-table-row-height-large-spacious:56px;--spectrum-table-row-height-extra-large-spacious:64px;--spectrum-table-row-top-to-text-small-regular:8px;--spectrum-table-row-top-to-text-medium-regular:11px;--spectrum-table-row-top-to-text-large-regular:14px;--spectrum-table-row-top-to-text-extra-large-regular:17px;--spectrum-table-row-bottom-to-text-small-regular:9px;--spectrum-table-row-bottom-to-text-medium-regular:12px;--spectrum-table-row-bottom-to-text-large-regular:14px;--spectrum-table-row-bottom-to-text-extra-large-regular:17px;--spectrum-table-row-top-to-text-small-spacious:12px;--spectrum-table-row-top-to-text-medium-spacious:15px;--spectrum-table-row-top-to-text-large-spacious:18px;--spectrum-table-row-top-to-text-extra-large-spacious:21px;--spectrum-table-row-bottom-to-text-small-spacious:13px;--spectrum-table-row-bottom-to-text-medium-spacious:16px;--spectrum-table-row-bottom-to-text-large-spacious:18px;--spectrum-table-row-bottom-to-text-extra-large-spacious:21px;--spectrum-table-checkbox-to-text:24px;--spectrum-table-header-row-checkbox-to-top-small:10px;--spectrum-table-header-row-checkbox-to-top-medium:9px;--spectrum-table-header-row-checkbox-to-top-large:12px;--spectrum-table-header-row-checkbox-to-top-extra-large:15px;--spectrum-table-row-checkbox-to-top-small-compact:6px;--spectrum-table-row-checkbox-to-top-small-regular:10px;--spectrum-table-row-checkbox-to-top-small-spacious:14px;--spectrum-table-row-checkbox-to-top-medium-compact:9px;--spectrum-table-row-checkbox-to-top-medium-regular:13px;--spectrum-table-row-checkbox-to-top-medium-spacious:17px;--spectrum-table-row-checkbox-to-top-large-compact:12px;--spectrum-table-row-checkbox-to-top-large-regular:16px;--spectrum-table-row-checkbox-to-top-large-spacious:20px;--spectrum-table-row-checkbox-to-top-extra-large-compact:15px;--spectrum-table-row-checkbox-to-top-extra-large-regular:19px;--spectrum-table-row-checkbox-to-top-extra-large-spacious:23px;--spectrum-table-section-header-row-height-small:24px;--spectrum-table-section-header-row-height-medium:32px;--spectrum-table-section-header-row-height-large:40px;--spectrum-table-section-header-row-height-extra-large:48px;--spectrum-table-thumbnail-to-top-minimum-small-compact:4px;--spectrum-table-thumbnail-to-top-minimum-medium-compact:5px;--spectrum-table-thumbnail-to-top-minimum-large-compact:7px;--spectrum-table-thumbnail-to-top-minimum-extra-large-compact:8px;--spectrum-table-thumbnail-to-top-minimum-small-regular:5px;--spectrum-table-thumbnail-to-top-minimum-medium-regular:7px;--spectrum-table-thumbnail-to-top-minimum-large-regular:8px;--spectrum-table-thumbnail-to-top-minimum-extra-large-regular:8px;--spectrum-table-thumbnail-to-top-minimum-small-spacious:7px;--spectrum-table-thumbnail-to-top-minimum-medium-spacious:8px;--spectrum-table-thumbnail-to-top-minimum-large-spacious:8px;--spectrum-table-thumbnail-to-top-minimum-extra-large-spacious:10px;--spectrum-tab-item-to-tab-item-horizontal-small:21px;--spectrum-tab-item-to-tab-item-horizontal-medium:24px;--spectrum-tab-item-to-tab-item-horizontal-large:27px;--spectrum-tab-item-to-tab-item-horizontal-extra-large:30px;--spectrum-tab-item-to-tab-item-vertical-small:4px;--spectrum-tab-item-to-tab-item-vertical-medium:4px;--spectrum-tab-item-to-tab-item-vertical-large:5px;--spectrum-tab-item-to-tab-item-vertical-extra-large:5px;--spectrum-tab-item-start-to-edge-small:12px;--spectrum-tab-item-start-to-edge-medium:12px;--spectrum-tab-item-start-to-edge-large:13px;--spectrum-tab-item-start-to-edge-extra-large:13px;--spectrum-tab-item-top-to-text-small:11px;--spectrum-tab-item-bottom-to-text-small:12px;--spectrum-tab-item-top-to-text-medium:14px;--spectrum-tab-item-bottom-to-text-medium:14px;--spectrum-tab-item-top-to-text-large:16px;--spectrum-tab-item-bottom-to-text-large:18px;--spectrum-tab-item-top-to-text-extra-large:19px;--spectrum-tab-item-bottom-to-text-extra-large:20px;--spectrum-tab-item-top-to-text-compact-small:4px;--spectrum-tab-item-bottom-to-text-compact-small:5px;--spectrum-tab-item-top-to-text-compact-medium:6px;--spectrum-tab-item-bottom-to-text-compact-medium:8px;--spectrum-tab-item-top-to-text-compact-large:10px;--spectrum-tab-item-bottom-to-text-compact-large:12px;--spectrum-tab-item-top-to-text-compact-extra-large:12px;--spectrum-tab-item-bottom-to-text-compact-extra-large:13px;--spectrum-tab-item-top-to-workflow-icon-small:13px;--spectrum-tab-item-top-to-workflow-icon-medium:15px;--spectrum-tab-item-top-to-workflow-icon-large:17px;--spectrum-tab-item-top-to-workflow-icon-extra-large:19px;--spectrum-tab-item-top-to-workflow-icon-compact-small:3px;--spectrum-tab-item-top-to-workflow-icon-compact-medium:7px;--spectrum-tab-item-top-to-workflow-icon-compact-large:9px;--spectrum-tab-item-top-to-workflow-icon-compact-extra-large:11px;--spectrum-tab-item-focus-indicator-gap-small:7px;--spectrum-tab-item-focus-indicator-gap-medium:8px;--spectrum-tab-item-focus-indicator-gap-large:9px;--spectrum-tab-item-focus-indicator-gap-extra-large:10px;--spectrum-side-navigation-width:192px;--spectrum-side-navigation-minimum-width:160px;--spectrum-side-navigation-maximum-width:240px;--spectrum-side-navigation-second-level-edge-to-text:24px;--spectrum-side-navigation-third-level-edge-to-text:36px;--spectrum-side-navigation-with-icon-second-level-edge-to-text:50px;--spectrum-side-navigation-with-icon-third-level-edge-to-text:62px;--spectrum-side-navigation-item-to-item:4px;--spectrum-side-navigation-item-to-header:24px;--spectrum-side-navigation-header-to-item:8px;--spectrum-side-navigation-bottom-to-text:8px;--spectrum-tray-top-to-content-area:4px;--spectrum-accordion-top-to-text-spacious-small:9px;--spectrum-drop-shadow-y:1px;--spectrum-drop-shadow-blur:4px;--spectrum-text-to-visual-50:5px;--spectrum-text-to-visual-75:5px;--spectrum-text-to-visual-100:6px;--spectrum-text-to-visual-200:7px;--spectrum-text-to-visual-300:8px;--spectrum-text-to-visual-400:9px;--spectrum-text-to-control-75:9px;--spectrum-text-to-control-100:10px;--spectrum-text-to-control-200:11px;--spectrum-text-to-control-300:13px;--spectrum-component-height-50:20px;--spectrum-component-height-75:24px;--spectrum-component-height-100:32px;--spectrum-component-height-200:40px;--spectrum-component-height-300:48px;--spectrum-component-height-400:56px;--spectrum-component-height-500:64px;--spectrum-component-pill-edge-to-visual-75:11px;--spectrum-component-pill-edge-to-visual-100:14px;--spectrum-component-pill-edge-to-visual-200:18px;--spectrum-component-pill-edge-to-visual-300:20px;--spectrum-component-pill-edge-to-visual-only-75:4px;--spectrum-component-pill-edge-to-visual-only-100:6px;--spectrum-component-pill-edge-to-visual-only-200:9px;--spectrum-component-pill-edge-to-visual-only-300:11px;--spectrum-component-pill-edge-to-text-75:13px;--spectrum-component-pill-edge-to-text-100:16px;--spectrum-component-pill-edge-to-text-200:20px;--spectrum-component-pill-edge-to-text-300:23px;--spectrum-component-edge-to-visual-50:7px;--spectrum-component-edge-to-visual-75:8px;--spectrum-component-edge-to-visual-100:10px;--spectrum-component-edge-to-visual-200:13px;--spectrum-component-edge-to-visual-300:14px;--spectrum-component-edge-to-visual-only-50:3px;--spectrum-component-edge-to-visual-only-75:4px;--spectrum-component-edge-to-visual-only-100:6px;--spectrum-component-edge-to-visual-only-200:9px;--spectrum-component-edge-to-visual-only-300:11px;--spectrum-component-edge-to-text-50:8px;--spectrum-component-edge-to-text-75:10px;--spectrum-component-edge-to-text-100:12px;--spectrum-component-edge-to-text-200:15px;--spectrum-component-edge-to-text-300:17px;--spectrum-component-top-to-workflow-icon-50:3px;--spectrum-component-top-to-workflow-icon-75:4px;--spectrum-component-top-to-workflow-icon-100:6px;--spectrum-component-top-to-workflow-icon-200:9px;--spectrum-component-top-to-workflow-icon-300:11px;--spectrum-component-top-to-text-50:3px;--spectrum-component-top-to-text-75:4px;--spectrum-component-top-to-text-100:6px;--spectrum-component-top-to-text-200:9px;--spectrum-component-top-to-text-300:12px;--spectrum-component-bottom-to-text-50:3px;--spectrum-component-bottom-to-text-75:5px;--spectrum-component-bottom-to-text-100:9px;--spectrum-component-bottom-to-text-200:11px;--spectrum-component-bottom-to-text-300:14px;--spectrum-component-to-menu-small:6px;--spectrum-component-to-menu-medium:6px;--spectrum-component-to-menu-large:7px;--spectrum-component-to-menu-extra-large:8px;--spectrum-field-edge-to-disclosure-icon-75:7px;--spectrum-field-edge-to-disclosure-icon-100:11px;--spectrum-field-edge-to-disclosure-icon-200:14px;--spectrum-field-edge-to-disclosure-icon-300:17px;--spectrum-field-end-edge-to-disclosure-icon-75:7px;--spectrum-field-end-edge-to-disclosure-icon-100:11px;--spectrum-field-end-edge-to-disclosure-icon-200:14px;--spectrum-field-end-edge-to-disclosure-icon-300:17px;--spectrum-field-top-to-disclosure-icon-75:7px;--spectrum-field-top-to-disclosure-icon-100:11px;--spectrum-field-top-to-disclosure-icon-200:14px;--spectrum-field-top-to-disclosure-icon-300:17px;--spectrum-field-top-to-alert-icon-small:4px;--spectrum-field-top-to-alert-icon-medium:7px;--spectrum-field-top-to-alert-icon-large:10px;--spectrum-field-top-to-alert-icon-extra-large:13px;--spectrum-field-top-to-validation-icon-small:7px;--spectrum-field-top-to-validation-icon-medium:11px;--spectrum-field-top-to-validation-icon-large:14px;--spectrum-field-top-to-validation-icon-extra-large:17px;--spectrum-field-top-to-progress-circle-small:4px;--spectrum-field-top-to-progress-circle-medium:8px;--spectrum-field-top-to-progress-circle-large:12px;--spectrum-field-top-to-progress-circle-extra-large:16px;--spectrum-field-edge-to-alert-icon-small:9px;--spectrum-field-edge-to-alert-icon-medium:12px;--spectrum-field-edge-to-alert-icon-large:15px;--spectrum-field-edge-to-alert-icon-extra-large:18px;--spectrum-field-edge-to-validation-icon-small:9px;--spectrum-field-edge-to-validation-icon-medium:12px;--spectrum-field-edge-to-validation-icon-large:15px;--spectrum-field-edge-to-validation-icon-extra-large:18px;--spectrum-field-text-to-alert-icon-small:8px;--spectrum-field-text-to-alert-icon-medium:12px;--spectrum-field-text-to-alert-icon-large:15px;--spectrum-field-text-to-alert-icon-extra-large:18px;--spectrum-field-text-to-validation-icon-small:8px;--spectrum-field-text-to-validation-icon-medium:12px;--spectrum-field-text-to-validation-icon-large:15px;--spectrum-field-text-to-validation-icon-extra-large:18px;--spectrum-field-width:192px;--spectrum-character-count-to-field-quiet-small:-3px;--spectrum-character-count-to-field-quiet-medium:-3px;--spectrum-character-count-to-field-quiet-large:-3px;--spectrum-character-count-to-field-quiet-extra-large:-4px;--spectrum-side-label-character-count-to-field:12px;--spectrum-side-label-character-count-top-margin-small:4px;--spectrum-side-label-character-count-top-margin-medium:8px;--spectrum-side-label-character-count-top-margin-large:11px;--spectrum-side-label-character-count-top-margin-extra-large:14px;--spectrum-disclosure-indicator-top-to-disclosure-icon-small:7px;--spectrum-disclosure-indicator-top-to-disclosure-icon-medium:11px;--spectrum-disclosure-indicator-top-to-disclosure-icon-large:14px;--spectrum-disclosure-indicator-top-to-disclosure-icon-extra-large:17px;--spectrum-navigational-indicator-top-to-back-icon-small:6px;--spectrum-navigational-indicator-top-to-back-icon-medium:9px;--spectrum-navigational-indicator-top-to-back-icon-large:12px;--spectrum-navigational-indicator-top-to-back-icon-extra-large:15px;--spectrum-color-control-track-width:24px;--spectrum-font-size-50:11px;--spectrum-font-size-75:12px;--spectrum-font-size-100:14px;--spectrum-font-size-200:16px;--spectrum-font-size-300:18px;--spectrum-font-size-400:20px;--spectrum-font-size-500:22px;--spectrum-font-size-600:25px;--spectrum-font-size-700:28px;--spectrum-font-size-800:32px;--spectrum-font-size-900:36px;--spectrum-font-size-1000:40px;--spectrum-font-size-1100:45px;--spectrum-font-size-1200:50px;--spectrum-font-size-1300:60px;--scale:medium;--spectrum-alert-banner-close-button-spacing:var(--spectrum-spacing-100);--spectrum-alert-banner-edge-to-button:var(--spectrum-spacing-100);--spectrum-alert-banner-edge-to-divider:var(--spectrum-spacing-100);--spectrum-alert-banner-text-to-button-vertical:var(--spectrum-spacing-100);--spectrum-alert-dialog-description-to-buttons:var(--spectrum-spacing-700);--spectrum-alert-dialog-padding:var(--spectrum-spacing-500);--spectrum-assetcard-content-font-size:var(--spectrum-body-size-s);--spectrum-assetcard-focus-ring-border-radius:8px;--spectrum-assetcard-header-content-font-size:var(--spectrum-heading-size-xs);--spectrum-assetcard-selectionindicator-margin:12px;--spectrum-assetcard-title-font-size:var(--spectrum-heading-size-xs);--spectrum-button-bottom-to-text-small:4px;--spectrum-button-bottom-to-text-medium:8px;--spectrum-button-bottom-to-text-large:10px;--spectrum-button-bottom-to-text-extra-large:13px;--spectrum-button-top-to-text-small:5px;--spectrum-button-top-to-text-medium:7px;--spectrum-button-top-to-text-large:10px;--spectrum-button-top-to-text-extra-large:13px;--spectrum-coach-indicator-gap:6px;--spectrum-coach-indicator-ring-diameter:var(--spectrum-spacing-300);--spectrum-coach-indicator-quiet-ring-diameter:var(--spectrum-spacing-100);--spectrum-coachmark-buttongroup-display:flex;--spectrum-coachmark-buttongroup-mobile-display:none;--spectrum-coachmark-menu-display:inline-flex;--spectrum-coachmark-menu-mobile-display:none;--spectrum-colorloupe-checkerboard-fill:url(#checkerboard-primary);--spectrum-colorwheel-colorarea-container-size:144px;--spectrum-colorwheel-path:"M 95 95 m -95 0 a 95 95 0 1 0 190 0 a 95 95 0 1 0 -190 0.2 M 95 95 m -73 0 a 73 73 0 1 0 146 0 a 73 73 0 1 0 -146 0";--spectrum-colorwheel-path-borders:"M 96 96 m -96 0 a 96 96 0 1 0 192 0 a 96 96 0 1 0 -192 0.2 M 96 96 m -72 0 a 72 72 0 1 0 144 0 a 72 72 0 1 0 -144 0";--spectrum-contextual-help-content-spacing:var(--spectrum-spacing-100);--spectrum-datepicker-dash-line-height:24px;--spectrum-datepicker-datetime-width-first:36px;--spectrum-datepicker-generic-padding:var(--spectrum-spacing-200);--spectrum-datepicker-initial-width:128px;--spectrum-datepicker-input-datetime-width:var(--spectrum-spacing-400);--spectrum-datepicker-invalid-icon-to-button:8px;--spectrum-datepicker-invalid-icon-to-button-quiet:7px;--spectrum-datepicker-width-quiet-first:72px;--spectrum-datepicker-width-quiet-second:16px;--spectrum-dial-border-radius:16px;--spectrum-dial-controls-margin:8px;--spectrum-dial-handle-block-margin:16px;--spectrum-dial-handle-inline-margin:16px;--spectrum-dial-handle-position:8px;--spectrum-dial-label-container-top-to-text:4px;--spectrum-dial-label-gap-y:5px;--spectrum-dialog-confirm-border-radius:4px;--spectrum-dialog-confirm-description-text-size:14px;--spectrum-dialog-confirm-entry-animation-distance:20px;--spectrum-dialog-confirm-hero-height:128px;--spectrum-dialog-confirm-padding-grid:40px;--spectrum-dialog-confirm-title-text-size:18px;--spectrum-menu-item-checkmark-height-small:10px;--spectrum-menu-item-checkmark-height-medium:10px;--spectrum-menu-item-checkmark-height-large:12px;--spectrum-menu-item-checkmark-height-extra-large:14px;--spectrum-menu-item-checkmark-width-small:10px;--spectrum-menu-item-checkmark-width-medium:10px;--spectrum-menu-item-checkmark-width-large:12px;--spectrum-menu-item-checkmark-width-extra-large:14px;--spectrum-menu-item-selectable-edge-to-text-not-selected-small:28px;--spectrum-menu-item-selectable-edge-to-text-not-selected-medium:32px;--spectrum-menu-item-selectable-edge-to-text-not-selected-large:38px;--spectrum-menu-item-selectable-edge-to-text-not-selected-extra-large:45px;--spectrum-pagination-item-inline-spacing:5px;--spectrum-pagination-textfield-width:var(--spectrum-spacing-700);--spectrum-rating-icon-spacing:var(--spectrum-spacing-75);--spectrum-slider-ramp-track-height:16px;--spectrum-slider-tick-mark-height:10px;--spectrum-treeview-indicator-inset-block-start:5px;--spectrum-treeview-item-indentation-small:var(--spectrum-spacing-200);--spectrum-treeview-item-indentation-medium:var(--spectrum-spacing-300);--spectrum-treeview-item-indentation-large:20px;--spectrum-treeview-item-indentation-extra-large:var(--spectrum-spacing-400);--spectrum-treeview-item-min-block-size-thumbnail-offset-medium:0px;--spectrum-tooltip-animation-distance:var(--spectrum-spacing-75);--spectrum-ui-icon-medium-display:block;--spectrum-ui-icon-large-display:none;--spectrum-well-border-radius:var(--spectrum-spacing-75);--spectrum-well-margin-top:var(--spectrum-spacing-75);--spectrum-well-min-width:240px;--spectrum-well-padding:var(--spectrum-spacing-300);--spectrum-workflow-icon-size-xxl:32px;--spectrum-workflow-icon-size-xxs:12px}:root,:host{--spectrum-global-alias-appframe-border-size:2px;--swc-scale-factor:1}
`;
var scale_medium_css_default = e6;

// node_modules/@spectrum-web-components/theme/src/spectrum-two/theme.css.js
init_src();
var t3 = i`
    :root,:host{--spectrum-global-animation-linear:cubic-bezier(0,0,1,1);--spectrum-global-animation-duration-0:0s;--spectrum-global-animation-duration-100:.13s;--spectrum-global-animation-duration-200:.16s;--spectrum-global-animation-duration-300:.19s;--spectrum-global-animation-duration-400:.22s;--spectrum-global-animation-duration-500:.25s;--spectrum-global-animation-duration-600:.3s;--spectrum-global-animation-duration-700:.35s;--spectrum-global-animation-duration-800:.4s;--spectrum-global-animation-duration-900:.45s;--spectrum-global-animation-duration-1000:.5s;--spectrum-global-animation-duration-2000:1s;--spectrum-global-animation-duration-4000:2s;--spectrum-global-animation-ease-in-out:cubic-bezier(.45,0,.4,1);--spectrum-global-animation-ease-in:cubic-bezier(.5,0,1,1);--spectrum-global-animation-ease-out:cubic-bezier(0,0,.4,1);--spectrum-global-animation-ease-linear:cubic-bezier(0,0,1,1);--spectrum-global-color-status:Verified;--spectrum-global-color-version:5.1;--spectrum-global-color-static-black-rgb:0,0,0;--spectrum-global-color-static-black:rgb(var(--spectrum-global-color-static-black-rgb));--spectrum-global-color-static-white-rgb:255,255,255;--spectrum-global-color-static-white:rgb(var(--spectrum-global-color-static-white-rgb));--spectrum-global-color-static-blue-rgb:0,87,191;--spectrum-global-color-static-blue:rgb(var(--spectrum-global-color-static-blue-rgb));--spectrum-global-color-static-gray-50-rgb:255,255,255;--spectrum-global-color-static-gray-50:rgb(var(--spectrum-global-color-static-gray-50-rgb));--spectrum-global-color-static-gray-75-rgb:255,255,255;--spectrum-global-color-static-gray-75:rgb(var(--spectrum-global-color-static-gray-75-rgb));--spectrum-global-color-static-gray-100-rgb:255,255,255;--spectrum-global-color-static-gray-100:rgb(var(--spectrum-global-color-static-gray-100-rgb));--spectrum-global-color-static-gray-200-rgb:235,235,235;--spectrum-global-color-static-gray-200:rgb(var(--spectrum-global-color-static-gray-200-rgb));--spectrum-global-color-static-gray-300-rgb:217,217,217;--spectrum-global-color-static-gray-300:rgb(var(--spectrum-global-color-static-gray-300-rgb));--spectrum-global-color-static-gray-400-rgb:179,179,179;--spectrum-global-color-static-gray-400:rgb(var(--spectrum-global-color-static-gray-400-rgb));--spectrum-global-color-static-gray-500-rgb:146,146,146;--spectrum-global-color-static-gray-500:rgb(var(--spectrum-global-color-static-gray-500-rgb));--spectrum-global-color-static-gray-600-rgb:110,110,110;--spectrum-global-color-static-gray-600:rgb(var(--spectrum-global-color-static-gray-600-rgb));--spectrum-global-color-static-gray-700-rgb:71,71,71;--spectrum-global-color-static-gray-700:rgb(var(--spectrum-global-color-static-gray-700-rgb));--spectrum-global-color-static-gray-800-rgb:34,34,34;--spectrum-global-color-static-gray-800:rgb(var(--spectrum-global-color-static-gray-800-rgb));--spectrum-global-color-static-gray-900-rgb:0,0,0;--spectrum-global-color-static-gray-900:rgb(var(--spectrum-global-color-static-gray-900-rgb));--spectrum-global-color-static-red-400-rgb:237,64,48;--spectrum-global-color-static-red-400:rgb(var(--spectrum-global-color-static-red-400-rgb));--spectrum-global-color-static-red-500-rgb:217,28,21;--spectrum-global-color-static-red-500:rgb(var(--spectrum-global-color-static-red-500-rgb));--spectrum-global-color-static-red-600-rgb:187,2,2;--spectrum-global-color-static-red-600:rgb(var(--spectrum-global-color-static-red-600-rgb));--spectrum-global-color-static-red-700-rgb:154,0,0;--spectrum-global-color-static-red-700:rgb(var(--spectrum-global-color-static-red-700-rgb));--spectrum-global-color-static-red-800-rgb:124,0,0;--spectrum-global-color-static-red-800:rgb(var(--spectrum-global-color-static-red-800-rgb));--spectrum-global-color-static-orange-400-rgb:250,139,26;--spectrum-global-color-static-orange-400:rgb(var(--spectrum-global-color-static-orange-400-rgb));--spectrum-global-color-static-orange-500-rgb:233,117,0;--spectrum-global-color-static-orange-500:rgb(var(--spectrum-global-color-static-orange-500-rgb));--spectrum-global-color-static-orange-600-rgb:209,97,0;--spectrum-global-color-static-orange-600:rgb(var(--spectrum-global-color-static-orange-600-rgb));--spectrum-global-color-static-orange-700-rgb:182,80,0;--spectrum-global-color-static-orange-700:rgb(var(--spectrum-global-color-static-orange-700-rgb));--spectrum-global-color-static-orange-800-rgb:155,64,0;--spectrum-global-color-static-orange-800:rgb(var(--spectrum-global-color-static-orange-800-rgb));--spectrum-global-color-static-yellow-200-rgb:250,237,123;--spectrum-global-color-static-yellow-200:rgb(var(--spectrum-global-color-static-yellow-200-rgb));--spectrum-global-color-static-yellow-300-rgb:250,224,23;--spectrum-global-color-static-yellow-300:rgb(var(--spectrum-global-color-static-yellow-300-rgb));--spectrum-global-color-static-yellow-400-rgb:238,205,0;--spectrum-global-color-static-yellow-400:rgb(var(--spectrum-global-color-static-yellow-400-rgb));--spectrum-global-color-static-yellow-500-rgb:221,185,0;--spectrum-global-color-static-yellow-500:rgb(var(--spectrum-global-color-static-yellow-500-rgb));--spectrum-global-color-static-yellow-600-rgb:201,164,0;--spectrum-global-color-static-yellow-600:rgb(var(--spectrum-global-color-static-yellow-600-rgb));--spectrum-global-color-static-yellow-700-rgb:181,144,0;--spectrum-global-color-static-yellow-700:rgb(var(--spectrum-global-color-static-yellow-700-rgb));--spectrum-global-color-static-yellow-800-rgb:160,125,0;--spectrum-global-color-static-yellow-800:rgb(var(--spectrum-global-color-static-yellow-800-rgb));--spectrum-global-color-static-chartreuse-300-rgb:176,222,27;--spectrum-global-color-static-chartreuse-300:rgb(var(--spectrum-global-color-static-chartreuse-300-rgb));--spectrum-global-color-static-chartreuse-400-rgb:157,203,13;--spectrum-global-color-static-chartreuse-400:rgb(var(--spectrum-global-color-static-chartreuse-400-rgb));--spectrum-global-color-static-chartreuse-500-rgb:139,182,4;--spectrum-global-color-static-chartreuse-500:rgb(var(--spectrum-global-color-static-chartreuse-500-rgb));--spectrum-global-color-static-chartreuse-600-rgb:122,162,0;--spectrum-global-color-static-chartreuse-600:rgb(var(--spectrum-global-color-static-chartreuse-600-rgb));--spectrum-global-color-static-chartreuse-700-rgb:106,141,0;--spectrum-global-color-static-chartreuse-700:rgb(var(--spectrum-global-color-static-chartreuse-700-rgb));--spectrum-global-color-static-chartreuse-800-rgb:90,120,0;--spectrum-global-color-static-chartreuse-800:rgb(var(--spectrum-global-color-static-chartreuse-800-rgb));--spectrum-global-color-static-celery-200-rgb:126,229,114;--spectrum-global-color-static-celery-200:rgb(var(--spectrum-global-color-static-celery-200-rgb));--spectrum-global-color-static-celery-300-rgb:87,212,86;--spectrum-global-color-static-celery-300:rgb(var(--spectrum-global-color-static-celery-300-rgb));--spectrum-global-color-static-celery-400-rgb:48,193,61;--spectrum-global-color-static-celery-400:rgb(var(--spectrum-global-color-static-celery-400-rgb));--spectrum-global-color-static-celery-500-rgb:15,172,38;--spectrum-global-color-static-celery-500:rgb(var(--spectrum-global-color-static-celery-500-rgb));--spectrum-global-color-static-celery-600-rgb:0,150,20;--spectrum-global-color-static-celery-600:rgb(var(--spectrum-global-color-static-celery-600-rgb));--spectrum-global-color-static-celery-700-rgb:0,128,15;--spectrum-global-color-static-celery-700:rgb(var(--spectrum-global-color-static-celery-700-rgb));--spectrum-global-color-static-celery-800-rgb:0,107,15;--spectrum-global-color-static-celery-800:rgb(var(--spectrum-global-color-static-celery-800-rgb));--spectrum-global-color-static-green-400-rgb:29,169,115;--spectrum-global-color-static-green-400:rgb(var(--spectrum-global-color-static-green-400-rgb));--spectrum-global-color-static-green-500-rgb:0,148,97;--spectrum-global-color-static-green-500:rgb(var(--spectrum-global-color-static-green-500-rgb));--spectrum-global-color-static-green-600-rgb:0,126,80;--spectrum-global-color-static-green-600:rgb(var(--spectrum-global-color-static-green-600-rgb));--spectrum-global-color-static-green-700-rgb:0,105,65;--spectrum-global-color-static-green-700:rgb(var(--spectrum-global-color-static-green-700-rgb));--spectrum-global-color-static-green-800-rgb:0,86,53;--spectrum-global-color-static-green-800:rgb(var(--spectrum-global-color-static-green-800-rgb));--spectrum-global-color-static-seafoam-200-rgb:75,206,199;--spectrum-global-color-static-seafoam-200:rgb(var(--spectrum-global-color-static-seafoam-200-rgb));--spectrum-global-color-static-seafoam-300-rgb:32,187,180;--spectrum-global-color-static-seafoam-300:rgb(var(--spectrum-global-color-static-seafoam-300-rgb));--spectrum-global-color-static-seafoam-400-rgb:0,166,160;--spectrum-global-color-static-seafoam-400:rgb(var(--spectrum-global-color-static-seafoam-400-rgb));--spectrum-global-color-static-seafoam-500-rgb:0,145,139;--spectrum-global-color-static-seafoam-500:rgb(var(--spectrum-global-color-static-seafoam-500-rgb));--spectrum-global-color-static-seafoam-600-rgb:0,124,118;--spectrum-global-color-static-seafoam-600:rgb(var(--spectrum-global-color-static-seafoam-600-rgb));--spectrum-global-color-static-seafoam-700-rgb:0,103,99;--spectrum-global-color-static-seafoam-700:rgb(var(--spectrum-global-color-static-seafoam-700-rgb));--spectrum-global-color-static-seafoam-800-rgb:10,83,80;--spectrum-global-color-static-seafoam-800:rgb(var(--spectrum-global-color-static-seafoam-800-rgb));--spectrum-global-color-static-blue-200-rgb:130,193,251;--spectrum-global-color-static-blue-200:rgb(var(--spectrum-global-color-static-blue-200-rgb));--spectrum-global-color-static-blue-300-rgb:98,173,247;--spectrum-global-color-static-blue-300:rgb(var(--spectrum-global-color-static-blue-300-rgb));--spectrum-global-color-static-blue-400-rgb:66,151,244;--spectrum-global-color-static-blue-400:rgb(var(--spectrum-global-color-static-blue-400-rgb));--spectrum-global-color-static-blue-500-rgb:27,127,245;--spectrum-global-color-static-blue-500:rgb(var(--spectrum-global-color-static-blue-500-rgb));--spectrum-global-color-static-blue-600-rgb:4,105,227;--spectrum-global-color-static-blue-600:rgb(var(--spectrum-global-color-static-blue-600-rgb));--spectrum-global-color-static-blue-700-rgb:0,87,190;--spectrum-global-color-static-blue-700:rgb(var(--spectrum-global-color-static-blue-700-rgb));--spectrum-global-color-static-blue-800-rgb:0,72,153;--spectrum-global-color-static-blue-800:rgb(var(--spectrum-global-color-static-blue-800-rgb));--spectrum-global-color-static-indigo-200-rgb:178,181,255;--spectrum-global-color-static-indigo-200:rgb(var(--spectrum-global-color-static-indigo-200-rgb));--spectrum-global-color-static-indigo-300-rgb:155,159,255;--spectrum-global-color-static-indigo-300:rgb(var(--spectrum-global-color-static-indigo-300-rgb));--spectrum-global-color-static-indigo-400-rgb:132,137,253;--spectrum-global-color-static-indigo-400:rgb(var(--spectrum-global-color-static-indigo-400-rgb));--spectrum-global-color-static-indigo-500-rgb:109,115,246;--spectrum-global-color-static-indigo-500:rgb(var(--spectrum-global-color-static-indigo-500-rgb));--spectrum-global-color-static-indigo-600-rgb:87,93,232;--spectrum-global-color-static-indigo-600:rgb(var(--spectrum-global-color-static-indigo-600-rgb));--spectrum-global-color-static-indigo-700-rgb:68,74,208;--spectrum-global-color-static-indigo-700:rgb(var(--spectrum-global-color-static-indigo-700-rgb));--spectrum-global-color-static-indigo-800-rgb:68,74,208;--spectrum-global-color-static-indigo-800:rgb(var(--spectrum-global-color-static-indigo-800-rgb));--spectrum-global-color-static-purple-400-rgb:178,121,250;--spectrum-global-color-static-purple-400:rgb(var(--spectrum-global-color-static-purple-400-rgb));--spectrum-global-color-static-purple-500-rgb:161,93,246;--spectrum-global-color-static-purple-500:rgb(var(--spectrum-global-color-static-purple-500-rgb));--spectrum-global-color-static-purple-600-rgb:142,67,234;--spectrum-global-color-static-purple-600:rgb(var(--spectrum-global-color-static-purple-600-rgb));--spectrum-global-color-static-purple-700-rgb:120,43,216;--spectrum-global-color-static-purple-700:rgb(var(--spectrum-global-color-static-purple-700-rgb));--spectrum-global-color-static-purple-800-rgb:98,23,190;--spectrum-global-color-static-purple-800:rgb(var(--spectrum-global-color-static-purple-800-rgb));--spectrum-global-color-static-fuchsia-400-rgb:228,93,230;--spectrum-global-color-static-fuchsia-400:rgb(var(--spectrum-global-color-static-fuchsia-400-rgb));--spectrum-global-color-static-fuchsia-500-rgb:211,63,212;--spectrum-global-color-static-fuchsia-500:rgb(var(--spectrum-global-color-static-fuchsia-500-rgb));--spectrum-global-color-static-fuchsia-600-rgb:188,39,187;--spectrum-global-color-static-fuchsia-600:rgb(var(--spectrum-global-color-static-fuchsia-600-rgb));--spectrum-global-color-static-fuchsia-700-rgb:163,10,163;--spectrum-global-color-static-fuchsia-700:rgb(var(--spectrum-global-color-static-fuchsia-700-rgb));--spectrum-global-color-static-fuchsia-800-rgb:135,0,136;--spectrum-global-color-static-fuchsia-800:rgb(var(--spectrum-global-color-static-fuchsia-800-rgb));--spectrum-global-color-static-magenta-200-rgb:253,127,175;--spectrum-global-color-static-magenta-200:rgb(var(--spectrum-global-color-static-magenta-200-rgb));--spectrum-global-color-static-magenta-300-rgb:242,98,157;--spectrum-global-color-static-magenta-300:rgb(var(--spectrum-global-color-static-magenta-300-rgb));--spectrum-global-color-static-magenta-400-rgb:226,68,135;--spectrum-global-color-static-magenta-400:rgb(var(--spectrum-global-color-static-magenta-400-rgb));--spectrum-global-color-static-magenta-500-rgb:205,40,111;--spectrum-global-color-static-magenta-500:rgb(var(--spectrum-global-color-static-magenta-500-rgb));--spectrum-global-color-static-magenta-600-rgb:179,15,89;--spectrum-global-color-static-magenta-600:rgb(var(--spectrum-global-color-static-magenta-600-rgb));--spectrum-global-color-static-magenta-700-rgb:149,0,72;--spectrum-global-color-static-magenta-700:rgb(var(--spectrum-global-color-static-magenta-700-rgb));--spectrum-global-color-static-magenta-800-rgb:119,0,58;--spectrum-global-color-static-magenta-800:rgb(var(--spectrum-global-color-static-magenta-800-rgb));--spectrum-global-color-static-transparent-white-200:#ffffff1a;--spectrum-global-color-static-transparent-white-300:#ffffff40;--spectrum-global-color-static-transparent-white-400:#fff6;--spectrum-global-color-static-transparent-white-500:#ffffff8c;--spectrum-global-color-static-transparent-white-600:#ffffffb3;--spectrum-global-color-static-transparent-white-700:#fffc;--spectrum-global-color-static-transparent-white-800:#ffffffe6;--spectrum-global-color-static-transparent-white-900-rgb:255,255,255;--spectrum-global-color-static-transparent-white-900:rgb(var(--spectrum-global-color-static-transparent-white-900-rgb));--spectrum-global-color-static-transparent-black-200:#0000001a;--spectrum-global-color-static-transparent-black-300:#00000040;--spectrum-global-color-static-transparent-black-400:#0006;--spectrum-global-color-static-transparent-black-500:#0000008c;--spectrum-global-color-static-transparent-black-600:#000000b3;--spectrum-global-color-static-transparent-black-700:#000c;--spectrum-global-color-static-transparent-black-800:#000000e6;--spectrum-global-color-static-transparent-black-900-rgb:0,0,0;--spectrum-global-color-static-transparent-black-900:rgb(var(--spectrum-global-color-static-transparent-black-900-rgb));--spectrum-global-color-sequential-cerulean:#e9fff1,#c8f1e4,#a5e3d7,#82d5ca,#68c5c1,#54b4ba,#3fa2b2,#2991ac,#2280a2,#1f6d98,#1d5c8d,#1a4b83,#1a3979,#1a266f,#191264,#180057;--spectrum-global-color-sequential-forest:#ffffdf,#e2f6ba,#c4eb95,#a4e16d,#8dd366,#77c460,#5fb65a,#48a754,#36984f,#2c894d,#237a4a,#196b47,#105c45,#094d41,#033f3e,#00313a;--spectrum-global-color-sequential-rose:#fff4dd,#ffddd7,#ffc5d2,#feaecb,#fa96c4,#f57ebd,#ef64b5,#e846ad,#d238a1,#bb2e96,#a3248c,#8a1b83,#71167c,#560f74,#370b6e,#000968;--spectrum-global-color-diverging-orange-yellow-seafoam:#580000,#79260b,#9c4511,#bd651a,#dd8629,#f5ad52,#fed693,#ffffe0,#bbe4d1,#76c7be,#3ea8a6,#208288,#076769,#00494b,#002c2d;--spectrum-global-color-diverging-red-yellow-blue:#4a001e,#751232,#a52747,#c65154,#e47961,#f0a882,#fad4ac,#ffffe0,#bce2cf,#89c0c4,#579eb9,#397aa8,#1c5796,#163771,#10194d;--spectrum-global-color-diverging-red-blue:#4a001e,#731331,#9f2945,#cc415a,#e06e85,#ed9ab0,#f8c3d9,#faf0ff,#c6d0f2,#92b2de,#5d94cb,#2f74b3,#265191,#163670,#0b194c;--spectrum-semantic-negative-background-color:var(--spectrum-global-color-static-red-600);--spectrum-semantic-negative-color-default:var(--spectrum-global-color-red-500);--spectrum-semantic-negative-color-hover:var(--spectrum-global-color-red-600);--spectrum-semantic-negative-color-dark:var(--spectrum-global-color-red-600);--spectrum-semantic-negative-border-color:var(--spectrum-global-color-red-400);--spectrum-semantic-negative-icon-color:var(--spectrum-global-color-red-600);--spectrum-semantic-negative-status-color:var(--spectrum-global-color-red-400);--spectrum-semantic-negative-text-color-large:var(--spectrum-global-color-red-500);--spectrum-semantic-negative-text-color-small:var(--spectrum-global-color-red-600);--spectrum-semantic-negative-text-color-small-hover:var(--spectrum-global-color-red-700);--spectrum-semantic-negative-text-color-small-down:var(--spectrum-global-color-red-700);--spectrum-semantic-negative-text-color-small-key-focus:var(--spectrum-global-color-red-600);--spectrum-semantic-negative-color-down:var(--spectrum-global-color-red-700);--spectrum-semantic-negative-color-key-focus:var(--spectrum-global-color-red-400);--spectrum-semantic-negative-background-color-default:var(--spectrum-global-color-static-red-600);--spectrum-semantic-negative-background-color-hover:var(--spectrum-global-color-static-red-700);--spectrum-semantic-negative-background-color-down:var(--spectrum-global-color-static-red-800);--spectrum-semantic-negative-background-color-key-focus:var(--spectrum-global-color-static-red-700);--spectrum-semantic-notice-background-color:var(--spectrum-global-color-static-orange-600);--spectrum-semantic-notice-color-default:var(--spectrum-global-color-orange-500);--spectrum-semantic-notice-color-dark:var(--spectrum-global-color-orange-600);--spectrum-semantic-notice-border-color:var(--spectrum-global-color-orange-400);--spectrum-semantic-notice-icon-color:var(--spectrum-global-color-orange-600);--spectrum-semantic-notice-status-color:var(--spectrum-global-color-orange-400);--spectrum-semantic-notice-text-color-large:var(--spectrum-global-color-orange-500);--spectrum-semantic-notice-text-color-small:var(--spectrum-global-color-orange-600);--spectrum-semantic-notice-color-down:var(--spectrum-global-color-orange-700);--spectrum-semantic-notice-color-key-focus:var(--spectrum-global-color-orange-400);--spectrum-semantic-notice-background-color-default:var(--spectrum-global-color-static-orange-600);--spectrum-semantic-notice-background-color-hover:var(--spectrum-global-color-static-orange-700);--spectrum-semantic-notice-background-color-down:var(--spectrum-global-color-static-orange-800);--spectrum-semantic-notice-background-color-key-focus:var(--spectrum-global-color-static-orange-700);--spectrum-semantic-positive-background-color:var(--spectrum-global-color-static-green-600);--spectrum-semantic-positive-color-default:var(--spectrum-global-color-green-500);--spectrum-semantic-positive-color-dark:var(--spectrum-global-color-green-600);--spectrum-semantic-positive-border-color:var(--spectrum-global-color-green-400);--spectrum-semantic-positive-icon-color:var(--spectrum-global-color-green-600);--spectrum-semantic-positive-status-color:var(--spectrum-global-color-green-400);--spectrum-semantic-positive-text-color-large:var(--spectrum-global-color-green-500);--spectrum-semantic-positive-text-color-small:var(--spectrum-global-color-green-600);--spectrum-semantic-positive-color-down:var(--spectrum-global-color-green-700);--spectrum-semantic-positive-color-key-focus:var(--spectrum-global-color-green-400);--spectrum-semantic-positive-background-color-default:var(--spectrum-global-color-static-green-600);--spectrum-semantic-positive-background-color-hover:var(--spectrum-global-color-static-green-700);--spectrum-semantic-positive-background-color-down:var(--spectrum-global-color-static-green-800);--spectrum-semantic-positive-background-color-key-focus:var(--spectrum-global-color-static-green-700);--spectrum-semantic-informative-background-color:var(--spectrum-global-color-static-blue-600);--spectrum-semantic-informative-color-default:var(--spectrum-global-color-blue-500);--spectrum-semantic-informative-color-dark:var(--spectrum-global-color-blue-600);--spectrum-semantic-informative-border-color:var(--spectrum-global-color-blue-400);--spectrum-semantic-informative-icon-color:var(--spectrum-global-color-blue-600);--spectrum-semantic-informative-status-color:var(--spectrum-global-color-blue-400);--spectrum-semantic-informative-text-color-large:var(--spectrum-global-color-blue-500);--spectrum-semantic-informative-text-color-small:var(--spectrum-global-color-blue-600);--spectrum-semantic-informative-color-down:var(--spectrum-global-color-blue-700);--spectrum-semantic-informative-color-key-focus:var(--spectrum-global-color-blue-400);--spectrum-semantic-informative-background-color-default:var(--spectrum-global-color-static-blue-600);--spectrum-semantic-informative-background-color-hover:var(--spectrum-global-color-static-blue-700);--spectrum-semantic-informative-background-color-down:var(--spectrum-global-color-static-blue-800);--spectrum-semantic-informative-background-color-key-focus:var(--spectrum-global-color-static-blue-700);--spectrum-semantic-cta-background-color-default:var(--spectrum-global-color-static-blue-600);--spectrum-semantic-cta-background-color-hover:var(--spectrum-global-color-static-blue-700);--spectrum-semantic-cta-background-color-down:var(--spectrum-global-color-static-blue-800);--spectrum-semantic-cta-background-color-key-focus:var(--spectrum-global-color-static-blue-700);--spectrum-semantic-emphasized-border-color-default:var(--spectrum-global-color-blue-500);--spectrum-semantic-emphasized-border-color-hover:var(--spectrum-global-color-blue-600);--spectrum-semantic-emphasized-border-color-down:var(--spectrum-global-color-blue-700);--spectrum-semantic-emphasized-border-color-key-focus:var(--spectrum-global-color-blue-600);--spectrum-semantic-neutral-background-color-default:var(--spectrum-global-color-static-gray-700);--spectrum-semantic-neutral-background-color-hover:var(--spectrum-global-color-static-gray-800);--spectrum-semantic-neutral-background-color-down:var(--spectrum-global-color-static-gray-900);--spectrum-semantic-neutral-background-color-key-focus:var(--spectrum-global-color-static-gray-800);--spectrum-semantic-presence-color-1:var(--spectrum-global-color-static-red-500);--spectrum-semantic-presence-color-2:var(--spectrum-global-color-static-orange-400);--spectrum-semantic-presence-color-3:var(--spectrum-global-color-static-yellow-400);--spectrum-semantic-presence-color-4-rgb:75,204,162;--spectrum-semantic-presence-color-4:rgb(var(--spectrum-semantic-presence-color-4-rgb));--spectrum-semantic-presence-color-5-rgb:0,199,255;--spectrum-semantic-presence-color-5:rgb(var(--spectrum-semantic-presence-color-5-rgb));--spectrum-semantic-presence-color-6-rgb:0,140,184;--spectrum-semantic-presence-color-6:rgb(var(--spectrum-semantic-presence-color-6-rgb));--spectrum-semantic-presence-color-7-rgb:126,75,243;--spectrum-semantic-presence-color-7:rgb(var(--spectrum-semantic-presence-color-7-rgb));--spectrum-semantic-presence-color-8:var(--spectrum-global-color-static-fuchsia-600);--spectrum-global-dimension-static-percent-50:50%;--spectrum-global-dimension-static-percent-70:70%;--spectrum-global-dimension-static-percent-100:100%;--spectrum-global-dimension-static-breakpoint-xsmall:304px;--spectrum-global-dimension-static-breakpoint-small:768px;--spectrum-global-dimension-static-breakpoint-medium:1280px;--spectrum-global-dimension-static-breakpoint-large:1768px;--spectrum-global-dimension-static-breakpoint-xlarge:2160px;--spectrum-global-dimension-static-grid-columns:12;--spectrum-global-dimension-static-grid-fluid-width:100%;--spectrum-global-dimension-static-grid-fixed-max-width:1280px;--spectrum-global-dimension-static-size-0:0px;--spectrum-global-dimension-static-size-10:1px;--spectrum-global-dimension-static-size-25:2px;--spectrum-global-dimension-static-size-40:3px;--spectrum-global-dimension-static-size-50:4px;--spectrum-global-dimension-static-size-65:5px;--spectrum-global-dimension-static-size-75:6px;--spectrum-global-dimension-static-size-85:7px;--spectrum-global-dimension-static-size-100:8px;--spectrum-global-dimension-static-size-115:9px;--spectrum-global-dimension-static-size-125:10px;--spectrum-global-dimension-static-size-130:11px;--spectrum-global-dimension-static-size-150:12px;--spectrum-global-dimension-static-size-160:13px;--spectrum-global-dimension-static-size-175:14px;--spectrum-global-dimension-static-size-185:15px;--spectrum-global-dimension-static-size-200:16px;--spectrum-global-dimension-static-size-225:18px;--spectrum-global-dimension-static-size-250:20px;--spectrum-global-dimension-static-size-275:22px;--spectrum-global-dimension-static-size-300:24px;--spectrum-global-dimension-static-size-325:26px;--spectrum-global-dimension-static-size-350:28px;--spectrum-global-dimension-static-size-400:32px;--spectrum-global-dimension-static-size-450:36px;--spectrum-global-dimension-static-size-500:40px;--spectrum-global-dimension-static-size-550:44px;--spectrum-global-dimension-static-size-600:48px;--spectrum-global-dimension-static-size-700:56px;--spectrum-global-dimension-static-size-800:64px;--spectrum-global-dimension-static-size-900:72px;--spectrum-global-dimension-static-size-1000:80px;--spectrum-global-dimension-static-size-1200:96px;--spectrum-global-dimension-static-size-1700:136px;--spectrum-global-dimension-static-size-2400:192px;--spectrum-global-dimension-static-size-2500:200px;--spectrum-global-dimension-static-size-2600:208px;--spectrum-global-dimension-static-size-2800:224px;--spectrum-global-dimension-static-size-3200:256px;--spectrum-global-dimension-static-size-3400:272px;--spectrum-global-dimension-static-size-3500:280px;--spectrum-global-dimension-static-size-3600:288px;--spectrum-global-dimension-static-size-3800:304px;--spectrum-global-dimension-static-size-4600:368px;--spectrum-global-dimension-static-size-5000:400px;--spectrum-global-dimension-static-size-6000:480px;--spectrum-global-dimension-static-size-16000:1280px;--spectrum-global-dimension-static-font-size-50:11px;--spectrum-global-dimension-static-font-size-75:12px;--spectrum-global-dimension-static-font-size-100:14px;--spectrum-global-dimension-static-font-size-150:15px;--spectrum-global-dimension-static-font-size-200:16px;--spectrum-global-dimension-static-font-size-300:18px;--spectrum-global-dimension-static-font-size-400:20px;--spectrum-global-dimension-static-font-size-500:22px;--spectrum-global-dimension-static-font-size-600:25px;--spectrum-global-dimension-static-font-size-700:28px;--spectrum-global-dimension-static-font-size-800:32px;--spectrum-global-dimension-static-font-size-900:36px;--spectrum-global-dimension-static-font-size-1000:40px;--spectrum-global-font-family-base:adobe-clean,"Source Sans Pro",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Trebuchet MS","Lucida Grande",sans-serif;--spectrum-global-font-family-serif:adobe-clean-serif,"Source Serif Pro",Georgia,serif;--spectrum-global-font-family-code:"Source Code Pro",Monaco,monospace;--spectrum-global-font-weight-thin:100;--spectrum-global-font-weight-ultra-light:200;--spectrum-global-font-weight-light:300;--spectrum-global-font-weight-regular:400;--spectrum-global-font-weight-medium:500;--spectrum-global-font-weight-semi-bold:600;--spectrum-global-font-weight-bold:700;--spectrum-global-font-weight-extra-bold:800;--spectrum-global-font-weight-black:900;--spectrum-global-font-style-regular:normal;--spectrum-global-font-style-italic:italic;--spectrum-global-font-letter-spacing-none:0;--spectrum-global-font-letter-spacing-small:.0125em;--spectrum-global-font-letter-spacing-han:.05em;--spectrum-global-font-letter-spacing-medium:.06em;--spectrum-global-font-line-height-large:1.7;--spectrum-global-font-line-height-medium:1.5;--spectrum-global-font-line-height-small:1.3;--spectrum-global-font-multiplier-0:0em;--spectrum-global-font-multiplier-25:.25em;--spectrum-global-font-multiplier-75:.75em;--spectrum-global-font-font-family-ar:myriad-arabic,adobe-clean,"Source Sans Pro",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Trebuchet MS","Lucida Grande",sans-serif;--spectrum-global-font-font-family-he:myriad-hebrew,adobe-clean,"Source Sans Pro",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Trebuchet MS","Lucida Grande",sans-serif;--spectrum-global-font-font-family-zh:adobe-clean-han-traditional,source-han-traditional,"MingLiu","Heiti TC Light","sans-serif";--spectrum-global-font-font-family-zhhans:adobe-clean-han-simplified-c,source-han-simplified-c,"SimSun","Heiti SC Light","sans-serif";--spectrum-global-font-font-family-ko:adobe-clean-han-korean,source-han-korean,"Malgun Gothic","Apple Gothic","sans-serif";--spectrum-global-font-font-family-ja:adobe-clean-han-japanese,"Hiragino Kaku Gothic ProN"," ProN W3","Osaka",YuGothic,"Yu Gothic","",Meiryo," ","MS PGothic","sans-serif";--spectrum-global-font-font-family-condensed:adobe-clean-han-traditional,source-han-traditional,"MingLiu","Heiti TC Light",adobe-clean,"Source Sans Pro",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Trebuchet MS","Lucida Grande",sans-serif;--spectrum-alias-border-size-thin:var(--spectrum-global-dimension-static-size-10);--spectrum-alias-border-size-thick:var(--spectrum-global-dimension-static-size-25);--spectrum-alias-border-size-thicker:var(--spectrum-global-dimension-static-size-50);--spectrum-alias-border-size-thickest:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-border-offset-thin:var(--spectrum-global-dimension-static-size-25);--spectrum-alias-border-offset-thick:var(--spectrum-global-dimension-static-size-50);--spectrum-alias-border-offset-thicker:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-border-offset-thickest:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-grid-baseline:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-grid-gutter-xsmall:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-grid-gutter-small:var(--spectrum-global-dimension-static-size-300);--spectrum-alias-grid-gutter-medium:var(--spectrum-global-dimension-static-size-400);--spectrum-alias-grid-gutter-large:var(--spectrum-global-dimension-static-size-500);--spectrum-alias-grid-gutter-xlarge:var(--spectrum-global-dimension-static-size-600);--spectrum-alias-grid-margin-xsmall:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-grid-margin-small:var(--spectrum-global-dimension-static-size-300);--spectrum-alias-grid-margin-medium:var(--spectrum-global-dimension-static-size-400);--spectrum-alias-grid-margin-large:var(--spectrum-global-dimension-static-size-500);--spectrum-alias-grid-margin-xlarge:var(--spectrum-global-dimension-static-size-600);--spectrum-alias-grid-layout-region-margin-bottom-xsmall:var(--spectrum-global-dimension-static-size-200);--spectrum-alias-grid-layout-region-margin-bottom-small:var(--spectrum-global-dimension-static-size-300);--spectrum-alias-grid-layout-region-margin-bottom-medium:var(--spectrum-global-dimension-static-size-400);--spectrum-alias-grid-layout-region-margin-bottom-large:var(--spectrum-global-dimension-static-size-500);--spectrum-alias-grid-layout-region-margin-bottom-xlarge:var(--spectrum-global-dimension-static-size-600);--spectrum-alias-radial-reaction-size-default:var(--spectrum-global-dimension-static-size-550);--spectrum-alias-focus-ring-gap:var(--spectrum-global-dimension-static-size-25);--spectrum-alias-focus-ring-size:var(--spectrum-global-dimension-static-size-25);--spectrum-alias-loupe-entry-animation-duration:var(--spectrum-global-animation-duration-300);--spectrum-alias-loupe-exit-animation-duration:var(--spectrum-global-animation-duration-300);--spectrum-alias-heading-text-line-height:var(--spectrum-global-font-line-height-small);--spectrum-alias-heading-text-font-weight-regular:var(--spectrum-global-font-weight-bold);--spectrum-alias-heading-text-font-weight-regular-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-heading-text-font-weight-light:var(--spectrum-global-font-weight-light);--spectrum-alias-heading-text-font-weight-light-strong:var(--spectrum-global-font-weight-bold);--spectrum-alias-heading-text-font-weight-heavy:var(--spectrum-global-font-weight-black);--spectrum-alias-heading-text-font-weight-heavy-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-heading-text-font-weight-quiet:var(--spectrum-global-font-weight-light);--spectrum-alias-heading-text-font-weight-quiet-strong:var(--spectrum-global-font-weight-bold);--spectrum-alias-heading-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-heading-text-font-weight-strong-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-heading-margin-bottom:var(--spectrum-global-font-multiplier-25);--spectrum-alias-subheading-text-font-weight:var(--spectrum-global-font-weight-bold);--spectrum-alias-subheading-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-body-text-font-family:var(--spectrum-global-font-family-base);--spectrum-alias-body-text-line-height:var(--spectrum-global-font-line-height-medium);--spectrum-alias-body-text-font-weight:var(--spectrum-global-font-weight-regular);--spectrum-alias-body-text-font-weight-strong:var(--spectrum-global-font-weight-bold);--spectrum-alias-body-margin-bottom:var(--spectrum-global-font-multiplier-75);--spectrum-alias-detail-text-font-weight:var(--spectrum-global-font-weight-bold);--spectrum-alias-detail-text-font-weight-regular:var(--spectrum-global-font-weight-bold);--spectrum-alias-detail-text-font-weight-light:var(--spectrum-global-font-weight-regular);--spectrum-alias-detail-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-article-heading-text-font-weight:var(--spectrum-global-font-weight-bold);--spectrum-alias-article-heading-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-article-heading-text-font-weight-quiet:var(--spectrum-global-font-weight-regular);--spectrum-alias-article-heading-text-font-weight-quiet-strong:var(--spectrum-global-font-weight-bold);--spectrum-alias-article-body-text-font-weight:var(--spectrum-global-font-weight-regular);--spectrum-alias-article-body-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-article-subheading-text-font-weight:var(--spectrum-global-font-weight-bold);--spectrum-alias-article-subheading-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-article-detail-text-font-weight:var(--spectrum-global-font-weight-regular);--spectrum-alias-article-detail-text-font-weight-strong:var(--spectrum-global-font-weight-bold);--spectrum-alias-code-text-font-family:var(--spectrum-global-font-family-code);--spectrum-alias-code-text-font-weight-regular:var(--spectrum-global-font-weight-regular);--spectrum-alias-code-text-font-weight-strong:var(--spectrum-global-font-weight-bold);--spectrum-alias-code-text-line-height:var(--spectrum-global-font-line-height-medium);--spectrum-alias-code-margin-bottom:var(--spectrum-global-font-multiplier-0);--spectrum-alias-font-family-ar:var(--spectrum-global-font-font-family-ar);--spectrum-alias-font-family-he:var(--spectrum-global-font-font-family-he);--spectrum-alias-font-family-zh:var(--spectrum-global-font-font-family-zh);--spectrum-alias-font-family-zhhans:var(--spectrum-global-font-font-family-zhhans);--spectrum-alias-font-family-ko:var(--spectrum-global-font-font-family-ko);--spectrum-alias-font-family-ja:var(--spectrum-global-font-font-family-ja);--spectrum-alias-font-family-condensed:var(--spectrum-global-font-font-family-condensed);--spectrum-alias-button-text-line-height:var(--spectrum-global-font-line-height-small);--spectrum-alias-component-text-line-height:var(--spectrum-global-font-line-height-small);--spectrum-alias-han-component-text-line-height:var(--spectrum-global-font-line-height-medium);--spectrum-alias-serif-text-font-family:var(--spectrum-global-font-family-serif);--spectrum-alias-han-heading-text-line-height:var(--spectrum-global-font-line-height-medium);--spectrum-alias-han-heading-text-font-weight-regular:var(--spectrum-global-font-weight-bold);--spectrum-alias-han-heading-text-font-weight-regular-emphasis:var(--spectrum-global-font-weight-extra-bold);--spectrum-alias-han-heading-text-font-weight-regular-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-han-heading-text-font-weight-quiet-strong:var(--spectrum-global-font-weight-bold);--spectrum-alias-han-heading-text-font-weight-light:var(--spectrum-global-font-weight-light);--spectrum-alias-han-heading-text-font-weight-light-emphasis:var(--spectrum-global-font-weight-regular);--spectrum-alias-han-heading-text-font-weight-light-strong:var(--spectrum-global-font-weight-bold);--spectrum-alias-han-heading-text-font-weight-heavy:var(--spectrum-global-font-weight-black);--spectrum-alias-han-heading-text-font-weight-heavy-emphasis:var(--spectrum-global-font-weight-black);--spectrum-alias-han-heading-text-font-weight-heavy-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-han-body-text-line-height:var(--spectrum-global-font-line-height-large);--spectrum-alias-han-body-text-font-weight-regular:var(--spectrum-global-font-weight-regular);--spectrum-alias-han-body-text-font-weight-emphasis:var(--spectrum-global-font-weight-bold);--spectrum-alias-han-body-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-han-subheading-text-font-weight-regular:var(--spectrum-global-font-weight-bold);--spectrum-alias-han-subheading-text-font-weight-emphasis:var(--spectrum-global-font-weight-extra-bold);--spectrum-alias-han-subheading-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-han-detail-text-font-weight:var(--spectrum-global-font-weight-regular);--spectrum-alias-han-detail-text-font-weight-emphasis:var(--spectrum-global-font-weight-bold);--spectrum-alias-han-detail-text-font-weight-strong:var(--spectrum-global-font-weight-black);--spectrum-alias-item-height-s:var(--spectrum-global-dimension-size-300);--spectrum-alias-item-height-m:var(--spectrum-global-dimension-size-400);--spectrum-alias-item-height-l:var(--spectrum-global-dimension-size-500);--spectrum-alias-item-height-xl:var(--spectrum-global-dimension-size-600);--spectrum-alias-item-rounded-border-radius-s:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-rounded-border-radius-m:var(--spectrum-global-dimension-size-200);--spectrum-alias-item-rounded-border-radius-l:var(--spectrum-global-dimension-size-250);--spectrum-alias-item-rounded-border-radius-xl:var(--spectrum-global-dimension-size-300);--spectrum-alias-item-text-size-s:var(--spectrum-global-dimension-font-size-75);--spectrum-alias-item-text-size-m:var(--spectrum-global-dimension-font-size-100);--spectrum-alias-item-text-size-l:var(--spectrum-global-dimension-font-size-200);--spectrum-alias-item-text-size-xl:var(--spectrum-global-dimension-font-size-300);--spectrum-alias-item-text-padding-top-s:var(--spectrum-global-dimension-static-size-50);--spectrum-alias-item-text-padding-top-m:var(--spectrum-global-dimension-size-75);--spectrum-alias-item-text-padding-top-xl:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-text-padding-bottom-m:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-text-padding-bottom-l:var(--spectrum-global-dimension-size-130);--spectrum-alias-item-text-padding-bottom-xl:var(--spectrum-global-dimension-size-175);--spectrum-alias-item-icon-padding-top-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-item-icon-padding-top-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-icon-padding-top-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-icon-padding-top-xl:var(--spectrum-global-dimension-size-160);--spectrum-alias-item-icon-padding-bottom-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-item-icon-padding-bottom-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-icon-padding-bottom-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-icon-padding-bottom-xl:var(--spectrum-global-dimension-size-160);--spectrum-alias-item-padding-s:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-padding-m:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-padding-l:var(--spectrum-global-dimension-size-185);--spectrum-alias-item-padding-xl:var(--spectrum-global-dimension-size-225);--spectrum-alias-item-rounded-padding-s:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-rounded-padding-m:var(--spectrum-global-dimension-size-200);--spectrum-alias-item-rounded-padding-l:var(--spectrum-global-dimension-size-250);--spectrum-alias-item-rounded-padding-xl:var(--spectrum-global-dimension-size-300);--spectrum-alias-item-icononly-padding-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-item-icononly-padding-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-icononly-padding-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-icononly-padding-xl:var(--spectrum-global-dimension-size-160);--spectrum-alias-item-control-gap-s:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-control-gap-m:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-control-gap-l:var(--spectrum-global-dimension-size-130);--spectrum-alias-item-control-gap-xl:var(--spectrum-global-dimension-size-160);--spectrum-alias-item-workflow-icon-gap-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-workflow-icon-gap-m:var(--spectrum-global-dimension-size-100);--spectrum-alias-item-workflow-icon-gap-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-workflow-icon-gap-xl:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-mark-gap-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-mark-gap-m:var(--spectrum-global-dimension-size-100);--spectrum-alias-item-mark-gap-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-mark-gap-xl:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-ui-icon-gap-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-ui-icon-gap-m:var(--spectrum-global-dimension-size-100);--spectrum-alias-item-ui-icon-gap-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-ui-icon-gap-xl:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-clearbutton-gap-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-item-clearbutton-gap-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-clearbutton-gap-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-clearbutton-gap-xl:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-workflow-padding-left-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-workflow-padding-left-l:var(--spectrum-global-dimension-size-160);--spectrum-alias-item-workflow-padding-left-xl:var(--spectrum-global-dimension-size-185);--spectrum-alias-item-rounded-workflow-padding-left-s:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-rounded-workflow-padding-left-l:var(--spectrum-global-dimension-size-225);--spectrum-alias-item-mark-padding-top-s:var(--spectrum-global-dimension-size-40);--spectrum-alias-item-mark-padding-top-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-mark-padding-top-xl:var(--spectrum-global-dimension-size-130);--spectrum-alias-item-mark-padding-bottom-s:var(--spectrum-global-dimension-size-40);--spectrum-alias-item-mark-padding-bottom-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-mark-padding-bottom-xl:var(--spectrum-global-dimension-size-130);--spectrum-alias-item-mark-padding-left-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-mark-padding-left-l:var(--spectrum-global-dimension-size-160);--spectrum-alias-item-mark-padding-left-xl:var(--spectrum-global-dimension-size-185);--spectrum-alias-item-control-1-size-s:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-item-control-1-size-m:var(--spectrum-global-dimension-size-100);--spectrum-alias-item-control-2-size-m:var(--spectrum-global-dimension-size-175);--spectrum-alias-item-control-2-size-l:var(--spectrum-global-dimension-size-200);--spectrum-alias-item-control-2-size-xl:var(--spectrum-global-dimension-size-225);--spectrum-alias-item-control-2-size-xxl:var(--spectrum-global-dimension-size-250);--spectrum-alias-item-control-2-border-radius-s:var(--spectrum-global-dimension-size-75);--spectrum-alias-item-control-2-border-radius-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-control-2-border-radius-l:var(--spectrum-global-dimension-size-100);--spectrum-alias-item-control-2-border-radius-xl:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-control-2-border-radius-xxl:var(--spectrum-global-dimension-size-125);--spectrum-alias-item-control-2-padding-s:var(--spectrum-global-dimension-size-75);--spectrum-alias-item-control-2-padding-m:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-control-2-padding-l:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-control-2-padding-xl:var(--spectrum-global-dimension-size-185);--spectrum-alias-item-control-3-height-m:var(--spectrum-global-dimension-size-175);--spectrum-alias-item-control-3-height-l:var(--spectrum-global-dimension-size-200);--spectrum-alias-item-control-3-height-xl:var(--spectrum-global-dimension-size-225);--spectrum-alias-item-control-3-border-radius-s:var(--spectrum-global-dimension-size-75);--spectrum-alias-item-control-3-border-radius-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-item-control-3-border-radius-l:var(--spectrum-global-dimension-size-100);--spectrum-alias-item-control-3-border-radius-xl:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-control-3-padding-s:var(--spectrum-global-dimension-size-75);--spectrum-alias-item-control-3-padding-m:var(--spectrum-global-dimension-size-115);--spectrum-alias-item-control-3-padding-l:var(--spectrum-global-dimension-size-150);--spectrum-alias-item-control-3-padding-xl:var(--spectrum-global-dimension-size-185);--spectrum-alias-item-mark-size-s:var(--spectrum-global-dimension-size-225);--spectrum-alias-item-mark-size-l:var(--spectrum-global-dimension-size-275);--spectrum-alias-item-mark-size-xl:var(--spectrum-global-dimension-size-325);--spectrum-alias-heading-xxxl-text-size:var(--spectrum-global-dimension-font-size-1300);--spectrum-alias-heading-xxl-text-size:var(--spectrum-global-dimension-font-size-1100);--spectrum-alias-heading-xl-text-size:var(--spectrum-global-dimension-font-size-900);--spectrum-alias-heading-l-text-size:var(--spectrum-global-dimension-font-size-700);--spectrum-alias-heading-m-text-size:var(--spectrum-global-dimension-font-size-500);--spectrum-alias-heading-s-text-size:var(--spectrum-global-dimension-font-size-300);--spectrum-alias-heading-xs-text-size:var(--spectrum-global-dimension-font-size-200);--spectrum-alias-heading-xxs-text-size:var(--spectrum-global-dimension-font-size-100);--spectrum-alias-heading-xxxl-margin-top:var(--spectrum-global-dimension-font-size-1200);--spectrum-alias-heading-xxl-margin-top:var(--spectrum-global-dimension-font-size-900);--spectrum-alias-heading-xl-margin-top:var(--spectrum-global-dimension-font-size-800);--spectrum-alias-heading-l-margin-top:var(--spectrum-global-dimension-font-size-600);--spectrum-alias-heading-m-margin-top:var(--spectrum-global-dimension-font-size-400);--spectrum-alias-heading-s-margin-top:var(--spectrum-global-dimension-font-size-200);--spectrum-alias-heading-xs-margin-top:var(--spectrum-global-dimension-font-size-100);--spectrum-alias-heading-xxs-margin-top:var(--spectrum-global-dimension-font-size-75);--spectrum-alias-heading-han-xxxl-text-size:var(--spectrum-global-dimension-font-size-1300);--spectrum-alias-heading-han-xxl-text-size:var(--spectrum-global-dimension-font-size-900);--spectrum-alias-heading-han-xl-text-size:var(--spectrum-global-dimension-font-size-800);--spectrum-alias-heading-han-l-text-size:var(--spectrum-global-dimension-font-size-600);--spectrum-alias-heading-han-m-text-size:var(--spectrum-global-dimension-font-size-400);--spectrum-alias-heading-han-s-text-size:var(--spectrum-global-dimension-font-size-300);--spectrum-alias-heading-han-xs-text-size:var(--spectrum-global-dimension-font-size-200);--spectrum-alias-heading-han-xxs-text-size:var(--spectrum-global-dimension-font-size-100);--spectrum-alias-heading-han-xxxl-margin-top:var(--spectrum-global-dimension-font-size-1200);--spectrum-alias-heading-han-xxl-margin-top:var(--spectrum-global-dimension-font-size-800);--spectrum-alias-heading-han-xl-margin-top:var(--spectrum-global-dimension-font-size-700);--spectrum-alias-heading-han-l-margin-top:var(--spectrum-global-dimension-font-size-500);--spectrum-alias-heading-han-m-margin-top:var(--spectrum-global-dimension-font-size-300);--spectrum-alias-heading-han-s-margin-top:var(--spectrum-global-dimension-font-size-200);--spectrum-alias-heading-han-xs-margin-top:var(--spectrum-global-dimension-font-size-100);--spectrum-alias-heading-han-xxs-margin-top:var(--spectrum-global-dimension-font-size-75);--spectrum-alias-component-border-radius:var(--spectrum-global-dimension-size-50);--spectrum-alias-component-border-radius-quiet:var(--spectrum-global-dimension-static-size-0);--spectrum-alias-component-focusring-gap:var(--spectrum-global-dimension-static-size-0);--spectrum-alias-component-focusring-gap-emphasized:var(--spectrum-global-dimension-static-size-25);--spectrum-alias-component-focusring-size:var(--spectrum-global-dimension-static-size-10);--spectrum-alias-component-focusring-size-emphasized:var(--spectrum-global-dimension-static-size-25);--spectrum-alias-input-border-size:var(--spectrum-global-dimension-static-size-10);--spectrum-alias-input-focusring-gap:var(--spectrum-global-dimension-static-size-0);--spectrum-alias-input-quiet-focusline-gap:var(--spectrum-global-dimension-static-size-10);--spectrum-alias-control-two-size-m:var(--spectrum-global-dimension-size-175);--spectrum-alias-control-two-size-l:var(--spectrum-global-dimension-size-200);--spectrum-alias-control-two-size-xl:var(--spectrum-global-dimension-size-225);--spectrum-alias-control-two-size-xxl:var(--spectrum-global-dimension-size-250);--spectrum-alias-control-two-border-radius-s:var(--spectrum-global-dimension-size-75);--spectrum-alias-control-two-border-radius-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-control-two-border-radius-l:var(--spectrum-global-dimension-size-100);--spectrum-alias-control-two-border-radius-xl:var(--spectrum-global-dimension-size-115);--spectrum-alias-control-two-border-radius-xxl:var(--spectrum-global-dimension-size-125);--spectrum-alias-control-two-focus-ring-border-radius-s:var(--spectrum-global-dimension-size-125);--spectrum-alias-control-two-focus-ring-border-radius-m:var(--spectrum-global-dimension-size-130);--spectrum-alias-control-two-focus-ring-border-radius-l:var(--spectrum-global-dimension-size-150);--spectrum-alias-control-two-focus-ring-border-radius-xl:var(--spectrum-global-dimension-size-160);--spectrum-alias-control-two-focus-ring-border-radius-xxl:var(--spectrum-global-dimension-size-175);--spectrum-alias-control-three-height-m:var(--spectrum-global-dimension-size-175);--spectrum-alias-control-three-height-l:var(--spectrum-global-dimension-size-200);--spectrum-alias-control-three-height-xl:var(--spectrum-global-dimension-size-225);--spectrum-alias-infieldbutton-icon-margin-y-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-infieldbutton-icon-margin-y-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-infieldbutton-icon-margin-y-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-infieldbutton-icon-margin-y-xl:var(--spectrum-global-dimension-size-160);--spectrum-alias-infieldbutton-border-radius:var(--spectrum-global-dimension-size-50);--spectrum-alias-infieldbutton-border-radius-sided:0;--spectrum-alias-infieldbutton-border-size:var(--spectrum-global-dimension-static-size-10);--spectrum-alias-infieldbutton-fill-padding-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-infieldbutton-fill-padding-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-infieldbutton-fill-padding-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-infieldbutton-fill-padding-xl:var(--spectrum-global-dimension-size-160);--spectrum-alias-infieldbutton-padding-s:0;--spectrum-alias-infieldbutton-padding-m:0;--spectrum-alias-infieldbutton-padding-l:0;--spectrum-alias-infieldbutton-padding-xl:0;--spectrum-alias-infieldbutton-full-height-s:var(--spectrum-global-dimension-size-300);--spectrum-alias-infieldbutton-full-height-m:var(--spectrum-global-dimension-size-400);--spectrum-alias-infieldbutton-full-height-l:var(--spectrum-global-dimension-size-500);--spectrum-alias-infieldbutton-full-height-xl:var(--spectrum-global-dimension-size-600);--spectrum-alias-infieldbutton-half-height-s:var(--spectrum-global-dimension-size-150);--spectrum-alias-infieldbutton-half-height-m:var(--spectrum-global-dimension-size-200);--spectrum-alias-infieldbutton-half-height-l:var(--spectrum-global-dimension-size-250);--spectrum-alias-infieldbutton-half-height-xl:var(--spectrum-global-dimension-size-300);--spectrum-alias-stepperbutton-gap:0;--spectrum-alias-stepperbutton-width-s:var(--spectrum-global-dimension-size-225);--spectrum-alias-stepperbutton-width-m:var(--spectrum-global-dimension-size-300);--spectrum-alias-stepperbutton-width-l:var(--spectrum-global-dimension-size-400);--spectrum-alias-stepperbutton-width-xl:var(--spectrum-global-dimension-size-450);--spectrum-alias-stepperbutton-icon-x-offset-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-stepperbutton-icon-x-offset-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-stepperbutton-icon-x-offset-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-stepperbutton-icon-x-offset-xl:var(--spectrum-global-dimension-size-130);--spectrum-alias-stepperbutton-icon-y-offset-top-s:var(--spectrum-global-dimension-size-25);--spectrum-alias-stepperbutton-icon-y-offset-top-m:var(--spectrum-global-dimension-size-50);--spectrum-alias-stepperbutton-icon-y-offset-top-l:var(--spectrum-global-dimension-size-65);--spectrum-alias-stepperbutton-icon-y-offset-top-xl:var(--spectrum-global-dimension-size-75);--spectrum-alias-stepperbutton-icon-y-offset-bottom-s:var(--spectrum-global-dimension-size-10);--spectrum-alias-stepperbutton-icon-y-offset-bottom-m:var(--spectrum-global-dimension-size-25);--spectrum-alias-stepperbutton-icon-y-offset-bottom-l:var(--spectrum-global-dimension-size-40);--spectrum-alias-stepperbutton-icon-y-offset-bottom-xl:var(--spectrum-global-dimension-size-50);--spectrum-alias-stepperbutton-radius-touching:0;--spectrum-alias-clearbutton-icon-margin-s:var(--spectrum-global-dimension-size-100);--spectrum-alias-clearbutton-icon-margin-m:var(--spectrum-global-dimension-size-150);--spectrum-alias-clearbutton-icon-margin-l:var(--spectrum-global-dimension-size-185);--spectrum-alias-clearbutton-icon-margin-xl:var(--spectrum-global-dimension-size-225);--spectrum-alias-clearbutton-border-radius:var(--spectrum-global-dimension-size-50);--spectrum-alias-pickerbutton-icononly-padding-x-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-pickerbutton-icononly-padding-x-m:var(--spectrum-global-dimension-size-125);--spectrum-alias-pickerbutton-icononly-padding-x-l:var(--spectrum-global-dimension-size-160);--spectrum-alias-pickerbutton-icononly-padding-x-xl:var(--spectrum-global-dimension-size-200);--spectrum-alias-pickerbutton-icon-margin-y-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-pickerbutton-icon-margin-y-m:var(--spectrum-global-dimension-size-125);--spectrum-alias-pickerbutton-icon-margin-y-l:var(--spectrum-global-dimension-size-160);--spectrum-alias-pickerbutton-icon-margin-y-xl:var(--spectrum-global-dimension-size-200);--spectrum-alias-pickerbutton-label-padding-y-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-pickerbutton-label-padding-y-m:var(--spectrum-global-dimension-size-75);--spectrum-alias-pickerbutton-label-padding-y-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-pickerbutton-label-padding-y-xl:var(--spectrum-global-dimension-size-150);--spectrum-alias-pickerbutton-border-radius-rounded:var(--spectrum-global-dimension-size-50);--spectrum-alias-pickerbutton-border-radius-rounded-sided:0;--spectrum-alias-search-border-radius:var(--spectrum-global-dimension-size-50);--spectrum-alias-search-border-radius-quiet:0;--spectrum-alias-combobox-quiet-button-offset-x:var(--spectrum-global-dimension-size-100);--spectrum-alias-thumbnail-border-radius-small:var(--spectrum-global-dimension-size-25);--spectrum-alias-actiongroup-button-gap:var(--spectrum-global-dimension-size-100);--spectrum-alias-actiongroup-button-gap-compact:var(--spectrum-global-dimension-size-0);--spectrum-alias-actiongroup-button-gap-quiet:var(--spectrum-global-dimension-size-100);--spectrum-alias-actiongroup-button-gap-quiet-compact:var(--spectrum-global-dimension-size-25);--spectrum-alias-search-padding-left-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-search-padding-left-l:var(--spectrum-global-dimension-size-160);--spectrum-alias-search-padding-left-xl:var(--spectrum-global-dimension-size-185);--spectrum-alias-percent-50:50%;--spectrum-alias-percent-70:70%;--spectrum-alias-percent-100:100%;--spectrum-alias-breakpoint-xsmall:304px;--spectrum-alias-breakpoint-small:768px;--spectrum-alias-breakpoint-medium:1280px;--spectrum-alias-breakpoint-large:1768px;--spectrum-alias-breakpoint-xlarge:2160px;--spectrum-alias-grid-columns:12;--spectrum-alias-grid-fluid-width:100%;--spectrum-alias-grid-fixed-max-width:1280px;--spectrum-alias-focus-ring-gap-small:var(--spectrum-global-dimension-static-size-0);--spectrum-alias-focus-ring-size-small:var(--spectrum-global-dimension-static-size-10);--spectrum-alias-dropshadow-blur:var(--spectrum-global-dimension-size-50);--spectrum-alias-dropshadow-offset-y:var(--spectrum-global-dimension-size-10);--spectrum-alias-font-size-default:var(--spectrum-global-dimension-font-size-100);--spectrum-alias-layout-label-gap-size:var(--spectrum-global-dimension-size-100);--spectrum-alias-pill-button-text-size:var(--spectrum-global-dimension-font-size-100);--spectrum-alias-pill-button-text-baseline:var(--spectrum-global-dimension-static-size-150);--spectrum-alias-border-radius-xsmall:var(--spectrum-global-dimension-size-10);--spectrum-alias-border-radius-small:var(--spectrum-global-dimension-size-25);--spectrum-alias-border-radius-regular:var(--spectrum-global-dimension-size-50);--spectrum-alias-border-radius-medium:var(--spectrum-global-dimension-size-100);--spectrum-alias-border-radius-large:var(--spectrum-global-dimension-size-200);--spectrum-alias-border-radius-xlarge:var(--spectrum-global-dimension-size-300);--spectrum-alias-focus-ring-border-radius-xsmall:var(--spectrum-global-dimension-size-50);--spectrum-alias-focus-ring-border-radius-small:var(--spectrum-global-dimension-static-size-65);--spectrum-alias-focus-ring-border-radius-medium:var(--spectrum-global-dimension-size-150);--spectrum-alias-focus-ring-border-radius-large:var(--spectrum-global-dimension-size-250);--spectrum-alias-focus-ring-border-radius-xlarge:var(--spectrum-global-dimension-size-350);--spectrum-alias-single-line-height:var(--spectrum-global-dimension-size-400);--spectrum-alias-single-line-width:var(--spectrum-global-dimension-size-2400);--spectrum-alias-workflow-icon-size-s:var(--spectrum-global-dimension-size-200);--spectrum-alias-workflow-icon-size-m:var(--spectrum-global-dimension-size-225);--spectrum-alias-workflow-icon-size-xl:var(--spectrum-global-dimension-size-275);--spectrum-alias-ui-icon-alert-size-75:var(--spectrum-global-dimension-size-200);--spectrum-alias-ui-icon-alert-size-100:var(--spectrum-global-dimension-size-225);--spectrum-alias-ui-icon-alert-size-200:var(--spectrum-global-dimension-size-250);--spectrum-alias-ui-icon-alert-size-300:var(--spectrum-global-dimension-size-275);--spectrum-alias-ui-icon-triplegripper-size-100-height:var(--spectrum-global-dimension-size-100);--spectrum-alias-ui-icon-doublegripper-size-100-width:var(--spectrum-global-dimension-size-200);--spectrum-alias-ui-icon-singlegripper-size-100-width:var(--spectrum-global-dimension-size-300);--spectrum-alias-ui-icon-cornertriangle-size-75:var(--spectrum-global-dimension-size-65);--spectrum-alias-ui-icon-cornertriangle-size-200:var(--spectrum-global-dimension-size-75);--spectrum-alias-ui-icon-asterisk-size-75:var(--spectrum-global-dimension-static-size-100);--spectrum-alias-ui-icon-asterisk-size-100:var(--spectrum-global-dimension-size-100);--spectrum-alias-avatar-size-50:var(--spectrum-global-dimension-size-200);--spectrum-alias-avatar-size-75:var(--spectrum-global-dimension-size-225);--spectrum-alias-avatar-size-200:var(--spectrum-global-dimension-size-275);--spectrum-alias-avatar-size-300:var(--spectrum-global-dimension-size-325);--spectrum-alias-avatar-size-500:var(--spectrum-global-dimension-size-400);--spectrum-alias-avatar-size-700:var(--spectrum-global-dimension-size-500);--spectrum-alias-avatar-border-size:var(--spectrum-global-dimension-size-0);--spectrum-alias-tag-border-radius:var(--spectrum-global-dimension-size-50);--spectrum-alias-tag-border-size-default:var(--spectrum-global-dimension-static-size-10);--spectrum-alias-tag-border-size-key-focus:var(--spectrum-global-dimension-static-size-25);--spectrum-alias-tag-border-size-disabled:var(--spectrum-global-dimension-size-0);--spectrum-alias-tag-border-size:var(--spectrum-global-dimension-static-size-10);--spectrum-alias-tag-padding-right-s:var(--spectrum-global-dimension-size-115);--spectrum-alias-tag-padding-right-m:var(--spectrum-global-dimension-size-150);--spectrum-alias-tag-padding-right-l:var(--spectrum-global-dimension-size-185);--spectrum-alias-tag-height-s:var(--spectrum-global-dimension-size-300);--spectrum-alias-tag-height-m:var(--spectrum-global-dimension-size-400);--spectrum-alias-tag-height-l:var(--spectrum-global-dimension-size-500);--spectrum-alias-tag-font-size-s:var(--spectrum-global-dimension-font-size-75);--spectrum-alias-tag-font-size-m:var(--spectrum-global-dimension-font-size-100);--spectrum-alias-tag-font-size-l:var(--spectrum-global-dimension-font-size-200);--spectrum-alias-tag-text-padding-top-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-tag-text-padding-top-m:var(--spectrum-global-dimension-size-75);--spectrum-alias-tag-text-padding-top-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-tag-icon-size-s:var(--spectrum-global-dimension-size-200);--spectrum-alias-tag-icon-size-m:var(--spectrum-global-dimension-size-225);--spectrum-alias-tag-icon-margin-top-s:var(--spectrum-global-dimension-size-50);--spectrum-alias-tag-icon-margin-top-m:var(--spectrum-global-dimension-size-85);--spectrum-alias-tag-icon-margin-top-l:var(--spectrum-global-dimension-size-125);--spectrum-alias-tag-icon-margin-right-s:var(--spectrum-global-dimension-size-85);--spectrum-alias-tag-icon-margin-right-m:var(--spectrum-global-dimension-size-100);--spectrum-alias-tag-icon-margin-right-l:var(--spectrum-global-dimension-size-115);--spectrum-alias-tag-clearbutton-width-s:var(--spectrum-global-dimension-size-300);--spectrum-alias-tag-clearbutton-width-m:var(--spectrum-global-dimension-size-400);--spectrum-alias-tag-clearbutton-width-l:var(--spectrum-global-dimension-size-500);--spectrum-alias-tag-clearbutton-icon-margin-s:var(--spectrum-global-dimension-size-100);--spectrum-alias-tag-clearbutton-icon-margin-m:var(--spectrum-global-dimension-size-150);--spectrum-alias-tag-clearbutton-icon-margin-l:var(--spectrum-global-dimension-size-185);--spectrum-alias-tag-focusring-size:var(--spectrum-global-dimension-size-25);--spectrum-alias-tag-focusring-gap:var(--spectrum-global-dimension-static-size-0);--spectrum-alias-tag-focusring-gap-selected:var(--spectrum-global-dimension-size-25);--spectrum-alias-colorloupe-width:var(--spectrum-global-dimension-static-size-600);--spectrum-alias-colorloupe-height:var(--spectrum-global-dimension-static-size-800);--spectrum-alias-colorhandle-outer-border-color:#0000006b;--spectrum-alias-transparent-blue-background-color-hover:#0057be26;--spectrum-alias-transparent-blue-background-color-down:#0048994d;--spectrum-alias-transparent-blue-background-color-key-focus:var(--spectrum-alias-transparent-blue-background-color-hover);--spectrum-alias-transparent-blue-background-color-mouse-focus:var(--spectrum-alias-transparent-blue-background-color-hover);--spectrum-alias-transparent-blue-background-color:var(--spectrum-alias-component-text-color-default);--spectrum-alias-transparent-red-background-color-hover:#9a000026;--spectrum-alias-transparent-red-background-color-down:#7c00004d;--spectrum-alias-transparent-red-background-color-key-focus:var(--spectrum-alias-transparent-red-background-color-hover);--spectrum-alias-transparent-red-background-color-mouse-focus:var(--spectrum-alias-transparent-red-background-color-hover);--spectrum-alias-transparent-red-background-color:var(--spectrum-alias-component-text-color-default);--spectrum-alias-component-text-color-disabled:var(--spectrum-global-color-gray-500);--spectrum-alias-component-text-color-default:var(--spectrum-global-color-gray-800);--spectrum-alias-component-text-color-hover:var(--spectrum-global-color-gray-900);--spectrum-alias-component-text-color-down:var(--spectrum-global-color-gray-900);--spectrum-alias-component-text-color-key-focus:var(--spectrum-alias-component-text-color-hover);--spectrum-alias-component-text-color-mouse-focus:var(--spectrum-alias-component-text-color-hover);--spectrum-alias-component-text-color:var(--spectrum-alias-component-text-color-default);--spectrum-alias-component-text-color-selected-default:var(--spectrum-alias-component-text-color-default);--spectrum-alias-component-text-color-selected-hover:var(--spectrum-alias-component-text-color-hover);--spectrum-alias-component-text-color-selected-down:var(--spectrum-alias-component-text-color-down);--spectrum-alias-component-text-color-selected-key-focus:var(--spectrum-alias-component-text-color-key-focus);--spectrum-alias-component-text-color-selected-mouse-focus:var(--spectrum-alias-component-text-color-mouse-focus);--spectrum-alias-component-text-color-selected:var(--spectrum-alias-component-text-color-selected-default);--spectrum-alias-component-text-color-emphasized-selected-default:var(--spectrum-global-color-static-white);--spectrum-alias-component-text-color-emphasized-selected-hover:var(--spectrum-alias-component-text-color-emphasized-selected-default);--spectrum-alias-component-text-color-emphasized-selected-down:var(--spectrum-alias-component-text-color-emphasized-selected-default);--spectrum-alias-component-text-color-emphasized-selected-key-focus:var(--spectrum-alias-component-text-color-emphasized-selected-default);--spectrum-alias-component-text-color-emphasized-selected-mouse-focus:var(--spectrum-alias-component-text-color-emphasized-selected-default);--spectrum-alias-component-text-color-emphasized-selected:var(--spectrum-alias-component-text-color-emphasized-selected-default);--spectrum-alias-component-text-color-error-default:var(--spectrum-semantic-negative-text-color-small);--spectrum-alias-component-text-color-error-hover:var(--spectrum-semantic-negative-text-color-small-hover);--spectrum-alias-component-text-color-error-down:var(--spectrum-semantic-negative-text-color-small-down);--spectrum-alias-component-text-color-error-key-focus:var(--spectrum-semantic-negative-text-color-small-key-focus);--spectrum-alias-component-text-color-error-mouse-focus:var(--spectrum-semantic-negative-text-color-small-key-focus);--spectrum-alias-component-text-color-error:var(--spectrum-alias-component-text-color-error-default);--spectrum-alias-component-icon-color-disabled:var(--spectrum-alias-icon-color-disabled);--spectrum-alias-component-icon-color-default:var(--spectrum-alias-icon-color);--spectrum-alias-component-icon-color-hover:var(--spectrum-alias-icon-color-hover);--spectrum-alias-component-icon-color-down:var(--spectrum-alias-icon-color-down);--spectrum-alias-component-icon-color-key-focus:var(--spectrum-alias-icon-color-hover);--spectrum-alias-component-icon-color-mouse-focus:var(--spectrum-alias-icon-color-down);--spectrum-alias-component-icon-color:var(--spectrum-alias-component-icon-color-default);--spectrum-alias-component-icon-color-selected:var(--spectrum-alias-icon-color-selected-neutral-subdued);--spectrum-alias-component-icon-color-emphasized-selected-default:var(--spectrum-global-color-static-white);--spectrum-alias-component-icon-color-emphasized-selected-hover:var(--spectrum-alias-component-icon-color-emphasized-selected-default);--spectrum-alias-component-icon-color-emphasized-selected-down:var(--spectrum-alias-component-icon-color-emphasized-selected-default);--spectrum-alias-component-icon-color-emphasized-selected-key-focus:var(--spectrum-alias-component-icon-color-emphasized-selected-default);--spectrum-alias-component-icon-color-emphasized-selected:var(--spectrum-alias-component-icon-color-emphasized-selected-default);--spectrum-alias-component-background-color-disabled:var(--spectrum-global-color-gray-200);--spectrum-alias-component-background-color-quiet-disabled:var(--spectrum-alias-background-color-transparent);--spectrum-alias-component-background-color-quiet-selected-disabled:var(--spectrum-alias-component-background-color-disabled);--spectrum-alias-component-background-color-default:var(--spectrum-global-color-gray-75);--spectrum-alias-component-background-color-hover:var(--spectrum-global-color-gray-50);--spectrum-alias-component-background-color-down:var(--spectrum-global-color-gray-200);--spectrum-alias-component-background-color-key-focus:var(--spectrum-global-color-gray-50);--spectrum-alias-component-background-color:var(--spectrum-alias-component-background-color-default);--spectrum-alias-component-background-color-selected-default:var(--spectrum-global-color-gray-200);--spectrum-alias-component-background-color-selected-hover:var(--spectrum-global-color-gray-200);--spectrum-alias-component-background-color-selected-down:var(--spectrum-global-color-gray-200);--spectrum-alias-component-background-color-selected-key-focus:var(--spectrum-global-color-gray-200);--spectrum-alias-component-background-color-selected:var(--spectrum-alias-component-background-color-selected-default);--spectrum-alias-component-background-color-quiet-default:var(--spectrum-alias-background-color-transparent);--spectrum-alias-component-background-color-quiet-hover:var(--spectrum-alias-background-color-transparent);--spectrum-alias-component-background-color-quiet-down:var(--spectrum-global-color-gray-300);--spectrum-alias-component-background-color-quiet-key-focus:var(--spectrum-alias-background-color-transparent);--spectrum-alias-component-background-color-quiet:var(--spectrum-alias-component-background-color-quiet-default);--spectrum-alias-component-background-color-quiet-selected-default:var(--spectrum-alias-component-background-color-selected-default);--spectrum-alias-component-background-color-quiet-selected-hover:var(--spectrum-alias-component-background-color-selected-hover);--spectrum-alias-component-background-color-quiet-selected-down:var(--spectrum-alias-component-background-color-selected-down);--spectrum-alias-component-background-color-quiet-selected-key-focus:var(--spectrum-alias-component-background-color-selected-key-focus);--spectrum-alias-component-background-color-quiet-selected:var(--spectrum-alias-component-background-color-selected-default);--spectrum-alias-component-background-color-emphasized-selected-default:var(--spectrum-semantic-cta-background-color-default);--spectrum-alias-component-background-color-emphasized-selected-hover:var(--spectrum-semantic-cta-background-color-hover);--spectrum-alias-component-background-color-emphasized-selected-down:var(--spectrum-semantic-cta-background-color-down);--spectrum-alias-component-background-color-emphasized-selected-key-focus:var(--spectrum-semantic-cta-background-color-key-focus);--spectrum-alias-component-background-color-emphasized-selected:var(--spectrum-alias-component-background-color-emphasized-selected-default);--spectrum-alias-component-border-color-disabled:var(--spectrum-alias-border-color-disabled);--spectrum-alias-component-border-color-quiet-disabled:var(--spectrum-alias-border-color-transparent);--spectrum-alias-component-border-color-default:var(--spectrum-alias-border-color);--spectrum-alias-component-border-color-hover:var(--spectrum-alias-border-color-hover);--spectrum-alias-component-border-color-down:var(--spectrum-alias-border-color-down);--spectrum-alias-component-border-color-key-focus:var(--spectrum-alias-border-color-key-focus);--spectrum-alias-component-border-color:var(--spectrum-alias-component-border-color-default);--spectrum-alias-component-border-color-selected-default:var(--spectrum-alias-border-color);--spectrum-alias-component-border-color-selected-hover:var(--spectrum-alias-border-color-hover);--spectrum-alias-component-border-color-selected-down:var(--spectrum-alias-border-color-down);--spectrum-alias-component-border-color-selected-key-focus:var(--spectrum-alias-border-color-key-focus);--spectrum-alias-component-border-color-selected:var(--spectrum-alias-component-border-color-selected-default);--spectrum-alias-component-border-color-quiet-default:var(--spectrum-alias-border-color-transparent);--spectrum-alias-component-border-color-quiet-hover:var(--spectrum-alias-border-color-transparent);--spectrum-alias-component-border-color-quiet-down:var(--spectrum-alias-border-color-transparent);--spectrum-alias-component-border-color-quiet-key-focus:var(--spectrum-alias-border-color-key-focus);--spectrum-alias-component-border-color-quiet:var(--spectrum-alias-component-border-color-quiet-default);--spectrum-alias-component-border-color-quiet-selected-default:var(--spectrum-global-color-gray-200);--spectrum-alias-component-border-color-quiet-selected-hover:var(--spectrum-global-color-gray-200);--spectrum-alias-component-border-color-quiet-selected-down:var(--spectrum-global-color-gray-200);--spectrum-alias-component-border-color-quiet-selected-key-focus:var(--spectrum-alias-border-color-key-focus);--spectrum-alias-component-border-color-quiet-selected:var(--spectrum-alias-component-border-color-quiet-selected-default);--spectrum-alias-component-border-color-emphasized-selected-default:var(--spectrum-semantic-cta-background-color-default);--spectrum-alias-component-border-color-emphasized-selected-hover:var(--spectrum-semantic-cta-background-color-hover);--spectrum-alias-component-border-color-emphasized-selected-down:var(--spectrum-semantic-cta-background-color-down);--spectrum-alias-component-border-color-emphasized-selected-key-focus:var(--spectrum-semantic-cta-background-color-key-focus);--spectrum-alias-component-border-color-emphasized-selected:var(--spectrum-alias-component-border-color-emphasized-selected-default);--spectrum-alias-tag-border-color-default:var(--spectrum-alias-border-color-darker-default);--spectrum-alias-tag-border-color-hover:var(--spectrum-alias-border-color-darker-hover);--spectrum-alias-tag-border-color-down:var(--spectrum-alias-border-color-darker-hover);--spectrum-alias-tag-border-color-key-focus:var(--spectrum-alias-border-color-key-focus);--spectrum-alias-tag-border-color-error-default:var(--spectrum-semantic-negative-color-default);--spectrum-alias-tag-border-color-error-hover:var(--spectrum-semantic-negative-color-hover);--spectrum-alias-tag-border-color-error-down:var(--spectrum-semantic-negative-color-hover);--spectrum-alias-tag-border-color-error-key-focus:var(--spectrum-alias-border-color-key-focus);--spectrum-alias-tag-border-color-error-selected:var(--spectrum-semantic-negative-color-default);--spectrum-alias-tag-border-color-selected:var(--spectrum-alias-tag-background-color-selected-default);--spectrum-alias-tag-border-color:var(--spectrum-alias-tag-border-color-default);--spectrum-alias-tag-border-color-disabled:var(--spectrum-alias-border-color-disabled);--spectrum-alias-tag-border-color-error:var(--spectrum-alias-tag-border-color-error-default);--spectrum-alias-tag-text-color-default:var(--spectrum-alias-label-text-color);--spectrum-alias-tag-text-color-hover:var(--spectrum-alias-text-color-hover);--spectrum-alias-tag-text-color-down:var(--spectrum-alias-text-color-down);--spectrum-alias-tag-text-color-key-focus:var(--spectrum-alias-text-color-hover);--spectrum-alias-tag-text-color-disabled:var(--spectrum-global-color-gray-500);--spectrum-alias-tag-text-color:var(--spectrum-alias-tag-text-color-default);--spectrum-alias-tag-text-color-error-default:var(--spectrum-global-color-red-600);--spectrum-alias-tag-text-color-error-hover:var(--spectrum-global-color-red-700);--spectrum-alias-tag-text-color-error-down:var(--spectrum-global-color-red-700);--spectrum-alias-tag-text-color-error-key-focus:var(--spectrum-global-color-red-700);--spectrum-alias-tag-text-color-error:var(--spectrum-alias-tag-text-color-error-default);--spectrum-alias-tag-text-color-selected:var(--spectrum-global-color-gray-50);--spectrum-alias-tag-icon-color-default:var(--spectrum-alias-icon-color);--spectrum-alias-tag-icon-color-hover:var(--spectrum-alias-icon-color-hover);--spectrum-alias-tag-icon-color-down:var(--spectrum-alias-icon-color-down);--spectrum-alias-tag-icon-color-key-focus:var(--spectrum-alias-icon-color-hover);--spectrum-alias-tag-icon-color-disabled:var(--spectrum-alias-icon-color-disabled);--spectrum-alias-tag-icon-color:var(--spectrum-alias-tag-icon-color-default);--spectrum-alias-tag-icon-color-error:var(--spectrum-global-color-red-600);--spectrum-alias-tag-icon-color-selected:var(--spectrum-global-color-gray-50);--spectrum-alias-tag-background-color-disabled:var(--spectrum-global-color-gray-200);--spectrum-alias-tag-background-color-default:var(--spectrum-global-color-gray-50);--spectrum-alias-tag-background-color-hover:var(--spectrum-global-color-gray-50);--spectrum-alias-tag-background-color-down:var(--spectrum-global-color-gray-200);--spectrum-alias-tag-background-color-key-focus:var(--spectrum-global-color-gray-50);--spectrum-alias-tag-background-color:var(--spectrum-alias-tag-background-color-default);--spectrum-alias-tag-background-color-error-default:var(--spectrum-global-color-gray-50);--spectrum-alias-tag-background-color-error-hover:var(--spectrum-global-color-gray-50);--spectrum-alias-tag-background-color-error-down:var(--spectrum-global-color-gray-200);--spectrum-alias-tag-background-color-error-key-focus:var(--spectrum-global-color-gray-50);--spectrum-alias-tag-background-color-error:var(--spectrum-alias-tag-background-color-error-default);--spectrum-alias-tag-background-color-error-selected-default:var(--spectrum-semantic-negative-color-default);--spectrum-alias-tag-background-color-error-selected-hover:var(--spectrum-semantic-negative-color-hover);--spectrum-alias-tag-background-color-error-selected-down:var(--spectrum-semantic-negative-color-hover);--spectrum-alias-tag-background-color-error-selected-key-focus:var(--spectrum-global-color-red-600);--spectrum-alias-tag-background-color-error-selected:var(--spectrum-alias-tag-background-color-error-selected-default);--spectrum-alias-tag-background-color-selected-default:var(--spectrum-global-color-gray-700);--spectrum-alias-tag-background-color-selected-hover:var(--spectrum-global-color-gray-800);--spectrum-alias-tag-background-color-selected-down:var(--spectrum-global-color-gray-900);--spectrum-alias-tag-background-color-selected-key-focus:var(--spectrum-global-color-gray-900);--spectrum-alias-tag-background-color-selected:var(--spectrum-alias-tag-background-color-selected-default);--spectrum-alias-tag-focusring-border-color-default:transparent;--spectrum-alias-tag-focusring-border-color-key-focus:transparent;--spectrum-alias-tag-focusring-border-color-disabled:transparent;--spectrum-alias-tag-focusring-border-color-selected-key-focus:var(--spectrum-alias-focus-ring-color);--spectrum-alias-tag-focusring-border-color:var(--spectrum-alias-tag-focusring-border-color-default);--spectrum-alias-avatar-border-color-default:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color-hover:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color-down:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color-key-focus:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color:var(--spectrum-alias-avatar-border-color-default);--spectrum-alias-avatar-border-color-disabled:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color-selected-default:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color-selected-hover:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color-selected-down:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color-selected-key-focus:var(--spectrum-alias-background-color-transparent);--spectrum-alias-avatar-border-color-selected:var(--spectrum-alias-avatar-border-color-selected-default);--spectrum-alias-avatar-border-color-selected-disabled:var(--spectrum-alias-background-color-transparent);--spectrum-alias-toggle-background-color-default:var(--spectrum-global-color-gray-700);--spectrum-alias-toggle-background-color-hover:var(--spectrum-global-color-gray-800);--spectrum-alias-toggle-background-color-down:var(--spectrum-global-color-gray-900);--spectrum-alias-toggle-background-color-key-focus:var(--spectrum-global-color-gray-800);--spectrum-alias-toggle-background-color:var(--spectrum-alias-toggle-background-color-default);--spectrum-alias-toggle-background-color-emphasized-selected-default:var(--spectrum-global-color-blue-500);--spectrum-alias-toggle-background-color-emphasized-selected-hover:var(--spectrum-global-color-blue-600);--spectrum-alias-toggle-background-color-emphasized-selected-down:var(--spectrum-global-color-blue-700);--spectrum-alias-toggle-background-color-emphasized-selected-key-focus:var(--spectrum-global-color-blue-600);--spectrum-alias-toggle-background-color-emphasized-selected:var(--spectrum-alias-toggle-background-color-emphasized-selected-default);--spectrum-alias-toggle-border-color-default:var(--spectrum-global-color-gray-700);--spectrum-alias-toggle-border-color-hover:var(--spectrum-global-color-gray-800);--spectrum-alias-toggle-border-color-down:var(--spectrum-global-color-gray-900);--spectrum-alias-toggle-border-color-key-focus:var(--spectrum-global-color-gray-800);--spectrum-alias-toggle-border-color:var(--spectrum-alias-toggle-border-color-default);--spectrum-alias-toggle-icon-color-selected:var(--spectrum-global-color-gray-75);--spectrum-alias-toggle-icon-color-emphasized-selected:var(--spectrum-global-color-gray-75);--spectrum-alias-button-primary-background-color-default:var(--spectrum-alias-background-color-transparent);--spectrum-alias-button-primary-background-color-hover:var(--spectrum-global-color-gray-800);--spectrum-alias-button-primary-background-color-down:var(--spectrum-global-color-gray-900);--spectrum-alias-button-primary-background-color-key-focus:var(--spectrum-global-color-gray-800);--spectrum-alias-button-primary-background-color:var(--spectrum-alias-button-primary-background-color-default);--spectrum-alias-button-primary-border-color-default:var(--spectrum-global-color-gray-800);--spectrum-alias-button-primary-border-color-hover:var(--spectrum-alias-button-primary-background-color-hover);--spectrum-alias-button-primary-border-color-down:var(--spectrum-alias-button-primary-background-color-down);--spectrum-alias-button-primary-border-color-key-focus:var(--spectrum-alias-button-primary-background-color-key-focus);--spectrum-alias-button-primary-border-color:var(--spectrum-alias-button-primary-border-color-default);--spectrum-alias-button-primary-text-color-default:var(--spectrum-global-color-gray-800);--spectrum-alias-button-primary-text-color-hover:var(--spectrum-global-color-gray-50);--spectrum-alias-button-primary-text-color-down:var(--spectrum-global-color-gray-50);--spectrum-alias-button-primary-text-color-key-focus:var(--spectrum-global-color-gray-50);--spectrum-alias-button-primary-text-color:var(--spectrum-alias-button-primary-text-color-default);--spectrum-alias-button-primary-icon-color-default:var(--spectrum-alias-button-primary-text-color-default);--spectrum-alias-button-primary-icon-color-hover:var(--spectrum-alias-button-primary-text-color-hover);--spectrum-alias-button-primary-icon-color-down:var(--spectrum-alias-button-primary-text-color-down);--spectrum-alias-button-primary-icon-color-key-focus:var(--spectrum-alias-button-primary-text-color-key-focus);--spectrum-alias-button-primary-icon-color:var(--spectrum-alias-button-primary-icon-color-default);--spectrum-alias-button-secondary-background-color-default:var(--spectrum-alias-background-color-transparent);--spectrum-alias-button-secondary-background-color-hover:var(--spectrum-global-color-gray-700);--spectrum-alias-button-secondary-background-color-down:var(--spectrum-global-color-gray-800);--spectrum-alias-button-secondary-background-color-key-focus:var(--spectrum-global-color-gray-700);--spectrum-alias-button-secondary-background-color:var(--spectrum-alias-button-secondary-background-color-default);--spectrum-alias-button-secondary-border-color-default:var(--spectrum-global-color-gray-700);--spectrum-alias-button-secondary-border-color-hover:var(--spectrum-alias-button-secondary-background-color-hover);--spectrum-alias-button-secondary-border-color-down:var(--spectrum-alias-button-secondary-background-color-down);--spectrum-alias-button-secondary-border-color-key-focus:var(--spectrum-alias-button-secondary-background-color-key-focus);--spectrum-alias-button-secondary-border-color:var(--spectrum-alias-button-secondary-border-color-default);--spectrum-alias-button-secondary-text-color-default:var(--spectrum-global-color-gray-700);--spectrum-alias-button-secondary-text-color-hover:var(--spectrum-global-color-gray-50);--spectrum-alias-button-secondary-text-color-down:var(--spectrum-global-color-gray-50);--spectrum-alias-button-secondary-text-color-key-focus:var(--spectrum-global-color-gray-50);--spectrum-alias-button-secondary-text-color:var(--spectrum-alias-button-secondary-text-color-default);--spectrum-alias-button-secondary-icon-color-default:var(--spectrum-alias-button-secondary-text-color-default);--spectrum-alias-button-secondary-icon-color-hover:var(--spectrum-alias-button-secondary-text-color-hover);--spectrum-alias-button-secondary-icon-color-down:var(--spectrum-alias-button-secondary-text-color-down);--spectrum-alias-button-secondary-icon-color-key-focus:var(--spectrum-alias-button-secondary-text-color-key-focus);--spectrum-alias-button-secondary-icon-color:var(--spectrum-alias-button-secondary-icon-color-default);--spectrum-alias-button-negative-background-color-default:var(--spectrum-alias-background-color-transparent);--spectrum-alias-button-negative-background-color-hover:var(--spectrum-semantic-negative-text-color-small);--spectrum-alias-button-negative-background-color-down:var(--spectrum-global-color-red-700);--spectrum-alias-button-negative-background-color-key-focus:var(--spectrum-semantic-negative-text-color-small);--spectrum-alias-button-negative-background-color:var(--spectrum-alias-button-negative-background-color-default);--spectrum-alias-button-negative-border-color-default:var(--spectrum-semantic-negative-text-color-small);--spectrum-alias-button-negative-border-color-hover:var(--spectrum-semantic-negative-text-color-small);--spectrum-alias-button-negative-border-color-down:var(--spectrum-global-color-red-700);--spectrum-alias-button-negative-border-color-key-focus:var(--spectrum-semantic-negative-text-color-small);--spectrum-alias-button-negative-border-color:var(--spectrum-alias-button-negative-border-color-default);--spectrum-alias-button-negative-text-color-default:var(--spectrum-semantic-negative-text-color-small);--spectrum-alias-button-negative-text-color-hover:var(--spectrum-global-color-gray-50);--spectrum-alias-button-negative-text-color-down:var(--spectrum-global-color-gray-50);--spectrum-alias-button-negative-text-color-key-focus:var(--spectrum-global-color-gray-50);--spectrum-alias-button-negative-text-color:var(--spectrum-alias-button-negative-text-color-default);--spectrum-alias-button-negative-icon-color-default:var(--spectrum-alias-button-negative-text-color-default);--spectrum-alias-button-negative-icon-color-hover:var(--spectrum-alias-button-negative-text-color-hover);--spectrum-alias-button-negative-icon-color-down:var(--spectrum-alias-button-negative-text-color-down);--spectrum-alias-button-negative-icon-color-key-focus:var(--spectrum-alias-button-negative-text-color-key-focus);--spectrum-alias-button-negative-icon-color:var(--spectrum-alias-button-negative-icon-color-default);--spectrum-alias-input-border-color-disabled:var(--spectrum-alias-border-color-transparent);--spectrum-alias-input-border-color-quiet-disabled:var(--spectrum-alias-border-color-mid);--spectrum-alias-input-border-color-default:var(--spectrum-alias-border-color);--spectrum-alias-input-border-color-hover:var(--spectrum-alias-border-color-hover);--spectrum-alias-input-border-color-down:var(--spectrum-alias-border-color-mouse-focus);--spectrum-alias-input-border-color-mouse-focus:var(--spectrum-alias-border-color-mouse-focus);--spectrum-alias-input-border-color-key-focus:var(--spectrum-alias-border-color-key-focus);--spectrum-alias-input-border-color:var(--spectrum-alias-input-border-color-default);--spectrum-alias-input-border-color-invalid-default:var(--spectrum-semantic-negative-color-default);--spectrum-alias-input-border-color-invalid-hover:var(--spectrum-semantic-negative-color-hover);--spectrum-alias-input-border-color-invalid-down:var(--spectrum-semantic-negative-color-down);--spectrum-alias-input-border-color-invalid-mouse-focus:var(--spectrum-semantic-negative-color-hover);--spectrum-alias-input-border-color-invalid-key-focus:var(--spectrum-alias-border-color-key-focus);--spectrum-alias-input-border-color-invalid:var(--spectrum-alias-input-border-color-invalid-default);--spectrum-alias-background-color-yellow-default:var(--spectrum-global-color-static-yellow-300);--spectrum-alias-background-color-yellow-hover:var(--spectrum-global-color-static-yellow-400);--spectrum-alias-background-color-yellow-key-focus:var(--spectrum-global-color-static-yellow-400);--spectrum-alias-background-color-yellow-down:var(--spectrum-global-color-static-yellow-500);--spectrum-alias-background-color-yellow:var(--spectrum-alias-background-color-yellow-default);--spectrum-alias-infieldbutton-background-color:var(--spectrum-global-color-gray-200);--spectrum-alias-infieldbutton-fill-loudnessLow-border-color-disabled:transparent;--spectrum-alias-infieldbutton-fill-loudnessMedium-border-color-disabled:transparent;--spectrum-alias-infieldbutton-fill-loudnessHigh-border-color-disabled:var(--spectrum-alias-component-background-color-disabled);--spectrum-alias-infieldbutton-fill-border-color-default:var(--spectrum-alias-input-border-color-default);--spectrum-alias-infieldbutton-fill-border-color-hover:var(--spectrum-alias-input-border-color-hover);--spectrum-alias-infieldbutton-fill-border-color-down:var(--spectrum-alias-input-border-color-down);--spectrum-alias-infieldbutton-fill-border-color-mouse-focus:var(--spectrum-alias-input-border-color-mouse-focus);--spectrum-alias-infieldbutton-fill-border-color-key-focus:var(--spectrum-alias-input-border-color-key-focus);--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-default:transparent;--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-hover:transparent;--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-down:transparent;--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-key-focus:transparent;--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-disabled:transparent;--spectrum-alias-infieldbutton-fill-loudnessMedium-background-color-default:var(--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-default);--spectrum-alias-infieldbutton-fill-loudnessMedium-background-color-hover:var(--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-hover);--spectrum-alias-infieldbutton-fill-loudnessMedium-background-color-down:var(--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-down);--spectrum-alias-infieldbutton-fill-loudnessMedium-background-color-key-focus:var(--spectrum-alias-infieldbutton-fill-loudnessLow-background-color-key-focus);--spectrum-alias-infieldbutton-fill-loudnessMedium-background-color-disabled:transparent;--spectrum-alias-infieldbutton-fill-loudnessHigh-background-color-default:var(--spectrum-alias-component-background-color-default);--spectrum-alias-infieldbutton-fill-loudnessHigh-background-color-hover:var(--spectrum-alias-component-background-color-hover);--spectrum-alias-infieldbutton-fill-loudnessHigh-background-color-down:var(--spectrum-alias-component-background-color-down);--spectrum-alias-infieldbutton-fill-loudnessHigh-background-color-key-focus:var(--spectrum-alias-component-background-color-key-focus);--spectrum-alias-infieldbutton-fill-loudnessHigh-background-color-disabled:var(--spectrum-alias-component-background-color-disabled);--spectrum-alias-actionbutton-staticBlack-border-color-default:#0006;--spectrum-alias-actionbutton-staticBlack-background-color-default:transparent;--spectrum-alias-actionbutton-staticBlack-border-color-hover:#0000008c;--spectrum-alias-actionbutton-staticBlack-background-color-hover:#00000040;--spectrum-alias-actionbutton-staticBlack-border-color-down:#000000b3;--spectrum-alias-actionbutton-staticBlack-background-color-down:#0006;--spectrum-alias-actionbutton-staticBlack-border-color-key-focus:#0000008c;--spectrum-alias-actionbutton-staticBlack-background-color-key-focus:#00000040;--spectrum-alias-actionbutton-staticBlack-border-color-disabled:#00000040;--spectrum-alias-actionbutton-staticBlack-background-color-disabled:transparent;--spectrum-alias-actionbutton-staticBlack-border-color-disabled-selected:transparent;--spectrum-alias-actionbutton-staticBlack-background-color-disabled-selected:#0000001a;--spectrum-alias-actionbutton-staticWhite-border-color-default:#fff6;--spectrum-alias-actionbutton-staticWhite-background-color-default:transparent;--spectrum-alias-actionbutton-staticWhite-border-color-hover:#ffffff8c;--spectrum-alias-actionbutton-staticWhite-background-color-hover:#ffffff40;--spectrum-alias-actionbutton-staticWhite-border-color-down:#ffffffb3;--spectrum-alias-actionbutton-staticWhite-background-color-down:#fff6;--spectrum-alias-actionbutton-staticWhite-border-color-key-focus:#ffffff8c;--spectrum-alias-actionbutton-staticWhite-background-color-key-focus:#ffffff40;--spectrum-alias-actionbutton-staticWhite-border-color-disabled:#ffffff40;--spectrum-alias-actionbutton-staticWhite-background-color-disabled:transparent;--spectrum-alias-actionbutton-staticWhite-border-color-disabled-selected:transparent;--spectrum-alias-actionbutton-staticWhite-background-color-disabled-selected:#ffffff1a;--spectrum-alias-tabs-divider-background-color-default:var(--spectrum-global-color-gray-300);--spectrum-alias-tabs-divider-background-color-quiet:var(--spectrum-alias-background-color-transparent);--spectrum-alias-tabitem-text-color-default:var(--spectrum-alias-label-text-color);--spectrum-alias-tabitem-text-color-hover:var(--spectrum-alias-text-color-hover);--spectrum-alias-tabitem-text-color-down:var(--spectrum-alias-text-color-down);--spectrum-alias-tabitem-text-color-key-focus:var(--spectrum-alias-text-color-hover);--spectrum-alias-tabitem-text-color-mouse-focus:var(--spectrum-alias-text-color-hover);--spectrum-alias-tabitem-text-color:var(--spectrum-alias-tabitem-text-color-default);--spectrum-alias-tabitem-text-color-selected-default:var(--spectrum-global-color-gray-900);--spectrum-alias-tabitem-text-color-selected-hover:var(--spectrum-alias-tabitem-text-color-selected-default);--spectrum-alias-tabitem-text-color-selected-down:var(--spectrum-alias-tabitem-text-color-selected-default);--spectrum-alias-tabitem-text-color-selected-key-focus:var(--spectrum-alias-tabitem-text-color-selected-default);--spectrum-alias-tabitem-text-color-selected-mouse-focus:var(--spectrum-alias-tabitem-text-color-selected-default);--spectrum-alias-tabitem-text-color-selected:var(--spectrum-alias-tabitem-text-color-selected-default);--spectrum-alias-tabitem-text-color-emphasized:var(--spectrum-alias-tabitem-text-color-default);--spectrum-alias-tabitem-text-color-emphasized-selected-default:var(--spectrum-global-color-static-blue-500);--spectrum-alias-tabitem-text-color-emphasized-selected-hover:var(--spectrum-alias-tabitem-text-color-emphasized-selected-default);--spectrum-alias-tabitem-text-color-emphasized-selected-down:var(--spectrum-alias-tabitem-text-color-emphasized-selected-default);--spectrum-alias-tabitem-text-color-emphasized-selected-key-focus:var(--spectrum-alias-tabitem-text-color-emphasized-selected-default);--spectrum-alias-tabitem-text-color-emphasized-selected-mouse-focus:var(--spectrum-alias-tabitem-text-color-emphasized-selected-default);--spectrum-alias-tabitem-text-color-emphasized-selected:var(--spectrum-alias-tabitem-text-color-emphasized-selected-default);--spectrum-alias-tabitem-selection-indicator-color-default:var(--spectrum-alias-tabitem-text-color-selected-default);--spectrum-alias-tabitem-selection-indicator-color-emphasized:var(--spectrum-alias-tabitem-text-color-emphasized-selected-default);--spectrum-alias-tabitem-icon-color-disabled:var(--spectrum-alias-text-color-disabled);--spectrum-alias-tabitem-icon-color-default:var(--spectrum-alias-icon-color);--spectrum-alias-tabitem-icon-color-hover:var(--spectrum-alias-icon-color-hover);--spectrum-alias-tabitem-icon-color-down:var(--spectrum-alias-icon-color-down);--spectrum-alias-tabitem-icon-color-key-focus:var(--spectrum-alias-icon-color-hover);--spectrum-alias-tabitem-icon-color-mouse-focus:var(--spectrum-alias-icon-color-down);--spectrum-alias-tabitem-icon-color:var(--spectrum-alias-tabitem-icon-color-default);--spectrum-alias-tabitem-icon-color-selected:var(--spectrum-alias-icon-color-selected-neutral);--spectrum-alias-tabitem-icon-color-emphasized:var(--spectrum-alias-tabitem-text-color-default);--spectrum-alias-tabitem-icon-color-emphasized-selected:var(--spectrum-alias-tabitem-text-color-emphasized-selected-default);--spectrum-alias-assetcard-selectionindicator-background-color-ordered:var(--spectrum-global-color-blue-500);--spectrum-alias-assetcard-overlay-background-color:#1b7ff51a;--spectrum-alias-assetcard-border-color-selected:var(--spectrum-global-color-blue-500);--spectrum-alias-assetcard-border-color-selected-hover:var(--spectrum-global-color-blue-500);--spectrum-alias-assetcard-border-color-selected-down:var(--spectrum-global-color-blue-600);--spectrum-alias-background-color-default:var(--spectrum-global-color-gray-100);--spectrum-alias-background-color-disabled:var(--spectrum-global-color-gray-200);--spectrum-alias-background-color-transparent:transparent;--spectrum-alias-background-color-overbackground-down:#fff3;--spectrum-alias-background-color-quiet-overbackground-hover:#ffffff1a;--spectrum-alias-background-color-quiet-overbackground-down:#fff3;--spectrum-alias-background-color-overbackground-disabled:#ffffff1a;--spectrum-alias-background-color-quickactions-overlay:#0003;--spectrum-alias-placeholder-text-color:var(--spectrum-global-color-gray-800);--spectrum-alias-placeholder-text-color-hover:var(--spectrum-global-color-gray-900);--spectrum-alias-placeholder-text-color-down:var(--spectrum-global-color-gray-900);--spectrum-alias-placeholder-text-color-selected:var(--spectrum-global-color-gray-800);--spectrum-alias-label-text-color:var(--spectrum-global-color-gray-700);--spectrum-alias-text-color:var(--spectrum-global-color-gray-800);--spectrum-alias-text-color-hover:var(--spectrum-global-color-gray-900);--spectrum-alias-text-color-down:var(--spectrum-global-color-gray-900);--spectrum-alias-text-color-key-focus:var(--spectrum-global-color-blue-600);--spectrum-alias-text-color-mouse-focus:var(--spectrum-global-color-blue-600);--spectrum-alias-text-color-disabled:var(--spectrum-global-color-gray-500);--spectrum-alias-text-color-invalid:var(--spectrum-global-color-red-500);--spectrum-alias-text-color-selected:var(--spectrum-global-color-blue-600);--spectrum-alias-text-color-selected-neutral:var(--spectrum-global-color-gray-900);--spectrum-alias-text-color-overbackground:var(--spectrum-global-color-static-white);--spectrum-alias-text-color-overbackground-disabled:#fff3;--spectrum-alias-text-color-quiet-overbackground-disabled:#fff3;--spectrum-alias-heading-text-color:var(--spectrum-global-color-gray-900);--spectrum-alias-link-primary-text-color-default:var(--spectrum-global-color-blue-600);--spectrum-alias-link-primary-text-color-hover:var(--spectrum-global-color-blue-600);--spectrum-alias-link-primary-text-color-down:var(--spectrum-global-color-blue-700);--spectrum-alias-link-primary-text-color-key-focus:var(--spectrum-alias-text-color-key-focus);--spectrum-alias-link-primary-text-color:var(--spectrum-alias-link-primary-text-color-default);--spectrum-alias-link-secondary-text-color-default:var(--spectrum-alias-link-primary-text-color-default);--spectrum-alias-link-secondary-text-color-hover:var(--spectrum-alias-link-primary-text-color-hover);--spectrum-alias-link-secondary-text-color-down:var(--spectrum-alias-link-primary-text-color-down);--spectrum-alias-link-secondary-text-color-key-focus:var(--spectrum-alias-link-primary-text-color-key-focus);--spectrum-alias-link-secondary-text-color:var(--spectrum-alias-link-secondary-text-color-default);--spectrum-alias-border-color:var(--spectrum-global-color-gray-400);--spectrum-alias-border-color-hover:var(--spectrum-global-color-gray-500);--spectrum-alias-border-color-down:var(--spectrum-global-color-gray-500);--spectrum-alias-border-color-key-focus:var(--spectrum-global-color-blue-400);--spectrum-alias-border-color-mouse-focus:var(--spectrum-global-color-blue-500);--spectrum-alias-border-color-disabled:var(--spectrum-global-color-gray-200);--spectrum-alias-border-color-extralight:var(--spectrum-global-color-gray-100);--spectrum-alias-border-color-light:var(--spectrum-global-color-gray-200);--spectrum-alias-border-color-mid:var(--spectrum-global-color-gray-300);--spectrum-alias-border-color-dark:var(--spectrum-global-color-gray-400);--spectrum-alias-border-color-darker-default:var(--spectrum-global-color-gray-600);--spectrum-alias-border-color-darker-hover:var(--spectrum-global-color-gray-900);--spectrum-alias-border-color-darker-down:var(--spectrum-global-color-gray-900);--spectrum-alias-border-color-transparent:transparent;--spectrum-alias-border-color-translucent-dark:#0000000d;--spectrum-alias-border-color-translucent-darker:#0000001a;--spectrum-alias-focus-color:var(--spectrum-global-color-blue-400);--spectrum-alias-focus-ring-color:var(--spectrum-alias-focus-color);--spectrum-alias-track-color-default:var(--spectrum-global-color-gray-300);--spectrum-alias-track-fill-color-overbackground:var(--spectrum-global-color-static-white);--spectrum-alias-track-color-disabled:var(--spectrum-global-color-gray-300);--spectrum-alias-thumbnail-darksquare-background-color:var(--spectrum-global-color-gray-300);--spectrum-alias-thumbnail-lightsquare-background-color:var(--spectrum-global-color-static-white);--spectrum-alias-track-color-overbackground:#fff3;--spectrum-alias-icon-color:var(--spectrum-global-color-gray-700);--spectrum-alias-icon-color-overbackground:var(--spectrum-global-color-static-white);--spectrum-alias-icon-color-hover:var(--spectrum-global-color-gray-900);--spectrum-alias-icon-color-down:var(--spectrum-global-color-gray-900);--spectrum-alias-icon-color-key-focus:var(--spectrum-global-color-gray-900);--spectrum-alias-icon-color-disabled:var(--spectrum-global-color-gray-400);--spectrum-alias-icon-color-overbackground-disabled:#fff3;--spectrum-alias-icon-color-quiet-overbackground-disabled:#ffffff26;--spectrum-alias-icon-color-selected-neutral:var(--spectrum-global-color-gray-900);--spectrum-alias-icon-color-selected-neutral-subdued:var(--spectrum-global-color-gray-800);--spectrum-alias-icon-color-selected:var(--spectrum-global-color-blue-500);--spectrum-alias-icon-color-selected-hover:var(--spectrum-global-color-blue-600);--spectrum-alias-icon-color-selected-down:var(--spectrum-global-color-blue-700);--spectrum-alias-icon-color-selected-focus:var(--spectrum-global-color-blue-600);--spectrum-alias-image-opacity-disabled:var(--spectrum-global-color-opacity-30);--spectrum-alias-toolbar-background-color:var(--spectrum-global-color-gray-100);--spectrum-alias-code-highlight-color-default:var(--spectrum-global-color-gray-800);--spectrum-alias-code-highlight-background-color:var(--spectrum-global-color-gray-75);--spectrum-alias-code-highlight-color-keyword:var(--spectrum-global-color-fuchsia-600);--spectrum-alias-code-highlight-color-section:var(--spectrum-global-color-red-600);--spectrum-alias-code-highlight-color-literal:var(--spectrum-global-color-blue-600);--spectrum-alias-code-highlight-color-attribute:var(--spectrum-global-color-seafoam-600);--spectrum-alias-code-highlight-color-class:var(--spectrum-global-color-magenta-600);--spectrum-alias-code-highlight-color-variable:var(--spectrum-global-color-purple-600);--spectrum-alias-code-highlight-color-title:var(--spectrum-global-color-indigo-600);--spectrum-alias-code-highlight-color-string:var(--spectrum-global-color-fuchsia-600);--spectrum-alias-code-highlight-color-function:var(--spectrum-global-color-blue-600);--spectrum-alias-code-highlight-color-comment:var(--spectrum-global-color-gray-700);--spectrum-alias-categorical-color-1:var(--spectrum-global-color-static-seafoam-200);--spectrum-alias-categorical-color-2:var(--spectrum-global-color-static-indigo-700);--spectrum-alias-categorical-color-3:var(--spectrum-global-color-static-orange-500);--spectrum-alias-categorical-color-4:var(--spectrum-global-color-static-magenta-500);--spectrum-alias-categorical-color-5:var(--spectrum-global-color-static-indigo-200);--spectrum-alias-categorical-color-6:var(--spectrum-global-color-static-celery-200);--spectrum-alias-categorical-color-7:var(--spectrum-global-color-static-blue-500);--spectrum-alias-categorical-color-8:var(--spectrum-global-color-static-purple-800);--spectrum-alias-categorical-color-9:var(--spectrum-global-color-static-yellow-500);--spectrum-alias-categorical-color-10:var(--spectrum-global-color-static-orange-700);--spectrum-alias-categorical-color-11:var(--spectrum-global-color-static-green-600);--spectrum-alias-categorical-color-12:var(--spectrum-global-color-static-chartreuse-300);--spectrum-alias-categorical-color-13:var(--spectrum-global-color-static-blue-200);--spectrum-alias-categorical-color-14:var(--spectrum-global-color-static-fuchsia-500);--spectrum-alias-categorical-color-15:var(--spectrum-global-color-static-magenta-200);--spectrum-alias-categorical-color-16:var(--spectrum-global-color-static-yellow-200)}:host,:root{-webkit-tap-highlight-color:#0000;--spectrum-focus-indicator-color:var(--spectrum-blue-800);--spectrum-static-white-focus-indicator-color:var(--spectrum-white);--spectrum-static-black-focus-indicator-color:var(--spectrum-black);--spectrum-overlay-color:var(--spectrum-black);--spectrum-drop-shadow-color:var(--spectrum-drop-shadow-color-100);--spectrum-opacity-disabled:.3;--spectrum-background-base-color:var(--spectrum-gray-25);--spectrum-background-layer-1-color:var(--spectrum-gray-50);--spectrum-neutral-background-color-default:var(--spectrum-gray-800);--spectrum-neutral-background-color-hover:var(--spectrum-gray-900);--spectrum-neutral-background-color-down:var(--spectrum-gray-900);--spectrum-neutral-background-color-key-focus:var(--spectrum-gray-900);--spectrum-neutral-background-color-selected-default:var(--spectrum-gray-800);--spectrum-neutral-background-color-selected-hover:var(--spectrum-gray-900);--spectrum-neutral-background-color-selected-down:var(--spectrum-gray-900);--spectrum-neutral-background-color-selected-key-focus:var(--spectrum-gray-900);--spectrum-neutral-subdued-content-color-selected:var(--spectrum-neutral-subdued-content-color-down);--spectrum-accent-content-color-selected:var(--spectrum-accent-content-color-down);--spectrum-disabled-background-color:var(--spectrum-gray-100);--spectrum-disabled-static-white-background-color:var(--spectrum-transparent-white-100);--spectrum-disabled-static-black-background-color:var(--spectrum-transparent-black-100);--spectrum-background-opacity-default:0;--spectrum-background-opacity-hover:.1;--spectrum-background-opacity-down:.1;--spectrum-background-opacity-key-focus:.1;--spectrum-neutral-content-color-default:var(--spectrum-gray-800);--spectrum-neutral-content-color-hover:var(--spectrum-gray-900);--spectrum-neutral-content-color-down:var(--spectrum-gray-900);--spectrum-neutral-content-color-focus-hover:var(--spectrum-neutral-content-color-down);--spectrum-neutral-content-color-focus:var(--spectrum-neutral-content-color-down);--spectrum-neutral-content-color-key-focus:var(--spectrum-gray-900);--spectrum-neutral-subdued-content-color-default:var(--spectrum-gray-700);--spectrum-neutral-subdued-content-color-hover:var(--spectrum-gray-800);--spectrum-neutral-subdued-content-color-down:var(--spectrum-gray-800);--spectrum-neutral-subdued-content-color-key-focus:var(--spectrum-gray-800);--spectrum-accent-content-color-default:var(--spectrum-accent-color-900);--spectrum-accent-content-color-hover:var(--spectrum-accent-color-1000);--spectrum-accent-content-color-down:var(--spectrum-accent-color-1000);--spectrum-accent-content-color-key-focus:var(--spectrum-accent-color-1000);--spectrum-negative-content-color-default:var(--spectrum-negative-color-900);--spectrum-negative-content-color-hover:var(--spectrum-negative-color-1000);--spectrum-negative-content-color-down:var(--spectrum-negative-color-1000);--spectrum-negative-content-color-key-focus:var(--spectrum-negative-color-1000);--spectrum-disabled-content-color:var(--spectrum-gray-400);--spectrum-disabled-static-white-content-color:var(--spectrum-transparent-white-400);--spectrum-disabled-static-black-content-color:var(--spectrum-transparent-black-400);--spectrum-disabled-border-color:var(--spectrum-gray-300);--spectrum-disabled-static-white-border-color:var(--spectrum-transparent-white-300);--spectrum-disabled-static-black-border-color:var(--spectrum-transparent-black-300);--spectrum-negative-border-color-default:var(--spectrum-negative-color-900);--spectrum-negative-border-color-hover:var(--spectrum-negative-color-1000);--spectrum-negative-border-color-down:var(--spectrum-negative-color-1100);--spectrum-negative-border-color-focus-hover:var(--spectrum-negative-border-color-down);--spectrum-negative-border-color-focus:var(--spectrum-negative-color-1000);--spectrum-negative-border-color-key-focus:var(--spectrum-negative-color-1000);--spectrum-title-color:var(--spectrum-gray-900);--spectrum-drop-shadow-emphasized-default-color:var(--spectrum-drop-shadow-color-100);--spectrum-drop-shadow-emphasized-hover-color:var(--spectrum-drop-shadow-color-200);--spectrum-drop-shadow-elevated-color:var(--spectrum-drop-shadow-color-200);--spectrum-drop-shadow-dragged-color:var(--spectrum-drop-shadow-color-300);--spectrum-static-black-text-color:var(--spectrum-black);--spectrum-static-white-text-color:var(--spectrum-white);--spectrum-track-color:var(--spectrum-gray-300);--spectrum-static-black-track-color:var(--spectrum-transparent-black-300);--spectrum-static-white-track-color:var(--spectrum-transparent-white-300);--spectrum-static-black-track-indicator-color:var(--spectrum-transparent-black-900);--spectrum-static-white-track-indicator-color:var(--spectrum-transparent-white-900);--spectrum-swatch-border-color:var(--spectrum-gray-900);--spectrum-swatch-border-opacity:.51;--spectrum-swatch-disabled-icon-border-color:var(--spectrum-black);--spectrum-swatch-disabled-icon-border-opacity:.51;--spectrum-thumbnail-border-color:var(--spectrum-gray-800);--spectrum-thumbnail-border-opacity:.1;--spectrum-thumbnail-opacity-disabled:var(--spectrum-opacity-disabled);--spectrum-opacity-checkerboard-square-light:var(--spectrum-white);--spectrum-avatar-opacity-disabled:var(--spectrum-opacity-disabled);--spectrum-color-area-border-color:var(--spectrum-gray-900);--spectrum-color-area-border-opacity:.1;--spectrum-color-slider-border-color:var(--spectrum-gray-900);--spectrum-color-slider-border-opacity:.1;--spectrum-color-loupe-drop-shadow-color:var(--spectrum-transparent-black-300);--spectrum-color-loupe-inner-border:var(--spectrum-transparent-black-200);--spectrum-color-loupe-outer-border:var(--spectrum-white);--spectrum-card-selection-background-color:var(--spectrum-gray-100);--spectrum-card-selection-background-color-opacity:.95;--spectrum-drop-zone-background-color:var(--spectrum-accent-visual-color);--spectrum-drop-zone-background-color-opacity:.1;--spectrum-drop-zone-background-color-opacity-filled:.3;--spectrum-coach-mark-pagination-color:var(--spectrum-gray-600);--spectrum-color-handle-inner-border-color:var(--spectrum-black);--spectrum-color-handle-inner-border-opacity:.42;--spectrum-color-handle-outer-border-color:var(--spectrum-black);--spectrum-color-handle-outer-border-opacity:var(--spectrum-color-handle-inner-border-opacity);--spectrum-color-handle-drop-shadow-color:var(--spectrum-drop-shadow-color);--spectrum-floating-action-button-drop-shadow-color:var(--spectrum-transparent-black-300);--spectrum-floating-action-button-shadow-color:var(--spectrum-floating-action-button-drop-shadow-color);--spectrum-table-row-hover-color:var(--spectrum-gray-900);--spectrum-table-row-hover-opacity:.07;--spectrum-table-selected-row-background-color:var(--spectrum-informative-background-color-default);--spectrum-table-selected-row-background-opacity:.1;--spectrum-table-selected-row-background-color-non-emphasized:var(--spectrum-neutral-background-color-selected-default);--spectrum-table-selected-row-background-opacity-non-emphasized:.1;--spectrum-table-row-down-opacity:.1;--spectrum-table-selected-row-background-opacity-hover:.15;--spectrum-table-selected-row-background-opacity-non-emphasized-hover:.15;--spectrum-black-rgb:0,0,0;--spectrum-black:rgba(var(--spectrum-black-rgb));--spectrum-transparent-black-1000-rgb:0,0,0;--spectrum-transparent-black-1000:rgba(var(--spectrum-transparent-black-1000-rgb));--spectrum-icon-color-inverse:var(--spectrum-gray-50);--spectrum-icon-color-primary-default:var(--spectrum-neutral-content-color-default);--spectrum-asterisk-icon-size-75:8px;--spectrum-radio-button-selection-indicator:4px;--spectrum-field-label-top-margin-small:0px;--spectrum-field-label-to-component:0px;--spectrum-help-text-to-component:0px;--spectrum-status-light-dot-size-small:8px;--spectrum-action-button-edge-to-hold-icon-extra-small:3px;--spectrum-action-button-edge-to-hold-icon-small:3px;--spectrum-button-minimum-width-multiplier:2.25;--spectrum-divider-thickness-small:1px;--spectrum-divider-thickness-medium:2px;--spectrum-divider-thickness-large:4px;--spectrum-swatch-rectangle-width-multiplier:2;--spectrum-swatch-slash-thickness-extra-small:2px;--spectrum-swatch-slash-thickness-small:3px;--spectrum-swatch-slash-thickness-medium:4px;--spectrum-swatch-slash-thickness-large:5px;--spectrum-progress-bar-minimum-width:48px;--spectrum-progress-bar-maximum-width:768px;--spectrum-meter-minimum-width:48px;--spectrum-meter-maximum-width:768px;--spectrum-meter-default-width:var(--spectrum-meter-width);--spectrum-in-line-alert-minimum-width:240px;--spectrum-popover-tip-width:16px;--spectrum-popover-tip-height:8px;--spectrum-menu-item-label-to-description:1px;--spectrum-menu-item-section-divider-height:8px;--spectrum-slider-track-thickness:2px;--spectrum-slider-handle-gap:4px;--spectrum-picker-minimum-width-multiplier:2;--spectrum-picker-border-width:var(--spectrum-border-width-100);--spectrum-picker-end-edge-to-disclousure-icon-quiet:var(--spectrum-picker-end-edge-to-disclosure-icon-quiet);--spectrum-picker-end-edge-to-disclosure-icon-quiet:0px;--spectrum-text-field-minimum-width-multiplier:1.5;--spectrum-combo-box-minimum-width-multiplier:2.5;--spectrum-combo-box-quiet-minimum-width-multiplier:2;--spectrum-combo-box-visual-to-field-button-quiet:0px;--spectrum-alert-dialog-minimum-width:288px;--spectrum-alert-dialog-maximum-width:480px;--spectrum-contextual-help-minimum-width:268px;--spectrum-breadcrumbs-height:var(--spectrum-component-height-300);--spectrum-breadcrumbs-height-compact:var(--spectrum-component-height-200);--spectrum-breadcrumbs-end-edge-to-text:0px;--spectrum-breadcrumbs-truncated-menu-to-separator-icon:0px;--spectrum-breadcrumbs-start-edge-to-truncated-menu:0px;--spectrum-breadcrumbs-truncated-menu-to-bottom-text:0px;--spectrum-alert-banner-to-top-workflow-icon:var(--spectrum-alert-banner-top-to-workflow-icon);--spectrum-alert-banner-to-top-text:var(--spectrum-alert-banner-top-to-text);--spectrum-alert-banner-to-bottom-text:var(--spectrum-alert-banner-bottom-to-text);--spectrum-color-area-border-width:var(--spectrum-border-width-100);--spectrum-color-area-border-rounding:var(--spectrum-corner-radius-medium-size-small);--spectrum-color-wheel-color-area-margin:12px;--spectrum-color-slider-border-width:1px;--spectrum-color-slider-border-rounding:var(--spectrum-corner-radius-medium-size-small);--spectrum-floating-action-button-drop-shadow-blur:12px;--spectrum-floating-action-button-drop-shadow-y:4px;--spectrum-illustrated-message-maximum-width:380px;--spectrum-search-field-minimum-width-multiplier:3;--spectrum-color-loupe-height:64px;--spectrum-color-loupe-width:48px;--spectrum-color-loupe-bottom-to-color-handle:12px;--spectrum-color-loupe-outer-border-width:var(--spectrum-border-width-200);--spectrum-color-loupe-inner-border-width:1px;--spectrum-color-loupe-drop-shadow-y:2px;--spectrum-color-loupe-drop-shadow-blur:8px;--spectrum-card-minimum-width:100px;--spectrum-card-preview-minimum-height:130px;--spectrum-card-selection-background-size:40px;--spectrum-drop-zone-width:428px;--spectrum-drop-zone-content-maximum-width:var(--spectrum-illustrated-message-maximum-width);--spectrum-drop-zone-border-dash-length:8px;--spectrum-drop-zone-border-dash-gap:4px;--spectrum-drop-zone-title-size:var(--spectrum-illustrated-message-title-size);--spectrum-drop-zone-cjk-title-size:var(--spectrum-illustrated-message-cjk-title-size);--spectrum-drop-zone-body-size:var(--spectrum-illustrated-message-body-size);--spectrum-accordion-top-to-text-compact-small:2px;--spectrum-accordion-top-to-text-compact-medium:4px;--spectrum-accordion-disclosure-indicator-to-text:0px;--spectrum-accordion-edge-to-disclosure-indicator:0px;--spectrum-accordion-edge-to-text:0px;--spectrum-accordion-focus-indicator-gap:0px;--spectrum-color-handle-border-width:var(--spectrum-border-width-200);--spectrum-color-handle-inner-border-width:1px;--spectrum-color-handle-outer-border-width:1px;--spectrum-color-handle-drop-shadow-x:0;--spectrum-color-handle-drop-shadow-y:0;--spectrum-color-handle-drop-shadow-blur:0;--spectrum-table-row-height-small-compact:var(--spectrum-component-height-75);--spectrum-table-row-height-medium-compact:var(--spectrum-component-height-100);--spectrum-table-row-height-large-compact:var(--spectrum-component-height-200);--spectrum-table-row-height-extra-large-compact:var(--spectrum-component-height-300);--spectrum-table-row-top-to-text-small-compact:var(--spectrum-component-top-to-text-75);--spectrum-table-row-top-to-text-medium-compact:var(--spectrum-component-top-to-text-100);--spectrum-table-row-top-to-text-large-compact:var(--spectrum-component-top-to-text-200);--spectrum-table-row-top-to-text-extra-large-compact:var(--spectrum-component-top-to-text-300);--spectrum-table-row-bottom-to-text-small-compact:var(--spectrum-component-bottom-to-text-75);--spectrum-table-row-bottom-to-text-medium-compact:var(--spectrum-component-bottom-to-text-100);--spectrum-table-row-bottom-to-text-large-compact:var(--spectrum-component-bottom-to-text-200);--spectrum-table-row-bottom-to-text-extra-large-compact:var(--spectrum-component-bottom-to-text-300);--spectrum-table-edge-to-content:16px;--spectrum-table-border-divider-width:1px;--spectrum-tab-item-height-small:var(--spectrum-component-height-200);--spectrum-tab-item-height-medium:var(--spectrum-component-height-300);--spectrum-tab-item-height-large:var(--spectrum-component-height-400);--spectrum-tab-item-height-extra-large:var(--spectrum-component-height-500);--spectrum-tab-item-compact-height-small:var(--spectrum-component-height-75);--spectrum-tab-item-compact-height-medium:var(--spectrum-component-height-100);--spectrum-tab-item-compact-height-large:var(--spectrum-component-height-200);--spectrum-tab-item-compact-height-extra-large:var(--spectrum-component-height-300);--spectrum-tab-item-start-to-edge-quiet:0px;--spectrum-in-field-button-width-stacked-small:20px;--spectrum-in-field-button-width-stacked-medium:28px;--spectrum-in-field-button-width-stacked-large:36px;--spectrum-in-field-button-width-stacked-extra-large:44px;--spectrum-in-field-button-fill-stacked-inner-border-rounding:0px;--spectrum-in-field-button-edge-to-fill:0px;--spectrum-in-field-button-stacked-inner-edge-to-fill:0px;--spectrum-in-field-button-edge-to-disclosure-icon-stacked-small:7px;--spectrum-in-field-button-edge-to-disclosure-icon-stacked-medium:9px;--spectrum-in-field-button-edge-to-disclosure-icon-stacked-large:13px;--spectrum-in-field-button-edge-to-disclosure-icon-stacked-extra-large:16px;--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-small:3px;--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-medium:3px;--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-large:4px;--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-extra-large:5px;--spectrum-in-field-button-inner-edge-to-disclosure-icon-stacked-small:var(--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-small);--spectrum-in-field-button-inner-edge-to-disclosure-icon-stacked-medium:var(--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-medium);--spectrum-in-field-button-inner-edge-to-disclosure-icon-stacked-large:var(--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-large);--spectrum-in-field-button-inner-edge-to-disclosure-icon-stacked-extra-large:var(--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-extra-large);--spectrum-corner-radius-0:0px;--spectrum-corner-radius-75:4px;--spectrum-corner-radius-100:8px;--spectrum-corner-radius-200:10px;--spectrum-corner-radius-300:6px;--spectrum-corner-radius-400:7px;--spectrum-corner-radius-500:8px;--spectrum-corner-radius-600:9px;--spectrum-corner-radius-700:10px;--spectrum-corner-radius-800:16px;--spectrum-corner-radius-1000:.5;--spectrum-corner-radius-none:var(--spectrum-corner-radius-0);--spectrum-corner-radius-small-default:var(--spectrum-corner-radius-100);--spectrum-corner-radius-medium-default:var(--spectrum-corner-radius-500);--spectrum-corner-radius-large-default:var(--spectrum-corner-radius-700);--spectrum-corner-radius-extra-large-default:var(--spectrum-corner-radius-800);--spectrum-corner-radius-full:var(--spectrum-corner-radius-1000);--spectrum-corner-radius-small-size-small:var(--spectrum-corner-radius-75);--spectrum-corner-radius-small-size-medium:var(--spectrum-corner-radius-100);--spectrum-corner-radius-small-size-large:var(--spectrum-corner-radius-200);--spectrum-corner-radius-small-size-extra-large:var(--spectrum-corner-radius-300);--spectrum-corner-radius-medium-size-extra-small:var(--spectrum-corner-radius-300);--spectrum-corner-radius-medium-size-small:var(--spectrum-corner-radius-400);--spectrum-corner-radius-medium-size-medium:var(--spectrum-corner-radius-500);--spectrum-corner-radius-medium-size-large:var(--spectrum-corner-radius-600);--spectrum-corner-radius-medium-size-extra-large:var(--spectrum-corner-radius-700);--spectrum-drop-shadow-x:0px;--spectrum-spacing-50:2px;--spectrum-spacing-75:4px;--spectrum-spacing-100:8px;--spectrum-spacing-200:12px;--spectrum-spacing-300:16px;--spectrum-spacing-400:24px;--spectrum-spacing-500:32px;--spectrum-spacing-600:40px;--spectrum-spacing-700:48px;--spectrum-spacing-800:64px;--spectrum-spacing-900:80px;--spectrum-spacing-1000:96px;--spectrum-focus-indicator-thickness:2px;--spectrum-focus-indicator-gap:2px;--spectrum-border-width-100:1px;--spectrum-border-width-200:2px;--spectrum-border-width-400:4px;--spectrum-field-edge-to-text-quiet:0px;--spectrum-field-edge-to-visual-quiet:0px;--spectrum-field-edge-to-border-quiet:0px;--spectrum-field-edge-to-alert-icon-quiet:0px;--spectrum-field-edge-to-validation-icon-quiet:0px;--spectrum-text-underline-thickness:1px;--spectrum-text-underline-gap:1px;--spectrum-accent-color-100:var(--spectrum-blue-100);--spectrum-accent-color-200:var(--spectrum-blue-200);--spectrum-accent-color-300:var(--spectrum-blue-300);--spectrum-accent-color-400:var(--spectrum-blue-400);--spectrum-accent-color-500:var(--spectrum-blue-500);--spectrum-accent-color-600:var(--spectrum-blue-600);--spectrum-accent-color-700:var(--spectrum-blue-700);--spectrum-accent-color-800:var(--spectrum-blue-800);--spectrum-accent-color-900:var(--spectrum-blue-900);--spectrum-accent-color-1000:var(--spectrum-blue-1000);--spectrum-accent-color-1100:var(--spectrum-blue-1100);--spectrum-accent-color-1200:var(--spectrum-blue-1200);--spectrum-accent-color-1300:var(--spectrum-blue-1300);--spectrum-accent-color-1400:var(--spectrum-blue-1400);--spectrum-accent-color-1500:var(--spectrum-blue-1500);--spectrum-accent-color-1600:var(--spectrum-blue-1600);--spectrum-informative-color-100:var(--spectrum-blue-100);--spectrum-informative-color-200:var(--spectrum-blue-200);--spectrum-informative-color-300:var(--spectrum-blue-300);--spectrum-informative-color-400:var(--spectrum-blue-400);--spectrum-informative-color-500:var(--spectrum-blue-500);--spectrum-informative-color-600:var(--spectrum-blue-600);--spectrum-informative-color-700:var(--spectrum-blue-700);--spectrum-informative-color-800:var(--spectrum-blue-800);--spectrum-informative-color-900:var(--spectrum-blue-900);--spectrum-informative-color-1000:var(--spectrum-blue-1000);--spectrum-informative-color-1100:var(--spectrum-blue-1100);--spectrum-informative-color-1200:var(--spectrum-blue-1200);--spectrum-informative-color-1300:var(--spectrum-blue-1300);--spectrum-informative-color-1400:var(--spectrum-blue-1400);--spectrum-informative-color-1500:var(--spectrum-blue-1500);--spectrum-informative-color-1600:var(--spectrum-blue-1600);--spectrum-negative-color-100:var(--spectrum-red-100);--spectrum-negative-color-200:var(--spectrum-red-200);--spectrum-negative-color-300:var(--spectrum-red-300);--spectrum-negative-color-400:var(--spectrum-red-400);--spectrum-negative-color-500:var(--spectrum-red-500);--spectrum-negative-color-600:var(--spectrum-red-600);--spectrum-negative-color-700:var(--spectrum-red-700);--spectrum-negative-color-800:var(--spectrum-red-800);--spectrum-negative-color-900:var(--spectrum-red-900);--spectrum-negative-color-1000:var(--spectrum-red-1000);--spectrum-negative-color-1100:var(--spectrum-red-1100);--spectrum-negative-color-1200:var(--spectrum-red-1200);--spectrum-negative-color-1300:var(--spectrum-red-1300);--spectrum-negative-color-1400:var(--spectrum-red-1400);--spectrum-negative-color-1500:var(--spectrum-red-1500);--spectrum-negative-color-1600:var(--spectrum-red-1600);--spectrum-notice-color-100:var(--spectrum-orange-100);--spectrum-notice-color-200:var(--spectrum-orange-200);--spectrum-notice-color-300:var(--spectrum-orange-300);--spectrum-notice-color-400:var(--spectrum-orange-400);--spectrum-notice-color-500:var(--spectrum-orange-500);--spectrum-notice-color-600:var(--spectrum-orange-600);--spectrum-notice-color-700:var(--spectrum-orange-700);--spectrum-notice-color-800:var(--spectrum-orange-800);--spectrum-notice-color-900:var(--spectrum-orange-900);--spectrum-notice-color-1000:var(--spectrum-orange-1000);--spectrum-notice-color-1100:var(--spectrum-orange-1100);--spectrum-notice-color-1200:var(--spectrum-orange-1200);--spectrum-notice-color-1300:var(--spectrum-orange-1300);--spectrum-notice-color-1400:var(--spectrum-orange-1400);--spectrum-notice-color-1500:var(--spectrum-orange-1500);--spectrum-notice-color-1600:var(--spectrum-orange-1600);--spectrum-positive-color-100:var(--spectrum-green-100);--spectrum-positive-color-200:var(--spectrum-green-200);--spectrum-positive-color-300:var(--spectrum-green-300);--spectrum-positive-color-400:var(--spectrum-green-400);--spectrum-positive-color-500:var(--spectrum-green-500);--spectrum-positive-color-600:var(--spectrum-green-600);--spectrum-positive-color-700:var(--spectrum-green-700);--spectrum-positive-color-800:var(--spectrum-green-800);--spectrum-positive-color-900:var(--spectrum-green-900);--spectrum-positive-color-1000:var(--spectrum-green-1000);--spectrum-positive-color-1100:var(--spectrum-green-1100);--spectrum-positive-color-1200:var(--spectrum-green-1200);--spectrum-positive-color-1300:var(--spectrum-green-1300);--spectrum-positive-color-1400:var(--spectrum-green-1400);--spectrum-positive-color-1500:var(--spectrum-green-1500);--spectrum-positive-color-1600:var(--spectrum-green-1600);--spectrum-negative-subdued-background-color-hover:var(--spectrum-negative-color-300);--spectrum-negative-subdued-background-color-down:var(--spectrum-negative-color-300);--spectrum-negative-subdued-background-color-key-focus:var(--spectrum-negative-color-300);--spectrum-default-font-family:var(--spectrum-sans-serif-font-family);--spectrum-sans-serif-font-family:Adobe Clean;--spectrum-serif-font-family:Adobe Clean Serif;--spectrum-cjk-font-family:Adobe Clean Han;--spectrum-light-font-weight:300;--spectrum-regular-font-weight:400;--spectrum-medium-font-weight:500;--spectrum-bold-font-weight:700;--spectrum-extra-bold-font-weight:800;--spectrum-black-font-weight:900;--spectrum-italic-font-style:italic;--spectrum-default-font-style:normal;--spectrum-line-height-100:1.3;--spectrum-line-height-200:1.5;--spectrum-cjk-line-height-100:1.5;--spectrum-cjk-line-height-200:1.7;--spectrum-cjk-letter-spacing:.05em;--spectrum-heading-sans-serif-font-family:var(--spectrum-sans-serif-font-family);--spectrum-heading-serif-font-family:var(--spectrum-serif-font-family);--spectrum-heading-cjk-font-family:var(--spectrum-cjk-font-family);--spectrum-heading-sans-serif-light-font-weight:var(--spectrum-light-font-weight);--spectrum-heading-sans-serif-light-font-style:var(--spectrum-default-font-style);--spectrum-heading-serif-light-font-weight:var(--spectrum-regular-font-weight);--spectrum-heading-serif-light-font-style:var(--spectrum-default-font-style);--spectrum-heading-cjk-light-font-weight:var(--spectrum-light-font-weight);--spectrum-heading-cjk-light-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-font-weight:var(--spectrum-bold-font-weight);--spectrum-heading-sans-serif-font-style:var(--spectrum-default-font-style);--spectrum-heading-serif-font-weight:var(--spectrum-bold-font-weight);--spectrum-heading-serif-font-style:var(--spectrum-default-font-style);--spectrum-heading-cjk-font-weight:var(--spectrum-extra-bold-font-weight);--spectrum-heading-cjk-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-heavy-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-sans-serif-heavy-font-style:var(--spectrum-default-font-style);--spectrum-heading-serif-heavy-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-serif-heavy-font-style:var(--spectrum-default-font-style);--spectrum-heading-cjk-heavy-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-cjk-heavy-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-light-strong-font-weight:var(--spectrum-bold-font-weight);--spectrum-heading-sans-serif-light-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-serif-light-strong-font-weight:var(--spectrum-bold-font-weight);--spectrum-heading-serif-light-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-cjk-light-strong-font-weight:var(--spectrum-extra-bold-font-weight);--spectrum-heading-cjk-light-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-sans-serif-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-serif-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-serif-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-cjk-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-cjk-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-heavy-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-sans-serif-heavy-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-serif-heavy-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-serif-heavy-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-cjk-heavy-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-cjk-heavy-strong-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-light-emphasized-font-weight:var(--spectrum-light-font-weight);--spectrum-heading-sans-serif-light-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-serif-light-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-heading-serif-light-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-cjk-light-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-heading-cjk-light-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-heading-sans-serif-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-serif-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-heading-serif-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-cjk-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-cjk-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-heavy-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-sans-serif-heavy-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-serif-heavy-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-serif-heavy-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-cjk-heavy-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-cjk-heavy-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-light-strong-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-heading-sans-serif-light-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-serif-light-strong-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-heading-serif-light-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-cjk-light-strong-emphasized-font-weight:var(--spectrum-extra-bold-font-weight);--spectrum-heading-cjk-light-strong-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-sans-serif-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-serif-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-serif-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-cjk-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-cjk-strong-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-heading-sans-serif-heavy-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-sans-serif-heavy-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-serif-heavy-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-serif-heavy-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-heading-cjk-heavy-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-heading-cjk-heavy-strong-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-heading-size-xxxl:var(--spectrum-font-size-1300);--spectrum-heading-size-xxl:var(--spectrum-font-size-1100);--spectrum-heading-size-xl:var(--spectrum-font-size-900);--spectrum-heading-size-l:var(--spectrum-font-size-700);--spectrum-heading-size-m:var(--spectrum-font-size-500);--spectrum-heading-size-s:var(--spectrum-font-size-300);--spectrum-heading-size-xs:var(--spectrum-font-size-200);--spectrum-heading-size-xxs:var(--spectrum-font-size-100);--spectrum-heading-cjk-size-xxxl:var(--spectrum-font-size-1300);--spectrum-heading-cjk-size-xxl:var(--spectrum-font-size-900);--spectrum-heading-cjk-size-xl:var(--spectrum-font-size-800);--spectrum-heading-cjk-size-l:var(--spectrum-font-size-600);--spectrum-heading-cjk-size-m:var(--spectrum-font-size-400);--spectrum-heading-cjk-size-s:var(--spectrum-font-size-300);--spectrum-heading-cjk-size-xs:var(--spectrum-font-size-200);--spectrum-heading-cjk-size-xxs:var(--spectrum-font-size-100);--spectrum-heading-line-height:var(--spectrum-line-height-100);--spectrum-heading-cjk-line-height:var(--spectrum-cjk-line-height-100);--spectrum-heading-margin-top-multiplier:.888889;--spectrum-heading-margin-bottom-multiplier:.25;--spectrum-heading-color:var(--spectrum-gray-900);--spectrum-body-sans-serif-font-family:var(--spectrum-sans-serif-font-family);--spectrum-body-serif-font-family:var(--spectrum-serif-font-family);--spectrum-body-cjk-font-family:var(--spectrum-cjk-font-family);--spectrum-body-sans-serif-font-weight:var(--spectrum-regular-font-weight);--spectrum-body-sans-serif-font-style:var(--spectrum-default-font-style);--spectrum-body-serif-font-weight:var(--spectrum-regular-font-weight);--spectrum-body-serif-font-style:var(--spectrum-default-font-style);--spectrum-body-cjk-font-weight:var(--spectrum-regular-font-weight);--spectrum-body-cjk-font-style:var(--spectrum-default-font-style);--spectrum-body-sans-serif-strong-font-weight:var(--spectrum-bold-font-weight);--spectrum-body-sans-serif-strong-font-style:var(--spectrum-default-font-style);--spectrum-body-serif-strong-font-weight:var(--spectrum-bold-font-weight);--spectrum-body-serif-strong-font-style:var(--spectrum-default-font-style);--spectrum-body-cjk-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-body-cjk-strong-font-style:var(--spectrum-default-font-style);--spectrum-body-sans-serif-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-body-sans-serif-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-body-serif-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-body-serif-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-body-cjk-emphasized-font-weight:var(--spectrum-extra-bold-font-weight);--spectrum-body-cjk-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-body-sans-serif-strong-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-body-sans-serif-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-body-serif-strong-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-body-serif-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-body-cjk-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-body-cjk-strong-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-body-size-xxxl:var(--spectrum-font-size-600);--spectrum-body-size-xxl:var(--spectrum-font-size-500);--spectrum-body-size-xl:var(--spectrum-font-size-400);--spectrum-body-size-l:var(--spectrum-font-size-300);--spectrum-body-size-m:var(--spectrum-font-size-200);--spectrum-body-size-s:var(--spectrum-font-size-100);--spectrum-body-size-xs:var(--spectrum-font-size-75);--spectrum-body-line-height:var(--spectrum-line-height-200);--spectrum-body-cjk-line-height:var(--spectrum-cjk-line-height-200);--spectrum-body-margin-multiplier:.75;--spectrum-body-color:var(--spectrum-gray-800);--spectrum-detail-sans-serif-font-family:var(--spectrum-sans-serif-font-family);--spectrum-detail-serif-font-family:var(--spectrum-serif-font-family);--spectrum-detail-cjk-font-family:var(--spectrum-cjk-font-family);--spectrum-detail-sans-serif-font-weight:var(--spectrum-bold-font-weight);--spectrum-detail-sans-serif-font-style:var(--spectrum-default-font-style);--spectrum-detail-serif-font-weight:var(--spectrum-bold-font-weight);--spectrum-detail-serif-font-style:var(--spectrum-default-font-style);--spectrum-detail-cjk-font-weight:var(--spectrum-extra-bold-font-weight);--spectrum-detail-cjk-font-style:var(--spectrum-default-font-style);--spectrum-detail-sans-serif-light-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-sans-serif-light-font-style:var(--spectrum-default-font-style);--spectrum-detail-serif-light-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-serif-light-font-style:var(--spectrum-default-font-style);--spectrum-detail-cjk-light-font-weight:var(--spectrum-light-font-weight);--spectrum-detail-cjk-light-font-style:var(--spectrum-default-font-style);--spectrum-detail-sans-serif-strong-font-weight:var(--spectrum-bold-font-weight);--spectrum-detail-sans-serif-strong-font-style:var(--spectrum-default-font-style);--spectrum-detail-serif-strong-font-weight:var(--spectrum-bold-font-weight);--spectrum-detail-serif-strong-font-style:var(--spectrum-default-font-style);--spectrum-detail-cjk-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-detail-cjk-strong-font-style:var(--spectrum-default-font-style);--spectrum-detail-sans-serif-light-strong-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-sans-serif-light-strong-font-style:var(--spectrum-default-font-style);--spectrum-detail-serif-light-strong-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-serif-light-strong-font-style:var(--spectrum-default-font-style);--spectrum-detail-cjk-light-strong-font-weight:var(--spectrum-extra-bold-font-weight);--spectrum-detail-cjk-light-strong-font-style:var(--spectrum-default-font-style);--spectrum-detail-sans-serif-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-detail-sans-serif-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-detail-serif-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-detail-serif-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-detail-cjk-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-detail-cjk-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-detail-sans-serif-light-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-sans-serif-light-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-detail-serif-light-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-serif-light-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-detail-cjk-light-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-cjk-light-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-detail-sans-serif-strong-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-detail-sans-serif-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-detail-serif-strong-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-detail-serif-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-detail-cjk-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-detail-cjk-strong-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-detail-sans-serif-light-strong-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-sans-serif-light-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-detail-serif-light-strong-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-detail-serif-light-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-detail-cjk-light-strong-emphasized-font-weight:var(--spectrum-extra-bold-font-weight);--spectrum-detail-cjk-light-strong-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-detail-size-xl:var(--spectrum-font-size-200);--spectrum-detail-size-l:var(--spectrum-font-size-100);--spectrum-detail-size-m:var(--spectrum-font-size-75);--spectrum-detail-size-s:var(--spectrum-font-size-50);--spectrum-detail-line-height:var(--spectrum-line-height-100);--spectrum-detail-cjk-line-height:var(--spectrum-cjk-line-height-100);--spectrum-detail-margin-top-multiplier:.888889;--spectrum-detail-margin-bottom-multiplier:.25;--spectrum-detail-letter-spacing:.06em;--spectrum-detail-sans-serif-text-transform:uppercase;--spectrum-detail-serif-text-transform:uppercase;--spectrum-detail-color:var(--spectrum-gray-900);--spectrum-code-font-family:Source Code Pro;--spectrum-code-cjk-font-family:var(--spectrum-code-font-family);--spectrum-code-font-weight:var(--spectrum-regular-font-weight);--spectrum-code-font-style:var(--spectrum-default-font-style);--spectrum-code-cjk-font-weight:var(--spectrum-regular-font-weight);--spectrum-code-cjk-font-style:var(--spectrum-default-font-style);--spectrum-code-strong-font-weight:var(--spectrum-bold-font-weight);--spectrum-code-strong-font-style:var(--spectrum-default-font-style);--spectrum-code-cjk-strong-font-weight:var(--spectrum-black-font-weight);--spectrum-code-cjk-strong-font-style:var(--spectrum-default-font-style);--spectrum-code-emphasized-font-weight:var(--spectrum-regular-font-weight);--spectrum-code-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-code-cjk-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-code-cjk-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-code-strong-emphasized-font-weight:var(--spectrum-bold-font-weight);--spectrum-code-strong-emphasized-font-style:var(--spectrum-italic-font-style);--spectrum-code-cjk-strong-emphasized-font-weight:var(--spectrum-black-font-weight);--spectrum-code-cjk-strong-emphasized-font-style:var(--spectrum-default-font-style);--spectrum-code-size-xl:var(--spectrum-font-size-400);--spectrum-code-size-l:var(--spectrum-font-size-300);--spectrum-code-size-m:var(--spectrum-font-size-200);--spectrum-code-size-s:var(--spectrum-font-size-100);--spectrum-code-size-xs:var(--spectrum-font-size-75);--spectrum-code-line-height:var(--spectrum-line-height-200);--spectrum-code-cjk-line-height:var(--spectrum-cjk-line-height-200);--spectrum-code-color:var(--spectrum-gray-800);--system:spectrum;--spectrum-animation-duration-0:0s;--spectrum-animation-duration-100:.13s;--spectrum-animation-duration-200:.16s;--spectrum-animation-duration-300:.19s;--spectrum-animation-duration-400:.22s;--spectrum-animation-duration-500:.25s;--spectrum-animation-duration-600:.3s;--spectrum-animation-duration-700:.35s;--spectrum-animation-duration-800:.4s;--spectrum-animation-duration-900:.45s;--spectrum-animation-duration-1000:.5s;--spectrum-animation-duration-2000:1s;--spectrum-animation-duration-4000:2s;--spectrum-animation-duration-6000:3s;--spectrum-animation-linear:cubic-bezier(0,0,1,1);--spectrum-animation-ease-in-out:cubic-bezier(.45,0,.4,1);--spectrum-animation-ease-in:cubic-bezier(.5,0,1,1);--spectrum-animation-ease-out:cubic-bezier(0,0,.4,1);--spectrum-animation-ease-linear:cubic-bezier(0,0,1,1);--spectrum-sans-font-family-stack:adobe-clean,var(--spectrum-sans-serif-font-family),"Source Sans Pro",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Trebuchet MS","Lucida Grande",sans-serif;--spectrum-sans-serif-font:var(--spectrum-sans-font-family-stack);--spectrum-serif-font-family-stack:adobe-clean-serif,var(--spectrum-serif-font-family),"Source Serif Pro",Georgia,serif;--spectrum-serif-font:var(--spectrum-serif-font-family-stack);--spectrum-code-font-family-stack:"Source Code Pro",Monaco,monospace;--spectrum-font-family-ar:myriad-arabic,adobe-clean,"Source Sans Pro",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Trebuchet MS","Lucida Grande",sans-serif;--spectrum-font-family-he:myriad-hebrew,adobe-clean,"Source Sans Pro",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Trebuchet MS","Lucida Grande",sans-serif;--spectrum-font-family:var(--spectrum-sans-font-family-stack);--spectrum-font-style:var(--spectrum-default-font-style);--spectrum-font-size:var(--spectrum-font-size-100);--spectrum-cjk-font-family-stack:adobe-clean-han-japanese,var(--spectrum-cjk-font-family),sans-serif;--spectrum-cjk-font:var(--spectrum-cjk-font-family-stack);--spectrum-docs-static-white-background-color-rgb:15,121,125;--spectrum-docs-static-white-background-color:rgba(var(--spectrum-docs-static-white-background-color-rgb));--spectrum-docs-static-black-background-color-rgb:181,209,211;--spectrum-docs-static-black-background-color:rgba(var(--spectrum-docs-static-black-background-color-rgb));--spectrum-coach-indicator-ring-static-white-color:var(--spectrum-white);--system-accordion-divider-color:var(--spectrum-gray-200);--system-accordion-item-content-disabled-color:var(--spectrum-disabled-content-color);--system-accordion-item-content-color:var(--spectrum-body-color);--system-action-bar-popover-background-color:var(--spectrum-gray-25);--system-action-bar-popover-border-color:var(--spectrum-gray-400);--system-action-button-background-color-default:var(--spectrum-gray-100);--system-action-button-background-color-hover:var(--spectrum-gray-200);--system-action-button-background-color-down:var(--spectrum-gray-200);--system-action-button-background-color-focus:var(--spectrum-gray-200);--system-action-button-background-color-disabled:var(--spectrum-disabled-background-color);--system-action-button-background-color-selected:var(--spectrum-neutral-background-color-selected-default);--system-action-button-background-color-selected-hover:var(--spectrum-neutral-background-color-selected-hover);--system-action-button-background-color-selected-down:var(--spectrum-neutral-background-color-selected-down);--system-action-button-background-color-selected-focus:var(--spectrum-neutral-background-color-selected-key-focus);--system-action-button-border-color-default:transparent;--system-action-button-border-color-hover:transparent;--system-action-button-border-color-down:transparent;--system-action-button-border-color-focus:transparent;--system-action-button-border-color-disabled:transparent;--system-action-button-content-color-selected:var(--spectrum-gray-50);--system-action-button-size-m-border-radius-default:var(--spectrum-corner-radius-medium-size-medium);--system-action-button-size-xs-border-radius-default:var(--spectrum-corner-radius-medium-size-extra-small);--system-action-button-size-s-border-radius-default:var(--spectrum-corner-radius-medium-size-small);--system-action-button-size-l-border-radius-default:var(--spectrum-corner-radius-medium-size-large);--system-action-button-size-xl-border-radius-default:var(--spectrum-corner-radius-medium-size-extra-large);--system-action-button-quiet-background-color-default:transparent;--system-action-button-quiet-background-color-hover:var(--spectrum-gray-200);--system-action-button-quiet-background-color-down:var(--spectrum-gray-200);--system-action-button-quiet-background-color-focus:var(--spectrum-gray-200);--system-action-button-quiet-background-color-disabled:transparent;--system-action-button-quiet-background-color-selected-disabled:var(--spectrum-disabled-background-color);--system-action-button-static-black-border-color-default:transparent;--system-action-button-static-black-border-color-hover:transparent;--system-action-button-static-black-border-color-down:transparent;--system-action-button-static-black-border-color-focus:transparent;--system-action-button-static-black-border-color-disabled:transparent;--system-action-button-static-black-background-color-disabled:var(--spectrum-disabled-static-black-background-color);--system-action-button-static-black-background-color-selected-disabled:var(--spectrum-disabled-static-black-background-color);--system-action-button-static-black-background-color-default:var(--spectrum-transparent-black-100);--system-action-button-static-black-background-color-hover:var(--spectrum-transparent-black-200);--system-action-button-static-black-background-color-down:var(--spectrum-transparent-black-200);--system-action-button-static-black-background-color-focus:var(--spectrum-transparent-black-200);--system-action-button-static-black-quiet-background-color-default:transparent;--system-action-button-static-black-quiet-background-color-hover:var(--spectrum-transparent-black-200);--system-action-button-static-black-quiet-background-color-down:var(--spectrum-transparent-black-200);--system-action-button-static-black-quiet-background-color-focus:var(--spectrum-transparent-black-200);--system-action-button-static-black-quiet-background-color-disabled:transparent;--system-action-button-static-white-border-color-default:transparent;--system-action-button-static-white-border-color-hover:transparent;--system-action-button-static-white-border-color-down:transparent;--system-action-button-static-white-border-color-focus:transparent;--system-action-button-static-white-border-color-disabled:transparent;--system-action-button-static-white-background-color-disabled:var(--spectrum-disabled-static-white-background-color);--system-action-button-static-white-background-color-selected-disabled:var(--spectrum-disabled-static-white-background-color);--system-action-button-static-white-background-color-default:var(--spectrum-transparent-white-100);--system-action-button-static-white-background-color-hover:var(--spectrum-transparent-white-200);--system-action-button-static-white-background-color-down:var(--spectrum-transparent-white-200);--system-action-button-static-white-background-color-focus:var(--spectrum-transparent-white-200);--system-action-button-static-white-quiet-background-color-default:transparent;--system-action-button-static-white-quiet-background-color-hover:var(--spectrum-transparent-white-200);--system-action-button-static-white-quiet-background-color-down:var(--spectrum-transparent-white-200);--system-action-button-static-white-quiet-background-color-focus:var(--spectrum-transparent-white-200);--system-action-button-static-white-quiet-background-color-disabled:transparent;--system-action-group-gap-size-compact:0;--system-action-group-horizontal-spacing-compact:-1px;--system-action-group-vertical-spacing-compact:-1px;--system-alert-banner-neutral-background:var(--spectrum-neutral-subdued-background-color-default);--system-asset-folder-background-color:var(--spectrum-gray-200);--system-asset-file-background-color:var(--spectrum-gray-25);--system-asset-icon-outline-color:var(--spectrum-gray-500);--system-button-background-color-default:var(--spectrum-gray-50);--system-button-background-color-hover:var(--spectrum-gray-100);--system-button-background-color-down:var(--spectrum-gray-200);--system-button-background-color-focus:var(--spectrum-gray-100);--system-button-border-color-default:var(--spectrum-gray-400);--system-button-border-color-hover:var(--spectrum-gray-500);--system-button-border-color-down:var(--spectrum-gray-600);--system-button-border-color-focus:var(--spectrum-gray-500);--system-button-background-color-disabled:transparent;--system-button-border-color-disabled:var(--spectrum-disabled-border-color);--system-button-selected-background-color-default:var(--spectrum-neutral-subdued-background-color-default);--system-button-selected-background-color-hover:var(--spectrum-neutral-subdued-background-color-hover);--system-button-selected-background-color-down:var(--spectrum-neutral-subdued-background-color-down);--system-button-selected-background-color-focus:var(--spectrum-neutral-subdued-background-color-key-focus);--system-button-primary-content-color-default:var(--spectrum-gray-25);--system-button-primary-content-color-hover:var(--spectrum-gray-25);--system-button-primary-content-color-down:var(--spectrum-gray-25);--system-button-primary-content-color-focus:var(--spectrum-gray-25);--system-button-primary-outline-background-color-hover:var(--spectrum-gray-100);--system-button-primary-outline-background-color-down:var(--spectrum-gray-100);--system-button-primary-outline-background-color-focus:var(--spectrum-gray-100);--system-button-secondary-background-color-default:var(--spectrum-gray-100);--system-button-secondary-background-color-hover:var(--spectrum-gray-200);--system-button-secondary-background-color-down:var(--spectrum-gray-200);--system-button-secondary-background-color-focus:var(--spectrum-gray-200);--system-button-secondary-outline-background-color-hover:var(--spectrum-gray-100);--system-button-secondary-outline-background-color-down:var(--spectrum-gray-100);--system-button-secondary-outline-background-color-focus:var(--spectrum-gray-100);--system-button-secondary-outline-border-color-default:var(--spectrum-gray-300);--system-button-secondary-outline-border-color-down:var(--spectrum-gray-400);--system-button-static-white-background-color-default:var(--spectrum-transparent-white-800);--system-button-static-white-background-color-hover:var(--spectrum-transparent-white-900);--system-button-static-white-background-color-down:var(--spectrum-transparent-white-900);--system-button-static-white-background-color-focus:var(--spectrum-transparent-white-900);--system-button-static-white-content-color-default:var(--spectrum-black);--system-button-static-white-content-color-hover:var(--spectrum-black);--system-button-static-white-content-color-down:var(--spectrum-black);--system-button-static-white-content-color-focus:var(--spectrum-black);--system-button-static-white-outline-background-color-default:var(--spectrum-transparent-white-25);--system-button-static-white-outline-background-color-hover:var(--spectrum-transparent-white-100);--system-button-static-white-outline-background-color-down:var(--spectrum-transparent-white-100);--system-button-static-white-outline-background-color-focus:var(--spectrum-transparent-white-100);--system-button-static-white-outline-content-color-default:var(--spectrum-transparent-white-800);--system-button-static-white-outline-content-color-hover:var(--spectrum-transparent-white-900);--system-button-static-white-outline-content-color-down:var(--spectrum-transparent-white-900);--system-button-static-white-outline-content-color-focus:var(--spectrum-transparent-white-900);--system-button-static-white-outline-border-color-default:var(--spectrum-transparent-white-800);--system-button-static-white-outline-border-color-hover:var(--spectrum-transparent-white-900);--system-button-static-white-outline-border-color-down:var(--spectrum-transparent-white-900);--system-button-static-white-outline-border-color-focus:var(--spectrum-transparent-white-900);--system-button-static-white-secondary-background-color-default:var(--spectrum-transparent-white-100);--system-button-static-white-secondary-background-color-hover:var(--spectrum-transparent-white-200);--system-button-static-white-secondary-background-color-down:var(--spectrum-transparent-white-200);--system-button-static-white-secondary-background-color-focus:var(--spectrum-transparent-white-200);--system-button-static-white-secondary-content-color-default:var(--spectrum-transparent-white-800);--system-button-static-white-secondary-content-color-hover:var(--spectrum-transparent-white-900);--system-button-static-white-secondary-content-color-down:var(--spectrum-transparent-white-900);--system-button-static-white-secondary-content-color-focus:var(--spectrum-transparent-white-900);--system-button-static-white-secondary-outline-border-color-default:var(--spectrum-transparent-white-300);--system-button-static-white-secondary-outline-border-color-hover:var(--spectrum-transparent-white-400);--system-button-static-white-secondary-outline-border-color-down:var(--spectrum-transparent-white-400);--system-button-static-white-secondary-outline-border-color-focus:var(--spectrum-transparent-white-400);--system-button-static-white-secondary-outline-background-color-default:var(--spectrum-transparent-white-25);--system-button-static-white-secondary-outline-background-color-hover:var(--spectrum-transparent-white-100);--system-button-static-white-secondary-outline-background-color-down:var(--spectrum-transparent-white-100);--system-button-static-white-secondary-outline-background-color-focus:var(--spectrum-transparent-white-100);--system-button-static-black-background-color-default:var(--spectrum-transparent-black-800);--system-button-static-black-background-color-hover:var(--spectrum-transparent-black-900);--system-button-static-black-background-color-down:var(--spectrum-transparent-black-900);--system-button-static-black-background-color-focus:var(--spectrum-transparent-black-900);--system-button-static-black-content-color-default:var(--spectrum-white);--system-button-static-black-content-color-hover:var(--spectrum-white);--system-button-static-black-content-color-down:var(--spectrum-white);--system-button-static-black-content-color-focus:var(--spectrum-white);--system-button-static-black-outline-background-color-default:var(--spectrum-transparent-black-25);--system-button-static-black-outline-background-color-hover:var(--spectrum-transparent-black-100);--system-button-static-black-outline-background-color-down:var(--spectrum-transparent-black-100);--system-button-static-black-outline-background-color-focus:var(--spectrum-transparent-black-100);--system-button-static-black-outline-content-color-default:var(--spectrum-transparent-black-800);--system-button-static-black-outline-content-color-hover:var(--spectrum-transparent-black-900);--system-button-static-black-outline-content-color-down:var(--spectrum-transparent-black-900);--system-button-static-black-outline-content-color-focus:var(--spectrum-transparent-black-900);--system-button-static-black-outline-border-color-default:var(--spectrum-transparent-black-800);--system-button-static-black-outline-border-color-hover:var(--spectrum-transparent-black-900);--system-button-static-black-outline-border-color-down:var(--spectrum-transparent-black-900);--system-button-static-black-outline-border-color-focus:var(--spectrum-transparent-black-900);--system-button-static-black-secondary-background-color-default:var(--spectrum-transparent-black-100);--system-button-static-black-secondary-background-color-hover:var(--spectrum-transparent-black-200);--system-button-static-black-secondary-background-color-down:var(--spectrum-transparent-black-200);--system-button-static-black-secondary-background-color-focus:var(--spectrum-transparent-black-200);--system-button-static-black-secondary-content-color-default:var(--spectrum-transparent-black-800);--system-button-static-black-secondary-content-color-hover:var(--spectrum-transparent-black-900);--system-button-static-black-secondary-content-color-down:var(--spectrum-transparent-black-900);--system-button-static-black-secondary-content-color-focus:var(--spectrum-transparent-black-900);--system-button-static-black-secondary-outline-border-color-default:var(--spectrum-transparent-black-300);--system-button-static-black-secondary-outline-border-color-hover:var(--spectrum-transparent-black-400);--system-button-static-black-secondary-outline-border-color-down:var(--spectrum-transparent-black-400);--system-button-static-black-secondary-outline-border-color-focus:var(--spectrum-transparent-black-400);--system-button-static-black-secondary-outline-background-color-default:var(--spectrum-transparent-black-25);--system-button-static-black-secondary-outline-background-color-hover:var(--spectrum-transparent-black-100);--system-button-static-black-secondary-outline-background-color-down:var(--spectrum-transparent-black-100);--system-button-static-black-secondary-outline-background-color-focus:var(--spectrum-transparent-black-100);--system-checkbox-control-color-default:var(--spectrum-neutral-content-color-default);--system-checkbox-control-color-hover:var(--spectrum-gray-700);--system-checkbox-control-color-down:var(--spectrum-gray-800);--system-checkbox-control-color-focus:var(--spectrum-gray-700);--system-checkbox-checkmark-color:var(--spectrum-gray-50);--system-checkbox-control-corner-radius:2px;--system-card-border-color:var(--spectrum-gray-100);--system-card-border-color-hover:var(--spectrum-gray-200);--system-card-divider-color:var(--spectrum-gray-200);--system-card-preview-background-color:var(--spectrum-gray-100);--system-card-preview-background-color-hover:var(--spectrum-gray-200);--system-clear-button-background-color:transparent;--system-clear-button-background-color-hover:transparent;--system-clear-button-background-color-down:transparent;--system-clear-button-background-color-key-focus:transparent;--system-clear-button-static-white-background-color-hover:var(--spectrum-transparent-white-400);--system-clear-button-static-white-background-color-down:var(--spectrum-transparent-white-500);--system-clear-button-static-white-background-color-key-focus:var(--spectrum-transparent-white-400);--system-close-button-background-color-default:transparent;--system-close-button-background-color-hover:var(--spectrum-gray-100);--system-close-button-background-color-down:var(--spectrum-gray-200);--system-close-button-background-color-focus:var(--spectrum-gray-100);--system-close-button-static-white-static-background-color-hover:var(--spectrum-transparent-white-400);--system-close-button-static-white-static-background-color-down:var(--spectrum-transparent-white-500);--system-close-button-static-white-static-background-color-focus:var(--spectrum-transparent-white-400);--system-close-button-static-black-static-background-color-hover:var(--spectrum-transparent-black-400);--system-close-button-static-black-static-background-color-down:var(--spectrum-transparent-black-500);--system-close-button-static-black-static-background-color-focus:var(--spectrum-transparent-black-400);--system-coach-indicator-ring-border-size:var(--spectrum-border-width-200);--system-coach-indicator-min-inline-size:calc(var(--spectrum-coach-indicator-ring-diameter)*3);--system-coach-indicator-min-block-size:calc(var(--spectrum-coach-indicator-ring-diameter)*3);--system-coach-indicator-inline-size:var(--system-coach-indicator-min-inline-size);--system-coach-indicator-block-size:var(--system-coach-indicator-min-block-size);--system-coach-indicator-ring-inline-size:var(--spectrum-coach-indicator-ring-diameter);--system-coach-indicator-ring-block-size:var(--spectrum-coach-indicator-ring-diameter);--system-coach-indicator-ring-dark-color:var(--spectrum-gray-900);--system-coach-indicator-ring-light-color:var(--spectrum-gray-25);--system-coach-indicator-top:calc(var(--system-coach-indicator-block-size)/3 - var(--system-coach-indicator-ring-border-size));--system-coach-indicator-left:calc(var(--system-coach-indicator-inline-size)/3 - var(--system-coach-indicator-ring-border-size));--system-coach-indicator-coach-animation-indicator-ring-duration:var(--spectrum-animation-duration-6000);--system-coach-indicator-coach-animation-indicator-ring-inner-delay-multiple:-.5;--system-coach-indicator-coach-animation-indicator-ring-center-delay-multiple:-.66;--system-coach-indicator-coach-animation-indicator-ring-outer-delay-multiple:-1;--system-coach-indicator-quiet-animation-ring-inner-delay-multiple:-.33;--system-coach-indicator-animation-name:pulse;--system-coach-indicator-inner-animation-delay-multiple:var(--system-coach-indicator-coach-animation-indicator-ring-inner-delay-multiple);--system-coach-indicator-animation-keyframe-0-scale:1;--system-coach-indicator-animation-keyframe-0-opacity:0;--system-coach-indicator-animation-keyframe-50-scale:1.5;--system-coach-indicator-animation-keyframe-50-opacity:1;--system-coach-indicator-animation-keyframe-100-scale:2;--system-coach-indicator-animation-keyframe-100-opacity:0;--system-coach-indicator-quiet-animation-keyframe-0-scale:.8;--system-coach-indicator-quiet-quiet-ring-diameter-size:var(--spectrum-coach-indicator-quiet-ring-diameter);--system-coach-indicator-quiet-animation-name:pulse-quiet;--system-coach-mark-min-width:var(--spectrum-coach-mark-minimum-width);--system-coach-mark-width:var(--spectrum-coach-mark-width);--system-coach-mark-max-width:var(--spectrum-coach-mark-maximum-width);--system-coach-mark-media-height:var(--spectrum-coach-mark-media-height);--system-coach-mark-media-min-height:var(--spectrum-coach-mark-media-minimum-height);--system-coach-mark-padding:var(--spectrum-coach-mark-edge-to-content);--system-coach-mark-heading-to-action-button:var(--spectrum-spacing-300);--system-coach-mark-header-to-body:var(--spectrum-spacing-200);--system-coach-mark-body-to-footer:var(--spectrum-spacing-300);--system-coach-mark-title-color:var(--spectrum-heading-color);--system-coach-mark-title-font-family:var(--spectrum-sans-serif-font);--system-coach-mark-title-font-style:var(--spectrum-heading-serif-font-style);--system-coach-mark-title-text-font-weight:var(--spectrum-heading-sans-serif-font-weight);--system-coach-mark-title-font-size:var(--spectrum-coach-mark-title-size);--system-coach-mark-title-text-line-height:var(--spectrum-heading-line-height);--system-coach-mark-content-font-color:var(--spectrum-body-color);--system-coach-mark-content-font-weight:var(--spectrum-body-sans-serif-font-weight);--system-coach-mark-content-font-family:var(--spectrum-sans-serif-font);--system-coach-mark-content-font-style:var(--spectrum-body-sans-serif-font-style);--system-coach-mark-content-line-height:var(--spectrum-body-line-height);--system-coach-mark-content-font-size:var(--spectrum-coach-mark-body-size);--system-coach-mark-step-color:var(--spectrum-coach-mark-pagination-color);--system-coach-mark-step-font-weight:var(--spectrum-body-medium-font-weight);--system-coach-mark-step-font-family:var(--spectrum-sans-serif-font);--system-coach-mark-step-font-style:var(--spectrum-body-sans-serif-font-style);--system-coach-mark-step-line-height:var(--spectrum-body-line-height);--system-coach-mark-step-font-size:var(--spectrum-coach-mark-pagination-body-size);--system-coach-mark-step-to-bottom:var(--spectrum-coach-mark-pagination-text-to-bottom-edge);--system-coach-mark-popover-border-width:var(--spectrum-border-width-100);--system-coach-mark-popover-corner-radius:var(--spectrum-corner-radius-100);--system-coach-mark-buttongroup-spacing-horizontal:var(--spectrum-spacing-100);--system-color-wheel-border-color:var(--spectrum-transparent-black-300);--system-combobox-border-color-default:var(--spectrum-gray-500);--system-combobox-border-color-hover:var(--spectrum-gray-600);--system-combobox-border-color-focus:var(--spectrum-gray-800);--system-combobox-border-color-focus-hover:var(--spectrum-gray-900);--system-combobox-border-color-key-focus:var(--spectrum-gray-800);--system-combobox-readonly-input-border-color:var(--spectrum-gray-500);--system-combobox-background-color-disabled:var(--spectrum-gray-25);--system-combobox-border-color-disabled:var(--spectrum-disabled-border-color);--system-dialog-fullscreen-header-text-size:28px;--system-dialog-min-inline-size:288px;--system-dialog-confirm-small-width:400px;--system-dialog-confirm-medium-width:480px;--system-dialog-confirm-large-width:640px;--system-dialog-confirm-divider-block-spacing-start:var(--spectrum-spacing-300);--system-dialog-confirm-divider-block-spacing-end:var(--spectrum-spacing-200);--system-dialog-confirm-description-text-color:var(--spectrum-gray-800);--system-dialog-confirm-title-text-color:var(--spectrum-gray-900);--system-dialog-confirm-description-text-line-height:var(--spectrum-line-height-100);--system-dialog-confirm-title-text-line-height:var(--spectrum-line-height-100);--system-dialog-heading-font-weight:var(--spectrum-heading-sans-serif-font-weight);--system-dialog-confirm-description-padding:var(--spectrum-spacing-50);--system-dialog-confirm-description-margin:calc(var(--spectrum-spacing-50)*-1);--system-dialog-confirm-footer-padding-top:var(--spectrum-spacing-600);--system-dialog-confirm-gap-size:var(--spectrum-component-pill-edge-to-text-100);--system-dialog-confirm-buttongroup-padding-top:var(--spectrum-spacing-600);--system-dialog-confirm-close-button-size:var(--spectrum-component-height-100);--system-dialog-confirm-close-button-padding:calc(26px - var(--spectrum-component-bottom-to-text-300));--system-dialog-confirm-divider-height:var(--spectrum-spacing-50);--system-divider-background-color:var(--spectrum-gray-200);--system-divider-background-color-static-white:var(--spectrum-transparent-white-200);--system-divider-background-color-static-black:var(--spectrum-transparent-black-200);--system-alert-dialog-divider-background-color:transparent;--system-alert-dialog-divider-background-color-static-white:transparent;--system-alert-dialog-divider-background-color-static-black:transparent;--system-drop-zone-border-color:var(--spectrum-gray-200);--system-field-group-margin:var(--spectrum-spacing-300);--system-field-group-readonly-delimiter:",";--system-infield-button-border-width:var(--spectrum-border-width-100);--system-infield-button-border-color:inherit;--system-infield-button-border-radius:var(--spectrum-corner-radius-100);--system-infield-button-border-radius-reset:0;--system-infield-button-stacked-top-border-radius-start-start:var(--system-infield-button-border-radius-reset);--system-infield-button-stacked-bottom-border-radius-end-start:var(--system-infield-button-border-radius-reset);--system-infield-button-background-color:var(--spectrum-gray-100);--system-infield-button-background-color-hover:var(--spectrum-gray-200);--system-infield-button-background-color-down:var(--spectrum-gray-200);--system-infield-button-background-color-key-focus:var(--spectrum-gray-200);--system-infield-button-disabled-border-color:var(--spectrum-gray-300);--system-menu-item-background-color-hover:rgba(var(--spectrum-gray-1000-rgb),var(--spectrum-transparent-black-200-opacity));--system-menu-item-background-color-down:rgba(var(--spectrum-gray-1000-rgb),var(--spectrum-transparent-black-200-opacity));--system-menu-item-background-color-key-focus:rgba(var(--spectrum-gray-1000-rgb),var(--spectrum-transparent-black-200-opacity));--system-menu-item-corner-radius:var(--spectrum-corner-radius-100);--system-menu-item-focus-indicator-shadow:none;--system-menu-item-focus-indicator-offset:var(--spectrum-spacing-50);--system-menu-item-spacing-multiplier:1;--system-menu-item-focus-indicator-outline-style:solid;--system-meter-min-width:var(--spectrum-meter-minimum-width);--system-meter-max-width:var(--spectrum-meter-maximum-width);--system-meter-inline-size:var(--spectrum-progressbar-size-2500);--system-meter-top-to-text:var(--spectrum-component-top-to-text-200);--system-meter-fill-color-positive:var(--spectrum-positive-visual-color);--system-meter-fill-color-notice:var(--spectrum-notice-visual-color);--system-meter-fill-color-negative:var(--spectrum-negative-visual-color);--system-meter-size-s-thickness:var(--spectrum-meter-thickness-small);--system-meter-size-s-inline-size:var(--spectrum-progressbar-size-2400);--system-meter-size-s-font-size:var(--spectrum-font-size-75);--system-meter-size-s-top-to-text:var(--spectrum-component-top-to-text-75);--system-meter-thickness:var(--spectrum-meter-thickness-large);--system-meter-size-l-thickness:var(--spectrum-meter-thickness-large);--system-meter-size-l-inline-size:var(--spectrum-progressbar-size-2500);--system-meter-font-size:var(--spectrum-font-size-100);--system-meter-size-l-font-size:var(--spectrum-font-size-100);--system-meter-size-l-top-to-text:var(--spectrum-component-top-to-text-200);--system-modal-background-color:var(--spectrum-background-layer-2-color);--system-picker-background-color-default:var(--spectrum-gray-100);--system-picker-background-color-default-open:var(--spectrum-gray-200);--system-picker-background-color-hover:var(--spectrum-gray-200);--system-picker-background-color-hover-open:var(--spectrum-gray-200);--system-picker-background-color-active:var(--spectrum-gray-200);--system-picker-background-color-key-focus:var(--spectrum-gray-200);--system-picker-border-color-default:transparent;--system-picker-border-color-default-open:transparent;--system-picker-border-color-hover:transparent;--system-picker-border-color-hover-open:transparent;--system-picker-border-color-active:transparent;--system-picker-border-color-key-focus:transparent;--system-picker-border-color-disabled:transparent;--system-picker-border-width:var(--spectrum-border-width-200);--system-picker-button-background-color:var(--spectrum-gray-100);--system-picker-button-background-color-hover:var(--spectrum-gray-200);--system-picker-button-background-color-down:var(--spectrum-gray-200);--system-picker-button-background-color-key-focus:var(--spectrum-gray-200);--system-picker-button-border-color:none;--system-picker-button-border-radius:var(--spectrum-corner-radius-75);--system-picker-button-border-radius-rounded-sided:var(--spectrum-corner-radius-200);--system-picker-button-border-radius-sided:var(--spectrum-corner-radius-75);--system-picker-button-border-width:0px;--system-picker-button-padding:4px;--system-popover-border-width:var(--spectrum-border-width-100);--system-progress-bar-animation-ease-in-out-indeterminate:var(--spectrum-animation-ease-in-out);--system-progress-bar-animation-duration-indeterminate:var(--spectrum-animation-duration-2000);--system-progress-bar-corner-radius:var(--spectrum-corner-radius-100);--system-progress-bar-fill-size-indeterminate:70%;--system-progress-bar-size-2400:192px;--system-progress-bar-size-2500:200px;--system-progress-bar-size-2800:224px;--system-progress-bar-line-height-cjk:var(--spectrum-cjk-line-height-100);--system-progress-bar-min-size:var(--spectrum-progress-bar-minimum-width);--system-progress-bar-max-size:var(--spectrum-progress-bar-maximum-width);--system-progress-bar-line-height:var(--spectrum-line-height-100);--system-progress-bar-spacing-label-to:var(--spectrum-spacing-75);--system-progress-bar-spacing-label-to-text:var(--spectrum-spacing-200);--system-progress-bar-text-color:var(--spectrum-neutral-content-color-default);--system-progress-bar-track-color:var(--spectrum-gray-200);--system-progress-bar-fill-color:var(--spectrum-accent-color-900);--system-progress-bar-label-and-value-white:var(--spectrum-white);--system-progress-bar-track-color-white:var(--spectrum-transparent-white-400);--system-progress-bar-fill-color-white:var(--spectrum-white);--system-progress-bar-size-default:var(--system-progress-bar-size-2400);--system-progress-bar-size-m-size-default:var(--system-progress-bar-size-2400);--system-progress-bar-font-size:var(--spectrum-font-size-75);--system-progress-bar-size-m-font-size:var(--spectrum-font-size-75);--system-progress-bar-thickness:var(--spectrum-progress-bar-thickness-large);--system-progress-bar-size-m-thickness:var(--spectrum-progress-bar-thickness-large);--system-progress-bar-spacing-top-to-text:var(--spectrum-component-top-to-text-75);--system-progress-bar-size-m-spacing-top-to-text:var(--spectrum-component-top-to-text-75);--system-progress-bar-size-s-size-default:var(--system-progress-bar-size-2400);--system-progress-bar-size-s-font-size:var(--spectrum-font-size-75);--system-progress-bar-size-s-thickness:var(--spectrum-progress-bar-thickness-small);--system-progress-bar-size-s-spacing-top-to-text:var(--spectrum-component-top-to-text-75);--system-progress-bar-size-l-size-default:var(--system-progress-bar-size-2500);--system-progress-bar-size-l-font-size:var(--spectrum-font-size-100);--system-progress-bar-size-l-thickness:var(--spectrum-progress-bar-thickness-large);--system-progress-bar-size-l-spacing-top-to-text:var(--spectrum-component-top-to-text-200);--system-progress-bar-size-xl-size-default:var(--system-progress-bar-size-2800);--system-progress-bar-size-xl-font-size:var(--spectrum-font-size-200);--system-progress-bar-size-xl-thickness:var(--spectrum-progress-bar-thickness-extra-large);--system-progress-bar-size-xl-spacing-top-to-text:var(--spectrum-component-top-to-text-300);--system-progress-circle-track-border-color:var(--spectrum-gray-200);--system-progress-circle-track-border-color-over-background:var(--spectrum-transparent-white-400);--system-progress-circle-fill-border-color-over-background:var(--spectrum-transparent-white-1000);--system-radio-button-border-color-default:var(--spectrum-gray-600);--system-radio-button-border-color-hover:var(--spectrum-gray-700);--system-radio-button-border-color-down:var(--spectrum-gray-800);--system-radio-button-border-color-focus:var(--spectrum-gray-700);--system-radio-neutral-content-color:var(--spectrum-neutral-content-color-default);--system-radio-neutral-content-color-hover:var(--spectrum-neutral-content-color-hover);--system-radio-neutral-content-color-down:var(--spectrum-neutral-content-color-down);--system-radio-neutral-content-color-focus:var(--spectrum-neutral-content-color-key-focus);--system-radio-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--system-radio-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--system-radio-focus-indicator-color:var(--spectrum-focus-indicator-color);--system-radio-disabled-content-color:var(--spectrum-disabled-content-color);--system-radio-disabled-border-color:var(--spectrum-disabled-content-color);--system-radio-emphasized-accent-color:var(--spectrum-accent-color-900);--system-radio-emphasized-accent-color-hover:var(--spectrum-accent-color-1000);--system-radio-emphasized-accent-color-down:var(--spectrum-accent-color-1100);--system-radio-emphasized-accent-color-focus:var(--spectrum-accent-color-1000);--system-radio-border-width:var(--spectrum-border-width-200);--system-radio-button-background-color:var(--spectrum-gray-50);--system-radio-button-checked-border-color-default:var(--spectrum-neutral-background-color-selected-default);--system-radio-button-checked-border-color-hover:var(--spectrum-neutral-background-color-selected-hover);--system-radio-button-checked-border-color-down:var(--spectrum-neutral-background-color-selected-down);--system-radio-button-checked-border-color-focus:var(--spectrum-neutral-background-color-selected-focus);--system-radio-line-height:var(--spectrum-line-height-100);--system-radio-animation-duration:var(--spectrum-animation-duration-100);--system-radio-lang-ja-line-height-cjk:var(--spectrum-cjk-line-height-100);--system-radio-lang-zh-line-height-cjk:var(--spectrum-cjk-line-height-100);--system-radio-lang-ko-line-height-cjk:var(--spectrum-cjk-line-height-100);--system-radio-height:var(--spectrum-component-height-100);--system-radio-size-m-height:var(--spectrum-component-height-100);--system-radio-button-control-size:var(--spectrum-radio-button-control-size-medium);--system-radio-size-m-button-control-size:var(--spectrum-radio-button-control-size-medium);--system-radio-text-to-control:var(--spectrum-text-to-control-100);--system-radio-size-m-text-to-control:var(--spectrum-text-to-control-100);--system-radio-label-top-to-text:var(--spectrum-component-top-to-text-100);--system-radio-size-m-label-top-to-text:var(--spectrum-component-top-to-text-100);--system-radio-label-bottom-to-text:var(--spectrum-component-bottom-to-text-100);--system-radio-size-m-label-bottom-to-text:var(--spectrum-component-bottom-to-text-100);--system-radio-button-top-to-control:var(--spectrum-radio-button-top-to-control-medium);--system-radio-size-m-button-top-to-control:var(--spectrum-radio-button-top-to-control-medium);--system-radio-font-size:var(--spectrum-font-size-100);--system-radio-size-m-font-size:var(--spectrum-font-size-100);--system-radio-size-s-height:var(--spectrum-component-height-75);--system-radio-size-s-button-control-size:var(--spectrum-radio-button-control-size-small);--system-radio-size-s-text-to-control:var(--spectrum-text-to-control-75);--system-radio-size-s-label-top-to-text:var(--spectrum-component-top-to-text-75);--system-radio-size-s-label-bottom-to-text:var(--spectrum-component-bottom-to-text-75);--system-radio-size-s-button-top-to-control:var(--spectrum-radio-button-top-to-control-small);--system-radio-size-s-font-size:var(--spectrum-font-size-75);--system-radio-size-l-height:var(--spectrum-component-height-200);--system-radio-size-l-button-control-size:var(--spectrum-radio-button-control-size-large);--system-radio-size-l-text-to-control:var(--spectrum-text-to-control-200);--system-radio-size-l-label-top-to-text:var(--spectrum-component-top-to-text-200);--system-radio-size-l-label-bottom-to-text:var(--spectrum-component-bottom-to-text-200);--system-radio-size-l-button-top-to-control:var(--spectrum-radio-button-top-to-control-large);--system-radio-size-l-font-size:var(--spectrum-font-size-200);--system-radio-size-xl-height:var(--spectrum-component-height-300);--system-radio-size-xl-button-control-size:var(--spectrum-radio-button-control-size-extra-large);--system-radio-size-xl-text-to-control:var(--spectrum-text-to-control-300);--system-radio-size-xl-label-top-to-text:var(--spectrum-component-top-to-text-300);--system-radio-size-xl-label-bottom-to-text:var(--spectrum-component-bottom-to-text-300);--system-radio-size-xl-button-top-to-control:var(--spectrum-radio-button-top-to-control-extra-large);--system-radio-size-xl-font-size:var(--spectrum-font-size-300);--system-radio-emphasized-button-checked-border-color-default:var(--spectrum-accent-color-900);--system-radio-emphasized-button-checked-border-color-hover:var(--spectrum-accent-color-1000);--system-radio-emphasized-button-checked-border-color-down:var(--spectrum-accent-color-1100);--system-radio-emphasized-button-checked-border-color-focus:var(--spectrum-accent-color-1000);--system-search-border-color-default:var(--spectrum-gray-500);--system-search-border-color-hover:var(--spectrum-gray-600);--system-search-border-color-focus:var(--spectrum-gray-800);--system-search-border-color-focus-hover:var(--spectrum-gray-900);--system-search-border-color-key-focus:var(--spectrum-gray-800);--system-search-background-color:var(--spectrum-gray-25);--system-search-background-color-disabled:var(--spectrum-gray-25);--system-search-border-color-disabled:var(--spectrum-gray-300);--system-search-border-radius:var(--spectrum-corner-radius-100);--system-search-size-m-border-radius:var(--spectrum-corner-radius-100);--system-search-edge-to-visual:var(--spectrum-component-edge-to-visual-100);--system-search-size-m-edge-to-visual:var(--spectrum-component-edge-to-visual-100);--system-search-size-s-border-radius:var(--spectrum-corner-radius-100);--system-search-size-s-edge-to-visual:var(--spectrum-component-edge-to-visual-75);--system-search-size-l-border-radius:var(--spectrum-corner-radius-100);--system-search-size-l-edge-to-visual:var(--spectrum-component-edge-to-visual-200);--system-search-size-xl-border-radius:var(--spectrum-corner-radius-100);--system-search-size-xl-edge-to-visual:var(--spectrum-component-edge-to-visual-300);--system-search-quiet-background-color-disabled:transparent;--system-search-quiet-border-color-disabled:var(--spectrum-disabled-border-color);--system-side-nav-background-hover:var(--spectrum-gray-100);--system-side-nav-item-background-down:var(--spectrum-gray-200);--system-side-nav-background-key-focus:var(--spectrum-gray-100);--system-side-nav-item-background-default-selected:var(--spectrum-gray-100);--system-side-nav-background-hover-selected:var(--spectrum-gray-200);--system-side-nav-item-background-down-selected:var(--spectrum-gray-200);--system-side-nav-background-key-focus-selected:var(--spectrum-gray-100);--system-slider-track-color:var(--spectrum-gray-200);--system-slider-track-fill-color:var(--spectrum-gray-700);--system-slider-ramp-track-color:var(--spectrum-gray-400);--system-slider-ramp-track-color-disabled:var(--spectrum-gray-100);--system-slider-handle-background-color:transparent;--system-slider-handle-background-color-disabled:transparent;--system-slider-ramp-handle-background-color:var(--spectrum-gray-75);--system-slider-ticks-handle-background-color:var(--spectrum-gray-75);--system-slider-handle-border-color:var(--spectrum-gray-700);--system-slider-handle-disabled-background-color:var(--spectrum-gray-75);--system-slider-tick-mark-color:var(--spectrum-gray-200);--system-slider-handle-border-color-hover:var(--spectrum-gray-800);--system-slider-handle-border-color-down:var(--spectrum-gray-800);--system-slider-handle-border-color-key-focus:var(--spectrum-gray-800);--system-slider-handle-focus-ring-color-key-focus:var(--spectrum-focus-indicator-color);--system-slider-track-corner-radius:2px;--system-slider-handle-border-radius:var(--spectrum-corner-radius-500);--system-slider-size-m-handle-border-radius:var(--spectrum-corner-radius-500);--system-slider-size-s-handle-border-radius:var(--spectrum-corner-radius-500);--system-slider-size-l-handle-border-radius:calc(var(--spectrum-corner-radius-500)*4);--system-slider-size-xl-handle-border-radius:calc(var(--spectrum-corner-radius-500)*4);--system-split-view-background-color:var(--spectrum-gray-75);--system-split-view-handle-background-color:var(--spectrum-gray-200);--system-split-view-gripper-border-radius:2px;--system-stepper-border-width:var(--spectrum-border-width-100);--system-stepper-border-color-default:var(--spectrum-gray-500);--system-stepper-border-color-hover:var(--spectrum-gray-600);--system-stepper-border-color-focus:var(--spectrum-gray-800);--system-stepper-border-color-focus-hover:var(--spectrum-gray-900);--system-stepper-border-color-keyboard-focus:var(--spectrum-gray-800);--system-stepper-buttons-border-style:none;--system-stepper-buttons-border-width:0;--system-stepper-buttons-border-color:var(--spectrum-gray-500);--system-stepper-buttons-background-color:var(--spectrum-gray-100);--system-stepper-buttons-border-color-hover:var(--spectrum-gray-600);--system-stepper-buttons-border-color-focus:var(--spectrum-gray-800);--system-stepper-buttons-border-color-keyboard-focus:var(--spectrum-gray-800);--system-stepper-button-border-width:var(--spectrum-border-width-100);--system-stepper-border-color-invalid:var(--spectrum-negative-border-color-default);--system-stepper-border-color-focus-invalid:var(--spectrum-negative-border-color-focus);--system-stepper-border-color-focus-hover-invalid:var(--spectrum-negative-border-color-focus-hover);--system-stepper-border-color-keyboard-focus-invalid:var(--spectrum-negative-border-color-key-focus);--system-stepper-border-color-disabled:var(--spectrum-gray-300);--system-stepper-button-border-width-disabled:var(--spectrum-border-width-200);--system-stepper-buttons-background-color-disabled:var(--spectrum-gray-50);--system-stepper-quiet-buttons-border-style:none;--system-stepper-quiet-button-edge-to-fill:0;--system-swatch-border-radius:var(--spectrum-corner-radius-100);--system-swatch-focus-indicator-border-radius:var(--spectrum-corner-radius-200);--system-swatch-border-thickness:var(--spectrum-border-width-100);--system-swatch-border-thickness-selected:var(--spectrum-border-width-200);--system-swatch-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--system-swatch-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--system-swatch-border-color-opacity:.51;--system-swatch-border-color-light-opacity:.2;--system-swatch-border-color:rgba(var(--spectrum-gray-1000-rgb),var(--system-swatch-border-color-opacity));--system-swatch-icon-border-color:rgba(var(--spectrum-black-rgb),var(--system-swatch-border-color-opacity));--system-swatch-border-color-light:rgba(var(--spectrum-black-rgb),var(--system-swatch-border-color-light-opacity));--system-swatch-border-color-selected:var(--spectrum-gray-900);--system-swatch-inner-border-color-selected:var(--spectrum-gray-25);--system-swatch-disabled-icon-color:var(--spectrum-gray-25);--system-swatch-dash-icon-color:var(--spectrum-gray-800);--system-swatch-slash-icon-color:var(--spectrum-red-900);--system-swatch-focus-indicator-color:var(--spectrum-focus-indicator-color);--system-swatch-size:var(--spectrum-swatch-size-medium);--system-swatch-size-m-size:var(--spectrum-swatch-size-medium);--system-swatch-disabled-icon-size:var(--spectrum-workflow-icon-size-100);--system-swatch-size-m-disabled-icon-size:var(--spectrum-workflow-icon-size-100);--system-swatch-slash-thickness:var(--spectrum-swatch-slash-thickness-medium);--system-swatch-size-m-slash-thickness:var(--spectrum-swatch-slash-thickness-medium);--system-swatch-size-xs-size:var(--spectrum-swatch-size-extra-small);--system-swatch-size-xs-disabled-icon-size:var(--spectrum-workflow-icon-size-50);--system-swatch-size-xs-slash-thickness:var(--spectrum-swatch-slash-thickness-extra-small);--system-swatch-size-s-size:var(--spectrum-swatch-size-small);--system-swatch-size-s-disabled-icon-size:var(--spectrum-workflow-icon-size-75);--system-swatch-size-s-slash-thickness:var(--spectrum-swatch-slash-thickness-small);--system-swatch-size-l-size:var(--spectrum-swatch-size-large);--system-swatch-size-l-disabled-icon-size:var(--spectrum-workflow-icon-size-200);--system-swatch-size-l-slash-thickness:var(--spectrum-swatch-slash-thickness-large);--system-swatch-group-spacing-compact:var(--spectrum-spacing-50);--system-swatch-group-spacing-regular:var(--spectrum-spacing-75);--system-swatch-group-spacing-spacious:var(--spectrum-spacing-100);--system-switch-handle-border-color-default:var(--spectrum-gray-600);--system-switch-handle-border-color-hover:var(--spectrum-gray-700);--system-switch-handle-border-color-down:var(--spectrum-gray-800);--system-switch-handle-border-color-focus:var(--spectrum-gray-700);--system-switch-handle-border-color-selected-default:var(--spectrum-gray-700);--system-switch-handle-border-color-selected-hover:var(--spectrum-gray-800);--system-switch-handle-border-color-selected-down:var(--spectrum-gray-900);--system-switch-handle-border-color-selected-focus:var(--spectrum-gray-800);--system-switch-background-color:var(--spectrum-gray-200);--system-switch-background-color-disabled:var(--spectrum-gray-200);--system-switch-handle-background-color:var(--spectrum-gray-50);--system-table-header-background-color:var(--spectrum-transparent-white-25);--system-table-border-color:var(--spectrum-gray-200);--system-table-divider-color:var(--spectrum-gray-200);--system-table-row-background-color:var(--spectrum-gray-25);--system-table-summary-row-background-color:var(--spectrum-gray-100);--system-table-section-header-background-color:var(--spectrum-gray-100);--system-table-icon-color-focus:var(--spectrum-neutral-subdued-content-color-key-focus);--system-table-icon-color-focus-hover:var(--spectrum-neutral-subdued-content-color-hover);--system-table-quiet-header-background-color:var(--spectrum-transparent-white-25);--system-table-quiet-row-background-color:var(--spectrum-transparent-white-25);--system-tabs-font-weight:var(--spectrum-regular-font-weight);--system-tabs-divider-background-color:var(--spectrum-gray-200);--system-tag-background-color:var(--spectrum-gray-50);--system-tag-background-color-hover:var(--spectrum-gray-50);--system-tag-background-color-active:var(--spectrum-gray-100);--system-tag-background-color-focus:var(--spectrum-gray-50);--system-tag-size-small-corner-radius:var(--spectrum-corner-radius-100);--system-tag-size-medium-corner-radius:var(--spectrum-corner-radius-100);--system-tag-size-large-corner-radius:var(--spectrum-corner-radius-100);--system-tag-border-color:var(--spectrum-gray-700);--system-tag-border-color-hover:var(--spectrum-gray-800);--system-tag-border-color-active:var(--spectrum-gray-900);--system-tag-border-color-focus:var(--spectrum-gray-800);--system-tag-content-color:var(--spectrum-neutral-subdued-content-color-default);--system-tag-content-color-hover:var(--spectrum-neutral-subdued-content-color-hover);--system-tag-content-color-active:var(--spectrum-neutral-subdued-content-color-down);--system-tag-content-color-focus:var(--spectrum-neutral-subdued-content-color-key-focus);--system-tag-content-color-selected:var(--spectrum-gray-25);--system-tag-border-color-selected:var(--spectrum-neutral-subdued-background-color-default);--system-tag-border-color-selected-hover:var(--spectrum-neutral-subdued-background-color-hover);--system-tag-border-color-selected-active:var(--spectrum-neutral-subdued-background-color-down);--system-tag-border-color-selected-focus:var(--spectrum-neutral-subdued-background-color-key-focus);--system-tag-border-color-disabled:transparent;--system-tag-background-color-disabled:var(--spectrum-disabled-background-color);--system-tag-size-small-spacing-inline-start:var(--spectrum-component-edge-to-visual-75);--system-tag-size-small-label-spacing-inline-end:var(--spectrum-component-edge-to-text-75);--system-tag-size-small-clear-button-spacing-inline-end:var(--spectrum-component-edge-to-visual-75);--system-tag-size-medium-spacing-inline-start:var(--spectrum-component-edge-to-visual-100);--system-tag-size-medium-label-spacing-inline-end:var(--spectrum-component-edge-to-text-100);--system-tag-size-medium-clear-button-spacing-inline-end:var(--spectrum-component-edge-to-visual-100);--system-tag-size-large-spacing-inline-start:var(--spectrum-component-edge-to-visual-200);--system-tag-size-large-label-spacing-inline-end:var(--spectrum-component-edge-to-text-200);--system-tag-size-large-clear-button-spacing-inline-end:var(--spectrum-component-edge-to-visual-200);--system-textfield-background-color:var(--spectrum-gray-25);--system-textfield-background-color-disabled:var(--spectrum-gray-25);--system-textfield-border-color:var(--spectrum-gray-300);--system-textfield-border-color-hover:var(--spectrum-gray-400);--system-textfield-border-color-focus:var(--spectrum-gray-800);--system-textfield-border-color-focus-hover:var(--spectrum-gray-900);--system-textfield-border-color-keyboard-focus:var(--spectrum-gray-800);--system-textfield-border-color-disabled:var(--spectrum-disabled-border-color);--system-textfield-border-width:var(--spectrum-border-width-200);--system-textfield-spacing-block-start:var(--spectrum-component-top-to-text-100);--system-textfield-spacing-block-start-small:var(--spectrum-component-top-to-text-75);--system-textfield-spacing-block-start-large:var(--spectrum-component-top-to-text-200);--system-textfield-spacing-block-start-extra-large:var(--spectrum-component-top-to-text-300);--system-textfield-spacing-block-end:var(--spectrum-component-bottom-to-text-100);--system-textfield-spacing-block-end-small:var(--spectrum-component-bottom-to-text-75);--system-textfield-spacing-block-end-large:var(--spectrum-component-bottom-to-text-200);--system-textfield-spacing-block-end-extra-large:var(--spectrum-component-bottom-to-text-300);--system-textfield-icon-spacing-block-invalid:var(--spectrum-component-top-to-workflow-icon-100);--system-textfield-size-s-icon-spacing-block-invalid:var(--spectrum-component-top-to-workflow-icon-75);--system-textfield-size-l-icon-spacing-block-invalid:var(--spectrum-component-top-to-workflow-icon-200);--system-textfield-size-xl-icon-spacing-block-invalid:var(--spectrum-component-top-to-workflow-icon-300);--system-textfield-quiet-border-color-disabled:var(--spectrum-gray-300);--system-thumbnail-border-radius:2px;--system-toast-background-color-default:var(--spectrum-neutral-subdued-background-color-default);--system-toast-divider-color:var(--spectrum-transparent-white-400);--system-tooltip-backgound-color-default-neutral:var(--spectrum-neutral-subdued-background-color-default);--system-field-label-top-to-text:var(--spectrum-component-top-to-text-100);--system-field-label-top-to-text-small:var(--spectrum-component-top-to-text-75);--system-field-label-top-to-text-large:var(--spectrum-component-top-to-text-200);--system-field-label-top-to-text-extra-large:var(--spectrum-component-top-to-text-300);--system-field-label-bottom-to-text:var(--spectrum-component-bottom-to-text-100);--system-field-label-bottom-to-text-small:var(--spectrum-component-bottom-to-text-75);--system-field-label-bottom-to-text-large:var(--spectrum-component-bottom-to-text-200);--system-field-label-bottom-to-text-extra-large:var(--spectrum-component-bottom-to-text-300);--system-helptext-top-to-text:var(--spectrum-component-top-to-text-100);--system-helptext-top-to-text-small:var(--spectrum-component-top-to-text-75);--system-helptext-top-to-text-large:var(--spectrum-component-top-to-text-200);--system-helptext-top-to-text-extra-large:var(--spectrum-component-top-to-text-300);--system-helptext-bottom-to-text:var(--spectrum-component-bottom-to-text-100);--system-helptext-bottom-to-text-small:var(--spectrum-component-bottom-to-text-75);--system-helptext-bottom-to-text-large:var(--spectrum-component-bottom-to-text-200);--system-helptext-bottom-to-text-extra-large:var(--spectrum-component-bottom-to-text-300);--system-textfield-corner-radius:var(--spectrum-corner-radius-medium-size-medium);--system-textfield-corner-radius-small:var(--spectrum-corner-radius-medium-size-small);--system-textfield-corner-radius-large:var(--spectrum-corner-radius-medium-size-large);--system-textfield-corner-radius-extra-large:var(--spectrum-corner-radius-medium-size-extra-large)}.spectrum-Typography{font-family:var(--spectrum-font-family);font-style:var(--spectrum-font-style);font-size:var(--spectrum-font-size)}.spectrum-Typography:lang(ar){font-family:var(--spectrum-font-family-ar)}.spectrum-Typography:lang(he){font-family:var(--spectrum-font-family-he)}.spectrum-Typography .spectrum-Heading{--spectrum-heading-margin-start:calc(var(--mod-heading-font-size,var(--spectrum-heading-font-size))*var(--spectrum-heading-margin-top-multiplier));--spectrum-heading-margin-end:calc(var(--mod-heading-font-size,var(--spectrum-heading-font-size))*var(--spectrum-heading-margin-bottom-multiplier))}.spectrum-Typography .spectrum-Body{--spectrum-body-margin-end:calc(var(--mod-body-font-size,var(--spectrum-body-font-size))*var(--spectrum-body-margin-multiplier))}.spectrum-Typography .spectrum-Detail{--spectrum-detail-margin-start:calc(var(--mod-detail-font-size,var(--spectrum-detail-font-size))*var(--spectrum-detail-margin-top-multiplier));--spectrum-detail-margin-end:calc(var(--mod-detail-font-size,var(--spectrum-detail-font-size))*var(--spectrum-detail-margin-bottom-multiplier))}.spectrum-Heading,.spectrum-Heading--sizeM{--spectrum-heading-font-size:var(--spectrum-heading-size-m);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-m)}.spectrum-Heading--sizeXXS{--spectrum-heading-font-size:var(--spectrum-heading-size-xxs);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xxs)}.spectrum-Heading--sizeXS{--spectrum-heading-font-size:var(--spectrum-heading-size-xs);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xs)}.spectrum-Heading--sizeS{--spectrum-heading-font-size:var(--spectrum-heading-size-s);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-s)}.spectrum-Heading--sizeL{--spectrum-heading-font-size:var(--spectrum-heading-size-l);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-l)}.spectrum-Heading--sizeXL{--spectrum-heading-font-size:var(--spectrum-heading-size-xl);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xl)}.spectrum-Heading--sizeXXL{--spectrum-heading-font-size:var(--spectrum-heading-size-xxl);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xxl)}.spectrum-Heading--sizeXXXL{--spectrum-heading-font-size:var(--spectrum-heading-size-xxxl);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xxxl)}.spectrum-Heading{--spectrum-heading-sans-serif-font-family:var(--spectrum-sans-font-family-stack);--spectrum-heading-serif-font-family:var(--spectrum-serif-font-family-stack);--spectrum-heading-cjk-font-family:var(--spectrum-cjk-font-family-stack);--spectrum-heading-cjk-letter-spacing:var(--spectrum-cjk-letter-spacing);--spectrum-heading-font-color:var(--spectrum-heading-color);font-family:var(--mod-heading-sans-serif-font-family,var(--spectrum-heading-sans-serif-font-family));font-style:var(--mod-heading-sans-serif-font-style,var(--spectrum-heading-sans-serif-font-style));font-weight:var(--mod-heading-sans-serif-font-weight,var(--spectrum-heading-sans-serif-font-weight));font-size:var(--mod-heading-font-size,var(--spectrum-heading-font-size));color:var(--highcontrast-heading-font-color,var(--mod-heading-font-color,var(--spectrum-heading-font-color)));line-height:var(--mod-heading-line-height,var(--spectrum-heading-line-height));margin-block-start:var(--mod-heading-margin-start,var(--spectrum-heading-margin-start,0));margin-block-end:var(--mod-heading-margin-end,var(--spectrum-heading-margin-end,0))}.spectrum-Heading .spectrum-Heading-strong,.spectrum-Heading strong{font-style:var(--mod-heading-sans-serif-strong-font-style,var(--spectrum-heading-sans-serif-strong-font-style));font-weight:var(--mod-heading-sans-serif-strong-font-weight,var(--spectrum-heading-sans-serif-strong-font-weight))}.spectrum-Heading .spectrum-Heading-emphasized,.spectrum-Heading em{font-style:var(--mod-heading-sans-serif-emphasized-font-style,var(--spectrum-heading-sans-serif-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-emphasized-font-weight,var(--spectrum-heading-sans-serif-emphasized-font-weight))}.spectrum-Heading .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading em strong,.spectrum-Heading strong em{font-style:var(--mod-heading-sans-serif-strong-emphasized-font-style,var(--spectrum-heading-sans-serif-strong-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-strong-emphasized-font-weight,var(--spectrum-heading-sans-serif-strong-emphasized-font-weight))}.spectrum-Heading:lang(ja),.spectrum-Heading:lang(ko),.spectrum-Heading:lang(zh){font-family:var(--mod-heading-cjk-font-family,var(--spectrum-heading-cjk-font-family));font-style:var(--mod-heading-cjk-font-style,var(--spectrum-heading-cjk-font-style));font-weight:var(--mod-heading-cjk-font-weight,var(--spectrum-heading-cjk-font-weight));font-size:var(--mod-heading-cjk-font-size,var(--spectrum-heading-cjk-font-size));line-height:var(--mod-heading-cjk-line-height,var(--spectrum-heading-cjk-line-height));letter-spacing:var(--mod-heading-cjk-letter-spacing,var(--spectrum-heading-cjk-letter-spacing))}.spectrum-Heading:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading:lang(ja) em,.spectrum-Heading:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading:lang(ko) em,.spectrum-Heading:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading:lang(zh) em{font-style:var(--mod-heading-cjk-emphasized-font-style,var(--spectrum-heading-cjk-emphasized-font-style));font-weight:var(--mod-heading-cjk-emphasized-font-weight,var(--spectrum-heading-cjk-emphasized-font-weight))}.spectrum-Heading:lang(ja) .spectrum-Heading-strong,.spectrum-Heading:lang(ja) strong,.spectrum-Heading:lang(ko) .spectrum-Heading-strong,.spectrum-Heading:lang(ko) strong,.spectrum-Heading:lang(zh) .spectrum-Heading-strong,.spectrum-Heading:lang(zh) strong{font-style:var(--mod-heading-cjk-strong-font-style,var(--spectrum-heading-cjk-strong-font-style));font-weight:var(--mod-heading-cjk-strong-font-weight,var(--spectrum-heading-cjk-strong-font-weight))}.spectrum-Heading:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(ja) em strong,.spectrum-Heading:lang(ja) strong em,.spectrum-Heading:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(ko) em strong,.spectrum-Heading:lang(ko) strong em,.spectrum-Heading:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(zh) em strong,.spectrum-Heading:lang(zh) strong em{font-style:var(--mod-heading-cjk-strong-emphasized-font-style,var(--spectrum-heading-cjk-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-strong-emphasized-font-weight,var(--spectrum-heading-cjk-strong-emphasized-font-weight))}.spectrum-Heading--heavy{font-style:var(--mod-heading-sans-serif-heavy-font-style,var(--spectrum-heading-sans-serif-heavy-font-style));font-weight:var(--mod-heading-sans-serif-heavy-font-weight,var(--spectrum-heading-sans-serif-heavy-font-weight))}.spectrum-Heading--heavy .spectrum-Heading-strong,.spectrum-Heading--heavy strong{font-style:var(--mod-heading-sans-serif-heavy-strong-font-style,var(--spectrum-heading-sans-serif-heavy-strong-font-style));font-weight:var(--mod-heading-sans-serif-heavy-strong-font-weight,var(--spectrum-heading-sans-serif-heavy-strong-font-weight))}.spectrum-Heading--heavy .spectrum-Heading-emphasized,.spectrum-Heading--heavy em{font-style:var(--mod-heading-sans-serif-heavy-emphasized-font-style,var(--spectrum-heading-sans-serif-heavy-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-heavy-emphasized-font-weight,var(--spectrum-heading-sans-serif-heavy-emphasized-font-weight))}.spectrum-Heading--heavy .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy em strong,.spectrum-Heading--heavy strong em{font-style:var(--mod-heading-sans-serif-heavy-strong-emphasized-font-style,var(--spectrum-heading-sans-serif-heavy-strong-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-heavy-strong-emphasized-font-weight,var(--spectrum-heading-sans-serif-heavy-strong-emphasized-font-weight))}.spectrum-Heading--heavy:lang(ja),.spectrum-Heading--heavy:lang(ko),.spectrum-Heading--heavy:lang(zh){font-style:var(--mod-heading-cjk-heavy-font-style,var(--spectrum-heading-cjk-heavy-font-style));font-weight:var(--mod-heading-cjk-heavy-font-weight,var(--spectrum-heading-cjk-heavy-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ja) em,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ko) em,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(zh) em{font-style:var(--mod-heading-cjk-heavy-emphasized-font-style,var(--spectrum-heading-cjk-heavy-emphasized-font-style));font-weight:var(--mod-heading-cjk-heavy-emphasized-font-weight,var(--spectrum-heading-cjk-heavy-emphasized-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(ja) strong,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(ko) strong,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(zh) strong{font-style:var(--mod-heading-cjk-heavy-strong-font-style,var(--spectrum-heading-cjk-heavy-strong-font-style));font-weight:var(--mod-heading-cjk-heavy-strong-font-weight,var(--spectrum-heading-cjk-heavy-strong-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ja) em strong,.spectrum-Heading--heavy:lang(ja) strong em,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ko) em strong,.spectrum-Heading--heavy:lang(ko) strong em,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(zh) em strong,.spectrum-Heading--heavy:lang(zh) strong em{font-style:var(--mod-heading-cjk-heavy-strong-emphasized-font-style,var(--spectrum-heading-cjk-heavy-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-heavy-strong-emphasized-font-weight,var(--spectrum-heading-cjk-heavy-strong-emphasized-font-weight))}.spectrum-Heading--light{font-style:var(--mod-heading-sans-serif-light-font-style,var(--spectrum-heading-sans-serif-light-font-style));font-weight:var(--mod-heading-sans-serif-light-font-weight,var(--spectrum-heading-sans-serif-light-font-weight))}.spectrum-Heading--light .spectrum-Heading-emphasized,.spectrum-Heading--light em{font-style:var(--mod-heading-sans-serif-light-emphasized-font-style,var(--spectrum-heading-sans-serif-light-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-light-emphasized-font-weight,var(--spectrum-heading-sans-serif-light-emphasized-font-weight))}.spectrum-Heading--light .spectrum-Heading-strong,.spectrum-Heading--light strong{font-style:var(--mod-heading-sans-serif-light-strong-font-style,var(--spectrum-heading-sans-serif-light-strong-font-style));font-weight:var(--mod-heading-sans-serif-light-strong-font-weight,var(--spectrum-heading-sans-serif-light-strong-font-weight))}.spectrum-Heading--light .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light em strong,.spectrum-Heading--light strong em{font-style:var(--mod-heading-sans-serif-light-strong-emphasized-font-style,var(--spectrum-heading-sans-serif-light-strong-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-light-strong-emphasized-font-weight,var(--spectrum-heading-sans-serif-light-strong-emphasized-font-weight))}.spectrum-Heading--light:lang(ja),.spectrum-Heading--light:lang(ko),.spectrum-Heading--light:lang(zh){font-style:var(--mod-heading-cjk-light-font-style,var(--spectrum-heading-cjk-light-font-style));font-weight:var(--mod-heading-cjk-light-font-weight,var(--spectrum-heading-cjk-light-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-strong,.spectrum-Heading--light:lang(ja) strong,.spectrum-Heading--light:lang(ko) .spectrum-Heading-strong,.spectrum-Heading--light:lang(ko) strong,.spectrum-Heading--light:lang(zh) .spectrum-Heading-strong,.spectrum-Heading--light:lang(zh) strong{font-style:var(--mod-heading-cjk-light-strong-font-style,var(--spectrum-heading-cjk-light-strong-font-style));font-weight:var(--mod-heading-cjk-light-strong-font-weight,var(--spectrum-heading-cjk-light-strong-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ja) em,.spectrum-Heading--light:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ko) em,.spectrum-Heading--light:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(zh) em{font-style:var(--mod-heading-cjk-light-emphasized-font-style,var(--spectrum-heading-cjk-light-emphasized-font-style));font-weight:var(--mod-heading-cjk-light-emphasized-font-weight,var(--spectrum-heading-cjk-light-emphasized-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ja) em strong,.spectrum-Heading--light:lang(ja) strong em,.spectrum-Heading--light:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ko) em strong,.spectrum-Heading--light:lang(ko) strong em,.spectrum-Heading--light:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(zh) em strong,.spectrum-Heading--light:lang(zh) strong em{font-style:var(--mod-heading-cjk-light-strong-emphasized-font-style,var(--spectrum-heading-cjk-light-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-light-strong-emphasized-font-weight,var(--spectrum-heading-cjk-light-strong-emphasized-font-weight))}.spectrum-Heading--serif{font-family:var(--mod-heading-serif-font-family,var(--spectrum-heading-serif-font-family));font-style:var(--mod-heading-serif-font-style,var(--spectrum-heading-serif-font-style));font-weight:var(--mod-heading-serif-font-weight,var(--spectrum-heading-serif-font-weight))}.spectrum-Heading--serif .spectrum-Heading-emphasized,.spectrum-Heading--serif em{font-style:var(--mod-heading-serif-emphasized-font-style,var(--spectrum-heading-serif-emphasized-font-style));font-weight:var(--mod-heading-serif-emphasized-font-weight,var(--spectrum-heading-serif-emphasized-font-weight))}.spectrum-Heading--serif .spectrum-Heading-strong,.spectrum-Heading--serif strong{font-style:var(--mod-heading-serif-strong-font-style,var(--spectrum-heading-serif-strong-font-style));font-weight:var(--mod-heading-serif-strong-font-weight,var(--spectrum-heading-serif-strong-font-weight))}.spectrum-Heading--serif .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--serif em strong,.spectrum-Heading--serif strong em{font-style:var(--mod-heading-serif-strong-emphasized-font-style,var(--spectrum-heading-serif-strong-emphasized-font-style));font-weight:var(--mod-heading-serif-strong-emphasized-font-weight,var(--spectrum-heading-serif-strong-emphasized-font-weight))}.spectrum-Heading--serif.spectrum-Heading--heavy{font-style:var(--mod-heading-serif-heavy-font-style,var(--spectrum-heading-serif-heavy-font-style));font-weight:var(--mod-heading-serif-heavy-font-weight,var(--spectrum-heading-serif-heavy-font-weight))}.spectrum-Heading--serif.spectrum-Heading--heavy .spectrum-Heading-strong,.spectrum-Heading--serif.spectrum-Heading--heavy strong{font-style:var(--mod-heading-serif-heavy-strong-font-style,var(--spectrum-heading-serif-heavy-strong-font-style));font-weight:var(--mod-heading-serif-heavy-strong-font-weight,var(--spectrum-heading-serif-heavy-strong-font-weight))}.spectrum-Heading--serif.spectrum-Heading--heavy .spectrum-Heading-emphasized,.spectrum-Heading--serif.spectrum-Heading--heavy em{font-style:var(--mod-heading-serif-heavy-emphasized-font-style,var(--spectrum-heading-serif-heavy-emphasized-font-style));font-weight:var(--mod-heading-serif-heavy-emphasized-font-weight,var(--spectrum-heading-serif-heavy-emphasized-font-weight))}.spectrum-Heading--serif.spectrum-Heading--heavy .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--serif.spectrum-Heading--heavy em strong,.spectrum-Heading--serif.spectrum-Heading--heavy strong em{font-style:var(--mod-heading-serif-heavy-strong-emphasized-font-style,var(--spectrum-heading-serif-heavy-strong-emphasized-font-style));font-weight:var(--mod-heading-serif-heavy-strong-emphasized-font-weight,var(--spectrum-heading-serif-heavy-strong-emphasized-font-weight))}.spectrum-Heading--serif.spectrum-Heading--light{font-style:var(--mod-heading-serif-light-font-style,var(--spectrum-heading-serif-light-font-style));font-weight:var(--mod-heading-serif-light-font-weight,var(--spectrum-heading-serif-light-font-weight))}.spectrum-Heading--serif.spectrum-Heading--light .spectrum-Heading-emphasized,.spectrum-Heading--serif.spectrum-Heading--light em{font-style:var(--mod-heading-serif-light-emphasized-font-style,var(--spectrum-heading-serif-light-emphasized-font-style));font-weight:var(--mod-heading-serif-light-emphasized-font-weight,var(--spectrum-heading-serif-light-emphasized-font-weight))}.spectrum-Heading--serif.spectrum-Heading--light .spectrum-Heading-strong,.spectrum-Heading--serif.spectrum-Heading--light strong{font-style:var(--mod-heading-serif-light-strong-font-style,var(--spectrum-heading-serif-light-strong-font-style));font-weight:var(--mod-heading-serif-light-strong-font-weight,var(--spectrum-heading-serif-light-strong-font-weight))}.spectrum-Heading--serif.spectrum-Heading--light .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--serif.spectrum-Heading--light em strong,.spectrum-Heading--serif.spectrum-Heading--light strong em{font-style:var(--mod-heading-serif-light-strong-emphasized-font-style,var(--spectrum-heading-serif-light-strong-emphasized-font-style));font-weight:var(--mod-heading-serif-light-strong-emphasized-font-weight,var(--spectrum-heading-serif-light-strong-emphasized-font-weight))}.spectrum-Body,.spectrum-Body--sizeM{--spectrum-body-font-size:var(--spectrum-body-size-m)}.spectrum-Body--sizeXS{--spectrum-body-font-size:var(--spectrum-body-size-xs)}.spectrum-Body--sizeS{--spectrum-body-font-size:var(--spectrum-body-size-s)}.spectrum-Body--sizeL{--spectrum-body-font-size:var(--spectrum-body-size-l)}.spectrum-Body--sizeXL{--spectrum-body-font-size:var(--spectrum-body-size-xl)}.spectrum-Body--sizeXXL{--spectrum-body-font-size:var(--spectrum-body-size-xxl)}.spectrum-Body--sizeXXXL{--spectrum-body-font-size:var(--spectrum-body-size-xxxl)}.spectrum-Body{--spectrum-body-sans-serif-font-family:var(--spectrum-sans-font-family-stack);--spectrum-body-serif-font-family:var(--spectrum-serif-font-family-stack);--spectrum-body-cjk-font-family:var(--spectrum-cjk-font-family-stack);--spectrum-body-cjk-letter-spacing:var(--spectrum-cjk-letter-spacing);--spectrum-body-font-color:var(--spectrum-body-color);font-family:var(--mod-body-sans-serif-font-family,var(--spectrum-body-sans-serif-font-family));font-style:var(--mod-body-sans-serif-font-style,var(--spectrum-body-sans-serif-font-style));font-weight:var(--mod-body-sans-serif-font-weight,var(--spectrum-body-sans-serif-font-weight));font-size:var(--mod-body-font-size,var(--spectrum-body-font-size));color:var(--highcontrast-body-font-color,var(--mod-body-font-color,var(--spectrum-body-font-color)));line-height:var(--mod-body-line-height,var(--spectrum-body-line-height));margin-block-start:var(--mod-body-margin-start,var(--mod-body-margin,0));margin-block-end:var(--mod-body-margin-end,var(--mod-body-margin,var(--spectrum-body-margin-end,0)))}.spectrum-Body .spectrum-Body-strong,.spectrum-Body strong{font-style:var(--mod-body-sans-serif-strong-font-style,var(--spectrum-body-sans-serif-strong-font-style));font-weight:var(--mod-body-sans-serif-strong-font-weight,var(--spectrum-body-sans-serif-strong-font-weight))}.spectrum-Body .spectrum-Body-emphasized,.spectrum-Body em{font-style:var(--mod-body-sans-serif-emphasized-font-style,var(--spectrum-body-sans-serif-emphasized-font-style));font-weight:var(--mod-body-sans-serif-emphasized-font-weight,var(--spectrum-body-sans-serif-emphasized-font-weight))}.spectrum-Body .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body em strong,.spectrum-Body strong em{font-style:var(--mod-body-sans-serif-strong-emphasized-font-style,var(--spectrum-body-sans-serif-strong-emphasized-font-style));font-weight:var(--mod-body-sans-serif-strong-emphasized-font-weight,var(--spectrum-body-sans-serif-strong-emphasized-font-weight))}.spectrum-Body:lang(ja),.spectrum-Body:lang(ko),.spectrum-Body:lang(zh){font-family:var(--mod-body-cjk-font-family,var(--spectrum-body-cjk-font-family));font-style:var(--mod-body-cjk-font-style,var(--spectrum-body-cjk-font-style));font-weight:var(--mod-body-cjk-font-weight,var(--spectrum-body-cjk-font-weight));line-height:var(--mod-body-cjk-line-height,var(--spectrum-body-cjk-line-height));letter-spacing:var(--mod-body-cjk-letter-spacing,var(--spectrum-body-cjk-letter-spacing))}.spectrum-Body:lang(ja) .spectrum-Body-strong,.spectrum-Body:lang(ja) strong,.spectrum-Body:lang(ko) .spectrum-Body-strong,.spectrum-Body:lang(ko) strong,.spectrum-Body:lang(zh) .spectrum-Body-strong,.spectrum-Body:lang(zh) strong{font-style:var(--mod-body-cjk-strong-font-style,var(--spectrum-body-cjk-strong-font-style));font-weight:var(--mod-body-cjk-strong-font-weight,var(--spectrum-body-cjk-strong-font-weight))}.spectrum-Body:lang(ja) .spectrum-Body-emphasized,.spectrum-Body:lang(ja) em,.spectrum-Body:lang(ko) .spectrum-Body-emphasized,.spectrum-Body:lang(ko) em,.spectrum-Body:lang(zh) .spectrum-Body-emphasized,.spectrum-Body:lang(zh) em{font-style:var(--mod-body-cjk-emphasized-font-style,var(--spectrum-body-cjk-emphasized-font-style));font-weight:var(--mod-body-cjk-emphasized-font-weight,var(--spectrum-body-cjk-emphasized-font-weight))}.spectrum-Body:lang(ja) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(ja) em strong,.spectrum-Body:lang(ja) strong em,.spectrum-Body:lang(ko) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(ko) em strong,.spectrum-Body:lang(ko) strong em,.spectrum-Body:lang(zh) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(zh) em strong,.spectrum-Body:lang(zh) strong em{font-style:var(--mod-body-cjk-strong-emphasized-font-style,var(--spectrum-body-cjk-strong-emphasized-font-style));font-weight:var(--mod-body-cjk-strong-emphasized-font-weight,var(--spectrum-body-cjk-strong-emphasized-font-weight))}.spectrum-Body--serif{font-family:var(--mod-body-serif-font-family,var(--spectrum-body-serif-font-family));font-weight:var(--mod-body-serif-font-weight,var(--spectrum-body-serif-font-weight));font-style:var(--mod-body-serif-font-style,var(--spectrum-body-serif-font-style))}.spectrum-Body--serif .spectrum-Body-strong,.spectrum-Body--serif strong{font-style:var(--mod-body-serif-strong-font-style,var(--spectrum-body-serif-strong-font-style));font-weight:var(--mod-body-serif-strong-font-weight,var(--spectrum-body-serif-strong-font-weight))}.spectrum-Body--serif .spectrum-Body-emphasized,.spectrum-Body--serif em{font-style:var(--mod-body-serif-emphasized-font-style,var(--spectrum-body-serif-emphasized-font-style));font-weight:var(--mod-body-serif-emphasized-font-weight,var(--spectrum-body-serif-emphasized-font-weight))}.spectrum-Body--serif .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body--serif em strong,.spectrum-Body--serif strong em{font-style:var(--mod-body-serif-strong-emphasized-font-style,var(--spectrum-body-serif-strong-emphasized-font-style));font-weight:var(--mod-body-serif-strong-emphasized-font-weight,var(--spectrum-body-serif-strong-emphasized-font-weight))}.spectrum-Detail,.spectrum-Detail--sizeM{--spectrum-detail-font-size:var(--spectrum-detail-size-m)}.spectrum-Detail--sizeS{--spectrum-detail-font-size:var(--spectrum-detail-size-s)}.spectrum-Detail--sizeL{--spectrum-detail-font-size:var(--spectrum-detail-size-l)}.spectrum-Detail--sizeXL{--spectrum-detail-font-size:var(--spectrum-detail-size-xl)}.spectrum-Detail{--spectrum-detail-sans-serif-font-family:var(--spectrum-sans-font-family-stack);--spectrum-detail-serif-font-family:var(--spectrum-serif-font-family-stack);--spectrum-detail-cjk-font-family:var(--spectrum-cjk-font-family-stack);--spectrum-detail-font-color:var(--spectrum-detail-color);font-family:var(--mod-detail-sans-serif-font-family,var(--spectrum-detail-sans-serif-font-family));font-style:var(--mod-detail-sans-serif-font-style,var(--spectrum-detail-sans-serif-font-style));font-weight:var(--mod-detail-sans-serif-font-weight,var(--spectrum-detail-sans-serif-font-weight));font-size:var(--mod-detail-font-size,var(--spectrum-detail-font-size));color:var(--highcontrast-detail-font-color,var(--mod-detail-font-color,var(--spectrum-detail-font-color)));line-height:var(--mod-detail-line-height,var(--spectrum-detail-line-height));letter-spacing:var(--mod-detail-letter-spacing,var(--spectrum-detail-letter-spacing));text-transform:uppercase;margin-block-start:var(--mod-detail-margin-start,var(--spectrum-detail-margin-start,0));margin-block-end:var(--mod-detail-margin-end,var(--spectrum-detail-margin-end,0))}.spectrum-Detail .spectrum-Detail-strong,.spectrum-Detail strong{font-style:var(--mod-detail-sans-serif-strong-font-style,var(--spectrum-detail-sans-serif-strong-font-style));font-weight:var(--mod-detail-sans-serif-strong-font-weight,var(--spectrum-detail-sans-serif-strong-font-weight))}.spectrum-Detail .spectrum-Detail-emphasized,.spectrum-Detail em{font-style:var(--mod-detail-sans-serif-emphasized-font-style,var(--spectrum-detail-sans-serif-emphasized-font-style));font-weight:var(--mod-detail-sans-serif-emphasized-font-weight,var(--spectrum-detail-sans-serif-emphasized-font-weight))}.spectrum-Detail .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail em strong,.spectrum-Detail strong em{font-style:var(--mod-detail-sans-serif-strong-emphasized-font-style,var(--spectrum-detail-sans-serif-strong-emphasized-font-style));font-weight:var(--mod-detail-sans-serif-strong-emphasized-font-weight,var(--spectrum-detail-sans-serif-strong-emphasized-font-weight))}.spectrum-Detail:lang(ja),.spectrum-Detail:lang(ko),.spectrum-Detail:lang(zh){font-family:var(--mod-detail-cjk-font-family,var(--spectrum-detail-cjk-font-family));font-style:var(--mod-detail-cjk-font-style,var(--spectrum-detail-cjk-font-style));font-weight:var(--mod-detail-cjk-font-weight,var(--spectrum-detail-cjk-font-weight));line-height:var(--mod-detail-cjk-line-height,var(--spectrum-detail-cjk-line-height))}.spectrum-Detail:lang(ja) .spectrum-Detail-strong,.spectrum-Detail:lang(ja) strong,.spectrum-Detail:lang(ko) .spectrum-Detail-strong,.spectrum-Detail:lang(ko) strong,.spectrum-Detail:lang(zh) .spectrum-Detail-strong,.spectrum-Detail:lang(zh) strong{font-style:var(--mod-detail-cjk-strong-font-style,var(--spectrum-detail-cjk-strong-font-style));font-weight:var(--mod-detail-cjk-strong-font-weight,var(--spectrum-detail-cjk-strong-font-weight))}.spectrum-Detail:lang(ja) .spectrum-Detail-emphasized,.spectrum-Detail:lang(ja) em,.spectrum-Detail:lang(ko) .spectrum-Detail-emphasized,.spectrum-Detail:lang(ko) em,.spectrum-Detail:lang(zh) .spectrum-Detail-emphasized,.spectrum-Detail:lang(zh) em{font-style:var(--mod-detail-cjk-emphasized-font-style,var(--spectrum-detail-cjk-emphasized-font-style));font-weight:var(--mod-detail-cjk-emphasized-font-weight,var(--spectrum-detail-cjk-emphasized-font-weight))}.spectrum-Detail:lang(ja) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail:lang(ja) em strong,.spectrum-Detail:lang(ja) strong em,.spectrum-Detail:lang(ko) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail:lang(ko) em strong,.spectrum-Detail:lang(ko) strong em,.spectrum-Detail:lang(zh) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail:lang(zh) em strong,.spectrum-Detail:lang(zh) strong em{font-style:var(--mod-detail-cjk-strong-emphasized-font-style,var(--spectrum-detail-cjk-strong-emphasized-font-style));font-weight:var(--mod-detail-cjk-strong-emphasized-font-weight,var(--spectrum-detail-cjk-strong-emphasized-font-weight))}.spectrum-Detail--serif{font-family:var(--mod-detail-serif-font-family,var(--spectrum-detail-serif-font-family));font-style:var(--mod-detail-serif-font-style,var(--spectrum-detail-serif-font-style));font-weight:var(--mod-detail-serif-font-weight,var(--spectrum-detail-serif-font-weight))}.spectrum-Detail--serif .spectrum-Detail-strong,.spectrum-Detail--serif strong{font-style:var(--mod-detail-serif-strong-font-style,var(--spectrum-detail-serif-strong-font-style));font-weight:var(--mod-detail-serif-strong-font-weight,var(--spectrum-detail-serif-strong-font-weight))}.spectrum-Detail--serif .spectrum-Detail-emphasized,.spectrum-Detail--serif em{font-style:var(--mod-detail-serif-emphasized-font-style,var(--spectrum-detail-serif-emphasized-font-style));font-weight:var(--mod-detail-serif-emphasized-font-weight,var(--spectrum-detail-serif-emphasized-font-weight))}.spectrum-Detail--serif .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail--serif em strong,.spectrum-Detail--serif strong em{font-style:var(--mod-detail-serif-strong-emphasized-font-style,var(--spectrum-detail-serif-strong-emphasized-font-style));font-weight:var(--mod-detail-serif-strong-emphasized-font-weight,var(--spectrum-detail-serif-strong-emphasized-font-weight))}.spectrum-Detail--light{font-style:var(--mod-detail-sans-serif-light-font-style,var(--spectrum-detail-sans-serif-light-font-style));font-weight:var(--spectrum-detail-sans-serif-light-font-weight,var(--spectrum-detail-sans-serif-light-font-weight))}.spectrum-Detail--light .spectrum-Detail-strong,.spectrum-Detail--light strong{font-style:var(--mod-detail-sans-serif-light-strong-font-style,var(--spectrum-detail-sans-serif-light-strong-font-style));font-weight:var(--mod-detail-sans-serif-light-strong-font-weight,var(--spectrum-detail-sans-serif-light-strong-font-weight))}.spectrum-Detail--light .spectrum-Detail-emphasized,.spectrum-Detail--light em{font-style:var(--mod-detail-sans-serif-light-emphasized-font-style,var(--spectrum-detail-sans-serif-light-emphasized-font-style));font-weight:var(--mod-detail-sans-serif-light-emphasized-font-weight,var(--spectrum-detail-sans-serif-light-emphasized-font-weight))}.spectrum-Detail--light .spectrum-Detail-strong.spectrum-Body-emphasized,.spectrum-Detail--light em strong,.spectrum-Detail--light strong em{font-style:var(--mod-detail-sans-serif-light-strong-emphasized-font-style,var(--spectrum-detail-sans-serif-light-strong-emphasized-font-style));font-weight:var(--mod-detail-sans-serif-light-strong-emphasized-font-weight,var(--spectrum-detail-sans-serif-light-strong-emphasized-font-weight))}.spectrum-Detail--light:lang(ja),.spectrum-Detail--light:lang(ko),.spectrum-Detail--light:lang(zh){font-style:var(--mod-detail-cjk-light-font-style,var(--spectrum-detail-cjk-light-font-style));font-weight:var(--mod-detail-cjk-light-font-weight,var(--spectrum-detail-cjk-light-font-weight))}.spectrum-Detail--light:lang(ja) .spectrum-Detail-strong,.spectrum-Detail--light:lang(ja) strong,.spectrum-Detail--light:lang(ko) .spectrum-Detail-strong,.spectrum-Detail--light:lang(ko) strong,.spectrum-Detail--light:lang(zh) .spectrum-Detail-strong,.spectrum-Detail--light:lang(zh) strong{font-style:var(--mod-detail-cjk-light-strong-font-style,var(--spectrum-detail-cjk-light-strong-font-style));font-weight:var(--mod-detail-cjk-light-strong-font-weight,var(--spectrum-detail-cjk-light-strong-font-weight))}.spectrum-Detail--light:lang(ja) .spectrum-Detail-emphasized,.spectrum-Detail--light:lang(ja) em,.spectrum-Detail--light:lang(ko) .spectrum-Detail-emphasized,.spectrum-Detail--light:lang(ko) em,.spectrum-Detail--light:lang(zh) .spectrum-Detail-emphasized,.spectrum-Detail--light:lang(zh) em{font-style:var(--mod-detail-cjk-light-emphasized-font-style,var(--spectrum-detail-cjk-light-emphasized-font-style));font-weight:var(--mod-detail-cjk-light-emphasized-font-weight,var(--spectrum-detail-cjk-light-emphasized-font-weight))}.spectrum-Detail--light:lang(ja) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail--light:lang(ko) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail--light:lang(zh) .spectrum-Detail-strong.spectrum-Detail-emphasized{font-style:var(--mod-detail-cjk-light-strong-emphasized-font-style,var(--spectrum-detail-cjk-light-strong-emphasized-font-style));font-weight:var(--mod-detail-cjk-light-strong-emphasized-font-weight,var(--spectrum-detail-cjk-light-strong-emphasized-font-weight))}.spectrum-Detail--serif.spectrum-Detail--light{font-style:var(--mod-detail-serif-light-font-style,var(--spectrum-detail-serif-light-font-style));font-weight:var(--mod-detail-serif-light-font-weight,var(--spectrum-detail-serif-light-font-weight))}.spectrum-Detail--serif.spectrum-Detail--light .spectrum-Detail-strong,.spectrum-Detail--serif.spectrum-Detail--light strong{font-style:var(--mod-detail-serif-light-strong-font-style,var(--spectrum-detail-serif-light-strong-font-style));font-weight:var(--mod-detail-serif-light-strong-font-weight,var(--spectrum-detail-serif-light-strong-font-weight))}.spectrum-Detail--serif.spectrum-Detail--light .spectrum-Detail-emphasized,.spectrum-Detail--serif.spectrum-Detail--light em{font-style:var(--mod-detail-serif-light-emphasized-font-style,var(--spectrum-detail-serif-light-emphasized-font-style));font-weight:var(--mod-detail-serif-light-emphasized-font-weight,var(--spectrum-detail-serif-light-emphasized-font-weight))}.spectrum-Detail--serif.spectrum-Detail--light .spectrum-Detail-strong.spectrum-Body-emphasized,.spectrum-Detail--serif.spectrum-Detail--light em strong,.spectrum-Detail--serif.spectrum-Detail--light strong em{font-style:var(--mod-detail-serif-light-strong-emphasized-font-style,var(--spectrum-detail-serif-light-strong-emphasized-font-style));font-weight:var(--mod-detail-serif-light-strong-emphasized-font-weight,var(--spectrum-detail-serif-light-strong-emphasized-font-weight))}.spectrum-Code,.spectrum-Code--sizeM{--spectrum-code-font-size:var(--spectrum-code-size-m)}.spectrum-Code--sizeXS{--spectrum-code-font-size:var(--spectrum-code-size-xs)}.spectrum-Code--sizeS{--spectrum-code-font-size:var(--spectrum-code-size-s)}.spectrum-Code--sizeL{--spectrum-code-font-size:var(--spectrum-code-size-l)}.spectrum-Code--sizeXL{--spectrum-code-font-size:var(--spectrum-code-size-xl)}.spectrum-Code{--spectrum-code-font-family:var(--spectrum-code-font-family-stack);--spectrum-code-cjk-letter-spacing:var(--spectrum-cjk-letter-spacing);--spectrum-code-font-color:var(--spectrum-code-color);font-family:var(--mod-code-font-family,var(--spectrum-code-font-family));font-style:var(--mod-code-font-style,var(--spectrum-code-font-style));font-weight:var(--mod-code-font-weight,var(--spectrum-code-font-weight));font-size:var(--mod-code-font-size,var(--spectrum-code-font-size));line-height:var(--mod-code-line-height,var(--spectrum-code-line-height));color:var(--highcontrast-code-font-color,var(--mod-code-font-color,var(--spectrum-code-font-color)));margin-block-start:var(--mod-code-margin-start,0);margin-block-end:var(--mod-code-margin-end,0)}.spectrum-Code .spectrum-Code-strong,.spectrum-Code strong{font-style:var(--mod-code-strong-font-style,var(--spectrum-code-strong-font-style));font-weight:var(--mod-code-strong-font-weight,var(--spectrum-code-strong-font-weight))}.spectrum-Code .spectrum-Code-emphasized,.spectrum-Code em{font-style:var(--mod-code-emphasized-font-style,var(--spectrum-code-emphasized-font-style));font-weight:var(--mod-code-emphasized-font-weight,var(--spectrum-code-emphasized-font-weight))}.spectrum-Code .spectrum-Code-strong.spectrum-Code-emphasized,.spectrum-Code em strong,.spectrum-Code strong em{font-style:var(--mod-code-strong-emphasized-font-style,var(--spectrum-code-strong-emphasized-font-style));font-weight:var(--mod-code-strong-emphasized-font-weight,var(--spectrum-code-strong-emphasized-font-weight))}.spectrum-Code:lang(ja),.spectrum-Code:lang(ko),.spectrum-Code:lang(zh){font-family:var(--mod-code-cjk-font-family,var(--spectrum-code-cjk-font-family));font-style:var(--mod-code-cjk-font-style,var(--spectrum-code-cjk-font-style));font-weight:var(--mod-code-cjk-font-weight,var(--spectrum-code-cjk-font-weight));line-height:var(--mod-code-cjk-line-height,var(--spectrum-code-cjk-line-height));letter-spacing:var(--mod-code-cjk-letter-spacing,var(--spectrum-code-cjk-letter-spacing))}.spectrum-Code:lang(ja) .spectrum-Code-strong,.spectrum-Code:lang(ja) strong,.spectrum-Code:lang(ko) .spectrum-Code-strong,.spectrum-Code:lang(ko) strong,.spectrum-Code:lang(zh) .spectrum-Code-strong,.spectrum-Code:lang(zh) strong{font-style:var(--mod-code-cjk-strong-font-style,var(--spectrum-code-cjk-strong-font-style));font-weight:var(--mod-code-cjk-strong-font-weight,var(--spectrum-code-cjk-strong-font-weight))}.spectrum-Code:lang(ja) .spectrum-Code-emphasized,.spectrum-Code:lang(ja) em,.spectrum-Code:lang(ko) .spectrum-Code-emphasized,.spectrum-Code:lang(ko) em,.spectrum-Code:lang(zh) .spectrum-Code-emphasized,.spectrum-Code:lang(zh) em{font-style:var(--mod-code-cjk-emphasized-font-style,var(--spectrum-code-cjk-emphasized-font-style));font-weight:var(--mod-code-cjk-emphasized-font-weight,var(--spectrum-code-cjk-emphasized-font-weight))}.spectrum-Code:lang(ja) .spectrum-Code-strong.spectrum-Code-emphasized,.spectrum-Code:lang(ja) em strong,.spectrum-Code:lang(ja) strong em,.spectrum-Code:lang(ko) .spectrum-Code-strong.spectrum-Code-emphasized,.spectrum-Code:lang(ko) em strong,.spectrum-Code:lang(ko) strong em,.spectrum-Code:lang(zh) .spectrum-Code-strong.spectrum-Code-emphasized,.spectrum-Code:lang(zh) em strong,.spectrum-Code:lang(zh) strong em{font-style:var(--mod-code-cjk-strong-emphasized-font-style,var(--spectrum-code-cjk-strong-emphasized-font-style));font-weight:var(--mod-code-cjk-strong-emphasized-font-weight,var(--spectrum-code-cjk-strong-emphasized-font-weight))}:host{font-family:var(--spectrum-font-family);font-size:var(--spectrum-font-size);font-style:var(--spectrum-font-style);display:block;&:lang(ar){font-family:var(--spectrum-font-family-ar)}&:lang(he){font-family:var(--spectrum-font-family-he)}}#scale,#theme{width:100%;height:100%}
`;
var theme_css_default = t3;

// node_modules/@spectrum-web-components/theme/src/spectrum-two/core.js
Theme.registerThemeFragment("spectrum-two", "system", theme_css_default);

// node_modules/@spectrum-web-components/theme/spectrum-two/scale-medium.js
Theme.registerThemeFragment("medium-spectrum-two", "scale", scale_medium_css_default);

// node_modules/@spectrum-web-components/theme/src/spectrum-two/theme-light.css.js
init_src();
var e7 = i`
    :root,:host{--spectrum-global-color-status:Verified;--spectrum-global-color-version:5.1;--spectrum-global-color-opacity-100:1;--spectrum-global-color-opacity-90:.9;--spectrum-global-color-opacity-80:.8;--spectrum-global-color-opacity-70:.7;--spectrum-global-color-opacity-60:.6;--spectrum-global-color-opacity-55:.55;--spectrum-global-color-opacity-50:.5;--spectrum-global-color-opacity-42:.42;--spectrum-global-color-opacity-40:.4;--spectrum-global-color-opacity-30:.3;--spectrum-global-color-opacity-25:.25;--spectrum-global-color-opacity-20:.2;--spectrum-global-color-opacity-15:.15;--spectrum-global-color-opacity-10:.1;--spectrum-global-color-opacity-8:.08;--spectrum-global-color-opacity-7:.07;--spectrum-global-color-opacity-6:.06;--spectrum-global-color-opacity-5:.05;--spectrum-global-color-opacity-4:.04;--spectrum-global-color-opacity-0:0;--spectrum-global-color-celery-400-rgb:39,187,54;--spectrum-global-color-celery-400:rgb(var(--spectrum-global-color-celery-400-rgb));--spectrum-global-color-celery-500-rgb:7,167,33;--spectrum-global-color-celery-500:rgb(var(--spectrum-global-color-celery-500-rgb));--spectrum-global-color-celery-600-rgb:0,145,18;--spectrum-global-color-celery-600:rgb(var(--spectrum-global-color-celery-600-rgb));--spectrum-global-color-celery-700-rgb:0,124,15;--spectrum-global-color-celery-700:rgb(var(--spectrum-global-color-celery-700-rgb));--spectrum-global-color-chartreuse-400-rgb:152,197,10;--spectrum-global-color-chartreuse-400:rgb(var(--spectrum-global-color-chartreuse-400-rgb));--spectrum-global-color-chartreuse-500-rgb:135,177,3;--spectrum-global-color-chartreuse-500:rgb(var(--spectrum-global-color-chartreuse-500-rgb));--spectrum-global-color-chartreuse-600-rgb:118,156,0;--spectrum-global-color-chartreuse-600:rgb(var(--spectrum-global-color-chartreuse-600-rgb));--spectrum-global-color-chartreuse-700-rgb:103,136,0;--spectrum-global-color-chartreuse-700:rgb(var(--spectrum-global-color-chartreuse-700-rgb));--spectrum-global-color-yellow-400-rgb:232,198,0;--spectrum-global-color-yellow-400:rgb(var(--spectrum-global-color-yellow-400-rgb));--spectrum-global-color-yellow-500-rgb:215,179,0;--spectrum-global-color-yellow-500:rgb(var(--spectrum-global-color-yellow-500-rgb));--spectrum-global-color-yellow-600-rgb:196,159,0;--spectrum-global-color-yellow-600:rgb(var(--spectrum-global-color-yellow-600-rgb));--spectrum-global-color-yellow-700-rgb:176,140,0;--spectrum-global-color-yellow-700:rgb(var(--spectrum-global-color-yellow-700-rgb));--spectrum-global-color-magenta-400-rgb:222,61,130;--spectrum-global-color-magenta-400:rgb(var(--spectrum-global-color-magenta-400-rgb));--spectrum-global-color-magenta-500-rgb:200,34,105;--spectrum-global-color-magenta-500:rgb(var(--spectrum-global-color-magenta-500-rgb));--spectrum-global-color-magenta-600-rgb:173,9,85;--spectrum-global-color-magenta-600:rgb(var(--spectrum-global-color-magenta-600-rgb));--spectrum-global-color-magenta-700-rgb:142,0,69;--spectrum-global-color-magenta-700:rgb(var(--spectrum-global-color-magenta-700-rgb));--spectrum-global-color-fuchsia-400-rgb:205,58,206;--spectrum-global-color-fuchsia-400:rgb(var(--spectrum-global-color-fuchsia-400-rgb));--spectrum-global-color-fuchsia-500-rgb:182,34,183;--spectrum-global-color-fuchsia-500:rgb(var(--spectrum-global-color-fuchsia-500-rgb));--spectrum-global-color-fuchsia-600-rgb:157,3,158;--spectrum-global-color-fuchsia-600:rgb(var(--spectrum-global-color-fuchsia-600-rgb));--spectrum-global-color-fuchsia-700-rgb:128,0,129;--spectrum-global-color-fuchsia-700:rgb(var(--spectrum-global-color-fuchsia-700-rgb));--spectrum-global-color-purple-400-rgb:157,87,244;--spectrum-global-color-purple-400:rgb(var(--spectrum-global-color-purple-400-rgb));--spectrum-global-color-purple-500-rgb:137,61,231;--spectrum-global-color-purple-500:rgb(var(--spectrum-global-color-purple-500-rgb));--spectrum-global-color-purple-600-rgb:115,38,211;--spectrum-global-color-purple-600:rgb(var(--spectrum-global-color-purple-600-rgb));--spectrum-global-color-purple-700-rgb:93,19,183;--spectrum-global-color-purple-700:rgb(var(--spectrum-global-color-purple-700-rgb));--spectrum-global-color-indigo-400-rgb:104,109,244;--spectrum-global-color-indigo-400:rgb(var(--spectrum-global-color-indigo-400-rgb));--spectrum-global-color-indigo-500-rgb:82,88,228;--spectrum-global-color-indigo-500:rgb(var(--spectrum-global-color-indigo-500-rgb));--spectrum-global-color-indigo-600-rgb:64,70,202;--spectrum-global-color-indigo-600:rgb(var(--spectrum-global-color-indigo-600-rgb));--spectrum-global-color-indigo-700-rgb:50,54,168;--spectrum-global-color-indigo-700:rgb(var(--spectrum-global-color-indigo-700-rgb));--spectrum-global-color-seafoam-400-rgb:0,161,154;--spectrum-global-color-seafoam-400:rgb(var(--spectrum-global-color-seafoam-400-rgb));--spectrum-global-color-seafoam-500-rgb:0,140,135;--spectrum-global-color-seafoam-500:rgb(var(--spectrum-global-color-seafoam-500-rgb));--spectrum-global-color-seafoam-600-rgb:0,119,114;--spectrum-global-color-seafoam-600:rgb(var(--spectrum-global-color-seafoam-600-rgb));--spectrum-global-color-seafoam-700-rgb:0,99,95;--spectrum-global-color-seafoam-700:rgb(var(--spectrum-global-color-seafoam-700-rgb));--spectrum-global-color-red-400-rgb:234,56,41;--spectrum-global-color-red-400:rgb(var(--spectrum-global-color-red-400-rgb));--spectrum-global-color-red-500-rgb:211,21,16;--spectrum-global-color-red-500:rgb(var(--spectrum-global-color-red-500-rgb));--spectrum-global-color-red-600-rgb:180,0,0;--spectrum-global-color-red-600:rgb(var(--spectrum-global-color-red-600-rgb));--spectrum-global-color-red-700-rgb:147,0,0;--spectrum-global-color-red-700:rgb(var(--spectrum-global-color-red-700-rgb));--spectrum-global-color-orange-400-rgb:246,133,17;--spectrum-global-color-orange-400:rgb(var(--spectrum-global-color-orange-400-rgb));--spectrum-global-color-orange-500-rgb:228,111,0;--spectrum-global-color-orange-500:rgb(var(--spectrum-global-color-orange-500-rgb));--spectrum-global-color-orange-600-rgb:203,93,0;--spectrum-global-color-orange-600:rgb(var(--spectrum-global-color-orange-600-rgb));--spectrum-global-color-orange-700-rgb:177,76,0;--spectrum-global-color-orange-700:rgb(var(--spectrum-global-color-orange-700-rgb));--spectrum-global-color-green-400-rgb:0,143,93;--spectrum-global-color-green-400:rgb(var(--spectrum-global-color-green-400-rgb));--spectrum-global-color-green-500-rgb:0,122,77;--spectrum-global-color-green-500:rgb(var(--spectrum-global-color-green-500-rgb));--spectrum-global-color-green-600-rgb:0,101,62;--spectrum-global-color-green-600:rgb(var(--spectrum-global-color-green-600-rgb));--spectrum-global-color-green-700-rgb:0,81,50;--spectrum-global-color-green-700:rgb(var(--spectrum-global-color-green-700-rgb));--spectrum-global-color-blue-400-rgb:20,122,243;--spectrum-global-color-blue-400:rgb(var(--spectrum-global-color-blue-400-rgb));--spectrum-global-color-blue-500-rgb:2,101,220;--spectrum-global-color-blue-500:rgb(var(--spectrum-global-color-blue-500-rgb));--spectrum-global-color-blue-600-rgb:0,84,182;--spectrum-global-color-blue-600:rgb(var(--spectrum-global-color-blue-600-rgb));--spectrum-global-color-blue-700-rgb:0,68,145;--spectrum-global-color-blue-700:rgb(var(--spectrum-global-color-blue-700-rgb));--spectrum-global-color-gray-50-rgb:255,255,255;--spectrum-global-color-gray-50:rgb(var(--spectrum-global-color-gray-50-rgb));--spectrum-global-color-gray-75-rgb:253,253,253;--spectrum-global-color-gray-75:rgb(var(--spectrum-global-color-gray-75-rgb));--spectrum-global-color-gray-100-rgb:248,248,248;--spectrum-global-color-gray-100:rgb(var(--spectrum-global-color-gray-100-rgb));--spectrum-global-color-gray-200-rgb:230,230,230;--spectrum-global-color-gray-200:rgb(var(--spectrum-global-color-gray-200-rgb));--spectrum-global-color-gray-300-rgb:213,213,213;--spectrum-global-color-gray-300:rgb(var(--spectrum-global-color-gray-300-rgb));--spectrum-global-color-gray-400-rgb:177,177,177;--spectrum-global-color-gray-400:rgb(var(--spectrum-global-color-gray-400-rgb));--spectrum-global-color-gray-500-rgb:144,144,144;--spectrum-global-color-gray-500:rgb(var(--spectrum-global-color-gray-500-rgb));--spectrum-global-color-gray-600-rgb:109,109,109;--spectrum-global-color-gray-600:rgb(var(--spectrum-global-color-gray-600-rgb));--spectrum-global-color-gray-700-rgb:70,70,70;--spectrum-global-color-gray-700:rgb(var(--spectrum-global-color-gray-700-rgb));--spectrum-global-color-gray-800-rgb:34,34,34;--spectrum-global-color-gray-800:rgb(var(--spectrum-global-color-gray-800-rgb));--spectrum-global-color-gray-900-rgb:0,0,0;--spectrum-global-color-gray-900:rgb(var(--spectrum-global-color-gray-900-rgb));--spectrum-alias-background-color-primary:var(--spectrum-global-color-gray-50);--spectrum-alias-background-color-secondary:var(--spectrum-global-color-gray-100);--spectrum-alias-background-color-tertiary:var(--spectrum-global-color-gray-300);--spectrum-alias-background-color-modal-overlay:#0006;--spectrum-alias-dropshadow-color:#00000026;--spectrum-alias-background-color-hover-overlay:#0000000a;--spectrum-alias-highlight-hover:#0000000f;--spectrum-alias-highlight-down:#0000001a;--spectrum-alias-highlight-selected:#0265dc1a;--spectrum-alias-highlight-selected-hover:#0265dc33;--spectrum-alias-text-highlight-color:#0265dc33;--spectrum-alias-background-color-quickactions:#f8f8f8e6;--spectrum-alias-border-color-selected:var(--spectrum-global-color-blue-500);--spectrum-alias-border-color-translucent:#0000001a;--spectrum-alias-radial-reaction-color-default:#2229;--spectrum-alias-pasteboard-background-color:var(--spectrum-global-color-gray-300);--spectrum-alias-appframe-border-color:var(--spectrum-global-color-gray-300);--spectrum-alias-appframe-separator-color:var(--spectrum-global-color-gray-300)}:host,:root{color-scheme:light;--spectrum-overlay-opacity:.4;--spectrum-background-layer-2-color:var(--spectrum-gray-25);--spectrum-neutral-subdued-background-color-default:var(--spectrum-gray-700);--spectrum-neutral-subdued-background-color-hover:var(--spectrum-gray-800);--spectrum-neutral-subdued-background-color-down:var(--spectrum-gray-800);--spectrum-neutral-subdued-background-color-key-focus:var(--spectrum-gray-800);--spectrum-accent-background-color-default:var(--spectrum-accent-color-900);--spectrum-accent-background-color-hover:var(--spectrum-accent-color-1000);--spectrum-accent-background-color-down:var(--spectrum-accent-color-1000);--spectrum-accent-background-color-key-focus:var(--spectrum-accent-color-1000);--spectrum-informative-background-color-default:var(--spectrum-informative-color-900);--spectrum-informative-background-color-hover:var(--spectrum-informative-color-1000);--spectrum-informative-background-color-down:var(--spectrum-informative-color-1000);--spectrum-informative-background-color-key-focus:var(--spectrum-informative-color-1000);--spectrum-negative-background-color-default:var(--spectrum-negative-color-900);--spectrum-negative-background-color-hover:var(--spectrum-negative-color-1000);--spectrum-negative-background-color-down:var(--spectrum-negative-color-1000);--spectrum-negative-background-color-key-focus:var(--spectrum-negative-color-1000);--spectrum-positive-background-color-default:var(--spectrum-positive-color-900);--spectrum-positive-background-color-hover:var(--spectrum-positive-color-1000);--spectrum-positive-background-color-down:var(--spectrum-positive-color-1000);--spectrum-positive-background-color-key-focus:var(--spectrum-positive-color-1000);--spectrum-notice-background-color-default:var(--spectrum-notice-color-600);--spectrum-gray-background-color-default:var(--spectrum-gray-700);--spectrum-red-background-color-default:var(--spectrum-red-900);--spectrum-orange-background-color-default:var(--spectrum-orange-600);--spectrum-yellow-background-color-default:var(--spectrum-yellow-400);--spectrum-chartreuse-background-color-default:var(--spectrum-chartreuse-500);--spectrum-celery-background-color-default:var(--spectrum-celery-600);--spectrum-green-background-color-default:var(--spectrum-green-900);--spectrum-seafoam-background-color-default:var(--spectrum-seafoam-900);--spectrum-cyan-background-color-default:var(--spectrum-cyan-900);--spectrum-blue-background-color-default:var(--spectrum-blue-900);--spectrum-indigo-background-color-default:var(--spectrum-indigo-900);--spectrum-purple-background-color-default:var(--spectrum-purple-900);--spectrum-fuchsia-background-color-default:var(--spectrum-fuchsia-900);--spectrum-magenta-background-color-default:var(--spectrum-magenta-900);--spectrum-neutral-visual-color:var(--spectrum-gray-500);--spectrum-accent-visual-color:var(--spectrum-accent-color-800);--spectrum-informative-visual-color:var(--spectrum-informative-color-800);--spectrum-negative-visual-color:var(--spectrum-negative-color-800);--spectrum-notice-visual-color:var(--spectrum-notice-color-800);--spectrum-positive-visual-color:var(--spectrum-positive-color-800);--spectrum-gray-visual-color:var(--spectrum-gray-500);--spectrum-red-visual-color:var(--spectrum-red-800);--spectrum-orange-visual-color:var(--spectrum-orange-700);--spectrum-yellow-visual-color:var(--spectrum-yellow-600);--spectrum-chartreuse-visual-color:var(--spectrum-chartreuse-600);--spectrum-celery-visual-color:var(--spectrum-celery-700);--spectrum-green-visual-color:var(--spectrum-green-700);--spectrum-seafoam-visual-color:var(--spectrum-seafoam-700);--spectrum-cyan-visual-color:var(--spectrum-cyan-600);--spectrum-blue-visual-color:var(--spectrum-blue-800);--spectrum-indigo-visual-color:var(--spectrum-indigo-800);--spectrum-purple-visual-color:var(--spectrum-purple-800);--spectrum-fuchsia-visual-color:var(--spectrum-fuchsia-800);--spectrum-magenta-visual-color:var(--spectrum-magenta-800);--spectrum-background-elevated-color:var(--spectrum-gray-25);--spectrum-background-pasteboard-color:var(--spectrum-gray-100);--spectrum-brown-visual-color:var(--spectrum-brown-800);--spectrum-cinnamon-visual-color:var(--spectrum-cinnamon-800);--spectrum-pink-visual-color:var(--spectrum-pink-800);--spectrum-silver-visual-color:var(--spectrum-silver-800);--spectrum-turquoise-visual-color:var(--spectrum-turquoise-800);--spectrum-brown-background-color-default:var(--spectrum-brown-900);--spectrum-cinnamon-background-color-default:var(--spectrum-cinnamon-900);--spectrum-pink-background-color-default:var(--spectrum-pink-900);--spectrum-silver-background-color-default:var(--spectrum-silver-900);--spectrum-turquoise-background-color-default:var(--spectrum-turquoise-900);--spectrum-drop-shadow-color-100-rgb:0,0,0;--spectrum-drop-shadow-color-100-opacity:.12;--spectrum-drop-shadow-color-100:rgba(var(--spectrum-drop-shadow-color-100-rgb),var(--spectrum-drop-shadow-color-100-opacity));--spectrum-drop-shadow-color-200-rgb:0,0,0;--spectrum-drop-shadow-color-200-opacity:.16;--spectrum-drop-shadow-color-200:rgba(var(--spectrum-drop-shadow-color-200-rgb),var(--spectrum-drop-shadow-color-200-opacity));--spectrum-drop-shadow-color-300-rgb:0,0,0;--spectrum-drop-shadow-color-300-opacity:.2;--spectrum-drop-shadow-color-300:rgba(var(--spectrum-drop-shadow-color-300-rgb),var(--spectrum-drop-shadow-color-300-opacity));--spectrum-neutral-subtle-background-color-default:var(--spectrum-gray-100);--spectrum-gray-subtle-background-color-default:var(--spectrum-gray-100);--spectrum-blue-subtle-background-color-default:var(--spectrum-blue-200);--spectrum-green-subtle-background-color-default:var(--spectrum-green-200);--spectrum-orange-subtle-background-color-default:var(--spectrum-orange-200);--spectrum-red-subtle-background-color-default:var(--spectrum-red-200);--spectrum-brown-subtle-background-color-default:var(--spectrum-brown-200);--spectrum-cinnamon-subtle-background-color-default:var(--spectrum-cinnamon-200);--spectrum-celery-subtle-background-color-default:var(--spectrum-celery-200);--spectrum-chartreuse-subtle-background-color-default:var(--spectrum-chartreuse-200);--spectrum-cyan-subtle-background-color-default:var(--spectrum-cyan-200);--spectrum-fuchsia-subtle-background-color-default:var(--spectrum-fuchsia-200);--spectrum-indigo-subtle-background-color-default:var(--spectrum-indigo-200);--spectrum-magenta-subtle-background-color-default:var(--spectrum-magenta-200);--spectrum-pink-subtle-background-color-default:var(--spectrum-pink-200);--spectrum-purple-subtle-background-color-default:var(--spectrum-purple-200);--spectrum-seafoam-subtle-background-color-default:var(--spectrum-seafoam-200);--spectrum-silver-subtle-background-color-default:var(--spectrum-silver-200);--spectrum-turquoise-subtle-background-color-default:var(--spectrum-turquoise-200);--spectrum-yellow-subtle-background-color-default:var(--spectrum-yellow-200);--spectrum-opacity-checkerboard-square-dark:var(--spectrum-gray-200);--spectrum-white-rgb:255,255,255;--spectrum-white:rgba(var(--spectrum-white-rgb));--spectrum-transparent-white-25-rgb:255,255,255;--spectrum-transparent-white-25-opacity:0;--spectrum-transparent-white-25:rgba(var(--spectrum-transparent-white-25-rgb),var(--spectrum-transparent-white-25-opacity));--spectrum-transparent-white-50-rgb:255,255,255;--spectrum-transparent-white-50-opacity:.04;--spectrum-transparent-white-50:rgba(var(--spectrum-transparent-white-50-rgb),var(--spectrum-transparent-white-50-opacity));--spectrum-transparent-white-75-rgb:255,255,255;--spectrum-transparent-white-75-opacity:.07;--spectrum-transparent-white-75:rgba(var(--spectrum-transparent-white-75-rgb),var(--spectrum-transparent-white-75-opacity));--spectrum-transparent-white-100-rgb:255,255,255;--spectrum-transparent-white-100-opacity:.11;--spectrum-transparent-white-100:rgba(var(--spectrum-transparent-white-100-rgb),var(--spectrum-transparent-white-100-opacity));--spectrum-transparent-white-200-rgb:255,255,255;--spectrum-transparent-white-200-opacity:.14;--spectrum-transparent-white-200:rgba(var(--spectrum-transparent-white-200-rgb),var(--spectrum-transparent-white-200-opacity));--spectrum-transparent-white-300-rgb:255,255,255;--spectrum-transparent-white-300-opacity:.17;--spectrum-transparent-white-300:rgba(var(--spectrum-transparent-white-300-rgb),var(--spectrum-transparent-white-300-opacity));--spectrum-transparent-white-400-rgb:255,255,255;--spectrum-transparent-white-400-opacity:.21;--spectrum-transparent-white-400:rgba(var(--spectrum-transparent-white-400-rgb),var(--spectrum-transparent-white-400-opacity));--spectrum-transparent-white-500-rgb:255,255,255;--spectrum-transparent-white-500-opacity:.39;--spectrum-transparent-white-500:rgba(var(--spectrum-transparent-white-500-rgb),var(--spectrum-transparent-white-500-opacity));--spectrum-transparent-white-600-rgb:255,255,255;--spectrum-transparent-white-600-opacity:.51;--spectrum-transparent-white-600:rgba(var(--spectrum-transparent-white-600-rgb),var(--spectrum-transparent-white-600-opacity));--spectrum-transparent-white-700-rgb:255,255,255;--spectrum-transparent-white-700-opacity:.66;--spectrum-transparent-white-700:rgba(var(--spectrum-transparent-white-700-rgb),var(--spectrum-transparent-white-700-opacity));--spectrum-transparent-white-800-rgb:255,255,255;--spectrum-transparent-white-800-opacity:.85;--spectrum-transparent-white-800:rgba(var(--spectrum-transparent-white-800-rgb),var(--spectrum-transparent-white-800-opacity));--spectrum-transparent-white-900-rgb:255,255,255;--spectrum-transparent-white-900-opacity:.94;--spectrum-transparent-white-900:rgba(var(--spectrum-transparent-white-900-rgb),var(--spectrum-transparent-white-900-opacity));--spectrum-transparent-white-1000-rgb:255,255,255;--spectrum-transparent-white-1000:rgba(var(--spectrum-transparent-white-1000-rgb));--spectrum-transparent-black-25-rgb:0,0,0;--spectrum-transparent-black-25-opacity:0;--spectrum-transparent-black-25:rgba(var(--spectrum-transparent-black-25-rgb),var(--spectrum-transparent-black-25-opacity));--spectrum-transparent-black-50-rgb:0,0,0;--spectrum-transparent-black-50-opacity:.03;--spectrum-transparent-black-50:rgba(var(--spectrum-transparent-black-50-rgb),var(--spectrum-transparent-black-50-opacity));--spectrum-transparent-black-75-rgb:0,0,0;--spectrum-transparent-black-75-opacity:.05;--spectrum-transparent-black-75:rgba(var(--spectrum-transparent-black-75-rgb),var(--spectrum-transparent-black-75-opacity));--spectrum-transparent-black-100-rgb:0,0,0;--spectrum-transparent-black-100-opacity:.09;--spectrum-transparent-black-100:rgba(var(--spectrum-transparent-black-100-rgb),var(--spectrum-transparent-black-100-opacity));--spectrum-transparent-black-200-rgb:0,0,0;--spectrum-transparent-black-200-opacity:.12;--spectrum-transparent-black-200:rgba(var(--spectrum-transparent-black-200-rgb),var(--spectrum-transparent-black-200-opacity));--spectrum-transparent-black-300-rgb:0,0,0;--spectrum-transparent-black-300-opacity:.15;--spectrum-transparent-black-300:rgba(var(--spectrum-transparent-black-300-rgb),var(--spectrum-transparent-black-300-opacity));--spectrum-transparent-black-400-rgb:0,0,0;--spectrum-transparent-black-400-opacity:.22;--spectrum-transparent-black-400:rgba(var(--spectrum-transparent-black-400-rgb),var(--spectrum-transparent-black-400-opacity));--spectrum-transparent-black-500-rgb:0,0,0;--spectrum-transparent-black-500-opacity:.44;--spectrum-transparent-black-500:rgba(var(--spectrum-transparent-black-500-rgb),var(--spectrum-transparent-black-500-opacity));--spectrum-transparent-black-600-rgb:0,0,0;--spectrum-transparent-black-600-opacity:.56;--spectrum-transparent-black-600:rgba(var(--spectrum-transparent-black-600-rgb),var(--spectrum-transparent-black-600-opacity));--spectrum-transparent-black-700-rgb:0,0,0;--spectrum-transparent-black-700-opacity:.69;--spectrum-transparent-black-700:rgba(var(--spectrum-transparent-black-700-rgb),var(--spectrum-transparent-black-700-opacity));--spectrum-transparent-black-800-rgb:0,0,0;--spectrum-transparent-black-800-opacity:.84;--spectrum-transparent-black-800:rgba(var(--spectrum-transparent-black-800-rgb),var(--spectrum-transparent-black-800-opacity));--spectrum-transparent-black-900-rgb:0,0,0;--spectrum-transparent-black-900-opacity:.93;--spectrum-transparent-black-900:rgba(var(--spectrum-transparent-black-900-rgb),var(--spectrum-transparent-black-900-opacity));--spectrum-gray-25-rgb:255,255,255;--spectrum-gray-25:rgba(var(--spectrum-gray-25-rgb));--spectrum-gray-50-rgb:248,248,248;--spectrum-gray-50:rgba(var(--spectrum-gray-50-rgb));--spectrum-gray-75-rgb:243,243,243;--spectrum-gray-75:rgba(var(--spectrum-gray-75-rgb));--spectrum-gray-100-rgb:233,233,233;--spectrum-gray-100:rgba(var(--spectrum-gray-100-rgb));--spectrum-gray-200-rgb:225,225,225;--spectrum-gray-200:rgba(var(--spectrum-gray-200-rgb));--spectrum-gray-300-rgb:218,218,218;--spectrum-gray-300:rgba(var(--spectrum-gray-300-rgb));--spectrum-gray-400-rgb:198,198,198;--spectrum-gray-400:rgba(var(--spectrum-gray-400-rgb));--spectrum-gray-500-rgb:143,143,143;--spectrum-gray-500:rgba(var(--spectrum-gray-500-rgb));--spectrum-gray-600-rgb:113,113,113;--spectrum-gray-600:rgba(var(--spectrum-gray-600-rgb));--spectrum-gray-700-rgb:80,80,80;--spectrum-gray-700:rgba(var(--spectrum-gray-700-rgb));--spectrum-gray-800-rgb:41,41,41;--spectrum-gray-800:rgba(var(--spectrum-gray-800-rgb));--spectrum-gray-900-rgb:19,19,19;--spectrum-gray-900:rgba(var(--spectrum-gray-900-rgb));--spectrum-gray-1000-rgb:0,0,0;--spectrum-gray-1000:rgba(var(--spectrum-gray-1000-rgb));--spectrum-blue-100-rgb:245,249,255;--spectrum-blue-100:rgba(var(--spectrum-blue-100-rgb));--spectrum-blue-200-rgb:229,240,254;--spectrum-blue-200:rgba(var(--spectrum-blue-200-rgb));--spectrum-blue-300-rgb:203,226,254;--spectrum-blue-300:rgba(var(--spectrum-blue-300-rgb));--spectrum-blue-400-rgb:172,207,253;--spectrum-blue-400:rgba(var(--spectrum-blue-400-rgb));--spectrum-blue-500-rgb:142,185,252;--spectrum-blue-500:rgba(var(--spectrum-blue-500-rgb));--spectrum-blue-600-rgb:114,158,253;--spectrum-blue-600:rgba(var(--spectrum-blue-600-rgb));--spectrum-blue-700-rgb:93,137,255;--spectrum-blue-700:rgba(var(--spectrum-blue-700-rgb));--spectrum-blue-800-rgb:75,117,255;--spectrum-blue-800:rgba(var(--spectrum-blue-800-rgb));--spectrum-blue-900-rgb:59,99,251;--spectrum-blue-900:rgba(var(--spectrum-blue-900-rgb));--spectrum-blue-1000-rgb:39,77,234;--spectrum-blue-1000:rgba(var(--spectrum-blue-1000-rgb));--spectrum-blue-1100-rgb:29,62,207;--spectrum-blue-1100:rgba(var(--spectrum-blue-1100-rgb));--spectrum-blue-1200-rgb:21,50,173;--spectrum-blue-1200:rgba(var(--spectrum-blue-1200-rgb));--spectrum-blue-1300-rgb:16,40,140;--spectrum-blue-1300:rgba(var(--spectrum-blue-1300-rgb));--spectrum-blue-1400-rgb:12,31,105;--spectrum-blue-1400:rgba(var(--spectrum-blue-1400-rgb));--spectrum-blue-1500-rgb:14,24,67;--spectrum-blue-1500:rgba(var(--spectrum-blue-1500-rgb));--spectrum-blue-1600-rgb:7,11,30;--spectrum-blue-1600:rgba(var(--spectrum-blue-1600-rgb));--spectrum-red-100-rgb:255,246,245;--spectrum-red-100:rgba(var(--spectrum-red-100-rgb));--spectrum-red-200-rgb:255,235,232;--spectrum-red-200:rgba(var(--spectrum-red-200-rgb));--spectrum-red-300-rgb:255,214,209;--spectrum-red-300:rgba(var(--spectrum-red-300-rgb));--spectrum-red-400-rgb:255,188,180;--spectrum-red-400:rgba(var(--spectrum-red-400-rgb));--spectrum-red-500-rgb:255,157,145;--spectrum-red-500:rgba(var(--spectrum-red-500-rgb));--spectrum-red-600-rgb:255,118,101;--spectrum-red-600:rgba(var(--spectrum-red-600-rgb));--spectrum-red-700-rgb:255,81,61;--spectrum-red-700:rgba(var(--spectrum-red-700-rgb));--spectrum-red-800-rgb:240,56,35;--spectrum-red-800:rgba(var(--spectrum-red-800-rgb));--spectrum-red-900-rgb:215,50,32;--spectrum-red-900:rgba(var(--spectrum-red-900-rgb));--spectrum-red-1000-rgb:183,40,24;--spectrum-red-1000:rgba(var(--spectrum-red-1000-rgb));--spectrum-red-1100-rgb:156,33,19;--spectrum-red-1100:rgba(var(--spectrum-red-1100-rgb));--spectrum-red-1200-rgb:129,27,14;--spectrum-red-1200:rgba(var(--spectrum-red-1200-rgb));--spectrum-red-1300-rgb:104,21,10;--spectrum-red-1300:rgba(var(--spectrum-red-1300-rgb));--spectrum-red-1400-rgb:80,16,6;--spectrum-red-1400:rgba(var(--spectrum-red-1400-rgb));--spectrum-red-1500-rgb:59,11,4;--spectrum-red-1500:rgba(var(--spectrum-red-1500-rgb));--spectrum-red-1600-rgb:29,5,2;--spectrum-red-1600:rgba(var(--spectrum-red-1600-rgb));--spectrum-orange-100-rgb:255,246,231;--spectrum-orange-100:rgba(var(--spectrum-orange-100-rgb));--spectrum-orange-200-rgb:255,236,207;--spectrum-orange-200:rgba(var(--spectrum-orange-200-rgb));--spectrum-orange-300-rgb:255,218,158;--spectrum-orange-300:rgba(var(--spectrum-orange-300-rgb));--spectrum-orange-400-rgb:255,193,94;--spectrum-orange-400:rgba(var(--spectrum-orange-400-rgb));--spectrum-orange-500-rgb:255,162,19;--spectrum-orange-500:rgba(var(--spectrum-orange-500-rgb));--spectrum-orange-600-rgb:252,125,0;--spectrum-orange-600:rgba(var(--spectrum-orange-600-rgb));--spectrum-orange-700-rgb:232,106,0;--spectrum-orange-700:rgba(var(--spectrum-orange-700-rgb));--spectrum-orange-800-rgb:212,91,0;--spectrum-orange-800:rgba(var(--spectrum-orange-800-rgb));--spectrum-orange-900-rgb:194,78,0;--spectrum-orange-900:rgba(var(--spectrum-orange-900-rgb));--spectrum-orange-1000-rgb:167,62,0;--spectrum-orange-1000:rgba(var(--spectrum-orange-1000-rgb));--spectrum-orange-1100-rgb:144,51,0;--spectrum-orange-1100:rgba(var(--spectrum-orange-1100-rgb));--spectrum-orange-1200-rgb:118,41,0;--spectrum-orange-1200:rgba(var(--spectrum-orange-1200-rgb));--spectrum-orange-1300-rgb:95,32,0;--spectrum-orange-1300:rgba(var(--spectrum-orange-1300-rgb));--spectrum-orange-1400-rgb:73,24,0;--spectrum-orange-1400:rgba(var(--spectrum-orange-1400-rgb));--spectrum-orange-1500-rgb:52,18,0;--spectrum-orange-1500:rgba(var(--spectrum-orange-1500-rgb));--spectrum-orange-1600-rgb:25,8,0;--spectrum-orange-1600:rgba(var(--spectrum-orange-1600-rgb));--spectrum-yellow-100-rgb:255,248,204;--spectrum-yellow-100:rgba(var(--spectrum-yellow-100-rgb));--spectrum-yellow-200-rgb:255,241,151;--spectrum-yellow-200:rgba(var(--spectrum-yellow-200-rgb));--spectrum-yellow-300-rgb:255,222,44;--spectrum-yellow-300:rgba(var(--spectrum-yellow-300-rgb));--spectrum-yellow-400-rgb:245,199,0;--spectrum-yellow-400:rgba(var(--spectrum-yellow-400-rgb));--spectrum-yellow-500-rgb:230,175,0;--spectrum-yellow-500:rgba(var(--spectrum-yellow-500-rgb));--spectrum-yellow-600-rgb:210,149,0;--spectrum-yellow-600:rgba(var(--spectrum-yellow-600-rgb));--spectrum-yellow-700-rgb:193,131,0;--spectrum-yellow-700:rgba(var(--spectrum-yellow-700-rgb));--spectrum-yellow-800-rgb:175,116,0;--spectrum-yellow-800:rgba(var(--spectrum-yellow-800-rgb));--spectrum-yellow-900-rgb:158,102,0;--spectrum-yellow-900:rgba(var(--spectrum-yellow-900-rgb));--spectrum-yellow-1000-rgb:134,85,0;--spectrum-yellow-1000:rgba(var(--spectrum-yellow-1000-rgb));--spectrum-yellow-1100-rgb:114,72,0;--spectrum-yellow-1100:rgba(var(--spectrum-yellow-1100-rgb));--spectrum-yellow-1200-rgb:93,59,0;--spectrum-yellow-1200:rgba(var(--spectrum-yellow-1200-rgb));--spectrum-yellow-1300-rgb:75,47,0;--spectrum-yellow-1300:rgba(var(--spectrum-yellow-1300-rgb));--spectrum-yellow-1400-rgb:56,35,0;--spectrum-yellow-1400:rgba(var(--spectrum-yellow-1400-rgb));--spectrum-yellow-1500-rgb:40,25,0;--spectrum-yellow-1500:rgba(var(--spectrum-yellow-1500-rgb));--spectrum-yellow-1600-rgb:18,11,0;--spectrum-yellow-1600:rgba(var(--spectrum-yellow-1600-rgb));--spectrum-chartreuse-100-rgb:246,251,222;--spectrum-chartreuse-100:rgba(var(--spectrum-chartreuse-100-rgb));--spectrum-chartreuse-200-rgb:234,246,173;--spectrum-chartreuse-200:rgba(var(--spectrum-chartreuse-200-rgb));--spectrum-chartreuse-300-rgb:208,236,70;--spectrum-chartreuse-300:rgba(var(--spectrum-chartreuse-300-rgb));--spectrum-chartreuse-400-rgb:182,219,0;--spectrum-chartreuse-400:rgba(var(--spectrum-chartreuse-400-rgb));--spectrum-chartreuse-500-rgb:163,196,0;--spectrum-chartreuse-500:rgba(var(--spectrum-chartreuse-500-rgb));--spectrum-chartreuse-600-rgb:143,172,0;--spectrum-chartreuse-600:rgba(var(--spectrum-chartreuse-600-rgb));--spectrum-chartreuse-700-rgb:128,153,0;--spectrum-chartreuse-700:rgba(var(--spectrum-chartreuse-700-rgb));--spectrum-chartreuse-800-rgb:114,137,0;--spectrum-chartreuse-800:rgba(var(--spectrum-chartreuse-800-rgb));--spectrum-chartreuse-900-rgb:102,122,0;--spectrum-chartreuse-900:rgba(var(--spectrum-chartreuse-900-rgb));--spectrum-chartreuse-1000-rgb:86,103,0;--spectrum-chartreuse-1000:rgba(var(--spectrum-chartreuse-1000-rgb));--spectrum-chartreuse-1100-rgb:73,87,0;--spectrum-chartreuse-1100:rgba(var(--spectrum-chartreuse-1100-rgb));--spectrum-chartreuse-1200-rgb:60,71,0;--spectrum-chartreuse-1200:rgba(var(--spectrum-chartreuse-1200-rgb));--spectrum-chartreuse-1300-rgb:47,57,0;--spectrum-chartreuse-1300:rgba(var(--spectrum-chartreuse-1300-rgb));--spectrum-chartreuse-1400-rgb:35,43,0;--spectrum-chartreuse-1400:rgba(var(--spectrum-chartreuse-1400-rgb));--spectrum-chartreuse-1500-rgb:25,30,0;--spectrum-chartreuse-1500:rgba(var(--spectrum-chartreuse-1500-rgb));--spectrum-chartreuse-1600-rgb:11,14,0;--spectrum-chartreuse-1600:rgba(var(--spectrum-chartreuse-1600-rgb));--spectrum-celery-100-rgb:235,255,220;--spectrum-celery-100:rgba(var(--spectrum-celery-100-rgb));--spectrum-celery-200-rgb:197,255,156;--spectrum-celery-200:rgba(var(--spectrum-celery-200-rgb));--spectrum-celery-300-rgb:157,247,92;--spectrum-celery-300:rgba(var(--spectrum-celery-300-rgb));--spectrum-celery-400-rgb:129,228,58;--spectrum-celery-400:rgba(var(--spectrum-celery-400-rgb));--spectrum-celery-500-rgb:110,206,42;--spectrum-celery-500:rgba(var(--spectrum-celery-500-rgb));--spectrum-celery-600-rgb:93,180,31;--spectrum-celery-600:rgba(var(--spectrum-celery-600-rgb));--spectrum-celery-700-rgb:82,161,25;--spectrum-celery-700:rgba(var(--spectrum-celery-700-rgb));--spectrum-celery-800-rgb:72,144,20;--spectrum-celery-800:rgba(var(--spectrum-celery-800-rgb));--spectrum-celery-900-rgb:64,129,17;--spectrum-celery-900:rgba(var(--spectrum-celery-900-rgb));--spectrum-celery-1000-rgb:52,109,12;--spectrum-celery-1000:rgba(var(--spectrum-celery-1000-rgb));--spectrum-celery-1100-rgb:44,92,9;--spectrum-celery-1100:rgba(var(--spectrum-celery-1100-rgb));--spectrum-celery-1200-rgb:35,75,6;--spectrum-celery-1200:rgba(var(--spectrum-celery-1200-rgb));--spectrum-celery-1300-rgb:27,60,3;--spectrum-celery-1300:rgba(var(--spectrum-celery-1300-rgb));--spectrum-celery-1400-rgb:19,46,0;--spectrum-celery-1400:rgba(var(--spectrum-celery-1400-rgb));--spectrum-celery-1500-rgb:12,33,0;--spectrum-celery-1500:rgba(var(--spectrum-celery-1500-rgb));--spectrum-celery-1600-rgb:4,15,0;--spectrum-celery-1600:rgba(var(--spectrum-celery-1600-rgb));--spectrum-green-100-rgb:237,252,241;--spectrum-green-100:rgba(var(--spectrum-green-100-rgb));--spectrum-green-200-rgb:215,247,225;--spectrum-green-200:rgba(var(--spectrum-green-200-rgb));--spectrum-green-300-rgb:173,238,197;--spectrum-green-300:rgba(var(--spectrum-green-300-rgb));--spectrum-green-400-rgb:107,227,162;--spectrum-green-400:rgba(var(--spectrum-green-400-rgb));--spectrum-green-500-rgb:43,209,125;--spectrum-green-500:rgba(var(--spectrum-green-500-rgb));--spectrum-green-600-rgb:18,184,103;--spectrum-green-600:rgba(var(--spectrum-green-600-rgb));--spectrum-green-700-rgb:11,164,93;--spectrum-green-700:rgba(var(--spectrum-green-700-rgb));--spectrum-green-800-rgb:7,147,85;--spectrum-green-800:rgba(var(--spectrum-green-800-rgb));--spectrum-green-900-rgb:5,131,78;--spectrum-green-900:rgba(var(--spectrum-green-900-rgb));--spectrum-green-1000-rgb:3,110,69;--spectrum-green-1000:rgba(var(--spectrum-green-1000-rgb));--spectrum-green-1100-rgb:2,93,60;--spectrum-green-1100:rgba(var(--spectrum-green-1100-rgb));--spectrum-green-1200-rgb:1,76,52;--spectrum-green-1200:rgba(var(--spectrum-green-1200-rgb));--spectrum-green-1300-rgb:0,61,44;--spectrum-green-1300:rgba(var(--spectrum-green-1300-rgb));--spectrum-green-1400-rgb:0,46,34;--spectrum-green-1400:rgba(var(--spectrum-green-1400-rgb));--spectrum-green-1500-rgb:0,33,25;--spectrum-green-1500:rgba(var(--spectrum-green-1500-rgb));--spectrum-green-1600-rgb:0,15,12;--spectrum-green-1600:rgba(var(--spectrum-green-1600-rgb));--spectrum-seafoam-100-rgb:235,251,246;--spectrum-seafoam-100:rgba(var(--spectrum-seafoam-100-rgb));--spectrum-seafoam-200-rgb:211,246,234;--spectrum-seafoam-200:rgba(var(--spectrum-seafoam-200-rgb));--spectrum-seafoam-300-rgb:169,237,216;--spectrum-seafoam-300:rgba(var(--spectrum-seafoam-300-rgb));--spectrum-seafoam-400-rgb:92,225,194;--spectrum-seafoam-400:rgba(var(--spectrum-seafoam-400-rgb));--spectrum-seafoam-500-rgb:16,207,169;--spectrum-seafoam-500:rgba(var(--spectrum-seafoam-500-rgb));--spectrum-seafoam-600-rgb:13,181,149;--spectrum-seafoam-600:rgba(var(--spectrum-seafoam-600-rgb));--spectrum-seafoam-700-rgb:11,162,134;--spectrum-seafoam-700:rgba(var(--spectrum-seafoam-700-rgb));--spectrum-seafoam-800-rgb:9,144,120;--spectrum-seafoam-800:rgba(var(--spectrum-seafoam-800-rgb));--spectrum-seafoam-900-rgb:7,129,109;--spectrum-seafoam-900:rgba(var(--spectrum-seafoam-900-rgb));--spectrum-seafoam-1000-rgb:5,108,92;--spectrum-seafoam-1000:rgba(var(--spectrum-seafoam-1000-rgb));--spectrum-seafoam-1100-rgb:3,92,80;--spectrum-seafoam-1100:rgba(var(--spectrum-seafoam-1100-rgb));--spectrum-seafoam-1200-rgb:1,75,67;--spectrum-seafoam-1200:rgba(var(--spectrum-seafoam-1200-rgb));--spectrum-seafoam-1300-rgb:0,60,54;--spectrum-seafoam-1300:rgba(var(--spectrum-seafoam-1300-rgb));--spectrum-seafoam-1400-rgb:0,46,40;--spectrum-seafoam-1400:rgba(var(--spectrum-seafoam-1400-rgb));--spectrum-seafoam-1500-rgb:0,33,29;--spectrum-seafoam-1500:rgba(var(--spectrum-seafoam-1500-rgb));--spectrum-seafoam-1600-rgb:0,15,14;--spectrum-seafoam-1600:rgba(var(--spectrum-seafoam-1600-rgb));--spectrum-cyan-100-rgb:238,250,254;--spectrum-cyan-100:rgba(var(--spectrum-cyan-100-rgb));--spectrum-cyan-200-rgb:217,244,253;--spectrum-cyan-200:rgba(var(--spectrum-cyan-200-rgb));--spectrum-cyan-300-rgb:183,231,252;--spectrum-cyan-300:rgba(var(--spectrum-cyan-300-rgb));--spectrum-cyan-400-rgb:138,213,255;--spectrum-cyan-400:rgba(var(--spectrum-cyan-400-rgb));--spectrum-cyan-500-rgb:92,192,255;--spectrum-cyan-500:rgba(var(--spectrum-cyan-500-rgb));--spectrum-cyan-600-rgb:48,167,254;--spectrum-cyan-600:rgba(var(--spectrum-cyan-600-rgb));--spectrum-cyan-700-rgb:29,149,231;--spectrum-cyan-700:rgba(var(--spectrum-cyan-700-rgb));--spectrum-cyan-800-rgb:18,134,205;--spectrum-cyan-800:rgba(var(--spectrum-cyan-800-rgb));--spectrum-cyan-900-rgb:11,120,179;--spectrum-cyan-900:rgba(var(--spectrum-cyan-900-rgb));--spectrum-cyan-1000-rgb:4,102,145;--spectrum-cyan-1000:rgba(var(--spectrum-cyan-1000-rgb));--spectrum-cyan-1100-rgb:0,87,121;--spectrum-cyan-1100:rgba(var(--spectrum-cyan-1100-rgb));--spectrum-cyan-1200-rgb:0,71,98;--spectrum-cyan-1200:rgba(var(--spectrum-cyan-1200-rgb));--spectrum-cyan-1300-rgb:0,57,78;--spectrum-cyan-1300:rgba(var(--spectrum-cyan-1300-rgb));--spectrum-cyan-1400-rgb:0,43,59;--spectrum-cyan-1400:rgba(var(--spectrum-cyan-1400-rgb));--spectrum-cyan-1500-rgb:0,31,43;--spectrum-cyan-1500:rgba(var(--spectrum-cyan-1500-rgb));--spectrum-cyan-1600-rgb:0,14,20;--spectrum-cyan-1600:rgba(var(--spectrum-cyan-1600-rgb));--spectrum-indigo-100-rgb:247,248,255;--spectrum-indigo-100:rgba(var(--spectrum-indigo-100-rgb));--spectrum-indigo-200-rgb:235,238,255;--spectrum-indigo-200:rgba(var(--spectrum-indigo-200-rgb));--spectrum-indigo-300-rgb:216,222,255;--spectrum-indigo-300:rgba(var(--spectrum-indigo-300-rgb));--spectrum-indigo-400-rgb:192,201,255;--spectrum-indigo-400:rgba(var(--spectrum-indigo-400-rgb));--spectrum-indigo-500-rgb:167,178,255;--spectrum-indigo-500:rgba(var(--spectrum-indigo-500-rgb));--spectrum-indigo-600-rgb:145,151,254;--spectrum-indigo-600:rgba(var(--spectrum-indigo-600-rgb));--spectrum-indigo-700-rgb:132,128,254;--spectrum-indigo-700:rgba(var(--spectrum-indigo-700-rgb));--spectrum-indigo-800-rgb:122,106,253;--spectrum-indigo-800:rgba(var(--spectrum-indigo-800-rgb));--spectrum-indigo-900-rgb:113,85,250;--spectrum-indigo-900:rgba(var(--spectrum-indigo-900-rgb));--spectrum-indigo-1000-rgb:99,56,238;--spectrum-indigo-1000:rgba(var(--spectrum-indigo-1000-rgb));--spectrum-indigo-1100-rgb:84,36,219;--spectrum-indigo-1100:rgba(var(--spectrum-indigo-1100-rgb));--spectrum-indigo-1200-rgb:69,19,191;--spectrum-indigo-1200:rgba(var(--spectrum-indigo-1200-rgb));--spectrum-indigo-1300-rgb:55,6,160;--spectrum-indigo-1300:rgba(var(--spectrum-indigo-1300-rgb));--spectrum-indigo-1400-rgb:42,0,129;--spectrum-indigo-1400:rgba(var(--spectrum-indigo-1400-rgb));--spectrum-indigo-1500-rgb:31,0,98;--spectrum-indigo-1500:rgba(var(--spectrum-indigo-1500-rgb));--spectrum-indigo-1600-rgb:17,0,54;--spectrum-indigo-1600:rgba(var(--spectrum-indigo-1600-rgb));--spectrum-purple-100-rgb:251,247,254;--spectrum-purple-100:rgba(var(--spectrum-purple-100-rgb));--spectrum-purple-200-rgb:244,235,252;--spectrum-purple-200:rgba(var(--spectrum-purple-200-rgb));--spectrum-purple-300-rgb:235,218,249;--spectrum-purple-300:rgba(var(--spectrum-purple-300-rgb));--spectrum-purple-400-rgb:221,193,246;--spectrum-purple-400:rgba(var(--spectrum-purple-400-rgb));--spectrum-purple-500-rgb:208,167,243;--spectrum-purple-500:rgba(var(--spectrum-purple-500-rgb));--spectrum-purple-600-rgb:191,138,238;--spectrum-purple-600:rgba(var(--spectrum-purple-600-rgb));--spectrum-purple-700-rgb:178,114,235;--spectrum-purple-700:rgba(var(--spectrum-purple-700-rgb));--spectrum-purple-800-rgb:166,92,231;--spectrum-purple-800:rgba(var(--spectrum-purple-800-rgb));--spectrum-purple-900-rgb:154,71,226;--spectrum-purple-900:rgba(var(--spectrum-purple-900-rgb));--spectrum-purple-1000-rgb:134,40,217;--spectrum-purple-1000:rgba(var(--spectrum-purple-1000-rgb));--spectrum-purple-1100-rgb:115,13,204;--spectrum-purple-1100:rgba(var(--spectrum-purple-1100-rgb));--spectrum-purple-1200-rgb:93,0,177;--spectrum-purple-1200:rgba(var(--spectrum-purple-1200-rgb));--spectrum-purple-1300-rgb:75,0,144;--spectrum-purple-1300:rgba(var(--spectrum-purple-1300-rgb));--spectrum-purple-1400-rgb:59,0,111;--spectrum-purple-1400:rgba(var(--spectrum-purple-1400-rgb));--spectrum-purple-1500-rgb:44,0,84;--spectrum-purple-1500:rgba(var(--spectrum-purple-1500-rgb));--spectrum-purple-1600-rgb:23,0,45;--spectrum-purple-1600:rgba(var(--spectrum-purple-1600-rgb));--spectrum-fuchsia-100-rgb:254,246,255;--spectrum-fuchsia-100:rgba(var(--spectrum-fuchsia-100-rgb));--spectrum-fuchsia-200-rgb:253,233,255;--spectrum-fuchsia-200:rgba(var(--spectrum-fuchsia-200-rgb));--spectrum-fuchsia-300-rgb:250,211,255;--spectrum-fuchsia-300:rgba(var(--spectrum-fuchsia-300-rgb));--spectrum-fuchsia-400-rgb:247,181,255;--spectrum-fuchsia-400:rgba(var(--spectrum-fuchsia-400-rgb));--spectrum-fuchsia-500-rgb:243,147,255;--spectrum-fuchsia-500:rgba(var(--spectrum-fuchsia-500-rgb));--spectrum-fuchsia-600-rgb:236,105,255;--spectrum-fuchsia-600:rgba(var(--spectrum-fuchsia-600-rgb));--spectrum-fuchsia-700-rgb:223,77,245;--spectrum-fuchsia-700:rgba(var(--spectrum-fuchsia-700-rgb));--spectrum-fuchsia-800-rgb:200,68,220;--spectrum-fuchsia-800:rgba(var(--spectrum-fuchsia-800-rgb));--spectrum-fuchsia-900-rgb:181,57,200;--spectrum-fuchsia-900:rgba(var(--spectrum-fuchsia-900-rgb));--spectrum-fuchsia-1000-rgb:156,40,175;--spectrum-fuchsia-1000:rgba(var(--spectrum-fuchsia-1000-rgb));--spectrum-fuchsia-1100-rgb:135,27,154;--spectrum-fuchsia-1100:rgba(var(--spectrum-fuchsia-1100-rgb));--spectrum-fuchsia-1200-rgb:113,15,131;--spectrum-fuchsia-1200:rgba(var(--spectrum-fuchsia-1200-rgb));--spectrum-fuchsia-1300-rgb:92,4,109;--spectrum-fuchsia-1300:rgba(var(--spectrum-fuchsia-1300-rgb));--spectrum-fuchsia-1400-rgb:72,0,88;--spectrum-fuchsia-1400:rgba(var(--spectrum-fuchsia-1400-rgb));--spectrum-fuchsia-1500-rgb:54,0,66;--spectrum-fuchsia-1500:rgba(var(--spectrum-fuchsia-1500-rgb));--spectrum-fuchsia-1600-rgb:29,0,35;--spectrum-fuchsia-1600:rgba(var(--spectrum-fuchsia-1600-rgb));--spectrum-magenta-100-rgb:255,245,248;--spectrum-magenta-100:rgba(var(--spectrum-magenta-100-rgb));--spectrum-magenta-200-rgb:255,232,240;--spectrum-magenta-200:rgba(var(--spectrum-magenta-200-rgb));--spectrum-magenta-300-rgb:255,213,227;--spectrum-magenta-300:rgba(var(--spectrum-magenta-300-rgb));--spectrum-magenta-400-rgb:255,185,208;--spectrum-magenta-400:rgba(var(--spectrum-magenta-400-rgb));--spectrum-magenta-500-rgb:255,152,187;--spectrum-magenta-500:rgba(var(--spectrum-magenta-500-rgb));--spectrum-magenta-600-rgb:255,112,159;--spectrum-magenta-600:rgba(var(--spectrum-magenta-600-rgb));--spectrum-magenta-700-rgb:255,72,133;--spectrum-magenta-700:rgba(var(--spectrum-magenta-700-rgb));--spectrum-magenta-800-rgb:240,45,110;--spectrum-magenta-800:rgba(var(--spectrum-magenta-800-rgb));--spectrum-magenta-900-rgb:217,35,97;--spectrum-magenta-900:rgba(var(--spectrum-magenta-900-rgb));--spectrum-magenta-1000-rgb:186,22,80;--spectrum-magenta-1000:rgba(var(--spectrum-magenta-1000-rgb));--spectrum-magenta-1100-rgb:163,5,62;--spectrum-magenta-1100:rgba(var(--spectrum-magenta-1100-rgb));--spectrum-magenta-1200-rgb:136,0,51;--spectrum-magenta-1200:rgba(var(--spectrum-magenta-1200-rgb));--spectrum-magenta-1300-rgb:111,0,40;--spectrum-magenta-1300:rgba(var(--spectrum-magenta-1300-rgb));--spectrum-magenta-1400-rgb:86,0,30;--spectrum-magenta-1400:rgba(var(--spectrum-magenta-1400-rgb));--spectrum-magenta-1500-rgb:64,0,22;--spectrum-magenta-1500:rgba(var(--spectrum-magenta-1500-rgb));--spectrum-magenta-1600-rgb:35,0,12;--spectrum-magenta-1600:rgba(var(--spectrum-magenta-1600-rgb));--spectrum-pink-100-rgb:255,246,252;--spectrum-pink-100:rgba(var(--spectrum-pink-100-rgb));--spectrum-pink-200-rgb:255,232,247;--spectrum-pink-200:rgba(var(--spectrum-pink-200-rgb));--spectrum-pink-300-rgb:255,211,240;--spectrum-pink-300:rgba(var(--spectrum-pink-300-rgb));--spectrum-pink-400-rgb:255,181,230;--spectrum-pink-400:rgba(var(--spectrum-pink-400-rgb));--spectrum-pink-500-rgb:255,148,219;--spectrum-pink-500:rgba(var(--spectrum-pink-500-rgb));--spectrum-pink-600-rgb:255,103,204;--spectrum-pink-600:rgba(var(--spectrum-pink-600-rgb));--spectrum-pink-700-rgb:242,76,184;--spectrum-pink-700:rgba(var(--spectrum-pink-700-rgb));--spectrum-pink-800-rgb:228,52,163;--spectrum-pink-800:rgba(var(--spectrum-pink-800-rgb));--spectrum-pink-900-rgb:206,42,146;--spectrum-pink-900:rgba(var(--spectrum-pink-900-rgb));--spectrum-pink-1000-rgb:176,31,123;--spectrum-pink-1000:rgba(var(--spectrum-pink-1000-rgb));--spectrum-pink-1100-rgb:152,22,104;--spectrum-pink-1100:rgba(var(--spectrum-pink-1100-rgb));--spectrum-pink-1200-rgb:128,12,85;--spectrum-pink-1200:rgba(var(--spectrum-pink-1200-rgb));--spectrum-pink-1300-rgb:105,3,68;--spectrum-pink-1300:rgba(var(--spectrum-pink-1300-rgb));--spectrum-pink-1400-rgb:83,0,53;--spectrum-pink-1400:rgba(var(--spectrum-pink-1400-rgb));--spectrum-pink-1500-rgb:62,0,39;--spectrum-pink-1500:rgba(var(--spectrum-pink-1500-rgb));--spectrum-pink-1600-rgb:33,0,21;--spectrum-pink-1600:rgba(var(--spectrum-pink-1600-rgb));--spectrum-turquoise-100-rgb:238,251,251;--spectrum-turquoise-100:rgba(var(--spectrum-turquoise-100-rgb));--spectrum-turquoise-200-rgb:209,245,245;--spectrum-turquoise-200:rgba(var(--spectrum-turquoise-200-rgb));--spectrum-turquoise-300-rgb:169,236,237;--spectrum-turquoise-300:rgba(var(--spectrum-turquoise-300-rgb));--spectrum-turquoise-400-rgb:111,221,228;--spectrum-turquoise-400:rgba(var(--spectrum-turquoise-400-rgb));--spectrum-turquoise-500-rgb:39,202,216;--spectrum-turquoise-500:rgba(var(--spectrum-turquoise-500-rgb));--spectrum-turquoise-600-rgb:15,177,192;--spectrum-turquoise-600:rgba(var(--spectrum-turquoise-600-rgb));--spectrum-turquoise-700-rgb:12,158,171;--spectrum-turquoise-700:rgba(var(--spectrum-turquoise-700-rgb));--spectrum-turquoise-800-rgb:10,141,153;--spectrum-turquoise-800:rgba(var(--spectrum-turquoise-800-rgb));--spectrum-turquoise-900-rgb:8,126,137;--spectrum-turquoise-900:rgba(var(--spectrum-turquoise-900-rgb));--spectrum-turquoise-1000-rgb:5,107,116;--spectrum-turquoise-1000:rgba(var(--spectrum-turquoise-1000-rgb));--spectrum-turquoise-1100-rgb:3,90,98;--spectrum-turquoise-1100:rgba(var(--spectrum-turquoise-1100-rgb));--spectrum-turquoise-1200-rgb:1,74,81;--spectrum-turquoise-1200:rgba(var(--spectrum-turquoise-1200-rgb));--spectrum-turquoise-1300-rgb:0,59,65;--spectrum-turquoise-1300:rgba(var(--spectrum-turquoise-1300-rgb));--spectrum-turquoise-1400-rgb:0,44,49;--spectrum-turquoise-1400:rgba(var(--spectrum-turquoise-1400-rgb));--spectrum-turquoise-1500-rgb:0,32,35;--spectrum-turquoise-1500:rgba(var(--spectrum-turquoise-1500-rgb));--spectrum-turquoise-1600-rgb:0,15,17;--spectrum-turquoise-1600:rgba(var(--spectrum-turquoise-1600-rgb));--spectrum-brown-100-rgb:252,247,242;--spectrum-brown-100:rgba(var(--spectrum-brown-100-rgb));--spectrum-brown-200-rgb:247,238,225;--spectrum-brown-200:rgba(var(--spectrum-brown-200-rgb));--spectrum-brown-300-rgb:239,221,195;--spectrum-brown-300:rgba(var(--spectrum-brown-300-rgb));--spectrum-brown-400-rgb:229,200,157;--spectrum-brown-400:rgba(var(--spectrum-brown-400-rgb));--spectrum-brown-500-rgb:214,177,123;--spectrum-brown-500:rgba(var(--spectrum-brown-500-rgb));--spectrum-brown-600-rgb:190,155,104;--spectrum-brown-600:rgba(var(--spectrum-brown-600-rgb));--spectrum-brown-700-rgb:171,138,90;--spectrum-brown-700:rgba(var(--spectrum-brown-700-rgb));--spectrum-brown-800-rgb:154,123,77;--spectrum-brown-800:rgba(var(--spectrum-brown-800-rgb));--spectrum-brown-900-rgb:139,109,66;--spectrum-brown-900:rgba(var(--spectrum-brown-900-rgb));--spectrum-brown-1000-rgb:119,91,50;--spectrum-brown-1000:rgba(var(--spectrum-brown-1000-rgb));--spectrum-brown-1100-rgb:103,76,35;--spectrum-brown-1100:rgba(var(--spectrum-brown-1100-rgb));--spectrum-brown-1200-rgb:88,61,21;--spectrum-brown-1200:rgba(var(--spectrum-brown-1200-rgb));--spectrum-brown-1300-rgb:70,49,17;--spectrum-brown-1300:rgba(var(--spectrum-brown-1300-rgb));--spectrum-brown-1400-rgb:52,37,13;--spectrum-brown-1400:rgba(var(--spectrum-brown-1400-rgb));--spectrum-brown-1500-rgb:38,26,9;--spectrum-brown-1500:rgba(var(--spectrum-brown-1500-rgb));--spectrum-brown-1600-rgb:16,12,4;--spectrum-brown-1600:rgba(var(--spectrum-brown-1600-rgb));--spectrum-silver-100-rgb:247,247,247;--spectrum-silver-100:rgba(var(--spectrum-silver-100-rgb));--spectrum-silver-200-rgb:239,239,239;--spectrum-silver-200:rgba(var(--spectrum-silver-200-rgb));--spectrum-silver-300-rgb:223,223,223;--spectrum-silver-300:rgba(var(--spectrum-silver-300-rgb));--spectrum-silver-400-rgb:204,204,204;--spectrum-silver-400:rgba(var(--spectrum-silver-400-rgb));--spectrum-silver-500-rgb:183,183,183;--spectrum-silver-500:rgba(var(--spectrum-silver-500-rgb));--spectrum-silver-600-rgb:160,160,160;--spectrum-silver-600:rgba(var(--spectrum-silver-600-rgb));--spectrum-silver-700-rgb:143,143,143;--spectrum-silver-700:rgba(var(--spectrum-silver-700-rgb));--spectrum-silver-800-rgb:128,128,128;--spectrum-silver-800:rgba(var(--spectrum-silver-800-rgb));--spectrum-silver-900-rgb:114,114,114;--spectrum-silver-900:rgba(var(--spectrum-silver-900-rgb));--spectrum-silver-1000-rgb:96,96,96;--spectrum-silver-1000:rgba(var(--spectrum-silver-1000-rgb));--spectrum-silver-1100-rgb:81,81,81;--spectrum-silver-1100:rgba(var(--spectrum-silver-1100-rgb));--spectrum-silver-1200-rgb:66,66,66;--spectrum-silver-1200:rgba(var(--spectrum-silver-1200-rgb));--spectrum-silver-1300-rgb:52,52,52;--spectrum-silver-1300:rgba(var(--spectrum-silver-1300-rgb));--spectrum-silver-1400-rgb:39,39,39;--spectrum-silver-1400:rgba(var(--spectrum-silver-1400-rgb));--spectrum-silver-1500-rgb:28,28,28;--spectrum-silver-1500:rgba(var(--spectrum-silver-1500-rgb));--spectrum-silver-1600-rgb:12,12,12;--spectrum-silver-1600:rgba(var(--spectrum-silver-1600-rgb));--spectrum-cinnamon-100-rgb:253,247,243;--spectrum-cinnamon-100:rgba(var(--spectrum-cinnamon-100-rgb));--spectrum-cinnamon-200-rgb:249,236,229;--spectrum-cinnamon-200:rgba(var(--spectrum-cinnamon-200-rgb));--spectrum-cinnamon-300-rgb:244,218,203;--spectrum-cinnamon-300:rgba(var(--spectrum-cinnamon-300-rgb));--spectrum-cinnamon-400-rgb:237,196,172;--spectrum-cinnamon-400:rgba(var(--spectrum-cinnamon-400-rgb));--spectrum-cinnamon-500-rgb:229,170,136;--spectrum-cinnamon-500:rgba(var(--spectrum-cinnamon-500-rgb));--spectrum-cinnamon-600-rgb:212,145,108;--spectrum-cinnamon-600:rgba(var(--spectrum-cinnamon-600-rgb));--spectrum-cinnamon-700-rgb:198,126,88;--spectrum-cinnamon-700:rgba(var(--spectrum-cinnamon-700-rgb));--spectrum-cinnamon-800-rgb:184,109,70;--spectrum-cinnamon-800:rgba(var(--spectrum-cinnamon-800-rgb));--spectrum-cinnamon-900-rgb:170,94,56;--spectrum-cinnamon-900:rgba(var(--spectrum-cinnamon-900-rgb));--spectrum-cinnamon-1000-rgb:147,77,43;--spectrum-cinnamon-1000:rgba(var(--spectrum-cinnamon-1000-rgb));--spectrum-cinnamon-1100-rgb:128,62,32;--spectrum-cinnamon-1100:rgba(var(--spectrum-cinnamon-1100-rgb));--spectrum-cinnamon-1200-rgb:110,48,21;--spectrum-cinnamon-1200:rgba(var(--spectrum-cinnamon-1200-rgb));--spectrum-cinnamon-1300-rgb:92,35,11;--spectrum-cinnamon-1300:rgba(var(--spectrum-cinnamon-1300-rgb));--spectrum-cinnamon-1400-rgb:72,25,6;--spectrum-cinnamon-1400:rgba(var(--spectrum-cinnamon-1400-rgb));--spectrum-cinnamon-1500-rgb:52,18,4;--spectrum-cinnamon-1500:rgba(var(--spectrum-cinnamon-1500-rgb));--spectrum-cinnamon-1600-rgb:24,8,2;--spectrum-cinnamon-1600:rgba(var(--spectrum-cinnamon-1600-rgb));--spectrum-icon-color-blue-primary-default:var(--spectrum-blue-900);--spectrum-icon-color-green-primary-default:var(--spectrum-green-900);--spectrum-icon-color-red-primary-default:var(--spectrum-red-900);--spectrum-icon-color-yellow-primary-default:var(--spectrum-yellow-400);--spectrum-negative-subdued-background-color-default:var(--spectrum-negative-subtle-background-color-default);--spectrum-accent-subtle-background-color-default:var(--spectrum-accent-color-200);--spectrum-informative-subtle-background-color-default:var(--spectrum-informative-color-200);--spectrum-positive-subtle-background-color-default:var(--spectrum-positive-color-200);--spectrum-notice-subtle-background-color-default:var(--spectrum-notice-color-200);--spectrum-negative-subtle-background-color-default:var(--spectrum-negative-color-200);--color-scheme:light;--spectrum-assetcard-border-color-selected:var(--spectrum-blue-900);--spectrum-assetcard-border-color-selected-hover:var(--spectrum-blue-900);--spectrum-assetcard-border-color-selected-down:var(--spectrum-blue-1000);--spectrum-assetcard-selectionindicator-background-color-ordered:var(--spectrum-blue-900);--spectrum-assestcard-focus-indicator-color:var(--spectrum-blue-800);--spectrum-assetlist-item-background-color-selected-hover:rgba(var(--spectrum-blue-900-rgb),.2);--spectrum-assetlist-item-background-color-selected:rgba(var(--spectrum-blue-900-rgb),.1);--spectrum-assetlist-border-color-key-focus:var(--spectrum-blue-800);--spectrum-badge-label-icon-color-primary:var(--spectrum-white);--spectrum-calendar-day-background-color-selected:rgba(var(--spectrum-blue-900-rgb),.1);--spectrum-calendar-day-background-color-hover:rgba(var(--spectrum-black-rgb),.06);--spectrum-calendar-day-today-background-color-selected-hover:rgba(var(--spectrum-blue-900-rgb),.2);--spectrum-calendar-day-background-color-selected-hover:rgba(var(--spectrum-blue-900-rgb),.2);--spectrum-calendar-day-background-color-down:var(--spectrum-transparent-black-200);--spectrum-calendar-day-background-color-cap-selected:rgba(var(--spectrum-blue-900-rgb),.2);--spectrum-calendar-day-background-color-key-focus:rgba(var(--spectrum-black-rgb),.06);--spectrum-calendar-day-border-color-key-focus:var(--spectrum-blue-800);--spectrum-card-selected-background-color-rgb:var(--spectrum-blue-900-rgb);--spectrum-coach-indicator-ring-default-color:var(--spectrum-blue-800);--spectrum-drop-zone-background-color-rgb:var(--spectrum-blue-800-rgb);--spectrum-dropindicator-color:var(--spectrum-blue-800);--spectrum-logic-button-and-background-color:var(--spectrum-blue-900);--spectrum-logic-button-and-border-color:var(--spectrum-blue-900);--spectrum-logic-button-and-background-color-hover:var(--spectrum-blue-1100);--spectrum-logic-button-and-border-color-hover:var(--spectrum-blue-1100);--spectrum-logic-button-or-background-color:var(--spectrum-magenta-900);--spectrum-logic-button-or-border-color:var(--spectrum-magenta-900);--spectrum-logic-button-or-background-color-hover:var(--spectrum-magenta-1100);--spectrum-logic-button-or-border-color-hover:var(--spectrum-magenta-1100);--spectrum-steplist-current-marker-color-key-focus:var(--spectrum-blue-800);--spectrum-swatch-border-color-rgb:0,0,0;--spectrum-swatch-border-color-opacity:.51;--spectrum-swatch-border-color:rgba(var(--spectrum-swatch-border-color-rgb),var(--spectrum-swatch-border-color-opacity));--spectrum-swatch-border-color-light-rgb:0,0,0;--spectrum-swatch-border-color-light-opacity:.2;--spectrum-swatch-border-color-light:rgba(var(--spectrum-swatch-border-color-light-rgb),var(--spectrum-swatch-border-color-light-opacity));--spectrum-treeview-item-background-color-quiet-selected:rgba(var(--spectrum-gray-900-rgb),.06);--spectrum-treeview-item-background-color-selected:rgba(var(--spectrum-blue-900-rgb),.1)}
`;
var theme_light_css_default = e7;

// node_modules/@spectrum-web-components/theme/spectrum-two/theme-light.js
Theme.registerThemeFragment("light-spectrum-two", "color", theme_light_css_default);

// node_modules/@spectrum-web-components/theme/src/spectrum-two/theme-dark.css.js
init_src();
var e8 = i`
    :root,:host{--spectrum-global-color-status:Verified;--spectrum-global-color-version:5.1;--spectrum-global-color-opacity-100:1;--spectrum-global-color-opacity-90:.9;--spectrum-global-color-opacity-80:.8;--spectrum-global-color-opacity-70:.7;--spectrum-global-color-opacity-60:.6;--spectrum-global-color-opacity-55:.55;--spectrum-global-color-opacity-50:.5;--spectrum-global-color-opacity-42:.42;--spectrum-global-color-opacity-40:.4;--spectrum-global-color-opacity-30:.3;--spectrum-global-color-opacity-25:.25;--spectrum-global-color-opacity-20:.2;--spectrum-global-color-opacity-15:.15;--spectrum-global-color-opacity-10:.1;--spectrum-global-color-opacity-8:.08;--spectrum-global-color-opacity-7:.07;--spectrum-global-color-opacity-6:.06;--spectrum-global-color-opacity-5:.05;--spectrum-global-color-opacity-4:.04;--spectrum-global-color-opacity-0:0;--spectrum-global-color-celery-400-rgb:34,184,51;--spectrum-global-color-celery-400:rgb(var(--spectrum-global-color-celery-400-rgb));--spectrum-global-color-celery-500-rgb:68,202,73;--spectrum-global-color-celery-500:rgb(var(--spectrum-global-color-celery-500-rgb));--spectrum-global-color-celery-600-rgb:105,220,99;--spectrum-global-color-celery-600:rgb(var(--spectrum-global-color-celery-600-rgb));--spectrum-global-color-celery-700-rgb:142,235,127;--spectrum-global-color-celery-700:rgb(var(--spectrum-global-color-celery-700-rgb));--spectrum-global-color-chartreuse-400-rgb:148,192,8;--spectrum-global-color-chartreuse-400:rgb(var(--spectrum-global-color-chartreuse-400-rgb));--spectrum-global-color-chartreuse-500-rgb:166,211,18;--spectrum-global-color-chartreuse-500:rgb(var(--spectrum-global-color-chartreuse-500-rgb));--spectrum-global-color-chartreuse-600-rgb:184,229,37;--spectrum-global-color-chartreuse-600:rgb(var(--spectrum-global-color-chartreuse-600-rgb));--spectrum-global-color-chartreuse-700-rgb:205,245,71;--spectrum-global-color-chartreuse-700:rgb(var(--spectrum-global-color-chartreuse-700-rgb));--spectrum-global-color-yellow-400-rgb:228,194,0;--spectrum-global-color-yellow-400:rgb(var(--spectrum-global-color-yellow-400-rgb));--spectrum-global-color-yellow-500-rgb:244,213,0;--spectrum-global-color-yellow-500:rgb(var(--spectrum-global-color-yellow-500-rgb));--spectrum-global-color-yellow-600-rgb:249,232,92;--spectrum-global-color-yellow-600:rgb(var(--spectrum-global-color-yellow-600-rgb));--spectrum-global-color-yellow-700-rgb:252,246,187;--spectrum-global-color-yellow-700:rgb(var(--spectrum-global-color-yellow-700-rgb));--spectrum-global-color-magenta-400-rgb:222,61,130;--spectrum-global-color-magenta-400:rgb(var(--spectrum-global-color-magenta-400-rgb));--spectrum-global-color-magenta-500-rgb:237,87,149;--spectrum-global-color-magenta-500:rgb(var(--spectrum-global-color-magenta-500-rgb));--spectrum-global-color-magenta-600-rgb:249,114,167;--spectrum-global-color-magenta-600:rgb(var(--spectrum-global-color-magenta-600-rgb));--spectrum-global-color-magenta-700-rgb:255,143,185;--spectrum-global-color-magenta-700:rgb(var(--spectrum-global-color-magenta-700-rgb));--spectrum-global-color-fuchsia-400-rgb:205,57,206;--spectrum-global-color-fuchsia-400:rgb(var(--spectrum-global-color-fuchsia-400-rgb));--spectrum-global-color-fuchsia-500-rgb:223,81,224;--spectrum-global-color-fuchsia-500:rgb(var(--spectrum-global-color-fuchsia-500-rgb));--spectrum-global-color-fuchsia-600-rgb:235,110,236;--spectrum-global-color-fuchsia-600:rgb(var(--spectrum-global-color-fuchsia-600-rgb));--spectrum-global-color-fuchsia-700-rgb:244,140,242;--spectrum-global-color-fuchsia-700:rgb(var(--spectrum-global-color-fuchsia-700-rgb));--spectrum-global-color-purple-400-rgb:157,87,243;--spectrum-global-color-purple-400:rgb(var(--spectrum-global-color-purple-400-rgb));--spectrum-global-color-purple-500-rgb:172,111,249;--spectrum-global-color-purple-500:rgb(var(--spectrum-global-color-purple-500-rgb));--spectrum-global-color-purple-600-rgb:187,135,251;--spectrum-global-color-purple-600:rgb(var(--spectrum-global-color-purple-600-rgb));--spectrum-global-color-purple-700-rgb:202,159,252;--spectrum-global-color-purple-700:rgb(var(--spectrum-global-color-purple-700-rgb));--spectrum-global-color-indigo-400-rgb:104,109,244;--spectrum-global-color-indigo-400:rgb(var(--spectrum-global-color-indigo-400-rgb));--spectrum-global-color-indigo-500-rgb:124,129,251;--spectrum-global-color-indigo-500:rgb(var(--spectrum-global-color-indigo-500-rgb));--spectrum-global-color-indigo-600-rgb:145,149,255;--spectrum-global-color-indigo-600:rgb(var(--spectrum-global-color-indigo-600-rgb));--spectrum-global-color-indigo-700-rgb:167,170,255;--spectrum-global-color-indigo-700:rgb(var(--spectrum-global-color-indigo-700-rgb));--spectrum-global-color-seafoam-400-rgb:0,158,152;--spectrum-global-color-seafoam-400:rgb(var(--spectrum-global-color-seafoam-400-rgb));--spectrum-global-color-seafoam-500-rgb:3,178,171;--spectrum-global-color-seafoam-500:rgb(var(--spectrum-global-color-seafoam-500-rgb));--spectrum-global-color-seafoam-600-rgb:54,197,189;--spectrum-global-color-seafoam-600:rgb(var(--spectrum-global-color-seafoam-600-rgb));--spectrum-global-color-seafoam-700-rgb:93,214,207;--spectrum-global-color-seafoam-700:rgb(var(--spectrum-global-color-seafoam-700-rgb));--spectrum-global-color-red-400-rgb:234,56,41;--spectrum-global-color-red-400:rgb(var(--spectrum-global-color-red-400-rgb));--spectrum-global-color-red-500-rgb:246,88,67;--spectrum-global-color-red-500:rgb(var(--spectrum-global-color-red-500-rgb));--spectrum-global-color-red-600-rgb:255,117,94;--spectrum-global-color-red-600:rgb(var(--spectrum-global-color-red-600-rgb));--spectrum-global-color-red-700-rgb:255,149,129;--spectrum-global-color-red-700:rgb(var(--spectrum-global-color-red-700-rgb));--spectrum-global-color-orange-400-rgb:244,129,12;--spectrum-global-color-orange-400:rgb(var(--spectrum-global-color-orange-400-rgb));--spectrum-global-color-orange-500-rgb:254,154,46;--spectrum-global-color-orange-500:rgb(var(--spectrum-global-color-orange-500-rgb));--spectrum-global-color-orange-600-rgb:255,181,88;--spectrum-global-color-orange-600:rgb(var(--spectrum-global-color-orange-600-rgb));--spectrum-global-color-orange-700-rgb:253,206,136;--spectrum-global-color-orange-700:rgb(var(--spectrum-global-color-orange-700-rgb));--spectrum-global-color-green-400-rgb:18,162,108;--spectrum-global-color-green-400:rgb(var(--spectrum-global-color-green-400-rgb));--spectrum-global-color-green-500-rgb:43,180,125;--spectrum-global-color-green-500:rgb(var(--spectrum-global-color-green-500-rgb));--spectrum-global-color-green-600-rgb:67,199,143;--spectrum-global-color-green-600:rgb(var(--spectrum-global-color-green-600-rgb));--spectrum-global-color-green-700-rgb:94,217,162;--spectrum-global-color-green-700:rgb(var(--spectrum-global-color-green-700-rgb));--spectrum-global-color-blue-400-rgb:52,143,244;--spectrum-global-color-blue-400:rgb(var(--spectrum-global-color-blue-400-rgb));--spectrum-global-color-blue-500-rgb:84,163,246;--spectrum-global-color-blue-500:rgb(var(--spectrum-global-color-blue-500-rgb));--spectrum-global-color-blue-600-rgb:114,183,249;--spectrum-global-color-blue-600:rgb(var(--spectrum-global-color-blue-600-rgb));--spectrum-global-color-blue-700-rgb:143,202,252;--spectrum-global-color-blue-700:rgb(var(--spectrum-global-color-blue-700-rgb));--spectrum-global-color-gray-50-rgb:29,29,29;--spectrum-global-color-gray-50:rgb(var(--spectrum-global-color-gray-50-rgb));--spectrum-global-color-gray-75-rgb:38,38,38;--spectrum-global-color-gray-75:rgb(var(--spectrum-global-color-gray-75-rgb));--spectrum-global-color-gray-100-rgb:50,50,50;--spectrum-global-color-gray-100:rgb(var(--spectrum-global-color-gray-100-rgb));--spectrum-global-color-gray-200-rgb:63,63,63;--spectrum-global-color-gray-200:rgb(var(--spectrum-global-color-gray-200-rgb));--spectrum-global-color-gray-300-rgb:84,84,84;--spectrum-global-color-gray-300:rgb(var(--spectrum-global-color-gray-300-rgb));--spectrum-global-color-gray-400-rgb:112,112,112;--spectrum-global-color-gray-400:rgb(var(--spectrum-global-color-gray-400-rgb));--spectrum-global-color-gray-500-rgb:144,144,144;--spectrum-global-color-gray-500:rgb(var(--spectrum-global-color-gray-500-rgb));--spectrum-global-color-gray-600-rgb:178,178,178;--spectrum-global-color-gray-600:rgb(var(--spectrum-global-color-gray-600-rgb));--spectrum-global-color-gray-700-rgb:209,209,209;--spectrum-global-color-gray-700:rgb(var(--spectrum-global-color-gray-700-rgb));--spectrum-global-color-gray-800-rgb:235,235,235;--spectrum-global-color-gray-800:rgb(var(--spectrum-global-color-gray-800-rgb));--spectrum-global-color-gray-900-rgb:255,255,255;--spectrum-global-color-gray-900:rgb(var(--spectrum-global-color-gray-900-rgb));--spectrum-alias-background-color-primary:var(--spectrum-global-color-gray-100);--spectrum-alias-background-color-secondary:var(--spectrum-global-color-gray-75);--spectrum-alias-background-color-tertiary:var(--spectrum-global-color-gray-50);--spectrum-alias-background-color-modal-overlay:#00000080;--spectrum-alias-dropshadow-color:#00000080;--spectrum-alias-background-color-hover-overlay:#ffffff0f;--spectrum-alias-highlight-hover:#ffffff12;--spectrum-alias-highlight-down:#ffffff1a;--spectrum-alias-highlight-selected:#54a3f626;--spectrum-alias-highlight-selected-hover:#54a3f640;--spectrum-alias-text-highlight-color:#54a3f640;--spectrum-alias-background-color-quickactions:#323232e6;--spectrum-alias-border-color-selected:var(--spectrum-global-color-blue-600);--spectrum-alias-border-color-translucent:#ffffff1a;--spectrum-alias-radial-reaction-color-default:#ebebeb99;--spectrum-alias-pasteboard-background-color:var(--spectrum-global-color-gray-50);--spectrum-alias-appframe-border-color:var(--spectrum-global-color-gray-50);--spectrum-alias-appframe-separator-color:var(--spectrum-global-color-gray-50)}:host,:root{color-scheme:dark;--spectrum-overlay-opacity:.6;--spectrum-background-layer-2-color:var(--spectrum-gray-75);--spectrum-neutral-subdued-background-color-default:var(--spectrum-gray-500);--spectrum-neutral-subdued-background-color-hover:var(--spectrum-gray-400);--spectrum-neutral-subdued-background-color-down:var(--spectrum-gray-400);--spectrum-neutral-subdued-background-color-key-focus:var(--spectrum-gray-400);--spectrum-accent-background-color-default:var(--spectrum-accent-color-800);--spectrum-accent-background-color-hover:var(--spectrum-accent-color-700);--spectrum-accent-background-color-down:var(--spectrum-accent-color-700);--spectrum-accent-background-color-key-focus:var(--spectrum-accent-color-700);--spectrum-informative-background-color-default:var(--spectrum-informative-color-800);--spectrum-informative-background-color-hover:var(--spectrum-informative-color-700);--spectrum-informative-background-color-down:var(--spectrum-informative-color-700);--spectrum-informative-background-color-key-focus:var(--spectrum-informative-color-700);--spectrum-negative-background-color-default:var(--spectrum-negative-color-800);--spectrum-negative-background-color-hover:var(--spectrum-negative-color-700);--spectrum-negative-background-color-down:var(--spectrum-negative-color-700);--spectrum-negative-background-color-key-focus:var(--spectrum-negative-color-700);--spectrum-positive-background-color-default:var(--spectrum-positive-color-800);--spectrum-positive-background-color-hover:var(--spectrum-positive-color-700);--spectrum-positive-background-color-down:var(--spectrum-positive-color-700);--spectrum-positive-background-color-key-focus:var(--spectrum-positive-color-700);--spectrum-notice-background-color-default:var(--spectrum-notice-color-900);--spectrum-gray-background-color-default:var(--spectrum-gray-500);--spectrum-red-background-color-default:var(--spectrum-red-800);--spectrum-orange-background-color-default:var(--spectrum-orange-900);--spectrum-yellow-background-color-default:var(--spectrum-yellow-1100);--spectrum-chartreuse-background-color-default:var(--spectrum-chartreuse-1000);--spectrum-celery-background-color-default:var(--spectrum-celery-900);--spectrum-green-background-color-default:var(--spectrum-green-800);--spectrum-seafoam-background-color-default:var(--spectrum-seafoam-800);--spectrum-cyan-background-color-default:var(--spectrum-cyan-800);--spectrum-blue-background-color-default:var(--spectrum-blue-800);--spectrum-indigo-background-color-default:var(--spectrum-indigo-800);--spectrum-purple-background-color-default:var(--spectrum-purple-800);--spectrum-fuchsia-background-color-default:var(--spectrum-fuchsia-800);--spectrum-magenta-background-color-default:var(--spectrum-magenta-800);--spectrum-neutral-visual-color:var(--spectrum-gray-600);--spectrum-accent-visual-color:var(--spectrum-accent-color-900);--spectrum-informative-visual-color:var(--spectrum-informative-color-900);--spectrum-negative-visual-color:var(--spectrum-negative-color-900);--spectrum-notice-visual-color:var(--spectrum-notice-color-900);--spectrum-positive-visual-color:var(--spectrum-positive-color-900);--spectrum-gray-visual-color:var(--spectrum-gray-600);--spectrum-red-visual-color:var(--spectrum-red-700);--spectrum-orange-visual-color:var(--spectrum-orange-900);--spectrum-yellow-visual-color:var(--spectrum-yellow-1100);--spectrum-chartreuse-visual-color:var(--spectrum-chartreuse-900);--spectrum-celery-visual-color:var(--spectrum-celery-800);--spectrum-green-visual-color:var(--spectrum-green-800);--spectrum-seafoam-visual-color:var(--spectrum-seafoam-800);--spectrum-cyan-visual-color:var(--spectrum-cyan-900);--spectrum-blue-visual-color:var(--spectrum-blue-900);--spectrum-indigo-visual-color:var(--spectrum-indigo-900);--spectrum-purple-visual-color:var(--spectrum-purple-900);--spectrum-fuchsia-visual-color:var(--spectrum-fuchsia-900);--spectrum-magenta-visual-color:var(--spectrum-magenta-900);--spectrum-background-elevated-color:var(--spectrum-gray-75);--spectrum-background-pasteboard-color:var(--spectrum-gray-25);--spectrum-brown-visual-color:var(--spectrum-brown-900);--spectrum-cinnamon-visual-color:var(--spectrum-cinnamon-900);--spectrum-pink-visual-color:var(--spectrum-pink-900);--spectrum-silver-visual-color:var(--spectrum-silver-900);--spectrum-turquoise-visual-color:var(--spectrum-turquoise-900);--spectrum-brown-background-color-default:var(--spectrum-brown-800);--spectrum-cinnamon-background-color-default:var(--spectrum-cinnamon-800);--spectrum-pink-background-color-default:var(--spectrum-pink-800);--spectrum-silver-background-color-default:var(--spectrum-silver-800);--spectrum-turquoise-background-color-default:var(--spectrum-turquoise-800);--spectrum-drop-shadow-color-100-rgb:0,0,0;--spectrum-drop-shadow-color-100-opacity:.36;--spectrum-drop-shadow-color-100:rgba(var(--spectrum-drop-shadow-color-100-rgb),var(--spectrum-drop-shadow-color-100-opacity));--spectrum-drop-shadow-color-200-rgb:0,0,0;--spectrum-drop-shadow-color-200-opacity:.48;--spectrum-drop-shadow-color-200:rgba(var(--spectrum-drop-shadow-color-200-rgb),var(--spectrum-drop-shadow-color-200-opacity));--spectrum-drop-shadow-color-300-rgb:0,0,0;--spectrum-drop-shadow-color-300-opacity:.6;--spectrum-drop-shadow-color-300:rgba(var(--spectrum-drop-shadow-color-300-rgb),var(--spectrum-drop-shadow-color-300-opacity));--spectrum-neutral-subtle-background-color-default:var(--spectrum-gray-300);--spectrum-gray-subtle-background-color-default:var(--spectrum-gray-300);--spectrum-blue-subtle-background-color-default:var(--spectrum-blue-300);--spectrum-green-subtle-background-color-default:var(--spectrum-green-300);--spectrum-orange-subtle-background-color-default:var(--spectrum-orange-300);--spectrum-red-subtle-background-color-default:var(--spectrum-red-300);--spectrum-brown-subtle-background-color-default:var(--spectrum-brown-300);--spectrum-cinnamon-subtle-background-color-default:var(--spectrum-cinnamon-300);--spectrum-celery-subtle-background-color-default:var(--spectrum-celery-300);--spectrum-chartreuse-subtle-background-color-default:var(--spectrum-chartreuse-300);--spectrum-cyan-subtle-background-color-default:var(--spectrum-cyan-300);--spectrum-fuchsia-subtle-background-color-default:var(--spectrum-fuchsia-300);--spectrum-indigo-subtle-background-color-default:var(--spectrum-indigo-300);--spectrum-magenta-subtle-background-color-default:var(--spectrum-magenta-300);--spectrum-pink-subtle-background-color-default:var(--spectrum-pink-300);--spectrum-purple-subtle-background-color-default:var(--spectrum-purple-300);--spectrum-seafoam-subtle-background-color-default:var(--spectrum-seafoam-300);--spectrum-silver-subtle-background-color-default:var(--spectrum-silver-300);--spectrum-turquoise-subtle-background-color-default:var(--spectrum-turquoise-300);--spectrum-yellow-subtle-background-color-default:var(--spectrum-yellow-300);--spectrum-opacity-checkerboard-square-dark:var(--spectrum-gray-800);--spectrum-white-rgb:255,255,255;--spectrum-white:rgba(var(--spectrum-white-rgb));--spectrum-transparent-white-25-rgb:255,255,255;--spectrum-transparent-white-25-opacity:0;--spectrum-transparent-white-25:rgba(var(--spectrum-transparent-white-25-rgb),var(--spectrum-transparent-white-25-opacity));--spectrum-transparent-white-50-rgb:255,255,255;--spectrum-transparent-white-50-opacity:.04;--spectrum-transparent-white-50:rgba(var(--spectrum-transparent-white-50-rgb),var(--spectrum-transparent-white-50-opacity));--spectrum-transparent-white-75-rgb:255,255,255;--spectrum-transparent-white-75-opacity:.07;--spectrum-transparent-white-75:rgba(var(--spectrum-transparent-white-75-rgb),var(--spectrum-transparent-white-75-opacity));--spectrum-transparent-white-100-rgb:255,255,255;--spectrum-transparent-white-100-opacity:.11;--spectrum-transparent-white-100:rgba(var(--spectrum-transparent-white-100-rgb),var(--spectrum-transparent-white-100-opacity));--spectrum-transparent-white-200-rgb:255,255,255;--spectrum-transparent-white-200-opacity:.14;--spectrum-transparent-white-200:rgba(var(--spectrum-transparent-white-200-rgb),var(--spectrum-transparent-white-200-opacity));--spectrum-transparent-white-300-rgb:255,255,255;--spectrum-transparent-white-300-opacity:.17;--spectrum-transparent-white-300:rgba(var(--spectrum-transparent-white-300-rgb),var(--spectrum-transparent-white-300-opacity));--spectrum-transparent-white-400-rgb:255,255,255;--spectrum-transparent-white-400-opacity:.21;--spectrum-transparent-white-400:rgba(var(--spectrum-transparent-white-400-rgb),var(--spectrum-transparent-white-400-opacity));--spectrum-transparent-white-500-rgb:255,255,255;--spectrum-transparent-white-500-opacity:.39;--spectrum-transparent-white-500:rgba(var(--spectrum-transparent-white-500-rgb),var(--spectrum-transparent-white-500-opacity));--spectrum-transparent-white-600-rgb:255,255,255;--spectrum-transparent-white-600-opacity:.51;--spectrum-transparent-white-600:rgba(var(--spectrum-transparent-white-600-rgb),var(--spectrum-transparent-white-600-opacity));--spectrum-transparent-white-700-rgb:255,255,255;--spectrum-transparent-white-700-opacity:.66;--spectrum-transparent-white-700:rgba(var(--spectrum-transparent-white-700-rgb),var(--spectrum-transparent-white-700-opacity));--spectrum-transparent-white-800-rgb:255,255,255;--spectrum-transparent-white-800-opacity:.85;--spectrum-transparent-white-800:rgba(var(--spectrum-transparent-white-800-rgb),var(--spectrum-transparent-white-800-opacity));--spectrum-transparent-white-900-rgb:255,255,255;--spectrum-transparent-white-900-opacity:.94;--spectrum-transparent-white-900:rgba(var(--spectrum-transparent-white-900-rgb),var(--spectrum-transparent-white-900-opacity));--spectrum-transparent-white-1000-rgb:255,255,255;--spectrum-transparent-white-1000:rgba(var(--spectrum-transparent-white-1000-rgb));--spectrum-transparent-black-25-rgb:0,0,0;--spectrum-transparent-black-25-opacity:0;--spectrum-transparent-black-25:rgba(var(--spectrum-transparent-black-25-rgb),var(--spectrum-transparent-black-25-opacity));--spectrum-transparent-black-50-rgb:0,0,0;--spectrum-transparent-black-50-opacity:.03;--spectrum-transparent-black-50:rgba(var(--spectrum-transparent-black-50-rgb),var(--spectrum-transparent-black-50-opacity));--spectrum-transparent-black-75-rgb:0,0,0;--spectrum-transparent-black-75-opacity:.05;--spectrum-transparent-black-75:rgba(var(--spectrum-transparent-black-75-rgb),var(--spectrum-transparent-black-75-opacity));--spectrum-transparent-black-100-rgb:0,0,0;--spectrum-transparent-black-100-opacity:.09;--spectrum-transparent-black-100:rgba(var(--spectrum-transparent-black-100-rgb),var(--spectrum-transparent-black-100-opacity));--spectrum-transparent-black-200-rgb:0,0,0;--spectrum-transparent-black-200-opacity:.12;--spectrum-transparent-black-200:rgba(var(--spectrum-transparent-black-200-rgb),var(--spectrum-transparent-black-200-opacity));--spectrum-transparent-black-300-rgb:0,0,0;--spectrum-transparent-black-300-opacity:.15;--spectrum-transparent-black-300:rgba(var(--spectrum-transparent-black-300-rgb),var(--spectrum-transparent-black-300-opacity));--spectrum-transparent-black-400-rgb:0,0,0;--spectrum-transparent-black-400-opacity:.22;--spectrum-transparent-black-400:rgba(var(--spectrum-transparent-black-400-rgb),var(--spectrum-transparent-black-400-opacity));--spectrum-transparent-black-500-rgb:0,0,0;--spectrum-transparent-black-500-opacity:.44;--spectrum-transparent-black-500:rgba(var(--spectrum-transparent-black-500-rgb),var(--spectrum-transparent-black-500-opacity));--spectrum-transparent-black-600-rgb:0,0,0;--spectrum-transparent-black-600-opacity:.56;--spectrum-transparent-black-600:rgba(var(--spectrum-transparent-black-600-rgb),var(--spectrum-transparent-black-600-opacity));--spectrum-transparent-black-700-rgb:0,0,0;--spectrum-transparent-black-700-opacity:.69;--spectrum-transparent-black-700:rgba(var(--spectrum-transparent-black-700-rgb),var(--spectrum-transparent-black-700-opacity));--spectrum-transparent-black-800-rgb:0,0,0;--spectrum-transparent-black-800-opacity:.84;--spectrum-transparent-black-800:rgba(var(--spectrum-transparent-black-800-rgb),var(--spectrum-transparent-black-800-opacity));--spectrum-transparent-black-900-rgb:0,0,0;--spectrum-transparent-black-900-opacity:.93;--spectrum-transparent-black-900:rgba(var(--spectrum-transparent-black-900-rgb),var(--spectrum-transparent-black-900-opacity));--spectrum-gray-25-rgb:17,17,17;--spectrum-gray-25:rgba(var(--spectrum-gray-25-rgb));--spectrum-gray-50-rgb:27,27,27;--spectrum-gray-50:rgba(var(--spectrum-gray-50-rgb));--spectrum-gray-75-rgb:34,34,34;--spectrum-gray-75:rgba(var(--spectrum-gray-75-rgb));--spectrum-gray-100-rgb:44,44,44;--spectrum-gray-100:rgba(var(--spectrum-gray-100-rgb));--spectrum-gray-200-rgb:50,50,50;--spectrum-gray-200:rgba(var(--spectrum-gray-200-rgb));--spectrum-gray-300-rgb:57,57,57;--spectrum-gray-300:rgba(var(--spectrum-gray-300-rgb));--spectrum-gray-400-rgb:68,68,68;--spectrum-gray-400:rgba(var(--spectrum-gray-400-rgb));--spectrum-gray-500-rgb:109,109,109;--spectrum-gray-500:rgba(var(--spectrum-gray-500-rgb));--spectrum-gray-600-rgb:138,138,138;--spectrum-gray-600:rgba(var(--spectrum-gray-600-rgb));--spectrum-gray-700-rgb:175,175,175;--spectrum-gray-700:rgba(var(--spectrum-gray-700-rgb));--spectrum-gray-800-rgb:219,219,219;--spectrum-gray-800:rgba(var(--spectrum-gray-800-rgb));--spectrum-gray-900-rgb:242,242,242;--spectrum-gray-900:rgba(var(--spectrum-gray-900-rgb));--spectrum-gray-1000-rgb:255,255,255;--spectrum-gray-1000:rgba(var(--spectrum-gray-1000-rgb));--spectrum-blue-100-rgb:14,23,63;--spectrum-blue-100:rgba(var(--spectrum-blue-100-rgb));--spectrum-blue-200-rgb:15,28,82;--spectrum-blue-200:rgba(var(--spectrum-blue-200-rgb));--spectrum-blue-300-rgb:12,33,117;--spectrum-blue-300:rgba(var(--spectrum-blue-300-rgb));--spectrum-blue-400-rgb:18,45,154;--spectrum-blue-400:rgba(var(--spectrum-blue-400-rgb));--spectrum-blue-500-rgb:26,58,195;--spectrum-blue-500:rgba(var(--spectrum-blue-500-rgb));--spectrum-blue-600-rgb:37,73,229;--spectrum-blue-600:rgba(var(--spectrum-blue-600-rgb));--spectrum-blue-700-rgb:52,91,248;--spectrum-blue-700:rgba(var(--spectrum-blue-700-rgb));--spectrum-blue-800-rgb:64,105,253;--spectrum-blue-800:rgba(var(--spectrum-blue-800-rgb));--spectrum-blue-900-rgb:86,129,255;--spectrum-blue-900:rgba(var(--spectrum-blue-900-rgb));--spectrum-blue-1000-rgb:105,149,254;--spectrum-blue-1000:rgba(var(--spectrum-blue-1000-rgb));--spectrum-blue-1100-rgb:124,169,252;--spectrum-blue-1100:rgba(var(--spectrum-blue-1100-rgb));--spectrum-blue-1200-rgb:152,192,252;--spectrum-blue-1200:rgba(var(--spectrum-blue-1200-rgb));--spectrum-blue-1300-rgb:181,213,253;--spectrum-blue-1300:rgba(var(--spectrum-blue-1300-rgb));--spectrum-blue-1400-rgb:213,231,254;--spectrum-blue-1400:rgba(var(--spectrum-blue-1400-rgb));--spectrum-blue-1500-rgb:238,245,255;--spectrum-blue-1500:rgba(var(--spectrum-blue-1500-rgb));--spectrum-blue-1600-rgb:255,255,255;--spectrum-blue-1600:rgba(var(--spectrum-blue-1600-rgb));--spectrum-red-100-rgb:54,10,3;--spectrum-red-100:rgba(var(--spectrum-red-100-rgb));--spectrum-red-200-rgb:68,13,5;--spectrum-red-200:rgba(var(--spectrum-red-200-rgb));--spectrum-red-300-rgb:87,17,7;--spectrum-red-300:rgba(var(--spectrum-red-300-rgb));--spectrum-red-400-rgb:115,24,11;--spectrum-red-400:rgba(var(--spectrum-red-400-rgb));--spectrum-red-500-rgb:147,31,17;--spectrum-red-500:rgba(var(--spectrum-red-500-rgb));--spectrum-red-600-rgb:177,38,23;--spectrum-red-600:rgba(var(--spectrum-red-600-rgb));--spectrum-red-700-rgb:205,46,29;--spectrum-red-700:rgba(var(--spectrum-red-700-rgb));--spectrum-red-800-rgb:223,52,34;--spectrum-red-800:rgba(var(--spectrum-red-800-rgb));--spectrum-red-900-rgb:252,67,46;--spectrum-red-900:rgba(var(--spectrum-red-900-rgb));--spectrum-red-1000-rgb:255,103,86;--spectrum-red-1000:rgba(var(--spectrum-red-1000-rgb));--spectrum-red-1100-rgb:255,134,120;--spectrum-red-1100:rgba(var(--spectrum-red-1100-rgb));--spectrum-red-1200-rgb:255,167,157;--spectrum-red-1200:rgba(var(--spectrum-red-1200-rgb));--spectrum-red-1300-rgb:255,196,189;--spectrum-red-1300:rgba(var(--spectrum-red-1300-rgb));--spectrum-red-1400-rgb:255,222,219;--spectrum-red-1400:rgba(var(--spectrum-red-1400-rgb));--spectrum-red-1500-rgb:255,242,240;--spectrum-red-1500:rgba(var(--spectrum-red-1500-rgb));--spectrum-red-1600-rgb:255,255,255;--spectrum-red-1600:rgba(var(--spectrum-red-1600-rgb));--spectrum-orange-100-rgb:49,16,0;--spectrum-orange-100:rgba(var(--spectrum-orange-100-rgb));--spectrum-orange-200-rgb:61,21,0;--spectrum-orange-200:rgba(var(--spectrum-orange-200-rgb));--spectrum-orange-300-rgb:80,27,0;--spectrum-orange-300:rgba(var(--spectrum-orange-300-rgb));--spectrum-orange-400-rgb:106,36,0;--spectrum-orange-400:rgba(var(--spectrum-orange-400-rgb));--spectrum-orange-500-rgb:135,47,0;--spectrum-orange-500:rgba(var(--spectrum-orange-500-rgb));--spectrum-orange-600-rgb:162,59,0;--spectrum-orange-600:rgba(var(--spectrum-orange-600-rgb));--spectrum-orange-700-rgb:185,73,0;--spectrum-orange-700:rgba(var(--spectrum-orange-700-rgb));--spectrum-orange-800-rgb:199,82,0;--spectrum-orange-800:rgba(var(--spectrum-orange-800-rgb));--spectrum-orange-900-rgb:224,100,0;--spectrum-orange-900:rgba(var(--spectrum-orange-900-rgb));--spectrum-orange-1000-rgb:243,117,0;--spectrum-orange-1000:rgba(var(--spectrum-orange-1000-rgb));--spectrum-orange-1100-rgb:255,137,0;--spectrum-orange-1100:rgba(var(--spectrum-orange-1100-rgb));--spectrum-orange-1200-rgb:255,173,45;--spectrum-orange-1200:rgba(var(--spectrum-orange-1200-rgb));--spectrum-orange-1300-rgb:255,201,116;--spectrum-orange-1300:rgba(var(--spectrum-orange-1300-rgb));--spectrum-orange-1400-rgb:255,225,178;--spectrum-orange-1400:rgba(var(--spectrum-orange-1400-rgb));--spectrum-orange-1500-rgb:255,243,225;--spectrum-orange-1500:rgba(var(--spectrum-orange-1500-rgb));--spectrum-orange-1600-rgb:255,255,255;--spectrum-orange-1600:rgba(var(--spectrum-orange-1600-rgb));--spectrum-yellow-100-rgb:37,23,0;--spectrum-yellow-100:rgba(var(--spectrum-yellow-100-rgb));--spectrum-yellow-200-rgb:47,29,0;--spectrum-yellow-200:rgba(var(--spectrum-yellow-200-rgb));--spectrum-yellow-300-rgb:61,39,0;--spectrum-yellow-300:rgba(var(--spectrum-yellow-300-rgb));--spectrum-yellow-400-rgb:83,52,0;--spectrum-yellow-400:rgba(var(--spectrum-yellow-400-rgb));--spectrum-yellow-500-rgb:107,67,0;--spectrum-yellow-500:rgba(var(--spectrum-yellow-500-rgb));--spectrum-yellow-600-rgb:130,82,0;--spectrum-yellow-600:rgba(var(--spectrum-yellow-600-rgb));--spectrum-yellow-700-rgb:151,97,0;--spectrum-yellow-700:rgba(var(--spectrum-yellow-700-rgb));--spectrum-yellow-800-rgb:164,106,0;--spectrum-yellow-800:rgba(var(--spectrum-yellow-800-rgb));--spectrum-yellow-900-rgb:186,124,0;--spectrum-yellow-900:rgba(var(--spectrum-yellow-900-rgb));--spectrum-yellow-1000-rgb:203,141,0;--spectrum-yellow-1000:rgba(var(--spectrum-yellow-1000-rgb));--spectrum-yellow-1100-rgb:218,159,0;--spectrum-yellow-1100:rgba(var(--spectrum-yellow-1100-rgb));--spectrum-yellow-1200-rgb:235,183,0;--spectrum-yellow-1200:rgba(var(--spectrum-yellow-1200-rgb));--spectrum-yellow-1300-rgb:249,206,0;--spectrum-yellow-1300:rgba(var(--spectrum-yellow-1300-rgb));--spectrum-yellow-1400-rgb:255,230,86;--spectrum-yellow-1400:rgba(var(--spectrum-yellow-1400-rgb));--spectrum-yellow-1500-rgb:255,246,195;--spectrum-yellow-1500:rgba(var(--spectrum-yellow-1500-rgb));--spectrum-yellow-1600-rgb:255,255,255;--spectrum-yellow-1600:rgba(var(--spectrum-yellow-1600-rgb));--spectrum-chartreuse-100-rgb:23,28,0;--spectrum-chartreuse-100:rgba(var(--spectrum-chartreuse-100-rgb));--spectrum-chartreuse-200-rgb:30,36,0;--spectrum-chartreuse-200:rgba(var(--spectrum-chartreuse-200-rgb));--spectrum-chartreuse-300-rgb:39,47,0;--spectrum-chartreuse-300:rgba(var(--spectrum-chartreuse-300-rgb));--spectrum-chartreuse-400-rgb:53,63,0;--spectrum-chartreuse-400:rgba(var(--spectrum-chartreuse-400-rgb));--spectrum-chartreuse-500-rgb:68,82,0;--spectrum-chartreuse-500:rgba(var(--spectrum-chartreuse-500-rgb));--spectrum-chartreuse-600-rgb:83,100,0;--spectrum-chartreuse-600:rgba(var(--spectrum-chartreuse-600-rgb));--spectrum-chartreuse-700-rgb:97,116,0;--spectrum-chartreuse-700:rgba(var(--spectrum-chartreuse-700-rgb));--spectrum-chartreuse-800-rgb:106,127,0;--spectrum-chartreuse-800:rgba(var(--spectrum-chartreuse-800-rgb));--spectrum-chartreuse-900-rgb:122,147,0;--spectrum-chartreuse-900:rgba(var(--spectrum-chartreuse-900-rgb));--spectrum-chartreuse-1000-rgb:136,164,0;--spectrum-chartreuse-1000:rgba(var(--spectrum-chartreuse-1000-rgb));--spectrum-chartreuse-1100-rgb:151,181,0;--spectrum-chartreuse-1100:rgba(var(--spectrum-chartreuse-1100-rgb));--spectrum-chartreuse-1200-rgb:169,203,0;--spectrum-chartreuse-1200:rgba(var(--spectrum-chartreuse-1200-rgb));--spectrum-chartreuse-1300-rgb:187,225,0;--spectrum-chartreuse-1300:rgba(var(--spectrum-chartreuse-1300-rgb));--spectrum-chartreuse-1400-rgb:219,240,117;--spectrum-chartreuse-1400:rgba(var(--spectrum-chartreuse-1400-rgb));--spectrum-chartreuse-1500-rgb:242,249,206;--spectrum-chartreuse-1500:rgba(var(--spectrum-chartreuse-1500-rgb));--spectrum-chartreuse-1600-rgb:255,255,255;--spectrum-chartreuse-1600:rgba(var(--spectrum-chartreuse-1600-rgb));--spectrum-celery-100-rgb:11,31,0;--spectrum-celery-100:rgba(var(--spectrum-celery-100-rgb));--spectrum-celery-200-rgb:15,38,0;--spectrum-celery-200:rgba(var(--spectrum-celery-200-rgb));--spectrum-celery-300-rgb:21,51,1;--spectrum-celery-300:rgba(var(--spectrum-celery-300-rgb));--spectrum-celery-400-rgb:31,67,4;--spectrum-celery-400:rgba(var(--spectrum-celery-400-rgb));--spectrum-celery-500-rgb:41,86,8;--spectrum-celery-500:rgba(var(--spectrum-celery-500-rgb));--spectrum-celery-600-rgb:50,105,11;--spectrum-celery-600:rgba(var(--spectrum-celery-600-rgb));--spectrum-celery-700-rgb:60,122,15;--spectrum-celery-700:rgba(var(--spectrum-celery-700-rgb));--spectrum-celery-800-rgb:66,134,18;--spectrum-celery-800:rgba(var(--spectrum-celery-800-rgb));--spectrum-celery-900-rgb:78,154,23;--spectrum-celery-900:rgba(var(--spectrum-celery-900-rgb));--spectrum-celery-1000-rgb:88,172,28;--spectrum-celery-1000:rgba(var(--spectrum-celery-1000-rgb));--spectrum-celery-1100-rgb:100,190,35;--spectrum-celery-1100:rgba(var(--spectrum-celery-1100-rgb));--spectrum-celery-1200-rgb:116,213,46;--spectrum-celery-1200:rgba(var(--spectrum-celery-1200-rgb));--spectrum-celery-1300-rgb:136,234,65;--spectrum-celery-1300:rgba(var(--spectrum-celery-1300-rgb));--spectrum-celery-1400-rgb:170,251,112;--spectrum-celery-1400:rgba(var(--spectrum-celery-1400-rgb));--spectrum-celery-1500-rgb:222,255,198;--spectrum-celery-1500:rgba(var(--spectrum-celery-1500-rgb));--spectrum-celery-1600-rgb:255,255,255;--spectrum-celery-1600:rgba(var(--spectrum-celery-1600-rgb));--spectrum-green-100-rgb:0,30,23;--spectrum-green-100:rgba(var(--spectrum-green-100-rgb));--spectrum-green-200-rgb:0,38,29;--spectrum-green-200:rgba(var(--spectrum-green-200-rgb));--spectrum-green-300-rgb:0,51,38;--spectrum-green-300:rgba(var(--spectrum-green-300-rgb));--spectrum-green-400-rgb:0,68,48;--spectrum-green-400:rgba(var(--spectrum-green-400-rgb));--spectrum-green-500-rgb:2,87,58;--spectrum-green-500:rgba(var(--spectrum-green-500-rgb));--spectrum-green-600-rgb:3,106,67;--spectrum-green-600:rgba(var(--spectrum-green-600-rgb));--spectrum-green-700-rgb:4,124,75;--spectrum-green-700:rgba(var(--spectrum-green-700-rgb));--spectrum-green-800-rgb:6,136,80;--spectrum-green-800:rgba(var(--spectrum-green-800-rgb));--spectrum-green-900-rgb:9,157,89;--spectrum-green-900:rgba(var(--spectrum-green-900-rgb));--spectrum-green-1000-rgb:14,175,98;--spectrum-green-1000:rgba(var(--spectrum-green-1000-rgb));--spectrum-green-1100-rgb:24,193,110;--spectrum-green-1100:rgba(var(--spectrum-green-1100-rgb));--spectrum-green-1200-rgb:57,215,134;--spectrum-green-1200:rgba(var(--spectrum-green-1200-rgb));--spectrum-green-1300-rgb:126,231,172;--spectrum-green-1300:rgba(var(--spectrum-green-1300-rgb));--spectrum-green-1400-rgb:189,241,208;--spectrum-green-1400:rgba(var(--spectrum-green-1400-rgb));--spectrum-green-1500-rgb:229,250,236;--spectrum-green-1500:rgba(var(--spectrum-green-1500-rgb));--spectrum-green-1600-rgb:255,255,255;--spectrum-green-1600:rgba(var(--spectrum-green-1600-rgb));--spectrum-seafoam-100-rgb:0,30,27;--spectrum-seafoam-100:rgba(var(--spectrum-seafoam-100-rgb));--spectrum-seafoam-200-rgb:0,39,35;--spectrum-seafoam-200:rgba(var(--spectrum-seafoam-200-rgb));--spectrum-seafoam-300-rgb:0,50,44;--spectrum-seafoam-300:rgba(var(--spectrum-seafoam-300-rgb));--spectrum-seafoam-400-rgb:0,67,59;--spectrum-seafoam-400:rgba(var(--spectrum-seafoam-400-rgb));--spectrum-seafoam-500-rgb:2,86,75;--spectrum-seafoam-500:rgba(var(--spectrum-seafoam-500-rgb));--spectrum-seafoam-600-rgb:4,105,89;--spectrum-seafoam-600:rgba(var(--spectrum-seafoam-600-rgb));--spectrum-seafoam-700-rgb:6,122,103;--spectrum-seafoam-700:rgba(var(--spectrum-seafoam-700-rgb));--spectrum-seafoam-800-rgb:8,134,112;--spectrum-seafoam-800:rgba(var(--spectrum-seafoam-800-rgb));--spectrum-seafoam-900-rgb:10,154,128;--spectrum-seafoam-900:rgba(var(--spectrum-seafoam-900-rgb));--spectrum-seafoam-1000-rgb:12,173,142;--spectrum-seafoam-1000:rgba(var(--spectrum-seafoam-1000-rgb));--spectrum-seafoam-1100-rgb:14,190,156;--spectrum-seafoam-1100:rgba(var(--spectrum-seafoam-1100-rgb));--spectrum-seafoam-1200-rgb:29,214,176;--spectrum-seafoam-1200:rgba(var(--spectrum-seafoam-1200-rgb));--spectrum-seafoam-1300-rgb:122,229,203;--spectrum-seafoam-1300:rgba(var(--spectrum-seafoam-1300-rgb));--spectrum-seafoam-1400-rgb:186,241,222;--spectrum-seafoam-1400:rgba(var(--spectrum-seafoam-1400-rgb));--spectrum-seafoam-1500-rgb:229,249,243;--spectrum-seafoam-1500:rgba(var(--spectrum-seafoam-1500-rgb));--spectrum-seafoam-1600-rgb:255,255,255;--spectrum-seafoam-1600:rgba(var(--spectrum-seafoam-1600-rgb));--spectrum-cyan-100-rgb:0,29,39;--spectrum-cyan-100:rgba(var(--spectrum-cyan-100-rgb));--spectrum-cyan-200-rgb:0,36,49;--spectrum-cyan-200:rgba(var(--spectrum-cyan-200-rgb));--spectrum-cyan-300-rgb:0,48,65;--spectrum-cyan-300:rgba(var(--spectrum-cyan-300-rgb));--spectrum-cyan-400-rgb:0,64,88;--spectrum-cyan-400:rgba(var(--spectrum-cyan-400-rgb));--spectrum-cyan-500-rgb:0,82,113;--spectrum-cyan-500:rgba(var(--spectrum-cyan-500-rgb));--spectrum-cyan-600-rgb:3,99,140;--spectrum-cyan-600:rgba(var(--spectrum-cyan-600-rgb));--spectrum-cyan-700-rgb:8,115,168;--spectrum-cyan-700:rgba(var(--spectrum-cyan-700-rgb));--spectrum-cyan-800-rgb:13,125,186;--spectrum-cyan-800:rgba(var(--spectrum-cyan-800-rgb));--spectrum-cyan-900-rgb:24,142,220;--spectrum-cyan-900:rgba(var(--spectrum-cyan-900-rgb));--spectrum-cyan-1000-rgb:38,159,244;--spectrum-cyan-1000:rgba(var(--spectrum-cyan-1000-rgb));--spectrum-cyan-1100-rgb:63,177,255;--spectrum-cyan-1100:rgba(var(--spectrum-cyan-1100-rgb));--spectrum-cyan-1200-rgb:107,199,255;--spectrum-cyan-1200:rgba(var(--spectrum-cyan-1200-rgb));--spectrum-cyan-1300-rgb:152,219,255;--spectrum-cyan-1300:rgba(var(--spectrum-cyan-1300-rgb));--spectrum-cyan-1400-rgb:195,236,252;--spectrum-cyan-1400:rgba(var(--spectrum-cyan-1400-rgb));--spectrum-cyan-1500-rgb:230,248,253;--spectrum-cyan-1500:rgba(var(--spectrum-cyan-1500-rgb));--spectrum-cyan-1600-rgb:255,255,255;--spectrum-cyan-1600:rgba(var(--spectrum-cyan-1600-rgb));--spectrum-indigo-100-rgb:30,0,93;--spectrum-indigo-100:rgba(var(--spectrum-indigo-100-rgb));--spectrum-indigo-200-rgb:35,0,110;--spectrum-indigo-200:rgba(var(--spectrum-indigo-200-rgb));--spectrum-indigo-300-rgb:47,0,140;--spectrum-indigo-300:rgba(var(--spectrum-indigo-300-rgb));--spectrum-indigo-400-rgb:62,12,174;--spectrum-indigo-400:rgba(var(--spectrum-indigo-400-rgb));--spectrum-indigo-500-rgb:79,30,209;--spectrum-indigo-500:rgba(var(--spectrum-indigo-500-rgb));--spectrum-indigo-600-rgb:95,52,235;--spectrum-indigo-600:rgba(var(--spectrum-indigo-600-rgb));--spectrum-indigo-700-rgb:109,75,248;--spectrum-indigo-700:rgba(var(--spectrum-indigo-700-rgb));--spectrum-indigo-800-rgb:116,91,252;--spectrum-indigo-800:rgba(var(--spectrum-indigo-800-rgb));--spectrum-indigo-900-rgb:128,119,254;--spectrum-indigo-900:rgba(var(--spectrum-indigo-900-rgb));--spectrum-indigo-1000-rgb:139,141,254;--spectrum-indigo-1000:rgba(var(--spectrum-indigo-1000-rgb));--spectrum-indigo-1100-rgb:153,161,255;--spectrum-indigo-1100:rgba(var(--spectrum-indigo-1100-rgb));--spectrum-indigo-1200-rgb:176,186,255;--spectrum-indigo-1200:rgba(var(--spectrum-indigo-1200-rgb));--spectrum-indigo-1300-rgb:199,208,255;--spectrum-indigo-1300:rgba(var(--spectrum-indigo-1300-rgb));--spectrum-indigo-1400-rgb:223,228,255;--spectrum-indigo-1400:rgba(var(--spectrum-indigo-1400-rgb));--spectrum-indigo-1500-rgb:243,244,255;--spectrum-indigo-1500:rgba(var(--spectrum-indigo-1500-rgb));--spectrum-indigo-1600-rgb:255,255,255;--spectrum-indigo-1600:rgba(var(--spectrum-indigo-1600-rgb));--spectrum-purple-100-rgb:41,0,79;--spectrum-purple-100:rgba(var(--spectrum-purple-100-rgb));--spectrum-purple-200-rgb:50,0,96;--spectrum-purple-200:rgba(var(--spectrum-purple-200-rgb));--spectrum-purple-300-rgb:64,0,122;--spectrum-purple-300:rgba(var(--spectrum-purple-300-rgb));--spectrum-purple-400-rgb:83,0,159;--spectrum-purple-400:rgba(var(--spectrum-purple-400-rgb));--spectrum-purple-500-rgb:107,6,195;--spectrum-purple-500:rgba(var(--spectrum-purple-500-rgb));--spectrum-purple-600-rgb:130,34,215;--spectrum-purple-600:rgba(var(--spectrum-purple-600-rgb));--spectrum-purple-700-rgb:148,62,224;--spectrum-purple-700:rgba(var(--spectrum-purple-700-rgb));--spectrum-purple-800-rgb:157,78,228;--spectrum-purple-800:rgba(var(--spectrum-purple-800-rgb));--spectrum-purple-900-rgb:173,105,233;--spectrum-purple-900:rgba(var(--spectrum-purple-900-rgb));--spectrum-purple-1000-rgb:186,127,237;--spectrum-purple-1000:rgba(var(--spectrum-purple-1000-rgb));--spectrum-purple-1100-rgb:197,149,240;--spectrum-purple-1100:rgba(var(--spectrum-purple-1100-rgb));--spectrum-purple-1200-rgb:212,176,244;--spectrum-purple-1200:rgba(var(--spectrum-purple-1200-rgb));--spectrum-purple-1300-rgb:225,201,247;--spectrum-purple-1300:rgba(var(--spectrum-purple-1300-rgb));--spectrum-purple-1400-rgb:238,224,250;--spectrum-purple-1400:rgba(var(--spectrum-purple-1400-rgb));--spectrum-purple-1500-rgb:248,243,253;--spectrum-purple-1500:rgba(var(--spectrum-purple-1500-rgb));--spectrum-purple-1600-rgb:255,255,255;--spectrum-purple-1600:rgba(var(--spectrum-purple-1600-rgb));--spectrum-fuchsia-100-rgb:50,0,61;--spectrum-fuchsia-100:rgba(var(--spectrum-fuchsia-100-rgb));--spectrum-fuchsia-200-rgb:61,0,74;--spectrum-fuchsia-200:rgba(var(--spectrum-fuchsia-200-rgb));--spectrum-fuchsia-300-rgb:79,0,95;--spectrum-fuchsia-300:rgba(var(--spectrum-fuchsia-300-rgb));--spectrum-fuchsia-400-rgb:102,9,120;--spectrum-fuchsia-400:rgba(var(--spectrum-fuchsia-400-rgb));--spectrum-fuchsia-500-rgb:127,23,146;--spectrum-fuchsia-500:rgba(var(--spectrum-fuchsia-500-rgb));--spectrum-fuchsia-600-rgb:151,38,170;--spectrum-fuchsia-600:rgba(var(--spectrum-fuchsia-600-rgb));--spectrum-fuchsia-700-rgb:173,51,192;--spectrum-fuchsia-700:rgba(var(--spectrum-fuchsia-700-rgb));--spectrum-fuchsia-800-rgb:186,60,206;--spectrum-fuchsia-800:rgba(var(--spectrum-fuchsia-800-rgb));--spectrum-fuchsia-900-rgb:213,73,235;--spectrum-fuchsia-900:rgba(var(--spectrum-fuchsia-900-rgb));--spectrum-fuchsia-1000-rgb:232,91,253;--spectrum-fuchsia-1000:rgba(var(--spectrum-fuchsia-1000-rgb));--spectrum-fuchsia-1100-rgb:240,122,255;--spectrum-fuchsia-1100:rgba(var(--spectrum-fuchsia-1100-rgb));--spectrum-fuchsia-1200-rgb:245,159,255;--spectrum-fuchsia-1200:rgba(var(--spectrum-fuchsia-1200-rgb));--spectrum-fuchsia-1300-rgb:248,191,255;--spectrum-fuchsia-1300:rgba(var(--spectrum-fuchsia-1300-rgb));--spectrum-fuchsia-1400-rgb:251,219,255;--spectrum-fuchsia-1400:rgba(var(--spectrum-fuchsia-1400-rgb));--spectrum-fuchsia-1500-rgb:253,241,255;--spectrum-fuchsia-1500:rgba(var(--spectrum-fuchsia-1500-rgb));--spectrum-fuchsia-1600-rgb:255,255,255;--spectrum-fuchsia-1600:rgba(var(--spectrum-fuchsia-1600-rgb));--spectrum-magenta-100-rgb:59,0,22;--spectrum-magenta-100:rgba(var(--spectrum-magenta-100-rgb));--spectrum-magenta-200-rgb:74,0,27;--spectrum-magenta-200:rgba(var(--spectrum-magenta-200-rgb));--spectrum-magenta-300-rgb:93,0,34;--spectrum-magenta-300:rgba(var(--spectrum-magenta-300-rgb));--spectrum-magenta-400-rgb:123,0,45;--spectrum-magenta-400:rgba(var(--spectrum-magenta-400-rgb));--spectrum-magenta-500-rgb:152,7,60;--spectrum-magenta-500:rgba(var(--spectrum-magenta-500-rgb));--spectrum-magenta-600-rgb:181,19,76;--spectrum-magenta-600:rgba(var(--spectrum-magenta-600-rgb));--spectrum-magenta-700-rgb:207,31,92;--spectrum-magenta-700:rgba(var(--spectrum-magenta-700-rgb));--spectrum-magenta-800-rgb:224,38,101;--spectrum-magenta-800:rgba(var(--spectrum-magenta-800-rgb));--spectrum-magenta-900-rgb:255,51,119;--spectrum-magenta-900:rgba(var(--spectrum-magenta-900-rgb));--spectrum-magenta-1000-rgb:255,96,149;--spectrum-magenta-1000:rgba(var(--spectrum-magenta-1000-rgb));--spectrum-magenta-1100-rgb:255,128,171;--spectrum-magenta-1100:rgba(var(--spectrum-magenta-1100-rgb));--spectrum-magenta-1200-rgb:255,163,194;--spectrum-magenta-1200:rgba(var(--spectrum-magenta-1200-rgb));--spectrum-magenta-1300-rgb:255,193,214;--spectrum-magenta-1300:rgba(var(--spectrum-magenta-1300-rgb));--spectrum-magenta-1400-rgb:255,220,232;--spectrum-magenta-1400:rgba(var(--spectrum-magenta-1400-rgb));--spectrum-magenta-1500-rgb:255,241,246;--spectrum-magenta-1500:rgba(var(--spectrum-magenta-1500-rgb));--spectrum-magenta-1600-rgb:255,255,255;--spectrum-magenta-1600:rgba(var(--spectrum-magenta-1600-rgb));--spectrum-pink-100-rgb:58,0,37;--spectrum-pink-100:rgba(var(--spectrum-pink-100-rgb));--spectrum-pink-200-rgb:71,0,44;--spectrum-pink-200:rgba(var(--spectrum-pink-200-rgb));--spectrum-pink-300-rgb:90,0,57;--spectrum-pink-300:rgba(var(--spectrum-pink-300-rgb));--spectrum-pink-400-rgb:115,7,75;--spectrum-pink-400:rgba(var(--spectrum-pink-400-rgb));--spectrum-pink-500-rgb:143,18,97;--spectrum-pink-500:rgba(var(--spectrum-pink-500-rgb));--spectrum-pink-600-rgb:171,29,119;--spectrum-pink-600:rgba(var(--spectrum-pink-600-rgb));--spectrum-pink-700-rgb:196,39,138;--spectrum-pink-700:rgba(var(--spectrum-pink-700-rgb));--spectrum-pink-800-rgb:213,45,151;--spectrum-pink-800:rgba(var(--spectrum-pink-800-rgb));--spectrum-pink-900-rgb:236,67,175;--spectrum-pink-900:rgba(var(--spectrum-pink-900-rgb));--spectrum-pink-1000-rgb:251,90,196;--spectrum-pink-1000:rgba(var(--spectrum-pink-1000-rgb));--spectrum-pink-1100-rgb:255,122,210;--spectrum-pink-1100:rgba(var(--spectrum-pink-1100-rgb));--spectrum-pink-1200-rgb:255,159,223;--spectrum-pink-1200:rgba(var(--spectrum-pink-1200-rgb));--spectrum-pink-1300-rgb:255,191,234;--spectrum-pink-1300:rgba(var(--spectrum-pink-1300-rgb));--spectrum-pink-1400-rgb:255,219,243;--spectrum-pink-1400:rgba(var(--spectrum-pink-1400-rgb));--spectrum-pink-1500-rgb:255,241,250;--spectrum-pink-1500:rgba(var(--spectrum-pink-1500-rgb));--spectrum-pink-1600-rgb:255,255,255;--spectrum-pink-1600:rgba(var(--spectrum-pink-1600-rgb));--spectrum-turquoise-100-rgb:0,30,33;--spectrum-turquoise-100:rgba(var(--spectrum-turquoise-100-rgb));--spectrum-turquoise-200-rgb:0,37,41;--spectrum-turquoise-200:rgba(var(--spectrum-turquoise-200-rgb));--spectrum-turquoise-300-rgb:0,49,54;--spectrum-turquoise-300:rgba(var(--spectrum-turquoise-300-rgb));--spectrum-turquoise-400-rgb:0,66,72;--spectrum-turquoise-400:rgba(var(--spectrum-turquoise-400-rgb));--spectrum-turquoise-500-rgb:3,84,92;--spectrum-turquoise-500:rgba(var(--spectrum-turquoise-500-rgb));--spectrum-turquoise-600-rgb:5,103,112;--spectrum-turquoise-600:rgba(var(--spectrum-turquoise-600-rgb));--spectrum-turquoise-700-rgb:7,120,131;--spectrum-turquoise-700:rgba(var(--spectrum-turquoise-700-rgb));--spectrum-turquoise-800-rgb:9,131,142;--spectrum-turquoise-800:rgba(var(--spectrum-turquoise-800-rgb));--spectrum-turquoise-900-rgb:11,151,164;--spectrum-turquoise-900:rgba(var(--spectrum-turquoise-900-rgb));--spectrum-turquoise-1000-rgb:13,168,182;--spectrum-turquoise-1000:rgba(var(--spectrum-turquoise-1000-rgb));--spectrum-turquoise-1100-rgb:16,186,202;--spectrum-turquoise-1100:rgba(var(--spectrum-turquoise-1100-rgb));--spectrum-turquoise-1200-rgb:64,208,220;--spectrum-turquoise-1200:rgba(var(--spectrum-turquoise-1200-rgb));--spectrum-turquoise-1300-rgb:128,225,231;--spectrum-turquoise-1300:rgba(var(--spectrum-turquoise-1300-rgb));--spectrum-turquoise-1400-rgb:183,240,240;--spectrum-turquoise-1400:rgba(var(--spectrum-turquoise-1400-rgb));--spectrum-turquoise-1500-rgb:228,249,249;--spectrum-turquoise-1500:rgba(var(--spectrum-turquoise-1500-rgb));--spectrum-turquoise-1600-rgb:255,255,255;--spectrum-turquoise-1600:rgba(var(--spectrum-turquoise-1600-rgb));--spectrum-brown-100-rgb:35,24,8;--spectrum-brown-100:rgba(var(--spectrum-brown-100-rgb));--spectrum-brown-200-rgb:44,31,11;--spectrum-brown-200:rgba(var(--spectrum-brown-200-rgb));--spectrum-brown-300-rgb:58,40,14;--spectrum-brown-300:rgba(var(--spectrum-brown-300-rgb));--spectrum-brown-400-rgb:78,55,19;--spectrum-brown-400:rgba(var(--spectrum-brown-400-rgb));--spectrum-brown-500-rgb:98,71,30;--spectrum-brown-500:rgba(var(--spectrum-brown-500-rgb));--spectrum-brown-600-rgb:115,88,47;--spectrum-brown-600:rgba(var(--spectrum-brown-600-rgb));--spectrum-brown-700-rgb:132,104,61;--spectrum-brown-700:rgba(var(--spectrum-brown-700-rgb));--spectrum-brown-800-rgb:143,114,69;--spectrum-brown-800:rgba(var(--spectrum-brown-800-rgb));--spectrum-brown-900-rgb:163,132,84;--spectrum-brown-900:rgba(var(--spectrum-brown-900-rgb));--spectrum-brown-1000-rgb:181,147,98;--spectrum-brown-1000:rgba(var(--spectrum-brown-1000-rgb));--spectrum-brown-1100-rgb:199,163,112;--spectrum-brown-1100:rgba(var(--spectrum-brown-1100-rgb));--spectrum-brown-1200-rgb:222,185,130;--spectrum-brown-1200:rgba(var(--spectrum-brown-1200-rgb));--spectrum-brown-1300-rgb:232,207,169;--spectrum-brown-1300:rgba(var(--spectrum-brown-1300-rgb));--spectrum-brown-1400-rgb:242,227,206;--spectrum-brown-1400:rgba(var(--spectrum-brown-1400-rgb));--spectrum-brown-1500-rgb:250,244,236;--spectrum-brown-1500:rgba(var(--spectrum-brown-1500-rgb));--spectrum-brown-1600-rgb:255,255,255;--spectrum-brown-1600:rgba(var(--spectrum-brown-1600-rgb));--spectrum-silver-100-rgb:26,26,26;--spectrum-silver-100:rgba(var(--spectrum-silver-100-rgb));--spectrum-silver-200-rgb:33,33,33;--spectrum-silver-200:rgba(var(--spectrum-silver-200-rgb));--spectrum-silver-300-rgb:44,44,44;--spectrum-silver-300:rgba(var(--spectrum-silver-300-rgb));--spectrum-silver-400-rgb:59,59,59;--spectrum-silver-400:rgba(var(--spectrum-silver-400-rgb));--spectrum-silver-500-rgb:76,76,76;--spectrum-silver-500:rgba(var(--spectrum-silver-500-rgb));--spectrum-silver-600-rgb:92,92,92;--spectrum-silver-600:rgba(var(--spectrum-silver-600-rgb));--spectrum-silver-700-rgb:108,108,108;--spectrum-silver-700:rgba(var(--spectrum-silver-700-rgb));--spectrum-silver-800-rgb:118,118,118;--spectrum-silver-800:rgba(var(--spectrum-silver-800-rgb));--spectrum-silver-900-rgb:137,137,137;--spectrum-silver-900:rgba(var(--spectrum-silver-900-rgb));--spectrum-silver-1000-rgb:152,152,152;--spectrum-silver-1000:rgba(var(--spectrum-silver-1000-rgb));--spectrum-silver-1100-rgb:169,169,169;--spectrum-silver-1100:rgba(var(--spectrum-silver-1100-rgb));--spectrum-silver-1200-rgb:190,190,190;--spectrum-silver-1200:rgba(var(--spectrum-silver-1200-rgb));--spectrum-silver-1300-rgb:211,211,211;--spectrum-silver-1300:rgba(var(--spectrum-silver-1300-rgb));--spectrum-silver-1400-rgb:229,229,229;--spectrum-silver-1400:rgba(var(--spectrum-silver-1400-rgb));--spectrum-silver-1500-rgb:244,244,244;--spectrum-silver-1500:rgba(var(--spectrum-silver-1500-rgb));--spectrum-silver-1600-rgb:255,255,255;--spectrum-silver-1600:rgba(var(--spectrum-silver-1600-rgb));--spectrum-cinnamon-100-rgb:48,17,4;--spectrum-cinnamon-100:rgba(var(--spectrum-cinnamon-100-rgb));--spectrum-cinnamon-200-rgb:59,21,5;--spectrum-cinnamon-200:rgba(var(--spectrum-cinnamon-200-rgb));--spectrum-cinnamon-300-rgb:79,28,7;--spectrum-cinnamon-300:rgba(var(--spectrum-cinnamon-300-rgb));--spectrum-cinnamon-400-rgb:100,41,15;--spectrum-cinnamon-400:rgba(var(--spectrum-cinnamon-400-rgb));--spectrum-cinnamon-500-rgb:122,57,28;--spectrum-cinnamon-500:rgba(var(--spectrum-cinnamon-500-rgb));--spectrum-cinnamon-600-rgb:143,74,40;--spectrum-cinnamon-600:rgba(var(--spectrum-cinnamon-600-rgb));--spectrum-cinnamon-700-rgb:163,88,52;--spectrum-cinnamon-700:rgba(var(--spectrum-cinnamon-700-rgb));--spectrum-cinnamon-800-rgb:176,98,59;--spectrum-cinnamon-800:rgba(var(--spectrum-cinnamon-800-rgb));--spectrum-cinnamon-900-rgb:192,119,80;--spectrum-cinnamon-900:rgba(var(--spectrum-cinnamon-900-rgb));--spectrum-cinnamon-1000-rgb:206,136,99;--spectrum-cinnamon-1000:rgba(var(--spectrum-cinnamon-1000-rgb));--spectrum-cinnamon-1100-rgb:220,154,118;--spectrum-cinnamon-1100:rgba(var(--spectrum-cinnamon-1100-rgb));--spectrum-cinnamon-1200-rgb:232,179,149;--spectrum-cinnamon-1200:rgba(var(--spectrum-cinnamon-1200-rgb));--spectrum-cinnamon-1300-rgb:239,203,183;--spectrum-cinnamon-1300:rgba(var(--spectrum-cinnamon-1300-rgb));--spectrum-cinnamon-1400-rgb:246,225,214;--spectrum-cinnamon-1400:rgba(var(--spectrum-cinnamon-1400-rgb));--spectrum-cinnamon-1500-rgb:252,244,239;--spectrum-cinnamon-1500:rgba(var(--spectrum-cinnamon-1500-rgb));--spectrum-cinnamon-1600-rgb:255,255,255;--spectrum-cinnamon-1600:rgba(var(--spectrum-cinnamon-1600-rgb));--spectrum-icon-color-blue-primary-default:var(--spectrum-blue-800);--spectrum-icon-color-green-primary-default:var(--spectrum-green-800);--spectrum-icon-color-red-primary-default:var(--spectrum-red-700);--spectrum-icon-color-yellow-primary-default:var(--spectrum-yellow-1000);--spectrum-negative-subdued-background-color-default:var(--spectrum-negative-subtle-background-color-default);--spectrum-accent-subtle-background-color-default:var(--spectrum-accent-color-300);--spectrum-informative-subtle-background-color-default:var(--spectrum-informative-color-300);--spectrum-positive-subtle-background-color-default:var(--spectrum-positive-color-300);--spectrum-notice-subtle-background-color-default:var(--spectrum-notice-color-300);--spectrum-negative-subtle-background-color-default:var(--spectrum-negative-color-300);--color-scheme:dark;--spectrum-assetcard-border-color-selected:var(--spectrum-blue-800);--spectrum-assetcard-border-color-selected-hover:var(--spectrum-blue-800);--spectrum-assetcard-border-color-selected-down:var(--spectrum-blue-900);--spectrum-assetcard-selectionindicator-background-color-ordered:var(--spectrum-blue-800);--spectrum-assestcard-focus-indicator-color:var(--spectrum-blue-700);--spectrum-assetlist-item-background-color-selected-hover:rgba(var(--spectrum-blue-800-rgb),.25);--spectrum-assetlist-item-background-color-selected:rgba(var(--spectrum-blue-800-rgb),.15);--spectrum-assetlist-border-color-key-focus:var(--spectrum-blue-700);--spectrum-badge-label-icon-color-primary:var(--spectrum-black);--spectrum-calendar-day-background-color-selected:rgba(var(--spectrum-blue-800-rgb),.15);--spectrum-calendar-day-background-color-hover:rgba(var(--spectrum-white-rgb),.07);--spectrum-calendar-day-today-background-color-selected-hover:rgba(var(--spectrum-blue-800-rgb),.25);--spectrum-calendar-day-background-color-selected-hover:rgba(var(--spectrum-blue-800-rgb),.25);--spectrum-calendar-day-background-color-down:var(--spectrum-transparent-white-200);--spectrum-calendar-day-background-color-cap-selected:rgba(var(--spectrum-blue-800-rgb),.25);--spectrum-calendar-day-background-color-key-focus:rgba(var(--spectrum-white-rgb),.07);--spectrum-calendar-day-border-color-key-focus:var(--spectrum-blue-700);--spectrum-card-selected-background-color-rgb:var(--spectrum-blue-500-rgb);--spectrum-coach-indicator-ring-default-color:var(--spectrum-blue-700);--spectrum-drop-zone-background-color-rgb:var(--spectrum-blue-900-rgb);--spectrum-dropindicator-color:var(--spectrum-blue-700);--spectrum-logic-button-and-background-color:var(--spectrum-blue-800);--spectrum-logic-button-and-border-color:var(--spectrum-blue-800);--spectrum-logic-button-and-background-color-hover:var(--spectrum-blue-1000);--spectrum-logic-button-and-border-color-hover:var(--spectrum-blue-1000);--spectrum-logic-button-or-background-color:var(--spectrum-magenta-700);--spectrum-logic-button-or-border-color:var(--spectrum-magenta-700);--spectrum-logic-button-or-background-color-hover:var(--spectrum-magenta-900);--spectrum-logic-button-or-border-color-hover:var(--spectrum-magenta-900);--spectrum-steplist-current-marker-color-key-focus:var(--spectrum-blue-700);--spectrum-swatch-border-color-rgb:255,255,255;--spectrum-swatch-border-color-opacity:.51;--spectrum-swatch-border-color:rgba(var(--spectrum-swatch-border-color-rgb),var(--spectrum-swatch-border-color-opacity));--spectrum-swatch-border-color-light-rgb:255,255,255;--spectrum-swatch-border-color-light-opacity:.2;--spectrum-swatch-border-color-light:rgba(var(--spectrum-swatch-border-color-light-rgb),var(--spectrum-swatch-border-color-light-opacity));--spectrum-treeview-item-background-color-quiet-selected:rgba(var(--spectrum-gray-900-rgb),.07);--spectrum-treeview-item-background-color-selected:rgba(var(--spectrum-blue-800-rgb),.15)}
`;
var theme_dark_css_default = e8;

// node_modules/@spectrum-web-components/theme/spectrum-two/theme-dark.js
Theme.registerThemeFragment("dark-spectrum-two", "color", theme_dark_css_default);

// src/bundle.js
init_sp_progress_circle();

// src/experience-elements-app.js
init_lit();

// node_modules/@spectrum-web-components/illustrated-message/src/IllustratedMessage.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/illustrated-message/src/illustrated-message.css.js
init_src();
var t6 = i`
    @media (forced-colors:active){:host{--highcontrast-illustrated-message-illustration-color:CanvasText;--highcontrast-illustrated-message-illustration-accent-color:Highlight}}:host{--spectrum-illustrated-message-description-max-inline-size:var(--spectrum-illustrated-message-maximum-width);--spectrum-illustrated-message-heading-max-inline-size:var(--spectrum-illustrated-message-maximum-width);--spectrum-illustrated-message-title-to-heading:var(--spectrum-spacing-400);--spectrum-illustrated-message-heading-to-description:var(--spectrum-spacing-75);--spectrum-illustrated-message-illustration-color:var(--spectrum-neutral-visual-color);--spectrum-illustrated-message-illustration-accent-color:var(--spectrum-accent-visual-color);--spectrum-illustrated-message-title-font-family:var(--spectrum-sans-font-family-stack);--spectrum-illustrated-message-title-font-weight:var(--spectrum-heading-sans-serif-font-weight);--spectrum-illustrated-message-title-font-style:var(--spectrum-heading-sans-serif-font-style);--spectrum-illustrated-message-title-font-size:var(--spectrum-illustrated-message-title-size);--spectrum-illustrated-message-title-line-height:var(--spectrum-heading-line-height);--spectrum-illustrated-message-title-color:var(--spectrum-heading-color);--spectrum-illustrated-message-description-font-family:var(--spectrum-sans-font-family-stack);--spectrum-illustrated-message-description-font-weight:var(--spectrum-body-sans-serif-font-weight);--spectrum-illustrated-message-description-font-style:var(--spectrum-body-sans-serif-font-style);--spectrum-illustrated-message-description-font-size:var(--spectrum-illustrated-message-body-size);--spectrum-illustrated-message-description-line-height:var(--spectrum-body-line-height);--spectrum-illustrated-message-description-color:var(--spectrum-body-color);block-size:100%;display:flex;display:var(--mod-illustrated-message-display,flex);text-align:center;pointer-events:auto;pointer-events:var(--mod-illustrated-message-pointer-events,auto);max-inline-size:var(--mod-illustrated-message-content-maximum-width);flex-direction:column;justify-content:center;align-items:center}:host:lang(ja),:host:lang(ko),:host:lang(zh){--spectrum-illustrated-message-title-font-size:var(--spectrum-illustrated-message-cjk-title-size)}#illustration{color:var(--highcontrast-illustrated-message-illustration-color,var(--mod-illustrated-message-illustration-color,var(--spectrum-illustrated-message-illustration-color)));fill:currentColor;stroke:currentColor;margin-block-end:var(--mod-illustrated-message-title-to-heading,var(--spectrum-illustrated-message-title-to-heading))}.spectrum-IllustratedMessage-accent{color:var(--highcontrast-illustrated-message-illustration-accent-color,var(--mod-illustrated-message-illustration-accent-color,var(--spectrum-illustrated-message-illustration-accent-color)));fill:currentColor;stroke:currentColor}#heading{font-family:var(--mod-illustrated-message-title-font-family,var(--spectrum-illustrated-message-title-font-family));font-weight:var(--mod-illustrated-message-title-font-weight,var(--spectrum-illustrated-message-title-font-weight));font-style:var(--mod-illustrated-message-title-font-style,var(--spectrum-illustrated-message-title-font-style));font-size:var(--mod-illustrated-message-title-font-size,var(--spectrum-illustrated-message-title-font-size));line-height:var(--mod-illustrated-message-title-line-height,var(--spectrum-illustrated-message-title-line-height));color:var(--mod-illustrated-message-title-color,var(--spectrum-illustrated-message-title-color));max-inline-size:var(--mod-illustrated-message-heading-max-inline-size,var(--spectrum-illustrated-message-heading-max-inline-size));margin-block-start:0;margin-block-end:var(--mod-illustrated-message-heading-to-body,0)}#description{position:var(--mod-illustrated-message-description-position);z-index:var(--mod-illustrated-message-description-z-index);pointer-events:auto;pointer-events:var(--mod-illustrated-message-description-pointer-events,auto);font-family:var(--mod-illustrated-message-description-font-family,var(--spectrum-illustrated-message-description-font-family));font-weight:var(--mod-illustrated-message-description-font-weight,var(--spectrum-illustrated-message-description-font-weight));font-style:var(--mod-illustrated-message-description-font-style,var(--spectrum-illustrated-message-description-font-style));font-size:var(--mod-illustrated-message-description-font-size,var(--spectrum-illustrated-message-description-font-size));line-height:var(--mod-illustrated-message-description-line-height,var(--spectrum-illustrated-message-description-line-height));color:var(--mod-illustrated-message-description-color,var(--spectrum-illustrated-message-description-color));max-inline-size:var(--mod-illustrated-message-description-max-inline-size,var(--spectrum-illustrated-message-description-max-inline-size));margin-block-start:var(--mod-illustrated-message-heading-to-description,var(--spectrum-illustrated-message-heading-to-description));margin-block-end:0}::slotted(svg[viewBox]){width:100%}
`;
var illustrated_message_css_default = t6;

// node_modules/@spectrum-web-components/styles/src/spectrum-base.css.js
init_src();
var o15 = i`
    .spectrum{color:var(--spectrum-body-m-text-color,var(--spectrum-alias-text-color));font-family:var(--spectrum-alias-body-text-font-family,var(--spectrum-global-font-family-base));font-size:var(--spectrum-alias-font-size-default,var(--spectrum-global-dimension-font-size-100))}
`;
var spectrum_base_css_default = o15;

// node_modules/@spectrum-web-components/styles/src/spectrum-lang.css.js
init_src();
var t7 = i`
    .spectrum-Typography:lang(ar){font-family:var(--spectrum-font-family-ar)}.spectrum-Typography:lang(he){font-family:var(--spectrum-font-family-he)}.spectrum-Heading:lang(ja),.spectrum-Heading:lang(ko),.spectrum-Heading:lang(zh){font-family:var(--mod-heading-cjk-font-family,var(--spectrum-heading-cjk-font-family));font-style:var(--mod-heading-cjk-font-style,var(--spectrum-heading-cjk-font-style));font-weight:var(--mod-heading-cjk-font-weight,var(--spectrum-heading-cjk-font-weight));font-size:var(--mod-heading-cjk-font-size,var(--spectrum-heading-cjk-font-size));line-height:var(--mod-heading-cjk-line-height,var(--spectrum-heading-cjk-line-height));letter-spacing:var(--mod-heading-cjk-letter-spacing,var(--spectrum-heading-cjk-letter-spacing))}.spectrum-Heading:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading:lang(ja) em,.spectrum-Heading:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading:lang(ko) em,.spectrum-Heading:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading:lang(zh) em{font-style:var(--mod-heading-cjk-emphasized-font-style,var(--spectrum-heading-cjk-emphasized-font-style));font-weight:var(--mod-heading-cjk-emphasized-font-weight,var(--spectrum-heading-cjk-emphasized-font-weight))}.spectrum-Heading:lang(ja) .spectrum-Heading-strong,.spectrum-Heading:lang(ja) strong,.spectrum-Heading:lang(ko) .spectrum-Heading-strong,.spectrum-Heading:lang(ko) strong,.spectrum-Heading:lang(zh) .spectrum-Heading-strong,.spectrum-Heading:lang(zh) strong{font-style:var(--mod-heading-cjk-strong-font-style,var(--spectrum-heading-cjk-strong-font-style));font-weight:var(--mod-heading-cjk-strong-font-weight,var(--spectrum-heading-cjk-strong-font-weight))}.spectrum-Heading:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(ja) em strong,.spectrum-Heading:lang(ja) strong em,.spectrum-Heading:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(ko) em strong,.spectrum-Heading:lang(ko) strong em,.spectrum-Heading:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(zh) em strong,.spectrum-Heading:lang(zh) strong em{font-style:var(--mod-heading-cjk-strong-emphasized-font-style,var(--spectrum-heading-cjk-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-strong-emphasized-font-weight,var(--spectrum-heading-cjk-strong-emphasized-font-weight))}.spectrum-Heading--heavy:lang(ja),.spectrum-Heading--heavy:lang(ko),.spectrum-Heading--heavy:lang(zh){font-style:var(--mod-heading-cjk-heavy-font-style,var(--spectrum-heading-cjk-heavy-font-style));font-weight:var(--mod-heading-cjk-heavy-font-weight,var(--spectrum-heading-cjk-heavy-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ja) em,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ko) em,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(zh) em{font-style:var(--mod-heading-cjk-heavy-emphasized-font-style,var(--spectrum-heading-cjk-heavy-emphasized-font-style));font-weight:var(--mod-heading-cjk-heavy-emphasized-font-weight,var(--spectrum-heading-cjk-heavy-emphasized-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(ja) strong,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(ko) strong,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(zh) strong{font-style:var(--mod-heading-cjk-heavy-strong-font-style,var(--spectrum-heading-cjk-heavy-strong-font-style));font-weight:var(--mod-heading-cjk-heavy-strong-font-weight,var(--spectrum-heading-cjk-heavy-strong-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ja) em strong,.spectrum-Heading--heavy:lang(ja) strong em,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ko) em strong,.spectrum-Heading--heavy:lang(ko) strong em,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(zh) em strong,.spectrum-Heading--heavy:lang(zh) strong em{font-style:var(--mod-heading-cjk-heavy-strong-emphasized-font-style,var(--spectrum-heading-cjk-heavy-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-heavy-strong-emphasized-font-weight,var(--spectrum-heading-cjk-heavy-strong-emphasized-font-weight))}.spectrum-Heading--light:lang(ja),.spectrum-Heading--light:lang(ko),.spectrum-Heading--light:lang(zh){font-style:var(--mod-heading-cjk-light-font-style,var(--spectrum-heading-cjk-light-font-style));font-weight:var(--mod-heading-cjk-light-font-weight,var(--spectrum-heading-cjk-light-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-strong,.spectrum-Heading--light:lang(ja) strong,.spectrum-Heading--light:lang(ko) .spectrum-Heading-strong,.spectrum-Heading--light:lang(ko) strong,.spectrum-Heading--light:lang(zh) .spectrum-Heading-strong,.spectrum-Heading--light:lang(zh) strong{font-style:var(--mod-heading-cjk-light-strong-font-style,var(--spectrum-heading-cjk-light-strong-font-style));font-weight:var(--mod-heading-cjk-light-strong-font-weight,var(--spectrum-heading-cjk-light-strong-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ja) em,.spectrum-Heading--light:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ko) em,.spectrum-Heading--light:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(zh) em{font-style:var(--mod-heading-cjk-light-emphasized-font-style,var(--spectrum-heading-cjk-light-emphasized-font-style));font-weight:var(--mod-heading-cjk-light-emphasized-font-weight,var(--spectrum-heading-cjk-light-emphasized-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ja) em strong,.spectrum-Heading--light:lang(ja) strong em,.spectrum-Heading--light:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ko) em strong,.spectrum-Heading--light:lang(ko) strong em,.spectrum-Heading--light:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(zh) em strong,.spectrum-Heading--light:lang(zh) strong em{font-style:var(--mod-heading-cjk-light-strong-emphasized-font-style,var(--spectrum-heading-cjk-light-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-light-strong-emphasized-font-weight,var(--spectrum-heading-cjk-light-strong-emphasized-font-weight))}.spectrum-Body:lang(ja),.spectrum-Body:lang(ko),.spectrum-Body:lang(zh){font-family:var(--mod-body-cjk-font-family,var(--spectrum-body-cjk-font-family));font-style:var(--mod-body-cjk-font-style,var(--spectrum-body-cjk-font-style));font-weight:var(--mod-body-cjk-font-weight,var(--spectrum-body-cjk-font-weight));line-height:var(--mod-body-cjk-line-height,var(--spectrum-body-cjk-line-height));letter-spacing:var(--mod-body-cjk-letter-spacing,var(--spectrum-body-cjk-letter-spacing))}.spectrum-Body:lang(ja) .spectrum-Body-strong,.spectrum-Body:lang(ja) strong,.spectrum-Body:lang(ko) .spectrum-Body-strong,.spectrum-Body:lang(ko) strong,.spectrum-Body:lang(zh) .spectrum-Body-strong,.spectrum-Body:lang(zh) strong{font-style:var(--mod-body-cjk-strong-font-style,var(--spectrum-body-cjk-strong-font-style));font-weight:var(--mod-body-cjk-strong-font-weight,var(--spectrum-body-cjk-strong-font-weight))}.spectrum-Body:lang(ja) .spectrum-Body-emphasized,.spectrum-Body:lang(ja) em,.spectrum-Body:lang(ko) .spectrum-Body-emphasized,.spectrum-Body:lang(ko) em,.spectrum-Body:lang(zh) .spectrum-Body-emphasized,.spectrum-Body:lang(zh) em{font-style:var(--mod-body-cjk-emphasized-font-style,var(--spectrum-body-cjk-emphasized-font-style));font-weight:var(--mod-body-cjk-emphasized-font-weight,var(--spectrum-body-cjk-emphasized-font-weight))}.spectrum-Body:lang(ja) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(ja) em strong,.spectrum-Body:lang(ja) strong em,.spectrum-Body:lang(ko) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(ko) em strong,.spectrum-Body:lang(ko) strong em,.spectrum-Body:lang(zh) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(zh) em strong,.spectrum-Body:lang(zh) strong em{font-style:var(--mod-body-cjk-strong-emphasized-font-style,var(--spectrum-body-cjk-strong-emphasized-font-style));font-weight:var(--mod-body-cjk-strong-emphasized-font-weight,var(--spectrum-body-cjk-strong-emphasized-font-weight))}.spectrum-Detail:lang(ja),.spectrum-Detail:lang(ko),.spectrum-Detail:lang(zh){font-family:var(--mod-detail-cjk-font-family,var(--spectrum-detail-cjk-font-family));font-style:var(--mod-detail-cjk-font-style,var(--spectrum-detail-cjk-font-style));font-weight:var(--mod-detail-cjk-font-weight,var(--spectrum-detail-cjk-font-weight));line-height:var(--mod-detail-cjk-line-height,var(--spectrum-detail-cjk-line-height))}.spectrum-Detail:lang(ja) .spectrum-Detail-strong,.spectrum-Detail:lang(ja) strong,.spectrum-Detail:lang(ko) .spectrum-Detail-strong,.spectrum-Detail:lang(ko) strong,.spectrum-Detail:lang(zh) .spectrum-Detail-strong,.spectrum-Detail:lang(zh) strong{font-style:var(--mod-detail-cjk-strong-font-style,var(--spectrum-detail-cjk-strong-font-style));font-weight:var(--mod-detail-cjk-strong-font-weight,var(--spectrum-detail-cjk-strong-font-weight))}.spectrum-Detail:lang(ja) .spectrum-Detail-emphasized,.spectrum-Detail:lang(ja) em,.spectrum-Detail:lang(ko) .spectrum-Detail-emphasized,.spectrum-Detail:lang(ko) em,.spectrum-Detail:lang(zh) .spectrum-Detail-emphasized,.spectrum-Detail:lang(zh) em{font-style:var(--mod-detail-cjk-emphasized-font-style,var(--spectrum-detail-cjk-emphasized-font-style));font-weight:var(--mod-detail-cjk-emphasized-font-weight,var(--spectrum-detail-cjk-emphasized-font-weight))}.spectrum-Detail:lang(ja) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail:lang(ja) em strong,.spectrum-Detail:lang(ja) strong em,.spectrum-Detail:lang(ko) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail:lang(ko) em strong,.spectrum-Detail:lang(ko) strong em,.spectrum-Detail:lang(zh) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail:lang(zh) em strong,.spectrum-Detail:lang(zh) strong em{font-style:var(--mod-detail-cjk-strong-emphasized-font-style,var(--spectrum-detail-cjk-strong-emphasized-font-style));font-weight:var(--mod-detail-cjk-strong-emphasized-font-weight,var(--spectrum-detail-cjk-strong-emphasized-font-weight))}.spectrum-Detail--light:lang(ja),.spectrum-Detail--light:lang(ko),.spectrum-Detail--light:lang(zh){font-style:var(--mod-detail-cjk-light-font-style,var(--spectrum-detail-cjk-light-font-style));font-weight:var(--mod-detail-cjk-light-font-weight,var(--spectrum-detail-cjk-light-font-weight))}.spectrum-Detail--light:lang(ja) .spectrum-Detail-strong,.spectrum-Detail--light:lang(ja) strong,.spectrum-Detail--light:lang(ko) .spectrum-Detail-strong,.spectrum-Detail--light:lang(ko) strong,.spectrum-Detail--light:lang(zh) .spectrum-Detail-strong,.spectrum-Detail--light:lang(zh) strong{font-style:var(--mod-detail-cjk-light-strong-font-style,var(--spectrum-detail-cjk-light-strong-font-style));font-weight:var(--mod-detail-cjk-light-strong-font-weight,var(--spectrum-detail-cjk-light-strong-font-weight))}.spectrum-Detail--light:lang(ja) .spectrum-Detail-emphasized,.spectrum-Detail--light:lang(ja) em,.spectrum-Detail--light:lang(ko) .spectrum-Detail-emphasized,.spectrum-Detail--light:lang(ko) em,.spectrum-Detail--light:lang(zh) .spectrum-Detail-emphasized,.spectrum-Detail--light:lang(zh) em{font-style:var(--mod-detail-cjk-light-emphasized-font-style,var(--spectrum-detail-cjk-light-emphasized-font-style));font-weight:var(--mod-detail-cjk-light-emphasized-font-weight,var(--spectrum-detail-cjk-light-emphasized-font-weight))}.spectrum-Detail--light:lang(ja) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail--light:lang(ko) .spectrum-Detail-strong.spectrum-Detail-emphasized,.spectrum-Detail--light:lang(zh) .spectrum-Detail-strong.spectrum-Detail-emphasized{font-style:var(--mod-detail-cjk-light-strong-emphasized-font-style,var(--spectrum-detail-cjk-light-strong-emphasized-font-style));font-weight:var(--mod-detail-cjk-light-strong-emphasized-font-weight,var(--spectrum-detail-cjk-light-strong-emphasized-font-weight))}.spectrum-Code:lang(ja),.spectrum-Code:lang(ko),.spectrum-Code:lang(zh){font-family:var(--mod-code-cjk-font-family,var(--spectrum-code-cjk-font-family));font-style:var(--mod-code-cjk-font-style,var(--spectrum-code-cjk-font-style));font-weight:var(--mod-code-cjk-font-weight,var(--spectrum-code-cjk-font-weight));line-height:var(--mod-code-cjk-line-height,var(--spectrum-code-cjk-line-height));letter-spacing:var(--mod-code-cjk-letter-spacing,var(--spectrum-code-cjk-letter-spacing))}.spectrum-Code:lang(ja) .spectrum-Code-strong,.spectrum-Code:lang(ja) strong,.spectrum-Code:lang(ko) .spectrum-Code-strong,.spectrum-Code:lang(ko) strong,.spectrum-Code:lang(zh) .spectrum-Code-strong,.spectrum-Code:lang(zh) strong{font-style:var(--mod-code-cjk-strong-font-style,var(--spectrum-code-cjk-strong-font-style));font-weight:var(--mod-code-cjk-strong-font-weight,var(--spectrum-code-cjk-strong-font-weight))}.spectrum-Code:lang(ja) .spectrum-Code-emphasized,.spectrum-Code:lang(ja) em,.spectrum-Code:lang(ko) .spectrum-Code-emphasized,.spectrum-Code:lang(ko) em,.spectrum-Code:lang(zh) .spectrum-Code-emphasized,.spectrum-Code:lang(zh) em{font-style:var(--mod-code-cjk-emphasized-font-style,var(--spectrum-code-cjk-emphasized-font-style));font-weight:var(--mod-code-cjk-emphasized-font-weight,var(--spectrum-code-cjk-emphasized-font-weight))}.spectrum-Code:lang(ja) .spectrum-Code-strong.spectrum-Code-emphasized,.spectrum-Code:lang(ja) em strong,.spectrum-Code:lang(ja) strong em,.spectrum-Code:lang(ko) .spectrum-Code-strong.spectrum-Code-emphasized,.spectrum-Code:lang(ko) em strong,.spectrum-Code:lang(ko) strong em,.spectrum-Code:lang(zh) .spectrum-Code-strong.spectrum-Code-emphasized,.spectrum-Code:lang(zh) em strong,.spectrum-Code:lang(zh) strong em{font-style:var(--mod-code-cjk-strong-emphasized-font-style,var(--spectrum-code-cjk-strong-emphasized-font-style));font-weight:var(--mod-code-cjk-strong-emphasized-font-weight,var(--spectrum-code-cjk-strong-emphasized-font-weight))}
`;
var spectrum_lang_css_default = t7;

// node_modules/@spectrum-web-components/styles/src/spectrum-heading.css.js
init_src();
var t8 = i`
    .spectrum-Typography .spectrum-Heading{--spectrum-heading-margin-start:calc(var(--mod-heading-font-size,var(--spectrum-heading-font-size))*var(--spectrum-heading-margin-top-multiplier));--spectrum-heading-margin-end:calc(var(--mod-heading-font-size,var(--spectrum-heading-font-size))*var(--spectrum-heading-margin-bottom-multiplier))}@media (forced-colors:active){.spectrum-Heading{--highcontrast-heading-font-color:Text}}.spectrum-Heading,.spectrum-Heading--sizeM{--spectrum-heading-font-size:var(--spectrum-heading-size-m);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-m)}.spectrum-Heading--sizeXXS{--spectrum-heading-font-size:var(--spectrum-heading-size-xxs);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xxs)}.spectrum-Heading--sizeXS{--spectrum-heading-font-size:var(--spectrum-heading-size-xs);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xs)}.spectrum-Heading--sizeS{--spectrum-heading-font-size:var(--spectrum-heading-size-s);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-s)}.spectrum-Heading--sizeL{--spectrum-heading-font-size:var(--spectrum-heading-size-l);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-l)}.spectrum-Heading--sizeXL{--spectrum-heading-font-size:var(--spectrum-heading-size-xl);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xl)}.spectrum-Heading--sizeXXL{--spectrum-heading-font-size:var(--spectrum-heading-size-xxl);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xxl)}.spectrum-Heading--sizeXXXL{--spectrum-heading-font-size:var(--spectrum-heading-size-xxxl);--spectrum-heading-cjk-font-size:var(--spectrum-heading-cjk-size-xxxl)}.spectrum-Heading{--spectrum-heading-sans-serif-font-family:var(--spectrum-sans-font-family-stack);--spectrum-heading-serif-font-family:var(--spectrum-serif-font-family-stack);--spectrum-heading-cjk-font-family:var(--spectrum-cjk-font-family-stack);--spectrum-heading-cjk-letter-spacing:var(--spectrum-cjk-letter-spacing);--spectrum-heading-font-color:var(--spectrum-heading-color);font-family:var(--mod-heading-sans-serif-font-family,var(--spectrum-heading-sans-serif-font-family));font-style:var(--mod-heading-sans-serif-font-style,var(--spectrum-heading-sans-serif-font-style));font-weight:var(--mod-heading-sans-serif-font-weight,var(--spectrum-heading-sans-serif-font-weight));font-size:var(--mod-heading-font-size,var(--spectrum-heading-font-size));color:var(--highcontrast-heading-font-color,var(--mod-heading-font-color,var(--spectrum-heading-font-color)));line-height:var(--mod-heading-line-height,var(--spectrum-heading-line-height));margin-block-start:var(--mod-heading-margin-start,var(--spectrum-heading-margin-start,0));margin-block-end:var(--mod-heading-margin-end,var(--spectrum-heading-margin-end,0))}.spectrum-Heading .spectrum-Heading-strong,.spectrum-Heading strong{font-style:var(--mod-heading-sans-serif-strong-font-style,var(--spectrum-heading-sans-serif-strong-font-style));font-weight:var(--mod-heading-sans-serif-strong-font-weight,var(--spectrum-heading-sans-serif-strong-font-weight))}.spectrum-Heading .spectrum-Heading-emphasized,.spectrum-Heading em{font-style:var(--mod-heading-sans-serif-emphasized-font-style,var(--spectrum-heading-sans-serif-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-emphasized-font-weight,var(--spectrum-heading-sans-serif-emphasized-font-weight))}.spectrum-Heading .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading em strong,.spectrum-Heading strong em{font-style:var(--mod-heading-sans-serif-strong-emphasized-font-style,var(--spectrum-heading-sans-serif-strong-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-strong-emphasized-font-weight,var(--spectrum-heading-sans-serif-strong-emphasized-font-weight))}.spectrum-Heading:lang(ja),.spectrum-Heading:lang(ko),.spectrum-Heading:lang(zh){font-family:var(--mod-heading-cjk-font-family,var(--spectrum-heading-cjk-font-family));font-style:var(--mod-heading-cjk-font-style,var(--spectrum-heading-cjk-font-style));font-weight:var(--mod-heading-cjk-font-weight,var(--spectrum-heading-cjk-font-weight));font-size:var(--mod-heading-cjk-font-size,var(--spectrum-heading-cjk-font-size));line-height:var(--mod-heading-cjk-line-height,var(--spectrum-heading-cjk-line-height));letter-spacing:var(--mod-heading-cjk-letter-spacing,var(--spectrum-heading-cjk-letter-spacing))}.spectrum-Heading:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading:lang(ja) em,.spectrum-Heading:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading:lang(ko) em,.spectrum-Heading:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading:lang(zh) em{font-style:var(--mod-heading-cjk-emphasized-font-style,var(--spectrum-heading-cjk-emphasized-font-style));font-weight:var(--mod-heading-cjk-emphasized-font-weight,var(--spectrum-heading-cjk-emphasized-font-weight))}.spectrum-Heading:lang(ja) .spectrum-Heading-strong,.spectrum-Heading:lang(ja) strong,.spectrum-Heading:lang(ko) .spectrum-Heading-strong,.spectrum-Heading:lang(ko) strong,.spectrum-Heading:lang(zh) .spectrum-Heading-strong,.spectrum-Heading:lang(zh) strong{font-style:var(--mod-heading-cjk-strong-font-style,var(--spectrum-heading-cjk-strong-font-style));font-weight:var(--mod-heading-cjk-strong-font-weight,var(--spectrum-heading-cjk-strong-font-weight))}.spectrum-Heading:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(ja) em strong,.spectrum-Heading:lang(ja) strong em,.spectrum-Heading:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(ko) em strong,.spectrum-Heading:lang(ko) strong em,.spectrum-Heading:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading:lang(zh) em strong,.spectrum-Heading:lang(zh) strong em{font-style:var(--mod-heading-cjk-strong-emphasized-font-style,var(--spectrum-heading-cjk-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-strong-emphasized-font-weight,var(--spectrum-heading-cjk-strong-emphasized-font-weight))}.spectrum-Heading--heavy{font-style:var(--mod-heading-sans-serif-heavy-font-style,var(--spectrum-heading-sans-serif-heavy-font-style));font-weight:var(--mod-heading-sans-serif-heavy-font-weight,var(--spectrum-heading-sans-serif-heavy-font-weight))}.spectrum-Heading--heavy .spectrum-Heading-strong,.spectrum-Heading--heavy strong{font-style:var(--mod-heading-sans-serif-heavy-strong-font-style,var(--spectrum-heading-sans-serif-heavy-strong-font-style));font-weight:var(--mod-heading-sans-serif-heavy-strong-font-weight,var(--spectrum-heading-sans-serif-heavy-strong-font-weight))}.spectrum-Heading--heavy .spectrum-Heading-emphasized,.spectrum-Heading--heavy em{font-style:var(--mod-heading-sans-serif-heavy-emphasized-font-style,var(--spectrum-heading-sans-serif-heavy-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-heavy-emphasized-font-weight,var(--spectrum-heading-sans-serif-heavy-emphasized-font-weight))}.spectrum-Heading--heavy .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy em strong,.spectrum-Heading--heavy strong em{font-style:var(--mod-heading-sans-serif-heavy-strong-emphasized-font-style,var(--spectrum-heading-sans-serif-heavy-strong-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-heavy-strong-emphasized-font-weight,var(--spectrum-heading-sans-serif-heavy-strong-emphasized-font-weight))}.spectrum-Heading--heavy:lang(ja),.spectrum-Heading--heavy:lang(ko),.spectrum-Heading--heavy:lang(zh){font-style:var(--mod-heading-cjk-heavy-font-style,var(--spectrum-heading-cjk-heavy-font-style));font-weight:var(--mod-heading-cjk-heavy-font-weight,var(--spectrum-heading-cjk-heavy-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ja) em,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ko) em,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(zh) em{font-style:var(--mod-heading-cjk-heavy-emphasized-font-style,var(--spectrum-heading-cjk-heavy-emphasized-font-style));font-weight:var(--mod-heading-cjk-heavy-emphasized-font-weight,var(--spectrum-heading-cjk-heavy-emphasized-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(ja) strong,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(ko) strong,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-strong,.spectrum-Heading--heavy:lang(zh) strong{font-style:var(--mod-heading-cjk-heavy-strong-font-style,var(--spectrum-heading-cjk-heavy-strong-font-style));font-weight:var(--mod-heading-cjk-heavy-strong-font-weight,var(--spectrum-heading-cjk-heavy-strong-font-weight))}.spectrum-Heading--heavy:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ja) em strong,.spectrum-Heading--heavy:lang(ja) strong em,.spectrum-Heading--heavy:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(ko) em strong,.spectrum-Heading--heavy:lang(ko) strong em,.spectrum-Heading--heavy:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--heavy:lang(zh) em strong,.spectrum-Heading--heavy:lang(zh) strong em{font-style:var(--mod-heading-cjk-heavy-strong-emphasized-font-style,var(--spectrum-heading-cjk-heavy-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-heavy-strong-emphasized-font-weight,var(--spectrum-heading-cjk-heavy-strong-emphasized-font-weight))}.spectrum-Heading--light{font-style:var(--mod-heading-sans-serif-light-font-style,var(--spectrum-heading-sans-serif-light-font-style));font-weight:var(--mod-heading-sans-serif-light-font-weight,var(--spectrum-heading-sans-serif-light-font-weight))}.spectrum-Heading--light .spectrum-Heading-emphasized,.spectrum-Heading--light em{font-style:var(--mod-heading-sans-serif-light-emphasized-font-style,var(--spectrum-heading-sans-serif-light-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-light-emphasized-font-weight,var(--spectrum-heading-sans-serif-light-emphasized-font-weight))}.spectrum-Heading--light .spectrum-Heading-strong,.spectrum-Heading--light strong{font-style:var(--mod-heading-sans-serif-light-strong-font-style,var(--spectrum-heading-sans-serif-light-strong-font-style));font-weight:var(--mod-heading-sans-serif-light-strong-font-weight,var(--spectrum-heading-sans-serif-light-strong-font-weight))}.spectrum-Heading--light .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light em strong,.spectrum-Heading--light strong em{font-style:var(--mod-heading-sans-serif-light-strong-emphasized-font-style,var(--spectrum-heading-sans-serif-light-strong-emphasized-font-style));font-weight:var(--mod-heading-sans-serif-light-strong-emphasized-font-weight,var(--spectrum-heading-sans-serif-light-strong-emphasized-font-weight))}.spectrum-Heading--light:lang(ja),.spectrum-Heading--light:lang(ko),.spectrum-Heading--light:lang(zh){font-style:var(--mod-heading-cjk-light-font-style,var(--spectrum-heading-cjk-light-font-style));font-weight:var(--mod-heading-cjk-light-font-weight,var(--spectrum-heading-cjk-light-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-strong,.spectrum-Heading--light:lang(ja) strong,.spectrum-Heading--light:lang(ko) .spectrum-Heading-strong,.spectrum-Heading--light:lang(ko) strong,.spectrum-Heading--light:lang(zh) .spectrum-Heading-strong,.spectrum-Heading--light:lang(zh) strong{font-style:var(--mod-heading-cjk-light-strong-font-style,var(--spectrum-heading-cjk-light-strong-font-style));font-weight:var(--mod-heading-cjk-light-strong-font-weight,var(--spectrum-heading-cjk-light-strong-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ja) em,.spectrum-Heading--light:lang(ko) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ko) em,.spectrum-Heading--light:lang(zh) .spectrum-Heading-emphasized,.spectrum-Heading--light:lang(zh) em{font-style:var(--mod-heading-cjk-light-emphasized-font-style,var(--spectrum-heading-cjk-light-emphasized-font-style));font-weight:var(--mod-heading-cjk-light-emphasized-font-weight,var(--spectrum-heading-cjk-light-emphasized-font-weight))}.spectrum-Heading--light:lang(ja) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ja) em strong,.spectrum-Heading--light:lang(ja) strong em,.spectrum-Heading--light:lang(ko) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(ko) em strong,.spectrum-Heading--light:lang(ko) strong em,.spectrum-Heading--light:lang(zh) .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--light:lang(zh) em strong,.spectrum-Heading--light:lang(zh) strong em{font-style:var(--mod-heading-cjk-light-strong-emphasized-font-style,var(--spectrum-heading-cjk-light-strong-emphasized-font-style));font-weight:var(--mod-heading-cjk-light-strong-emphasized-font-weight,var(--spectrum-heading-cjk-light-strong-emphasized-font-weight))}.spectrum-Heading--serif{font-family:var(--mod-heading-serif-font-family,var(--spectrum-heading-serif-font-family));font-style:var(--mod-heading-serif-font-style,var(--spectrum-heading-serif-font-style));font-weight:var(--mod-heading-serif-font-weight,var(--spectrum-heading-serif-font-weight))}.spectrum-Heading--serif .spectrum-Heading-emphasized,.spectrum-Heading--serif em{font-style:var(--mod-heading-serif-emphasized-font-style,var(--spectrum-heading-serif-emphasized-font-style));font-weight:var(--mod-heading-serif-emphasized-font-weight,var(--spectrum-heading-serif-emphasized-font-weight))}.spectrum-Heading--serif .spectrum-Heading-strong,.spectrum-Heading--serif strong{font-style:var(--mod-heading-serif-strong-font-style,var(--spectrum-heading-serif-strong-font-style));font-weight:var(--mod-heading-serif-strong-font-weight,var(--spectrum-heading-serif-strong-font-weight))}.spectrum-Heading--serif .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--serif em strong,.spectrum-Heading--serif strong em{font-style:var(--mod-heading-serif-strong-emphasized-font-style,var(--spectrum-heading-serif-strong-emphasized-font-style));font-weight:var(--mod-heading-serif-strong-emphasized-font-weight,var(--spectrum-heading-serif-strong-emphasized-font-weight))}.spectrum-Heading--serif.spectrum-Heading--heavy{font-style:var(--mod-heading-serif-heavy-font-style,var(--spectrum-heading-serif-heavy-font-style));font-weight:var(--mod-heading-serif-heavy-font-weight,var(--spectrum-heading-serif-heavy-font-weight))}.spectrum-Heading--serif.spectrum-Heading--heavy .spectrum-Heading-strong,.spectrum-Heading--serif.spectrum-Heading--heavy strong{font-style:var(--mod-heading-serif-heavy-strong-font-style,var(--spectrum-heading-serif-heavy-strong-font-style));font-weight:var(--mod-heading-serif-heavy-strong-font-weight,var(--spectrum-heading-serif-heavy-strong-font-weight))}.spectrum-Heading--serif.spectrum-Heading--heavy .spectrum-Heading-emphasized,.spectrum-Heading--serif.spectrum-Heading--heavy em{font-style:var(--mod-heading-serif-heavy-emphasized-font-style,var(--spectrum-heading-serif-heavy-emphasized-font-style));font-weight:var(--mod-heading-serif-heavy-emphasized-font-weight,var(--spectrum-heading-serif-heavy-emphasized-font-weight))}.spectrum-Heading--serif.spectrum-Heading--heavy .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--serif.spectrum-Heading--heavy em strong,.spectrum-Heading--serif.spectrum-Heading--heavy strong em{font-style:var(--mod-heading-serif-heavy-strong-emphasized-font-style,var(--spectrum-heading-serif-heavy-strong-emphasized-font-style));font-weight:var(--mod-heading-serif-heavy-strong-emphasized-font-weight,var(--spectrum-heading-serif-heavy-strong-emphasized-font-weight))}.spectrum-Heading--serif.spectrum-Heading--light{font-style:var(--mod-heading-serif-light-font-style,var(--spectrum-heading-serif-light-font-style));font-weight:var(--mod-heading-serif-light-font-weight,var(--spectrum-heading-serif-light-font-weight))}.spectrum-Heading--serif.spectrum-Heading--light .spectrum-Heading-emphasized,.spectrum-Heading--serif.spectrum-Heading--light em{font-style:var(--mod-heading-serif-light-emphasized-font-style,var(--spectrum-heading-serif-light-emphasized-font-style));font-weight:var(--mod-heading-serif-light-emphasized-font-weight,var(--spectrum-heading-serif-light-emphasized-font-weight))}.spectrum-Heading--serif.spectrum-Heading--light .spectrum-Heading-strong,.spectrum-Heading--serif.spectrum-Heading--light strong{font-style:var(--mod-heading-serif-light-strong-font-style,var(--spectrum-heading-serif-light-strong-font-style));font-weight:var(--mod-heading-serif-light-strong-font-weight,var(--spectrum-heading-serif-light-strong-font-weight))}.spectrum-Heading--serif.spectrum-Heading--light .spectrum-Heading-strong.spectrum-Heading-emphasized,.spectrum-Heading--serif.spectrum-Heading--light em strong,.spectrum-Heading--serif.spectrum-Heading--light strong em{font-style:var(--mod-heading-serif-light-strong-emphasized-font-style,var(--spectrum-heading-serif-light-strong-emphasized-font-style));font-weight:var(--mod-heading-serif-light-strong-emphasized-font-weight,var(--spectrum-heading-serif-light-strong-emphasized-font-weight))}
`;
var spectrum_heading_css_default = t8;

// node_modules/@spectrum-web-components/styles/heading.js
var heading_default = [spectrum_base_css_default, spectrum_lang_css_default, spectrum_heading_css_default];

// node_modules/@spectrum-web-components/styles/src/spectrum-body.css.js
init_src();
var e14 = i`
    .spectrum-Typography .spectrum-Body{--spectrum-body-margin-end:calc(var(--mod-body-font-size,var(--spectrum-body-font-size))*var(--spectrum-body-margin-multiplier))}@media (forced-colors:active){.spectrum-Body{--highcontrast-body-font-color:Text}}.spectrum-Body,.spectrum-Body--sizeM{--spectrum-body-font-size:var(--spectrum-body-size-m)}.spectrum-Body--sizeXS{--spectrum-body-font-size:var(--spectrum-body-size-xs)}.spectrum-Body--sizeS{--spectrum-body-font-size:var(--spectrum-body-size-s)}.spectrum-Body--sizeL{--spectrum-body-font-size:var(--spectrum-body-size-l)}.spectrum-Body--sizeXL{--spectrum-body-font-size:var(--spectrum-body-size-xl)}.spectrum-Body--sizeXXL{--spectrum-body-font-size:var(--spectrum-body-size-xxl)}.spectrum-Body--sizeXXXL{--spectrum-body-font-size:var(--spectrum-body-size-xxxl)}.spectrum-Body{--spectrum-body-sans-serif-font-family:var(--spectrum-sans-font-family-stack);--spectrum-body-serif-font-family:var(--spectrum-serif-font-family-stack);--spectrum-body-cjk-font-family:var(--spectrum-cjk-font-family-stack);--spectrum-body-cjk-letter-spacing:var(--spectrum-cjk-letter-spacing);--spectrum-body-font-color:var(--spectrum-body-color);font-family:var(--mod-body-sans-serif-font-family,var(--spectrum-body-sans-serif-font-family));font-style:var(--mod-body-sans-serif-font-style,var(--spectrum-body-sans-serif-font-style));font-weight:var(--mod-body-sans-serif-font-weight,var(--spectrum-body-sans-serif-font-weight));font-size:var(--mod-body-font-size,var(--spectrum-body-font-size));color:var(--highcontrast-body-font-color,var(--mod-body-font-color,var(--spectrum-body-font-color)));line-height:var(--mod-body-line-height,var(--spectrum-body-line-height));margin-block-start:var(--mod-body-margin-start,var(--mod-body-margin,0));margin-block-end:var(--mod-body-margin-end,var(--mod-body-margin,var(--spectrum-body-margin-end,0)))}.spectrum-Body .spectrum-Body-strong,.spectrum-Body strong{font-style:var(--mod-body-sans-serif-strong-font-style,var(--spectrum-body-sans-serif-strong-font-style));font-weight:var(--mod-body-sans-serif-strong-font-weight,var(--spectrum-body-sans-serif-strong-font-weight))}.spectrum-Body .spectrum-Body-emphasized,.spectrum-Body em{font-style:var(--mod-body-sans-serif-emphasized-font-style,var(--spectrum-body-sans-serif-emphasized-font-style));font-weight:var(--mod-body-sans-serif-emphasized-font-weight,var(--spectrum-body-sans-serif-emphasized-font-weight))}.spectrum-Body .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body em strong,.spectrum-Body strong em{font-style:var(--mod-body-sans-serif-strong-emphasized-font-style,var(--spectrum-body-sans-serif-strong-emphasized-font-style));font-weight:var(--mod-body-sans-serif-strong-emphasized-font-weight,var(--spectrum-body-sans-serif-strong-emphasized-font-weight))}.spectrum-Body:lang(ja),.spectrum-Body:lang(ko),.spectrum-Body:lang(zh){font-family:var(--mod-body-cjk-font-family,var(--spectrum-body-cjk-font-family));font-style:var(--mod-body-cjk-font-style,var(--spectrum-body-cjk-font-style));font-weight:var(--mod-body-cjk-font-weight,var(--spectrum-body-cjk-font-weight));line-height:var(--mod-body-cjk-line-height,var(--spectrum-body-cjk-line-height));letter-spacing:var(--mod-body-cjk-letter-spacing,var(--spectrum-body-cjk-letter-spacing))}.spectrum-Body:lang(ja) .spectrum-Body-strong,.spectrum-Body:lang(ja) strong,.spectrum-Body:lang(ko) .spectrum-Body-strong,.spectrum-Body:lang(ko) strong,.spectrum-Body:lang(zh) .spectrum-Body-strong,.spectrum-Body:lang(zh) strong{font-style:var(--mod-body-cjk-strong-font-style,var(--spectrum-body-cjk-strong-font-style));font-weight:var(--mod-body-cjk-strong-font-weight,var(--spectrum-body-cjk-strong-font-weight))}.spectrum-Body:lang(ja) .spectrum-Body-emphasized,.spectrum-Body:lang(ja) em,.spectrum-Body:lang(ko) .spectrum-Body-emphasized,.spectrum-Body:lang(ko) em,.spectrum-Body:lang(zh) .spectrum-Body-emphasized,.spectrum-Body:lang(zh) em{font-style:var(--mod-body-cjk-emphasized-font-style,var(--spectrum-body-cjk-emphasized-font-style));font-weight:var(--mod-body-cjk-emphasized-font-weight,var(--spectrum-body-cjk-emphasized-font-weight))}.spectrum-Body:lang(ja) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(ja) em strong,.spectrum-Body:lang(ja) strong em,.spectrum-Body:lang(ko) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(ko) em strong,.spectrum-Body:lang(ko) strong em,.spectrum-Body:lang(zh) .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body:lang(zh) em strong,.spectrum-Body:lang(zh) strong em{font-style:var(--mod-body-cjk-strong-emphasized-font-style,var(--spectrum-body-cjk-strong-emphasized-font-style));font-weight:var(--mod-body-cjk-strong-emphasized-font-weight,var(--spectrum-body-cjk-strong-emphasized-font-weight))}.spectrum-Body--serif{font-family:var(--mod-body-serif-font-family,var(--spectrum-body-serif-font-family));font-weight:var(--mod-body-serif-font-weight,var(--spectrum-body-serif-font-weight));font-style:var(--mod-body-serif-font-style,var(--spectrum-body-serif-font-style))}.spectrum-Body--serif .spectrum-Body-strong,.spectrum-Body--serif strong{font-style:var(--mod-body-serif-strong-font-style,var(--spectrum-body-serif-strong-font-style));font-weight:var(--mod-body-serif-strong-font-weight,var(--spectrum-body-serif-strong-font-weight))}.spectrum-Body--serif .spectrum-Body-emphasized,.spectrum-Body--serif em{font-style:var(--mod-body-serif-emphasized-font-style,var(--spectrum-body-serif-emphasized-font-style));font-weight:var(--mod-body-serif-emphasized-font-weight,var(--spectrum-body-serif-emphasized-font-weight))}.spectrum-Body--serif .spectrum-Body-strong.spectrum-Body-emphasized,.spectrum-Body--serif em strong,.spectrum-Body--serif strong em{font-style:var(--mod-body-serif-strong-emphasized-font-style,var(--spectrum-body-serif-strong-emphasized-font-style));font-weight:var(--mod-body-serif-strong-emphasized-font-weight,var(--spectrum-body-serif-strong-emphasized-font-weight))}.spectrum-Detail--light .spectrum-Detail-strong.spectrum-Body-emphasized{font-style:var(--mod-detail-sans-serif-light-strong-emphasized-font-style,var(--spectrum-detail-sans-serif-light-strong-emphasized-font-style));font-weight:var(--mod-detail-sans-serif-light-strong-emphasized-font-weight,var(--spectrum-detail-sans-serif-light-strong-emphasized-font-weight))}.spectrum-Detail--serif.spectrum-Detail--light .spectrum-Detail-strong.spectrum-Body-emphasized{font-style:var(--mod-detail-serif-light-strong-emphasized-font-style,var(--spectrum-detail-serif-light-strong-emphasized-font-style));font-weight:var(--mod-detail-serif-light-strong-emphasized-font-weight,var(--spectrum-detail-serif-light-strong-emphasized-font-weight))}
`;
var spectrum_body_css_default = e14;

// node_modules/@spectrum-web-components/styles/body.js
var body_default = [spectrum_base_css_default, spectrum_lang_css_default, spectrum_body_css_default];

// node_modules/@spectrum-web-components/illustrated-message/src/IllustratedMessage.js
var m5 = Object.defineProperty;
var n11 = Object.getOwnPropertyDescriptor;
var l5 = (r25, t34, s19, i21) => {
  for (var e36 = i21 > 1 ? void 0 : i21 ? n11(t34, s19) : t34, o52 = r25.length - 1, d22; o52 >= 0; o52--) (d22 = r25[o52]) && (e36 = (i21 ? d22(t34, s19, e36) : d22(e36)) || e36);
  return i21 && e36 && m5(t34, s19, e36), e36;
};
var IllustratedMessage = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.heading = "";
    this.description = "";
  }
  static get styles() {
    return [heading_default, body_default, illustrated_message_css_default];
  }
  render() {
    return x`
            <div id="illustration"><slot></slot></div>
            <h2
                id="heading"
                class="spectrum-Heading spectrum-Heading--sizeL spectrum-Heading--light"
            >
                <slot name="heading">${this.heading}</slot>
            </h2>
            <div id="description" class="spectrum-Body spectrum-Body--sizeS">
                <slot name="description">${this.description}</slot>
            </div>
        `;
  }
};
IllustratedMessage.is = "sp-illustrated-message", l5([n4()], IllustratedMessage.prototype, "heading", 2), l5([n4()], IllustratedMessage.prototype, "description", 2);

// node_modules/@spectrum-web-components/illustrated-message/sp-illustrated-message.js
init_define_element();
defineElement("sp-illustrated-message", IllustratedMessage);

// src/experience-elements-editor.js
init_lit();

// src/features/toolbar/ee-toolbar.js
init_lit();
init_unsafe_html2();
init_if_defined2();
init_repeat2();

// src/utils/lit-converters.js
var booleanConverter = {
  fromAttribute: (value) => value !== null && value !== "false",
  toAttribute: (value) => value ? "" : null
};

// src/features/toolbar/ee-toolbar.css.js
init_lit();
var eeToolbarStyles = i`

  :host {
    display: inline-block;
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  :host([static]) {
    position: relative;
    inset: auto;
    pointer-events: auto;
  }

  #ee-toolbar {
    position: fixed;
    left: 0;
    top: 0;

    display: inline-flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-100);
    flex-wrap: nowrap;
    white-space: nowrap;
    min-height: 44px;
    pointer-events: auto;
    background: var(--spectrum-global-color-gray-100);
    border: 1px solid var(--spectrum-global-color-gray-500);
    border-radius: 9999px; /* pill */
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.10);
    padding: 8px 16px; /* thinner */
    animation: eeToolbarFadeIn 0.12s ease-out;
    overflow-x: auto;
    overflow-y: hidden;
    scrollbar-width: none;
  }

  #ee-toolbar::-webkit-scrollbar {
    display: none;
  }

  :host([static]) #ee-toolbar {
    position: relative;
    left: auto;
    top: auto;
    transform: none !important;
  }

  @keyframes eeToolbarFadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  sp-divider { display: none; }
  /* Show dividers placed around author controls group in toolbar */
  sp-divider.author-controls-divider {
    display: inline-block;
    align-self: stretch;
    height: 44px;
    width: 1px;
    margin-inline: var(--spectrum-global-dimension-size-100);
  }

  .attributes {
    display: inline-flex;
    gap: 6px;
    align-items: center;
  }

  .footer { display: none; }

  /* Make action buttons feel compact */
  sp-action-button[quiet] {
    --spectrum-actionbutton-height: 28px;
    --mod-actionbutton-min-width: 28px;
    padding-inline: 8px;
  }

  sp-picker {
    --spectrum-picker-height: 28px;
  }

  sp-number-field, sp-textfield {
    --spectrum-textfield-height: 28px;
  }

  sp-field-label, sp-help-text { display: none !important; }

  /* In popover (expanded form), show labels and help text and stack fields vertically */
  :host sp-popover .popover-content {
    padding: var(--spectrum-global-dimension-size-200)
      var(--spectrum-global-dimension-size-300);
    min-width: 280px;
    max-height: 580px;
    overflow-y: auto;
  }
  :host sp-popover .attributes {
    display: grid !important;
    grid-template-columns: 1fr;
    gap: var(--spectrum-global-dimension-size-150);
  }
  :host sp-popover sp-field-label,
  :host sp-popover sp-help-text {
    display: block !important;
  }
  :host sp-popover sp-number-field,
  :host sp-popover sp-textfield,
  :host sp-popover sp-picker {
    width: 100%;
  }

  /* Form mode styles removed; popovers show full content instead */

  /* Functional groups */
  .group {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .rte-node-group {
    display: inline-flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-150);
  }

  .rte-node-group__label {
    display: none;
  }

  .rte-node-group__fields {
    display: inline-flex;
    gap: var(--spectrum-global-dimension-size-100);
    align-items: center;
  }

  .rte-node-field {
    display: inline-flex;
    flex-direction: column;
    gap: 4px;
    min-width: 160px;
  }

  /* Select Parent button: rotated icon, smooth background sheen on hover */
  #select-parent-button-icon sp-icon-chevron-double-left {
    transform: rotate(45deg);
  }

  #select-parent-button-icon {
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
  }

  #select-parent-button-icon::after {
    content: "";
    position: absolute;
    inset: -4px;
    border-radius: 6px;
    background-image: linear-gradient(
      to top left,
      rgba(255, 255, 255, 0) 0%,
      rgba(255, 255, 255, 0) 45%,
      rgba(255, 255, 255, 0.28) 50%,
      rgba(255, 255, 255, 0) 55%,
      rgba(255, 255, 255, 0) 100%
    );
    background-size: 200% 200%;
    background-position: 100% 100%;
    opacity: 0;
    pointer-events: none;
    will-change: background-position, opacity;
    transition: opacity 180ms ease-out;
  }

  @keyframes eeSheenDiagBRtoTL {
    from {
      background-position: 100% 100%;
    }
    to {
      background-position: 0% 0%;
    }
  }

  #select-parent-button:hover #select-parent-button-icon::after {
    opacity: 1;
    animation: eeSheenDiagBRtoTL 360ms ease-out;
  }

`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLink.js
init_src();

// node_modules/@spectrum-web-components/icon/src/IconBase.js
init_src();

// node_modules/@spectrum-web-components/reactive-controllers/src/SystemContextResolution.js
var systemResolverUpdatedSymbol = Symbol("system resolver updated");
var SystemResolutionController = class {
  constructor(e36) {
    this.system = "spectrum";
    this.host = e36, this.host.addController(this);
  }
  hostConnected() {
    this.resolveSystem();
  }
  hostDisconnected() {
    var e36;
    (e36 = this.unsubscribe) == null || e36.call(this);
  }
  resolveSystem() {
    const e36 = new CustomEvent("sp-system-context", { bubbles: true, composed: true, detail: { callback: (t34, s19) => {
      const o52 = this.system;
      this.system = t34, this.unsubscribe = s19, this.host.requestUpdate(systemResolverUpdatedSymbol, o52);
    } }, cancelable: true });
    this.host.dispatchEvent(e36);
  }
};

// node_modules/@spectrum-web-components/icon/src/IconBase.js
init_decorators2();

// node_modules/@spectrum-web-components/icon/src/icon.css.js
init_src();
var i9 = i`
    :host{--spectrum-icon-inline-size:var(--mod-icon-inline-size,var(--mod-icon-size,var(--spectrum-icon-size)));--spectrum-icon-block-size:var(--mod-icon-block-size,var(--mod-icon-size,var(--spectrum-icon-size)));inline-size:var(--spectrum-icon-inline-size);block-size:var(--spectrum-icon-block-size);color:var(--mod-icon-color,inherit);fill:currentColor;pointer-events:none;display:inline-block}@media (forced-colors:active){:host{forced-color-adjust:auto}}:host{--spectrum-icon-size:var(--spectrum-workflow-icon-size-100)}:host([size=xxs]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-xxs)}:host([size=xs]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-50)}:host([size=s]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-75)}:host([size=l]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-200)}:host([size=xl]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-300)}:host([size=xxl]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-xxl)}#container{height:100%}img,svg,::slotted(*){vertical-align:top;width:100%;height:100%;color:inherit}@media (forced-colors:active){img,svg,::slotted(*){forced-color-adjust:auto}}:host(:not(:root)){overflow:hidden}
`;
var icon_css_default = i9;

// node_modules/@spectrum-web-components/icon/src/IconBase.js
var c8 = Object.defineProperty;
var m6 = Object.getOwnPropertyDescriptor;
var l6 = (i21, r25, e36, s19) => {
  for (var t34 = s19 > 1 ? void 0 : s19 ? m6(r25, e36) : r25, o52 = i21.length - 1, u36; o52 >= 0; o52--) (u36 = i21[o52]) && (t34 = (s19 ? u36(r25, e36, t34) : u36(t34)) || t34);
  return s19 && t34 && c8(r25, e36, t34), t34;
};
var IconBase = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.unsubscribeSystemContext = null;
    this.spectrumVersion = 1;
    this.label = "";
    this.systemResolver = new SystemResolutionController(this);
  }
  static get styles() {
    return [icon_css_default];
  }
  connectedCallback() {
    super.connectedCallback();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.unsubscribeSystemContext && (this.unsubscribeSystemContext(), this.unsubscribeSystemContext = null);
  }
  update(e36) {
    e36.has("label") && (this.label ? this.removeAttribute("aria-hidden") : this.setAttribute("aria-hidden", "true")), e36.has(systemResolverUpdatedSymbol) && (this.spectrumVersion = this.systemResolver.system === "spectrum-two" ? 2 : 1), super.update(e36);
  }
  render() {
    return x`
            <slot></slot>
        `;
  }
};
l6([r5()], IconBase.prototype, "spectrumVersion", 2), l6([n4({ reflect: true })], IconBase.prototype, "label", 2), l6([n4({ reflect: true })], IconBase.prototype, "size", 2);

// node_modules/@spectrum-web-components/icons-workflow/src/custom-tag.js
var t9;
var tag = function(e36, ...a23) {
  return t9 ? t9(e36, ...a23) : a23.reduce((r25, p30, l16) => r25 + p30 + e36[l16 + 1], e36[0]);
};
var setCustomTemplateLiteralTag = (e36) => {
  t9 = e36;
};

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Link.js
var LinkIcon = ({ width: l16 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Link" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m5.31348,18.74805c-1.04102,0-2.08105-.39648-2.87305-1.18848-1.58398-1.58398-1.58398-4.16211,0-5.74707l3.90527-3.90527c1.58496-1.58398,4.16211-1.58301,5.74707,0,.2168.21777.40723.45703.56641.70996.2207.35059.11523.81348-.23535,1.03418-.35254.22168-.81348.11426-1.03418-.23535-.10059-.16016-.22168-.31152-.35938-.44922-.99902-.99902-2.625-.99805-3.62402.00098l-3.90527,3.90527c-.99902,1-.99902,2.62695,0,3.62598,1.00098,1.00098,2.62695.99707,3.62598,0l1.95215-1.95215c.29297-.29297.76758-.29297,1.06055,0s.29297.76758,0,1.06055l-1.95215,1.95215c-.79199.79199-1.83301,1.1875-2.87402,1.18848Zm8.34082-6.65527l3.90527-3.90527c1.58398-1.58496,1.58398-4.16309,0-5.74707s-4.16309-1.58398-5.74707,0l-1.95215,1.95215c-.29297.29297-.29297.76758,0,1.06055s.76758.29297,1.06055,0l1.95215-1.95215c.99902-.99805,2.625-1,3.62598,0,.99902.99902.99902,2.62598,0,3.62598l-3.90527,3.90527c-.99902.99902-2.625,1-3.62402.00098-.1377-.1377-.25879-.28906-.35938-.44922-.2207-.34961-.68164-.45703-1.03418-.23535-.35059.2207-.45605.68359-.23535,1.03418.15918.25293.34961.49219.56641.70996.79297.79199,1.83301,1.18848,2.87402,1.18848,1.04004,0,2.08105-.39648,2.87305-1.18848Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Link.js
var LinkIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "Link" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M31.7 4.3a7.176 7.176 0 0 0-10.148 0c-.385.386-4.264 4.222-5.351 5.309a8.307 8.307 0 0 1 3.743.607c.519-.52 3.568-3.526 3.783-3.741a4.1 4.1 0 0 1 5.8 5.8l-7.119 7.115a4.617 4.617 0 0 1-3.372 1.3 3.953 3.953 0 0 1-2.7-1.109 4.154 4.154 0 0 1-1.241-1.626 2.067 2.067 0 0 0-.428.318l-1.635 1.712a7.144 7.144 0 0 0 1.226 1.673c2.8 2.8 7.875 2.364 10.677-.438l6.765-6.768a7.174 7.174 0 0 0 0-10.152Z"
    />
    <path
      d="M15.926 25.824c-.52.52-3.5 3.547-3.713 3.762a4.1 4.1 0 1 1-5.8-5.8L13.6 16.6a4.58 4.58 0 0 1 3.366-1.292 4.2 4.2 0 0 1 3.784 2.782 2.067 2.067 0 0 0 .428-.318l1.734-1.721a7.165 7.165 0 0 0-1.226-1.673 7.311 7.311 0 0 0-10.26.048l-7.187 7.186a7.176 7.176 0 0 0 10.148 10.149c.386-.386 4.194-4.243 5.281-5.33a8.3 8.3 0 0 1-3.742-.607Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLink.js
var IconLink = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? LinkIcon({ hidden: !this.label, title: this.label }) : LinkIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-link.js
init_define_element();
defineElement("sp-icon-link", IconLink);

// src/custom-elements/core/spectrum-color-palette.js
init_lit();
init_style_map2();

// node_modules/@spectrum-web-components/link/src/Link.js
init_decorators2();
init_like_anchor();
init_focusable();

// node_modules/@spectrum-web-components/link/src/link.css.js
init_src();
var t10 = i`
    @media (forced-colors:active){:host{--highcontrast-link-text-color:LinkText}}:host([variant=secondary]) a{--mod-link-text-color:var(--mod-link-text-color-secondary-default,var(--spectrum-neutral-content-color-default));--mod-link-text-color-hover:var(--mod-link-text-color-secondary-hover,var(--spectrum-neutral-content-color-hover));--mod-link-text-color-active:var(--mod-link-text-color-secondary-active,var(--spectrum-neutral-content-color-down));--mod-link-text-color-focus:var(--mod-link-text-color-secondary-focus,var(--spectrum-neutral-content-color-key-focus))}a{background-color:initial;-webkit-text-decoration-skip:objects;text-decoration-skip:objects;transition:color var(--mod-link-animation-duration,var(--spectrum-animation-duration-100))ease-in-out;cursor:pointer;color:var(--highcontrast-link-text-color,var(--mod-link-text-color,var(--mod-link-text-color-primary-default,var(--spectrum-accent-content-color-default))));outline:none;-webkit-text-decoration:underline;text-decoration:underline}a:active{--mod-link-text-color:var(--mod-link-text-color-active,var(--mod-link-text-color-primary-active,var(--spectrum-accent-content-color-down)))}:host([quiet]) a{-webkit-text-decoration:none;text-decoration:none}a:focus-visible,:host([quiet]) a:focus-visible{--mod-link-text-color:var(--mod-link-text-color-focus,var(--mod-link-text-color-primary-focus,var(--spectrum-accent-content-color-key-focus)));text-decoration:underline double;text-decoration-color:inherit}@media (hover:hover){a:hover{--mod-link-text-color:var(--mod-link-text-color-hover,var(--mod-link-text-color-primary-hover,var(--spectrum-accent-content-color-hover)))}:host([quiet]) a:hover{-webkit-text-decoration:underline;text-decoration:underline}}:host([static-color=white]) a{--mod-link-text-color:var(--mod-link-text-color-white,var(--spectrum-white));--mod-link-text-color-hover:var(--mod-link-text-color-white,var(--spectrum-white));--mod-link-text-color-active:var(--mod-link-text-color-white,var(--spectrum-white));--mod-link-text-color-focus:var(--mod-link-text-color-white,var(--spectrum-white))}:host([static-color=black]) a{--mod-link-text-color:var(--mod-link-text-color-black,var(--spectrum-black));--mod-link-text-color-hover:var(--mod-link-text-color-black,var(--spectrum-black));--mod-link-text-color-active:var(--mod-link-text-color-black,var(--spectrum-black));--mod-link-text-color-focus:var(--mod-link-text-color-black,var(--spectrum-black))}:host{display:inline}:host(:focus){outline:none}:host([href]) a:focus-visible{text-decoration:underline double}:host([disabled]){pointer-events:none}
`;
var link_css_default = t10;

// node_modules/@spectrum-web-components/link/src/Link.js
var a4 = Object.defineProperty;
var s7 = Object.getOwnPropertyDescriptor;
var t11 = (l16, r25, i21, o52) => {
  for (var e36 = o52 > 1 ? void 0 : o52 ? s7(r25, i21) : r25, c33 = l16.length - 1, u36; c33 >= 0; c33--) (u36 = l16[c33]) && (e36 = (o52 ? u36(r25, i21, e36) : u36(e36)) || e36);
  return o52 && e36 && a4(r25, i21, e36), e36;
};
var Link = class extends LikeAnchor(Focusable) {
  constructor() {
    super(...arguments);
    this.quiet = false;
  }
  static get styles() {
    return [link_css_default];
  }
  get focusElement() {
    return this.anchorElement;
  }
  render() {
    return this.renderAnchor({ id: "anchor" });
  }
};
t11([e5("#anchor")], Link.prototype, "anchorElement", 2), t11([n4({ type: String, reflect: true })], Link.prototype, "variant", 2), t11([n4({ reflect: true, attribute: "static-color" })], Link.prototype, "staticColor", 2), t11([n4({ type: Boolean, reflect: true, attribute: "quiet" })], Link.prototype, "quiet", 2);

// node_modules/@spectrum-web-components/link/sp-link.js
init_define_element();
defineElement("sp-link", Link);

// node_modules/@spectrum-web-components/button/src/Button.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/button/src/ButtonBase.js
init_src();
init_decorators2();
init_like_anchor();
init_focusable();
init_observe_slot_text();

// node_modules/@spectrum-web-components/button/src/button-base.css.js
init_src();
var e15 = i`
    :host{vertical-align:top;--spectrum-progress-circle-size:var(--spectrum-workflow-icon-size-100);--spectrum-icon-size:var(--spectrum-workflow-icon-size-100);display:inline-flex}:host([dir]){-webkit-appearance:none}:host([disabled]){pointer-events:none;cursor:auto}#button{position:absolute;inset:0}::slotted(sp-overlay),::slotted(sp-tooltip){position:absolute}:host:after,::slotted(*){pointer-events:none}slot[name=icon]::slotted(svg),slot[name=icon]::slotted(img){fill:currentColor;stroke:currentColor;block-size:var(--spectrum-icon-size,var(--spectrum-workflow-icon-size-100));inline-size:var(--spectrum-icon-size,var(--spectrum-workflow-icon-size-100))}[icon-only]+#label{display:contents}:host([size=xs]){--spectrum-progress-circle-size:var(--spectrum-workflow-icon-size-50);--spectrum-icon-size:var(--spectrum-workflow-icon-size-50)}:host([size=s]){--spectrum-progress-circle-size:var(--spectrum-workflow-icon-size-75);--spectrum-icon-size:var(--spectrum-workflow-icon-size-75)}:host([size=l]){--spectrum-progress-circle-size:var(--spectrum-workflow-icon-size-200);--spectrum-icon-size:var(--spectrum-workflow-icon-size-200)}:host([size=xl]){--spectrum-progress-circle-size:var(--spectrum-workflow-icon-size-300);--spectrum-icon-size:var(--spectrum-workflow-icon-size-300)}:host([size=xxl]){--spectrum-progress-circle-size:var(--spectrum-workflow-icon-size-400);--spectrum-icon-size:var(--spectrum-workflow-icon-size-400)}
`;
var button_base_css_default = e15;

// node_modules/@spectrum-web-components/button/src/ButtonBase.js
var u9 = Object.defineProperty;
var d5 = Object.getOwnPropertyDescriptor;
var s8 = (n25, i21, e36, t34) => {
  for (var r25 = t34 > 1 ? void 0 : t34 ? d5(i21, e36) : i21, a23 = n25.length - 1, l16; a23 >= 0; a23--) (l16 = n25[a23]) && (r25 = (t34 ? l16(i21, e36, r25) : l16(r25)) || r25);
  return t34 && r25 && u9(i21, e36, r25), r25;
};
var ButtonBase = class extends ObserveSlotText(LikeAnchor(Focusable), "", ["sp-overlay,sp-tooltip"]) {
  constructor() {
    super();
    this.active = false;
    this.type = "button";
    this.proxyFocus = this.proxyFocus.bind(this), this.addEventListener("click", this.handleClickCapture, { capture: true });
  }
  static get styles() {
    return [button_base_css_default];
  }
  get focusElement() {
    return this;
  }
  get hasLabel() {
    return this.slotHasContent;
  }
  get buttonContent() {
    return [x`
                <slot name="icon" ?icon-only=${!this.hasLabel}></slot>
            `, x`
                <span id="label">
                    <slot @slotchange=${this.manageTextObservedSlot}></slot>
                </span>
            `];
  }
  handleClickCapture(e36) {
    if (this.disabled) return e36.preventDefault(), e36.stopImmediatePropagation(), e36.stopPropagation(), false;
    this.shouldProxyClick(e36);
  }
  proxyFocus() {
    this.focus();
  }
  shouldProxyClick(e36) {
    let t34 = false;
    if (e36 && (e36.metaKey || e36.ctrlKey || e36.shiftKey || e36.altKey)) return false;
    if (this.anchorElement) this.anchorElement.click(), t34 = true;
    else if (this.type !== "button") {
      const r25 = document.createElement("button");
      r25.type = this.type, this.insertAdjacentElement("afterend", r25), r25.click(), r25.remove(), t34 = true;
    }
    return t34;
  }
  renderAnchor() {
    return x`
            ${this.buttonContent}
            ${super.renderAnchor({ id: "button", ariaHidden: true, className: "button anchor", tabindex: -1 })}
        `;
  }
  renderButton() {
    return x`
            ${this.buttonContent}
        `;
  }
  render() {
    return this.href && this.href.length > 0 ? this.renderAnchor() : this.renderButton();
  }
  handleKeydown(e36) {
    const { code: t34 } = e36;
    switch (t34) {
      case "Space":
        e36.preventDefault(), typeof this.href == "undefined" && (this.addEventListener("keyup", this.handleKeyup), this.active = true);
        break;
      default:
        break;
    }
  }
  handleKeypress(e36) {
    const { code: t34 } = e36;
    switch (t34) {
      case "Enter":
      case "NumpadEnter":
        this.click();
        break;
      default:
        break;
    }
  }
  handleKeyup(e36) {
    const { code: t34 } = e36;
    switch (t34) {
      case "Space":
        this.removeEventListener("keyup", this.handleKeyup), this.active = false, this.click();
        break;
      default:
        break;
    }
  }
  manageAnchor() {
    this.href && this.href.length > 0 ? (!this.hasAttribute("role") || this.getAttribute("role") === "button") && this.setAttribute("role", "link") : (!this.hasAttribute("role") || this.getAttribute("role") === "link") && this.setAttribute("role", "button");
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.hasAttribute("tabindex") || this.setAttribute("tabindex", "0"), this.manageAnchor(), this.addEventListener("keydown", this.handleKeydown), this.addEventListener("keypress", this.handleKeypress);
  }
  updated(e36) {
    super.updated(e36), e36.has("href") && this.manageAnchor(), e36.has("label") && (this.label ? this.setAttribute("aria-label", this.label) : this.removeAttribute("aria-label")), this.anchorElement && (this.anchorElement.tabIndex = -1, this.anchorElement.hasAttribute("aria-hidden") || this.anchorElement.setAttribute("aria-hidden", "true"), this.anchorElement.addEventListener("focus", this.proxyFocus));
  }
};
s8([n4({ type: Boolean, reflect: true })], ButtonBase.prototype, "active", 2), s8([n4({ type: String })], ButtonBase.prototype, "type", 2), s8([e5(".anchor")], ButtonBase.prototype, "anchorElement", 2);

// node_modules/@spectrum-web-components/button/src/button.css.js
init_src();
var o16 = i`
    :host{cursor:pointer;-webkit-user-select:none;user-select:none;box-sizing:border-box;font-family:var(--mod-button-font-family,var(--mod-sans-font-family-stack,var(--spectrum-sans-font-family-stack)));-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;line-height:var(--mod-button-line-height,var(--mod-line-height-100,var(--spectrum-line-height-100)));text-transform:none;vertical-align:top;-webkit-appearance:button;transition:background var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,border-color var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,color var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,box-shadow var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out;justify-content:center;align-items:center;margin:0;-webkit-text-decoration:none;text-decoration:none;display:inline-flex;overflow:visible}:host(:focus){outline:none}:host .is-disabled,:host([disabled]){cursor:default}:host:after{margin:calc(var(--mod-button-focus-indicator-gap,var(--spectrum-focus-indicator-gap))*-1);transition:opacity var(--mod-button-animation-duration,var(--mod-button-animation-duration,var(--spectrum-animation-duration-100)))ease-out,margin var(--mod-button-animation-duration,var(--mod-button-animation-duration,var(--spectrum-animation-duration-100)))ease-out;display:block;inset-block:0;inset-inline:0}:host(:focus-visible):after{margin:calc(var(--mod-focus-indicator-gap,var(--spectrum-focus-indicator-gap))*-2)}#label{text-align:center;place-self:center}#label[hidden]{display:none}:host{--spectrum-button-sized-height:var(--spectrum-component-height-100);--spectrum-button-sized-font-size:var(--spectrum-font-size-100);--spectrum-button-sized-edge-to-visual:calc(var(--spectrum-component-pill-edge-to-visual-100) - var(--spectrum-button-border-width));--spectrum-button-sized-edge-to-visual-only:var(--spectrum-component-pill-edge-to-visual-only-100);--spectrum-button-sized-edge-to-text:calc(var(--spectrum-component-pill-edge-to-text-100) - var(--spectrum-button-border-width));--spectrum-button-sized-padding-label-to-icon:var(--spectrum-text-to-visual-100);--spectrum-button-sized-top-to-text:var(--spectrum-button-top-to-text-medium);--spectrum-button-sized-bottom-to-text:var(--spectrum-button-bottom-to-text-medium);--spectrum-button-sized-top-to-icon:var(--spectrum-component-top-to-workflow-icon-100);--spectrum-button-intended-icon-size:var(--spectrum-workflow-icon-size-100)}:host([size=s]){--spectrum-button-sized-height:var(--spectrum-component-height-75);--spectrum-button-sized-font-size:var(--spectrum-font-size-75);--spectrum-button-sized-edge-to-visual:calc(var(--spectrum-component-pill-edge-to-visual-75) - var(--spectrum-button-border-width));--spectrum-button-sized-edge-to-visual-only:var(--spectrum-component-pill-edge-to-visual-only-75);--spectrum-button-sized-edge-to-text:calc(var(--spectrum-component-pill-edge-to-text-75) - var(--spectrum-button-border-width));--spectrum-button-sized-padding-label-to-icon:var(--spectrum-text-to-visual-75);--spectrum-button-sized-top-to-text:var(--spectrum-button-top-to-text-small);--spectrum-button-sized-bottom-to-text:var(--spectrum-button-bottom-to-text-small);--spectrum-button-sized-top-to-icon:var(--spectrum-component-top-to-workflow-icon-75);--spectrum-button-intended-icon-size:var(--spectrum-workflow-icon-size-75)}:host([size=l]){--spectrum-button-sized-height:var(--spectrum-component-height-200);--spectrum-button-sized-font-size:var(--spectrum-font-size-200);--spectrum-button-sized-edge-to-visual:calc(var(--spectrum-component-pill-edge-to-visual-200) - var(--spectrum-button-border-width));--spectrum-button-sized-edge-to-visual-only:var(--spectrum-component-pill-edge-to-visual-only-200);--spectrum-button-sized-edge-to-text:calc(var(--spectrum-component-pill-edge-to-text-200) - var(--spectrum-button-border-width));--spectrum-button-sized-padding-label-to-icon:var(--spectrum-text-to-visual-200);--spectrum-button-sized-top-to-text:var(--spectrum-button-top-to-text-large);--spectrum-button-sized-bottom-to-text:var(--spectrum-button-bottom-to-text-large);--spectrum-button-sized-top-to-icon:var(--spectrum-component-top-to-workflow-icon-200);--spectrum-button-intended-icon-size:var(--spectrum-workflow-icon-size-200)}:host([size=xl]){--spectrum-button-sized-height:var(--spectrum-component-height-300);--spectrum-button-sized-font-size:var(--spectrum-font-size-300);--spectrum-button-sized-edge-to-visual:calc(var(--spectrum-component-pill-edge-to-visual-300) - var(--spectrum-button-border-width));--spectrum-button-sized-edge-to-visual-only:var(--spectrum-component-pill-edge-to-visual-only-300);--spectrum-button-sized-edge-to-text:calc(var(--spectrum-component-pill-edge-to-text-300) - var(--spectrum-button-border-width));--spectrum-button-sized-padding-label-to-icon:var(--spectrum-text-to-visual-300);--spectrum-button-sized-top-to-text:var(--spectrum-button-top-to-text-extra-large);--spectrum-button-sized-bottom-to-text:var(--spectrum-button-bottom-to-text-extra-large);--spectrum-button-sized-top-to-icon:var(--spectrum-component-top-to-workflow-icon-300);--spectrum-button-intended-icon-size:var(--spectrum-workflow-icon-size-300)}:host{--spectrum-button-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-button-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-button-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-button-content-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-button-content-color-disabled:var(--spectrum-disabled-content-color)}:host([selected]){--spectrum-button-border-color-default:transparent;--spectrum-button-border-color-hover:transparent;--spectrum-button-border-color-down:transparent;--spectrum-button-border-color-focus:transparent;--spectrum-button-content-color-default:var(--spectrum-white);--spectrum-button-content-color-hover:var(--spectrum-white);--spectrum-button-content-color-down:var(--spectrum-white);--spectrum-button-content-color-focus:var(--spectrum-white);--spectrum-button-background-color-disabled:var(--spectrum-disabled-background-color);--spectrum-button-border-color-disabled:transparent}:host([selected][emphasized]),:host([variant=accent]){--spectrum-button-background-color-default:var(--spectrum-accent-background-color-default);--spectrum-button-background-color-hover:var(--spectrum-accent-background-color-hover);--spectrum-button-background-color-down:var(--spectrum-accent-background-color-down);--spectrum-button-background-color-focus:var(--spectrum-accent-background-color-key-focus)}:host([variant=accent]){--spectrum-button-background-color-disabled:var(--spectrum-disabled-background-color);--spectrum-button-border-color-default:transparent;--spectrum-button-border-color-hover:transparent;--spectrum-button-border-color-down:transparent;--spectrum-button-border-color-focus:transparent;--spectrum-button-border-color-disabled:transparent;--spectrum-button-content-color-default:var(--spectrum-white);--spectrum-button-content-color-hover:var(--spectrum-white);--spectrum-button-content-color-down:var(--spectrum-white);--spectrum-button-content-color-focus:var(--spectrum-white)}:host([variant=accent][treatment=outline]){--spectrum-button-background-color-hover:var(--spectrum-accent-color-200);--spectrum-button-background-color-down:var(--spectrum-accent-color-300);--spectrum-button-background-color-focus:var(--spectrum-accent-color-200);--spectrum-button-border-color-default:var(--spectrum-accent-color-900);--spectrum-button-border-color-hover:var(--spectrum-accent-color-1000);--spectrum-button-border-color-down:var(--spectrum-accent-color-1100);--spectrum-button-border-color-focus:var(--spectrum-accent-color-1000);--spectrum-button-border-color-disabled:var(--spectrum-disabled-border-color);--spectrum-button-content-color-default:var(--spectrum-accent-content-color-default);--spectrum-button-content-color-hover:var(--spectrum-accent-content-color-hover);--spectrum-button-content-color-down:var(--spectrum-accent-content-color-down);--spectrum-button-content-color-focus:var(--spectrum-accent-content-color-key-focus);--spectrum-button-content-color-disabled:var(--spectrum-disabled-content-color)}:host([variant=negative]){--spectrum-button-background-color-default:var(--spectrum-negative-background-color-default);--spectrum-button-background-color-hover:var(--spectrum-negative-background-color-hover);--spectrum-button-background-color-down:var(--spectrum-negative-background-color-down);--spectrum-button-background-color-focus:var(--spectrum-negative-background-color-key-focus);--spectrum-button-border-color-default:transparent;--spectrum-button-border-color-hover:transparent;--spectrum-button-border-color-down:transparent;--spectrum-button-border-color-focus:transparent;--spectrum-button-content-color-default:var(--spectrum-white);--spectrum-button-content-color-hover:var(--spectrum-white);--spectrum-button-content-color-down:var(--spectrum-white);--spectrum-button-content-color-focus:var(--spectrum-white);--spectrum-button-background-color-disabled:var(--spectrum-disabled-background-color);--spectrum-button-border-color-disabled:transparent;--spectrum-button-content-color-disabled:var(--spectrum-disabled-content-color)}:host([variant=negative][treatment=outline]){--spectrum-button-background-color-hover:var(--spectrum-negative-color-200);--spectrum-button-background-color-down:var(--spectrum-negative-color-300);--spectrum-button-background-color-focus:var(--spectrum-negative-color-200);--spectrum-button-border-color-default:var(--spectrum-negative-color-900);--spectrum-button-border-color-hover:var(--spectrum-negative-color-1000);--spectrum-button-border-color-down:var(--spectrum-negative-color-1100);--spectrum-button-border-color-focus:var(--spectrum-negative-color-1000);--spectrum-button-border-color-disabled:var(--spectrum-disabled-border-color);--spectrum-button-content-color-default:var(--spectrum-negative-content-color-default);--spectrum-button-content-color-hover:var(--spectrum-negative-content-color-hover);--spectrum-button-content-color-down:var(--spectrum-negative-content-color-down);--spectrum-button-content-color-focus:var(--spectrum-negative-content-color-key-focus);--spectrum-button-content-color-disabled:var(--spectrum-disabled-content-color)}:host([variant=primary]){--spectrum-button-background-color-default:var(--spectrum-neutral-background-color-default);--spectrum-button-background-color-hover:var(--spectrum-neutral-background-color-hover);--spectrum-button-background-color-down:var(--spectrum-neutral-background-color-down);--spectrum-button-background-color-focus:var(--spectrum-neutral-background-color-key-focus);--spectrum-button-background-color-disabled:var(--spectrum-disabled-background-color);--spectrum-button-border-color-default:transparent;--spectrum-button-border-color-hover:transparent;--spectrum-button-border-color-down:transparent;--spectrum-button-border-color-focus:transparent;--spectrum-button-border-color-disabled:transparent}:host([variant=primary][treatment=outline]){--spectrum-button-border-color-default:var(--spectrum-gray-800);--spectrum-button-border-color-hover:var(--spectrum-gray-900);--spectrum-button-border-color-down:var(--spectrum-gray-900);--spectrum-button-border-color-focus:var(--spectrum-gray-900);--spectrum-button-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-button-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-button-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-button-content-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-button-border-color-disabled:var(--spectrum-disabled-border-color);--spectrum-button-content-color-disabled:var(--spectrum-disabled-content-color)}:host([variant=secondary]){--spectrum-button-background-color-disabled:var(--spectrum-disabled-background-color);--spectrum-button-border-color-default:transparent;--spectrum-button-border-color-hover:transparent;--spectrum-button-border-color-down:transparent;--spectrum-button-border-color-focus:transparent;--spectrum-button-border-color-disabled:transparent;--spectrum-button-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-button-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-button-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-button-content-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-button-content-color-disabled:var(--spectrum-disabled-content-color)}:host([variant=secondary][treatment=outline]){--spectrum-button-background-color-down:var(--spectrum-gray-400);--spectrum-button-border-color-default:var(--spectrum-gray-300);--spectrum-button-border-color-hover:var(--spectrum-gray-400);--spectrum-button-border-color-focus:var(--spectrum-gray-400);--spectrum-button-border-color-disabled:var(--spectrum-disabled-border-color);--spectrum-button-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-button-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-button-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-button-content-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-button-content-color-disabled:var(--spectrum-disabled-content-color)}:host([quiet]){--spectrum-button-background-color-hover:var(--spectrum-gray-200);--spectrum-button-background-color-down:var(--spectrum-gray-300);--spectrum-button-background-color-focus:var(--spectrum-gray-200)}:host([quiet]),:host([static-color=black]),:host([static-color=white]){--spectrum-button-border-color-default:transparent;--spectrum-button-border-color-hover:transparent;--spectrum-button-border-color-down:transparent;--spectrum-button-border-color-focus:transparent;--spectrum-button-border-color-disabled:transparent}:host([static-color=black][selected]),:host([static-color=white][selected]){--mod-button-content-color-default:var(--mod-button-static-content-color);--mod-button-content-color-hover:var(--mod-button-static-content-color);--mod-button-content-color-down:var(--mod-button-static-content-color);--mod-button-content-color-focus:var(--mod-button-static-content-color);--spectrum-button-border-color-disabled:transparent}:host([static-color=black][variant=secondary]),:host([static-color=white][variant=secondary]){--spectrum-button-border-color-default:transparent;--spectrum-button-border-color-hover:transparent;--spectrum-button-border-color-down:transparent;--spectrum-button-border-color-focus:transparent;--spectrum-button-border-color-disabled:transparent}:host([static-color=black][variant=secondary][treatment=outline]),:host([static-color=white][variant=secondary][treatment=outline]){--spectrum-button-background-color-disabled:transparent}:host([static-color=black][quiet]),:host([static-color=white][quiet]){--spectrum-button-border-color-default:transparent;--spectrum-button-border-color-hover:transparent;--spectrum-button-border-color-down:transparent;--spectrum-button-border-color-focus:transparent;--spectrum-button-border-color-disabled:transparent}:host([static-color=white]){--spectrum-button-content-color-disabled:var(--spectrum-disabled-static-white-content-color);--spectrum-button-background-color-disabled:var(--spectrum-disabled-static-white-background-color);--spectrum-button-focus-indicator-color:var(--spectrum-static-white-focus-indicator-color)}:host([static-color=white][treatment=outline]){--spectrum-button-content-color-disabled:var(--spectrum-disabled-static-white-content-color);--spectrum-button-border-color-disabled:var(--spectrum-disabled-static-white-border-color)}:host([static-color=white][variant=secondary]){--spectrum-button-background-color-disabled:var(--spectrum-disabled-static-white-background-color)}:host([static-color=black]){--spectrum-button-content-color-disabled:var(--spectrum-disabled-static-black-content-color);--spectrum-button-background-color-disabled:var(--spectrum-disabled-static-black-background-color);--spectrum-button-focus-indicator-color:var(--mod-static-black-focus-indicator-color,var(--spectrum-static-black-focus-indicator-color))}:host([static-color=black][treatment=outline]){--spectrum-button-content-color-disabled:var(--spectrum-disabled-static-black-content-color);--spectrum-button-border-color-disabled:var(--spectrum-disabled-static-black-border-color)}:host([static-color=black][variant=secondary]){--spectrum-button-background-color-disabled:var(--spectrum-disabled-static-black-background-color)}:host([treatment=outline]),:host([quiet]){--spectrum-button-background-color-default:transparent;--spectrum-button-background-color-disabled:transparent}:host{--spectrum-button-height:var(--mod-button-height,var(--spectrum-button-sized-height));--spectrum-button-min-width:var(--mod-button-min-width,calc(var(--spectrum-button-height)*var(--spectrum-button-minimum-width-multiplier)));--spectrum-button-line-height:var(--mod-button-line-height,1.2);--spectrum-button-font-size:var(--mod-button-font-size,var(--spectrum-button-sized-font-size));--spectrum-button-padding-label-to-icon:var(--mod-button-padding-label-to-icon,var(--spectrum-button-sized-padding-label-to-icon));--spectrum-button-edge-to-visual:var(--mod-button-edge-to-visual,var(--spectrum-button-sized-edge-to-visual));--spectrum-button-edge-to-visual-only:var(--mod-button-edge-to-visual-only,var(--spectrum-button-sized-edge-to-visual-only));--spectrum-button-edge-to-text:var(--mod-button-edge-to-text,var(--spectrum-button-sized-edge-to-text));--spectrum-button-top-to-text:var(--mod-button-top-to-text,var(--spectrum-button-sized-top-to-text));--spectrum-button-bottom-to-text:var(--mod-button-bottom-to-text,var(--spectrum-button-sized-bottom-to-text));--spectrum-button-top-to-icon:var(--mod-button-top-to-icon,var(--spectrum-button-sized-top-to-icon));--spectrum-button-focus-ring-thickness:var(--mod-button-focus-ring-thickness,var(--spectrum-focus-indicator-thickness));--spectrum-button-focus-indicator-color:var(--mod-button-focus-ring-color,var(--spectrum-focus-indicator-color));--spectrum-button-animation-duration:var(--mod-button-animation-duration,var(--spectrum-animation-duration-100));--spectrum-button-border-width:var(--mod-button-border-width,var(--spectrum-border-width-200));--spectrum-button-focus-ring-gap:var(--mod-focus-indicator-gap,var(--mod-button-focus-ring-gap,var(--spectrum-focus-indicator-gap)));--spectrum-button-border-radius:var(--mod-button-border-radius,calc(var(--spectrum-button-height)/2));--mod-progress-circle-position:absolute;border-radius:var(--spectrum-button-border-radius);border-width:var(--spectrum-button-border-width);font-size:var(--spectrum-button-font-size);font-weight:var(--mod-bold-font-weight,var(--spectrum-bold-font-weight));gap:var(--spectrum-button-padding-label-to-icon);max-inline-size:var(--mod-button-max-inline-size,none);min-inline-size:var(--spectrum-button-min-width);min-block-size:var(--spectrum-button-height);padding-block:0;padding-inline:var(--spectrum-button-edge-to-text);margin-block:var(--mod-button-margin-block);background-color:var(--highcontrast-button-background-color-default,var(--mod-button-background-color-default,var(--spectrum-button-background-color-default)));border-style:solid;border-color:var(--highcontrast-button-border-color-default,var(--mod-button-border-color-default,var(--spectrum-button-border-color-default)));color:var(--highcontrast-button-content-color-default,var(--mod-button-content-color-default,var(--spectrum-button-content-color-default,inherit)));transition:border var(--spectrum-button-animation-duration,.13s)linear,color var(--spectrum-button-animation-duration,.13s)linear,background-color var(--spectrum-button-animation-duration,.13s)linear;margin-inline-start:var(--mod-button-margin-left);margin-inline-end:var(--mod-button-margin-right);position:relative}:host([treatment=outline]){background-color:initial}:host:after{margin:var(--mod-button-focus-ring-border-radius,calc((var(--spectrum-button-focus-ring-gap) + var(--spectrum-button-border-width))*-1));transition:box-shadow var(--spectrum-button-animation-duration)ease-in-out;pointer-events:none;content:"";border-radius:calc(var(--spectrum-button-border-radius) + var(--spectrum-focus-indicator-gap));position:absolute;inset:0}:host(:focus-visible){background-color:var(--highcontrast-button-background-color-focus,var(--mod-button-background-color-focus,var(--spectrum-button-background-color-focus)));border-color:var(--highcontrast-button-border-color-focus,var(--mod-button-border-color-focus,var(--spectrum-button-border-color-focus)));color:var(--highcontrast-button-content-color-focus,var(--mod-button-content-color-focus,var(--spectrum-button-content-color-focus)));box-shadow:none;outline:none}:host([focused]):after,:host(:focus-visible):after{box-shadow:0 0 0 var(--spectrum-button-focus-ring-thickness)var(--spectrum-button-focus-indicator-color)}:host(:is(:active,[active])){background-color:var(--highcontrast-button-background-color-down,var(--mod-button-background-color-down,var(--spectrum-button-background-color-down)));border-color:var(--highcontrast-button-border-color-down,var(--mod-button-border-color-down,var(--spectrum-button-border-color-down)));color:var(--highcontrast-button-content-color-down,var(--mod-button-content-color-down,var(--spectrum-button-content-color-down)));box-shadow:none}@media (hover:hover){:host(:hover){background-color:var(--highcontrast-button-background-color-hover,var(--mod-button-background-color-hover,var(--spectrum-button-background-color-hover)));border-color:var(--highcontrast-button-border-color-hover,var(--mod-button-border-color-hover,var(--spectrum-button-border-color-hover)));color:var(--highcontrast-button-content-color-hover,var(--mod-button-content-color-hover,var(--spectrum-button-content-color-hover)));box-shadow:none}}:host .is-disabled,:host([pending]),:host([disabled]),:host([pending]){background-color:var(--highcontrast-button-background-color-disabled,var(--mod-button-background-color-disabled,var(--spectrum-button-background-color-disabled)));border-color:var(--highcontrast-button-border-color-disabled,var(--mod-button-border-color-disabled,var(--spectrum-button-border-color-disabled)));color:var(--highcontrast-button-content-color-disabled,var(--mod-button-content-color-disabled,var(--spectrum-button-content-color-disabled)))}::slotted([slot=icon]){--_icon-size-difference:max(0px,var(--spectrum-button-intended-icon-size) - var(--spectrum-icon-block-size,var(--spectrum-button-intended-icon-size)));margin-block-start:var(--mod-button-icon-margin-block-start,max(0px,var(--mod-button-top-to-icon,var(--spectrum-button-top-to-icon)) - var(--mod-button-border-width,var(--spectrum-button-border-width)) + (var(--_icon-size-difference,0px)/2)));margin-inline-start:calc(var(--mod-button-edge-to-visual,var(--spectrum-button-edge-to-visual)) - var(--mod-button-edge-to-text,var(--spectrum-button-edge-to-text)))}:host([icon-only]){padding:calc(var(--mod-button-edge-to-visual-only,var(--spectrum-button-edge-to-visual-only)) - var(--mod-button-border-width,var(--spectrum-button-border-width)))}#label,::slotted([slot=icon]){visibility:visible;opacity:1;transition:opacity var(--spectrum-button-animation-duration,.13s)ease-in-out}.spectrum-ProgressCircle{visibility:hidden;opacity:0;transition:opacity var(--spectrum-button-animation-duration,.13s)ease-in-out,visibility 0s linear var(--spectrum-button-animation-duration,.13s)}:host([pending]),:host([pending]){cursor:default}:host([pending]) .spectrum-ProgressCircle,:host([pending]) .spectrum-ProgressCircle{visibility:visible;opacity:1;transition:opacity var(--spectrum-button-animation-duration,.13s)ease-in-out}::slotted([slot=icon]){--_icon-size-difference:max(0px,calc(var(--spectrum-button-intended-icon-size) - var(--spectrum-icon-block-size,var(--spectrum-button-intended-icon-size))));color:inherit;flex-shrink:0;align-self:flex-start;margin-block-start:var(--mod-button-icon-margin-block-start,max(0px,calc(var(--spectrum-button-top-to-icon) - var(--spectrum-button-border-width) + var(--_icon-size-difference,0px)/2)));margin-inline-start:calc(var(--spectrum-button-edge-to-visual) - var(--spectrum-button-edge-to-text))}:host([icon-only]){min-inline-size:unset;padding:calc(var(--spectrum-button-edge-to-visual-only) - var(--spectrum-button-border-width));border-radius:50%}:host([icon-only]) ::slotted([slot=icon]){align-self:center;margin-block-start:0;margin-inline-start:0}:host([icon-only]):after{border-radius:50%}[name=icon]+#label{text-align:var(--mod-button-text-align-with-icon,start)}#label{line-height:var(--spectrum-button-line-height);text-align:var(--mod-button-text-align,center);align-self:start;padding-block-start:calc(var(--spectrum-button-top-to-text) - var(--spectrum-button-border-width));padding-block-end:calc(var(--spectrum-button-bottom-to-text) - var(--spectrum-button-border-width))}:host([no-wrap]) #label{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@media (forced-colors:active){:host{--highcontrast-button-content-color-default:ButtonText;--highcontrast-button-content-color-hover:ButtonText;--highcontrast-button-content-color-focus:ButtonText;--highcontrast-button-content-color-down:ButtonText;--highcontrast-button-content-color-disabled:GrayText;--highcontrast-button-border-color-default:ButtonBorder;--highcontrast-button-border-color-hover:ButtonBorder;--highcontrast-button-border-color-focus:ButtonBorder;--highcontrast-button-border-color-down:ButtonBorder;--highcontrast-button-border-color-disabled:GrayText;--highcontrast-button-background-color-default:ButtonFace;--highcontrast-button-background-color-hover:ButtonFace;--highcontrast-button-background-color-down:ButtonFace;--highcontrast-button-background-color-focus:ButtonFace;--highcontrast-button-background-color-disabled:ButtonFace;--mod-progress-circle-track-border-color:ButtonText;--mod-progress-circle-track-border-color-over-background:ButtonText;--mod-progress-circle-thickness:var(--spectrum-progress-circle-thickness-medium);--spectrum-button-animation-duration:0s}#label{forced-color-adjust:none}:host(:focus-visible):after{forced-color-adjust:none;box-shadow:0 0 0 var(--spectrum-button-focus-ring-thickness)ButtonText}:host([variant=accent][treatment=fill]){--highcontrast-button-background-color-default:ButtonText;--highcontrast-button-background-color-hover:Highlight;--highcontrast-button-background-color-down:Highlight;--highcontrast-button-background-color-focus:Highlight;--highcontrast-button-background-color-disabled:ButtonFace;--highcontrast-button-content-color-default:ButtonFace;--highcontrast-button-content-color-hover:HighlightText;--highcontrast-button-content-color-down:HighlightText;--highcontrast-button-content-color-focus:HighlightText;--highcontrast-button-border-color-default:ButtonText;--highcontrast-button-border-color-hover:Highlight;--highcontrast-button-border-color-focus:Highlight;--highcontrast-button-border-color-down:Highlight}:host([static-color=white][variant=accent]){--highcontrast-button-content-color-disabled:GrayText}}:host{--spectrum-button-background-color-default:var(--system-button-background-color-default);--spectrum-button-background-color-hover:var(--system-button-background-color-hover);--spectrum-button-background-color-down:var(--system-button-background-color-down);--spectrum-button-background-color-focus:var(--system-button-background-color-focus);--spectrum-button-border-color-default:var(--system-button-border-color-default);--spectrum-button-border-color-hover:var(--system-button-border-color-hover);--spectrum-button-border-color-down:var(--system-button-border-color-down);--spectrum-button-border-color-focus:var(--system-button-border-color-focus);--spectrum-button-background-color-disabled:var(--system-button-background-color-disabled);--spectrum-button-border-color-disabled:var(--system-button-border-color-disabled)}:host([selected]){--spectrum-button-background-color-default:var(--system-button-selected-background-color-default);--spectrum-button-background-color-hover:var(--system-button-selected-background-color-hover);--spectrum-button-background-color-down:var(--system-button-selected-background-color-down);--spectrum-button-background-color-focus:var(--system-button-selected-background-color-focus)}:host([variant=primary]){--spectrum-button-content-color-default:var(--system-button-primary-content-color-default);--spectrum-button-content-color-hover:var(--system-button-primary-content-color-hover);--spectrum-button-content-color-down:var(--system-button-primary-content-color-down);--spectrum-button-content-color-focus:var(--system-button-primary-content-color-focus)}:host([variant=primary][treatment=outline]){--spectrum-button-background-color-hover:var(--system-button-primary-outline-background-color-hover);--spectrum-button-background-color-down:var(--system-button-primary-outline-background-color-down);--spectrum-button-background-color-focus:var(--system-button-primary-outline-background-color-focus)}:host([variant=secondary]){--spectrum-button-background-color-default:var(--system-button-secondary-background-color-default);--spectrum-button-background-color-hover:var(--system-button-secondary-background-color-hover);--spectrum-button-background-color-down:var(--system-button-secondary-background-color-down);--spectrum-button-background-color-focus:var(--system-button-secondary-background-color-focus)}:host([variant=secondary][treatment=outline]){--spectrum-button-background-color-hover:var(--system-button-secondary-outline-background-color-hover);--spectrum-button-background-color-down:var(--system-button-secondary-outline-background-color-down);--spectrum-button-background-color-focus:var(--system-button-secondary-outline-background-color-focus);--spectrum-button-border-color-default:var(--system-button-secondary-outline-border-color-default);--spectrum-button-border-color-down:var(--system-button-secondary-outline-border-color-down)}:host([static-color=white]){--spectrum-button-background-color-default:var(--system-button-static-white-background-color-default);--spectrum-button-background-color-hover:var(--system-button-static-white-background-color-hover);--spectrum-button-background-color-down:var(--system-button-static-white-background-color-down);--spectrum-button-background-color-focus:var(--system-button-static-white-background-color-focus);--spectrum-button-content-color-default:var(--system-button-static-white-content-color-default);--spectrum-button-content-color-hover:var(--system-button-static-white-content-color-hover);--spectrum-button-content-color-down:var(--system-button-static-white-content-color-down);--spectrum-button-content-color-focus:var(--system-button-static-white-content-color-focus)}:host([static-color=white][treatment=outline]){--spectrum-button-background-color-default:var(--system-button-static-white-outline-background-color-default);--spectrum-button-background-color-hover:var(--system-button-static-white-outline-background-color-hover);--spectrum-button-background-color-down:var(--system-button-static-white-outline-background-color-down);--spectrum-button-background-color-focus:var(--system-button-static-white-outline-background-color-focus);--spectrum-button-content-color-default:var(--system-button-static-white-outline-content-color-default);--spectrum-button-content-color-hover:var(--system-button-static-white-outline-content-color-hover);--spectrum-button-content-color-down:var(--system-button-static-white-outline-content-color-down);--spectrum-button-content-color-focus:var(--system-button-static-white-outline-content-color-focus);--spectrum-button-border-color-default:var(--system-button-static-white-outline-border-color-default);--spectrum-button-border-color-hover:var(--system-button-static-white-outline-border-color-hover);--spectrum-button-border-color-down:var(--system-button-static-white-outline-border-color-down);--spectrum-button-border-color-focus:var(--system-button-static-white-outline-border-color-focus)}:host([static-color=white][variant=secondary]){--spectrum-button-background-color-default:var(--system-button-static-white-secondary-background-color-default);--spectrum-button-background-color-hover:var(--system-button-static-white-secondary-background-color-hover);--spectrum-button-background-color-down:var(--system-button-static-white-secondary-background-color-down);--spectrum-button-background-color-focus:var(--system-button-static-white-secondary-background-color-focus);--spectrum-button-content-color-default:var(--system-button-static-white-secondary-content-color-default);--spectrum-button-content-color-hover:var(--system-button-static-white-secondary-content-color-hover);--spectrum-button-content-color-down:var(--system-button-static-white-secondary-content-color-down);--spectrum-button-content-color-focus:var(--system-button-static-white-secondary-content-color-focus)}:host([static-color=white][variant=secondary][treatment=outline]){--spectrum-button-border-color-default:var(--system-button-static-white-secondary-outline-border-color-default);--spectrum-button-border-color-hover:var(--system-button-static-white-secondary-outline-border-color-hover);--spectrum-button-border-color-down:var(--system-button-static-white-secondary-outline-border-color-down);--spectrum-button-border-color-focus:var(--system-button-static-white-secondary-outline-border-color-focus);--spectrum-button-background-color-default:var(--system-button-static-white-secondary-outline-background-color-default);--spectrum-button-background-color-hover:var(--system-button-static-white-secondary-outline-background-color-hover);--spectrum-button-background-color-down:var(--system-button-static-white-secondary-outline-background-color-down);--spectrum-button-background-color-focus:var(--system-button-static-white-secondary-outline-background-color-focus)}:host([static-color=black]){--spectrum-button-background-color-default:var(--system-button-static-black-background-color-default);--spectrum-button-background-color-hover:var(--system-button-static-black-background-color-hover);--spectrum-button-background-color-down:var(--system-button-static-black-background-color-down);--spectrum-button-background-color-focus:var(--system-button-static-black-background-color-focus);--spectrum-button-content-color-default:var(--system-button-static-black-content-color-default);--spectrum-button-content-color-hover:var(--system-button-static-black-content-color-hover);--spectrum-button-content-color-down:var(--system-button-static-black-content-color-down);--spectrum-button-content-color-focus:var(--system-button-static-black-content-color-focus)}:host([static-color=black][treatment=outline]){--spectrum-button-background-color-default:var(--system-button-static-black-outline-background-color-default);--spectrum-button-background-color-hover:var(--system-button-static-black-outline-background-color-hover);--spectrum-button-background-color-down:var(--system-button-static-black-outline-background-color-down);--spectrum-button-background-color-focus:var(--system-button-static-black-outline-background-color-focus);--spectrum-button-content-color-default:var(--system-button-static-black-outline-content-color-default);--spectrum-button-content-color-hover:var(--system-button-static-black-outline-content-color-hover);--spectrum-button-content-color-down:var(--system-button-static-black-outline-content-color-down);--spectrum-button-content-color-focus:var(--system-button-static-black-outline-content-color-focus);--spectrum-button-border-color-default:var(--system-button-static-black-outline-border-color-default);--spectrum-button-border-color-hover:var(--system-button-static-black-outline-border-color-hover);--spectrum-button-border-color-down:var(--system-button-static-black-outline-border-color-down);--spectrum-button-border-color-focus:var(--system-button-static-black-outline-border-color-focus)}:host([static-color=black][variant=secondary]){--spectrum-button-background-color-default:var(--system-button-static-black-secondary-background-color-default);--spectrum-button-background-color-hover:var(--system-button-static-black-secondary-background-color-hover);--spectrum-button-background-color-down:var(--system-button-static-black-secondary-background-color-down);--spectrum-button-background-color-focus:var(--system-button-static-black-secondary-background-color-focus);--spectrum-button-content-color-default:var(--system-button-static-black-secondary-content-color-default);--spectrum-button-content-color-hover:var(--system-button-static-black-secondary-content-color-hover);--spectrum-button-content-color-down:var(--system-button-static-black-secondary-content-color-down);--spectrum-button-content-color-focus:var(--system-button-static-black-secondary-content-color-focus)}:host([static-color=black][variant=secondary][treatment=outline]){--spectrum-button-border-color-default:var(--system-button-static-black-secondary-outline-border-color-default);--spectrum-button-border-color-hover:var(--system-button-static-black-secondary-outline-border-color-hover);--spectrum-button-border-color-down:var(--system-button-static-black-secondary-outline-border-color-down);--spectrum-button-border-color-focus:var(--system-button-static-black-secondary-outline-border-color-focus);--spectrum-button-background-color-default:var(--system-button-static-black-secondary-outline-background-color-default);--spectrum-button-background-color-hover:var(--system-button-static-black-secondary-outline-background-color-hover);--spectrum-button-background-color-down:var(--system-button-static-black-secondary-outline-background-color-down);--spectrum-button-background-color-focus:var(--system-button-static-black-secondary-outline-background-color-focus)}@media (forced-colors:active){:host([treatment][disabled]){border-color:graytext}:host([treatment]:not([disabled]):hover){border-color:highlight}:host(.remove-focus-ring-safari-hack:focus-visible):after{forced-color-adjust:none;box-shadow:none}}@keyframes show-progress-circle{0%{visibility:hidden}to{visibility:visible}}@keyframes hide-icons-label{0%{visibility:visible}to{visibility:hidden}}@keyframes update-pending-button-styles{to{background-color:var(--highcontrast-button-background-color-disabled,var(--mod-button-background-color-disabled,var(--spectrum-button-background-color-disabled)));border-color:var(--highcontrast-button-border-color-disabled,var(--mod-button-border-color-disabled,var(--spectrum-button-border-color-disabled)));color:var(--highcontrast-button-content-color-disabled,var(--mod-button-content-color-disabled,var(--spectrum-button-content-color-disabled)))}}:host([pending]:not([disabled])){cursor:default;pointer-events:none;animation:update-pending-button-styles 0s var(--pending-delay,1s)forwards}::slotted([slot=icon]){visibility:revert-layer;--mod-progress-circle-position:relative;--spectrum-icon-size:inherit}sp-progress-circle{visibility:hidden;display:block;position:absolute;left:50%;transform:translate(-50%)}:host([pending]:not([disabled])) sp-progress-circle{animation:show-progress-circle 0s var(--pending-delay,1s)forwards}:host([pending]:not([disabled])) slot[name=icon],:host([pending]:not([disabled])) #label{animation:hide-icons-label 0s var(--pending-delay,1s)forwards}:host(.remove-focus-ring-safari-hack:focus-visible):after{margin:calc(-1*var(--mod-button-focus-indicator-gap,var(--mod-focus-indicator-gap,var(--spectrum-focus-indicator-gap))));box-shadow:none}:host(.remove-focus-ring-safari-hack:focus-visible){box-shadow:none;outline:none}:host(.remove-focus-ring-safari-hack:focus-visible:not(:hover)){background-color:var(--highcontrast-button-background-color-default,var(--mod-button-background-color-default,var(--spectrum-button-background-color-default)));border-color:var(--highcontrast-button-border-color-default,var(--mod-button-border-color-default,var(--spectrum-button-border-color-default)));color:var(--highcontrast-button-content-color-default,var(--mod-button-content-color-default,var(--spectrum-button-content-color-default)))}
`;
var button_css_default = o16;

// node_modules/@spectrum-web-components/reactive-controllers/src/PendingState.js
init_sp_progress_circle();
init_lit();
var PendingStateController = class {
  constructor(e36) {
    this.cachedAriaLabel = null;
    this.host = e36, this.host.addController(this);
  }
  renderPendingState() {
    return this.host.pending ? x`
                  <sp-progress-circle
                      id="loader"
                      size="s"
                      indeterminate
                      class="progress-circle"
                      role="presentation"
                  ></sp-progress-circle>
              ` : x``;
  }
  updateAriaLabel() {
    const { pending: e36, disabled: n25, pendingLabel: i21 } = this.host, a23 = this.host.getAttribute("aria-label");
    function o52(l16, t34, s19) {
      return !l16 && t34 !== s19 || l16 !== t34 && t34 !== s19;
    }
    o52(this.cachedAriaLabel, a23, i21) && (this.cachedAriaLabel = a23), e36 && !n25 ? this.host.setAttribute("aria-label", i21 || "Pending") : this.cachedAriaLabel ? this.host.setAttribute("aria-label", this.cachedAriaLabel) : this.host.removeAttribute("aria-label");
  }
  hostConnected() {
    this.cachedAriaLabel || (this.cachedAriaLabel = this.host.getAttribute("aria-label")), this.updateAriaLabel();
  }
  hostUpdated() {
    this.updateAriaLabel();
  }
};

// node_modules/@spectrum-web-components/button/src/Button.js
var c9 = Object.defineProperty;
var u10 = Object.getOwnPropertyDescriptor;
var e16 = (o52, i21, t34, n25) => {
  for (var r25 = n25 > 1 ? void 0 : n25 ? u10(i21, t34) : i21, s19 = o52.length - 1, l16; s19 >= 0; s19--) (l16 = o52[s19]) && (r25 = (n25 ? l16(i21, t34, r25) : l16(r25)) || r25);
  return n25 && r25 && c9(i21, t34, r25), r25;
};
var VALID_VARIANTS = ["accent", "primary", "secondary", "negative", "white", "black"];
var Button = class extends SizedMixin(ButtonBase, { noDefaultSize: true }) {
  constructor() {
    super();
    this.pendingLabel = "Pending";
    this.pending = false;
    this._variant = "accent";
    this.treatment = "fill";
    this.noWrap = false;
    this.pendingStateController = new PendingStateController(this);
  }
  static get styles() {
    return [...super.styles, button_css_default];
  }
  click() {
    this.pending || super.click();
  }
  get variant() {
    return this._variant;
  }
  set variant(t34) {
    if (t34 !== this.variant) {
      switch (this.requestUpdate("variant", this.variant), t34) {
        case "cta":
          this._variant = "accent";
          break;
        case "overBackground":
          this.removeAttribute("variant"), this.staticColor = "white", this.treatment = "outline";
          return;
        case "white":
          this.staticColor = "white";
          return;
        case "black":
          this.staticColor = "black";
          return;
        case null:
          return;
        default:
          VALID_VARIANTS.includes(t34) ? this._variant = t34 : this._variant = "accent";
          break;
      }
      this.setAttribute("variant", this.variant);
    }
  }
  set quiet(t34) {
    this.treatment = t34 ? "outline" : "fill";
  }
  get quiet() {
    return this.treatment === "outline";
  }
  firstUpdated(t34) {
    super.firstUpdated(t34), this.hasAttribute("variant") || this.setAttribute("variant", this.variant), this.pending && this.pendingStateController.hostUpdated();
  }
  renderButton() {
    return x`
            ${this.buttonContent}
            ${this.pendingStateController.renderPendingState()}
        `;
  }
};
e16([n4({ type: String, attribute: "pending-label" })], Button.prototype, "pendingLabel", 2), e16([n4({ type: Boolean, reflect: true, attribute: true })], Button.prototype, "pending", 2), e16([n4()], Button.prototype, "variant", 1), e16([n4({ reflect: true, attribute: "static-color" })], Button.prototype, "staticColor", 2), e16([n4({ reflect: true })], Button.prototype, "treatment", 2), e16([n4({ type: Boolean })], Button.prototype, "quiet", 1), e16([n4({ type: Boolean, attribute: "no-wrap", reflect: true })], Button.prototype, "noWrap", 2);

// node_modules/@spectrum-web-components/button/sp-button.js
init_define_element();
defineElement("sp-button", Button);

// node_modules/@spectrum-web-components/action-button/src/ActionButton.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/button/src/ClearButton.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/button/src/StyledButton.js
var StyledButton = class extends ButtonBase {
};

// node_modules/@spectrum-web-components/clear-button/src/clear-button.css.js
init_src();
var t13 = i`
    :host{--spectrum-clear-button-background-color:var(--system-clear-button-background-color);--spectrum-clear-button-background-color-hover:var(--system-clear-button-background-color-hover);--spectrum-clear-button-background-color-down:var(--system-clear-button-background-color-down);--spectrum-clear-button-background-color-key-focus:var(--system-clear-button-background-color-key-focus)}:host([static-color=white]){--spectrum-clear-button-background-color-hover:var(--system-clear-button-static-white-background-color-hover);--spectrum-clear-button-background-color-down:var(--system-clear-button-static-white-background-color-down);--spectrum-clear-button-background-color-key-focus:var(--system-clear-button-static-white-background-color-key-focus)}:host{--spectrum-clear-button-height:var(--spectrum-component-height-100);--spectrum-clear-button-width:var(--spectrum-component-height-100);--spectrum-clear-button-padding:var(--spectrum-in-field-button-edge-to-fill);--spectrum-clear-button-icon-color:var(--spectrum-neutral-content-color-default);--spectrum-clear-button-icon-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-clear-button-icon-color-down:var(--spectrum-neutral-content-color-down);--spectrum-clear-button-icon-color-key-focus:var(--spectrum-neutral-content-color-key-focus);box-sizing:border-box;block-size:var(--mod-clear-button-height,var(--spectrum-clear-button-height));inline-size:var(--mod-clear-button-width,var(--spectrum-clear-button-width));background-color:var(--mod-clear-button-background-color,transparent);padding:var(--mod-clear-button-padding,var(--spectrum-clear-button-padding));color:var(--mod-clear-button-icon-color,var(--spectrum-clear-button-icon-color));border:none;border-radius:100%;margin:0}:host([size=s]){--spectrum-clear-button-height:var(--spectrum-component-height-75);--spectrum-clear-button-width:var(--spectrum-component-height-75)}:host([size=l]){--spectrum-clear-button-height:var(--spectrum-component-height-200);--spectrum-clear-button-width:var(--spectrum-component-height-200)}:host([size=xl]){--spectrum-clear-button-height:var(--spectrum-component-height-300);--spectrum-clear-button-width:var(--spectrum-component-height-300)}:host([quiet]){--mod-clear-button-background-color:transparent;--mod-clear-button-background-color-hover:transparent;--mod-clear-button-background-color-down:transparent;--mod-clear-button-background-color-key-focus:transparent}:host([static-color=white]){--mod-clear-button-icon-color:var(--spectrum-white);--mod-clear-button-icon-color-hover:var(--spectrum-white);--mod-clear-button-icon-color-down:var(--spectrum-white);--mod-clear-button-icon-color-key-focus:var(--spectrum-white);--mod-clear-button-icon-color-disabled:var(--spectrum-disabled-static-white-content-color);--mod-clear-button-background-color:transparent}:host(:disabled),:host([disabled]){--mod-clear-button-icon-color:var(--mod-clear-button-icon-color-disabled,var(--spectrum-disabled-content-color));--mod-clear-button-icon-color-hover:var(--spectrum-disabled-content-color);--mod-clear-button-icon-color-down:var(--spectrum-disabled-content-color);--mod-clear-button-background-color:var(--mod-clear-button-background-color-disabled,transparent)}:host(:not(:disabled)),:host(:not([disabled])){cursor:pointer}.icon{margin-block:0;margin-inline:auto}@media (hover:hover){:host(:hover:not(:disabled)),:host(:hover:not([disabled])){color:var(--highcontrast-clear-button-icon-color-hover,var(--mod-clear-button-icon-color-hover,var(--spectrum-clear-button-icon-color-hover)))}:host(:hover:not(:disabled)) .fill,:host(:hover:not([disabled])) .fill{background-color:var(--mod-clear-button-background-color-hover,var(--spectrum-clear-button-background-color-hover))}}:host(:is(:active,[active]):not(:disabled)),:host(:is(:active,[active]):not([disabled])){color:var(--mod-clear-button-icon-color-down,var(--spectrum-clear-button-icon-color-down))}:host(:is(:active,[active]):not(:disabled)),:host(:is(:active,[active]):not([disabled])) .fill{background-color:var(--mod-clear-button-background-color-down,var(--spectrum-clear-button-background-color-down))}:host(:not(:disabled):focus-visible),:host(:not([disabled]):focus-visible),:host(:not(:disabled):focus-within),:host(:not([disabled]):focus-within){color:var(--mod-clear-button-icon-color-key-focus,var(--spectrum-clear-button-icon-color-key-focus))}:host(:not(:disabled):focus-visible) .fill,:host(:not([disabled]):focus-visible) .fill,:host(:not(:disabled):focus-within) .fill,:host(:not([disabled]):focus-within) .fill{background-color:var(--mod-clear-button-background-color-key-focus,var(--spectrum-clear-button-background-color-key-focus))}.icon{color:inherit}.fill{background-color:var(--mod-clear-button-background-color,var(--spectrum-clear-button-background-color));border-radius:100%;justify-content:center;align-items:center;block-size:100%;inline-size:100%;display:flex}:host([variant=overBackground]:focus-visible),:host([static-color=white]:focus-visible){outline:none}@media (forced-colors:active){:host(:not(:disabled)),:host(:not([disabled])){--highcontrast-clear-button-icon-color-hover:Highlight}}
`;
var clear_button_css_default = t13;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross75.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/custom-tag.js
var t14;
var tag2 = function(e36, ...a23) {
  return t14 ? t14(e36, ...a23) : a23.reduce((r25, p30, l16) => r25 + p30 + e36[l16 + 1], e36[0]);
};
var setCustomTemplateLiteralTag2 = (e36) => {
  t14 = e36;
};

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Cross75.js
var Cross75Icon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: l16 = "Cross75" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 8 8"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m5.188 4 2.14-2.14A.84.84 0 1 0 6.141.672L4 2.812 1.86.672A.84.84 0 0 0 .672 1.86L2.812 4 .672 6.14A.84.84 0 1 0 1.86 7.328L4 5.188l2.14 2.14A.84.84 0 1 0 7.328 6.14z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Cross75.js
var Cross75Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: l16 = "Cross75" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 8 8"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m5.188 4 2.14-2.14A.84.84 0 1 0 6.141.672L4 2.812 1.86.672A.84.84 0 0 0 .672 1.86L2.812 4 .672 6.14A.84.84 0 1 0 1.86 7.328L4 5.188l2.14 2.14A.84.84 0 1 0 7.328 6.14z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross75.js
var IconCross75 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Cross75Icon({ hidden: !this.label, title: this.label }) : Cross75Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-cross75.js
init_define_element();
defineElement("sp-icon-cross75", IconCross75);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross100.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Cross100.js
var Cross100Icon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Cross100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 8 8"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m5.238 4 2.456-2.457A.875.875 0 1 0 6.456.306L4 2.763 1.543.306A.875.875 0 0 0 .306 1.544L2.763 4 .306 6.457a.875.875 0 1 0 1.238 1.237L4 5.237l2.456 2.457a.875.875 0 1 0 1.238-1.237z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Cross100.js
var Cross100Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Cross100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 8 8"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m5.238 4 2.456-2.457A.875.875 0 1 0 6.456.306L4 2.763 1.543.306A.875.875 0 0 0 .306 1.544L2.763 4 .306 6.457a.875.875 0 1 0 1.238 1.237L4 5.237l2.456 2.457a.875.875 0 1 0 1.238-1.237z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross100.js
var IconCross100 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Cross100Icon({ hidden: !this.label, title: this.label }) : Cross100Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-cross100.js
init_define_element();
defineElement("sp-icon-cross100", IconCross100);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross200.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Cross200.js
var Cross200Icon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Cross200" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m6.29 5 2.922-2.922a.911.911 0 0 0-1.29-1.29L5 3.712 2.078.789a.911.911 0 0 0-1.29 1.289L3.712 5 .79 7.922a.911.911 0 1 0 1.289 1.29L5 6.288 7.923 9.21a.911.911 0 0 0 1.289-1.289z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Cross200.js
var Cross200Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Cross200" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m6.29 5 2.922-2.922a.911.911 0 0 0-1.29-1.29L5 3.712 2.078.789a.911.911 0 0 0-1.29 1.289L3.712 5 .79 7.922a.911.911 0 1 0 1.289 1.29L5 6.288 7.923 9.21a.911.911 0 0 0 1.289-1.289z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross200.js
var IconCross200 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Cross200Icon({ hidden: !this.label, title: this.label }) : Cross200Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-cross200.js
init_define_element();
defineElement("sp-icon-cross200", IconCross200);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross300.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Cross300.js
var Cross300Icon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Cross300" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m7.344 6 3.395-3.396a.95.95 0 0 0-1.344-1.342L6 4.657 2.604 1.262a.95.95 0 0 0-1.342 1.342L4.657 6 1.262 9.396a.95.95 0 0 0 1.343 1.343L6 7.344l3.395 3.395a.95.95 0 0 0 1.344-1.344z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Cross300.js
var Cross300Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Cross300" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m7.344 6 3.395-3.396a.95.95 0 0 0-1.344-1.342L6 4.657 2.604 1.262a.95.95 0 0 0-1.342 1.342L4.657 6 1.262 9.396a.95.95 0 0 0 1.343 1.343L6 7.344l3.395 3.395a.95.95 0 0 0 1.344-1.344z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross300.js
var IconCross300 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Cross300Icon({ hidden: !this.label, title: this.label }) : Cross300Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-cross300.js
init_define_element();
defineElement("sp-icon-cross300", IconCross300);

// node_modules/@spectrum-web-components/icon/src/spectrum-icon-cross.css.js
init_src();
var c10 = i`
    .spectrum-UIIcon-Cross75{--spectrum-icon-size:var(--spectrum-cross-icon-size-75)}.spectrum-UIIcon-Cross100{--spectrum-icon-size:var(--spectrum-cross-icon-size-100)}.spectrum-UIIcon-Cross200{--spectrum-icon-size:var(--spectrum-cross-icon-size-200)}.spectrum-UIIcon-Cross300{--spectrum-icon-size:var(--spectrum-cross-icon-size-300)}.spectrum-UIIcon-Cross400{--spectrum-icon-size:var(--spectrum-cross-icon-size-400)}.spectrum-UIIcon-Cross500{--spectrum-icon-size:var(--spectrum-cross-icon-size-500)}.spectrum-UIIcon-Cross600{--spectrum-icon-size:var(--spectrum-cross-icon-size-600)}
`;
var spectrum_icon_cross_css_default = c10;

// node_modules/@spectrum-web-components/button/src/ClearButton.js
var u11 = Object.defineProperty;
var p6 = Object.getOwnPropertyDescriptor;
var i11 = (c33, o52, e36, s19) => {
  for (var t34 = s19 > 1 ? void 0 : s19 ? p6(o52, e36) : o52, n25 = c33.length - 1, a23; n25 >= 0; n25--) (a23 = c33[n25]) && (t34 = (s19 ? a23(o52, e36, t34) : a23(t34)) || t34);
  return s19 && t34 && u11(o52, e36, t34), t34;
};
var h7 = { s: () => x`
        <sp-icon-cross75
            slot="icon"
            class="icon spectrum-UIIcon-Cross75"
        ></sp-icon-cross75>
    `, m: () => x`
        <sp-icon-cross100
            slot="icon"
            class="icon spectrum-UIIcon-Cross100"
        ></sp-icon-cross100>
    `, l: () => x`
        <sp-icon-cross200
            slot="icon"
            class="icon spectrum-UIIcon-Cross200"
        ></sp-icon-cross200>
    `, xl: () => x`
        <sp-icon-cross300
            slot="icon"
            class="icon spectrum-UIIcon-Cross300"
        ></sp-icon-cross300>
    ` };
var ClearButton = class extends SizedMixin(StyledButton, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.quiet = false;
  }
  static get styles() {
    return [...super.styles, clear_button_css_default, spectrum_icon_cross_css_default];
  }
  set variant(e36) {
    const s19 = this._variant, t34 = this.staticColor;
    if (e36 !== "overBackground") {
      this.removeAttribute("variant"), this._variant = void 0, this.staticColor = void 0;
      return;
    }
    this.setAttribute("variant", e36), this._variant = e36, this.staticColor = "white", this.requestUpdate("variant", s19), this.requestUpdate("staticColor", t34);
  }
  get variant() {
    return this._variant;
  }
  get buttonContent() {
    return [h7[this.size]()];
  }
  render() {
    return x`
            <div class="fill">${super.render()}</div>
        `;
  }
};
i11([n4({ type: Boolean, reflect: true })], ClearButton.prototype, "quiet", 2), i11([n4({ reflect: true })], ClearButton.prototype, "variant", 1), i11([n4({ reflect: true, attribute: "static-color" })], ClearButton.prototype, "staticColor", 2);

// node_modules/@spectrum-web-components/button/src/CloseButton.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/close-button/src/close-button.css.js
init_src();
var t15 = i`
    :host{cursor:pointer;-webkit-user-select:none;user-select:none;box-sizing:border-box;font-family:var(--mod-button-font-family,var(--mod-sans-font-family-stack,var(--spectrum-sans-font-family-stack)));-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;line-height:var(--mod-button-line-height,var(--mod-line-height-100,var(--spectrum-line-height-100)));text-transform:none;vertical-align:top;-webkit-appearance:button;transition:background var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,border-color var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,color var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,box-shadow var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out;border-style:solid;margin:0;-webkit-text-decoration:none;text-decoration:none;overflow:visible}:host(:focus){outline:none}:host([disabled]),:host([disabled]){cursor:default}:host a{-webkit-user-select:none;user-select:none;-webkit-appearance:none}@media (forced-colors:active){:host{--highcontrast-closebutton-icon-color-disabled:GrayText;--highcontrast-closebutton-icon-color-down:Highlight;--highcontrast-closebutton-icon-color-hover:Highlight;--highcontrast-closebutton-icon-color-focus:Highlight;--highcontrast-closebutton-background-color-default:ButtonFace;--highcontrast-closebutton-focus-indicator-color:ButtonText}:host(:focus-visible):after{forced-color-adjust:none;margin:var(--mod-closebutton-focus-indicator-gap,var(--spectrum-closebutton-focus-indicator-gap));transition:opacity var(--mod-closebutton-animation-duration,var(--spectrum-closebutton-animation-duration))ease-out,margin var(--mod-closebutton-animation-duraction,var(--spectrum-closebutton-animation-duration))ease-out}:host([static-color=black]){--highcontrast-closebutton-static-background-color-default:ButtonFace;--highcontrast-closebutton-icon-color-default:Highlight;--highcontrast-closebutton-icon-color-disabled:GrayText}:host([static-color=white]){--highcontrast-closebutton-static-background-color-default:ButtonFace;--highcontrast-closebutton-icon-color-default:Highlight;--highcontrast-closebutton-icon-color-disabled:Highlight}}:host{--spectrum-closebutton-icon-color-default:var(--spectrum-neutral-content-color-default);--spectrum-closebutton-icon-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-closebutton-icon-color-down:var(--spectrum-neutral-content-color-down);--spectrum-closebutton-icon-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-closebutton-icon-color-disabled:var(--spectrum-disabled-content-color);--spectrum-closebutton-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-closebutton-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--spectrum-closebutton-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-closebutton-animation-duration:var(--spectrum-animation-duration-100);block-size:var(--mod-closebutton-height,var(--spectrum-closebutton-size));inline-size:var(--mod-closebutton-width,var(--mod-closebutton-height,var(--spectrum-closebutton-size)));color:inherit;border-radius:var(--mod-closebutton-border-radius,var(--spectrum-closebutton-border-radius));transition:border-color var(--mod-closebutton-animation-duration,var(--spectrum-closebutton-animation-duration))ease-in-out;margin-inline:var(--mod-closebutton-margin-inline);justify-content:center;align-items:center;align-self:var(--mod-closebutton-align-self);border-width:0;border-color:#0000;flex-direction:row;margin-block-start:var(--mod-closebutton-margin-top);padding:0;display:inline-flex;position:relative}:host([size=s]){--spectrum-closebutton-size:var(--spectrum-component-height-75);--spectrum-closebutton-border-radius:var(--spectrum-component-height-75)}:host,:host{--spectrum-closebutton-size:var(--spectrum-component-height-100);--spectrum-closebutton-border-radius:var(--spectrum-component-height-100)}:host([size=l]){--spectrum-closebutton-size:var(--spectrum-component-height-200);--spectrum-closebutton-border-radius:var(--spectrum-component-height-200)}:host([size=xl]){--spectrum-closebutton-size:var(--spectrum-component-height-300);--spectrum-closebutton-border-radius:var(--spectrum-component-height-300)}:host([static-color=white]){--spectrum-closebutton-static-background-color-default:transparent;--spectrum-closebutton-icon-color-default:var(--spectrum-white);--spectrum-closebutton-icon-color-disabled:var(--spectrum-disabled-static-white-content-color);--spectrum-closebutton-focus-indicator-color:var(--spectrum-static-white-focus-indicator-color)}:host([static-color=black]){--spectrum-closebutton-static-background-color-default:transparent;--spectrum-closebutton-icon-color-default:var(--spectrum-black);--spectrum-closebutton-icon-color-disabled:var(--spectrum-disabled-static-black-content-color);--spectrum-closebutton-focus-indicator-color:var(--spectrum-static-black-focus-indicator-color)}:host:after{pointer-events:none;content:"";margin:calc(var(--mod-closebutton-focus-indicator-gap,var(--spectrum-closebutton-focus-indicator-gap))*-1);border-radius:calc(var(--mod-closebutton-size,var(--spectrum-closebutton-size)) + var(--mod-closebutton-focus-indicator-gap,var(--spectrum-closebutton-focus-indicator-gap)));transition:box-shadow var(--mod-closebutton-animation-duration,var(--spectrum-closebutton-animation-duration))ease-in-out;position:absolute;inset-block:0;inset-inline:0}:host(:focus-visible){box-shadow:none;outline:none}:host(:focus-visible):after{box-shadow:0 0 0 var(--mod-closebutton-focus-indicator-thickness,var(--spectrum-closebutton-focus-indicator-thickness))var(--highcontrast-closebutton-focus-indicator-color,var(--mod-closebutton-focus-indicator-color,var(--spectrum-closebutton-focus-indicator-color)))}:host(:not([disabled])){background-color:var(--highcontrast-closebutton-background-color-default,var(--mod-closebutton-background-color-default,var(--spectrum-closebutton-background-color-default)))}:host(:not([disabled]):is(:active,[active])){background-color:var(--mod-closebutton-background-color-down,var(--spectrum-closebutton-background-color-down))}:host(:not([disabled]):is(:active,[active])) .icon{color:var(--highcontrast-closebutton-icon-color-down,var(--mod-closebutton-icon-color-down,var(--spectrum-closebutton-icon-color-down)))}:host([focused]:not([disabled])),:host(:not([disabled]):focus-visible){background-color:var(--mod-closebutton-background-color-focus,var(--spectrum-closebutton-background-color-focus))}:host([focused]:not([disabled])) .icon,:host(:not([disabled]):focus-visible) .icon{color:var(--highcontrast-closebutton-icon-color-focus,var(--mod-closebutton-icon-color-focus,var(--spectrum-closebutton-icon-color-focus)))}:host(:not([disabled])) .icon{color:var(--mod-closebutton-icon-color-default,var(--spectrum-closebutton-icon-color-default))}:host([focused]:not([disabled])) .icon,:host(:not([disabled]):focus) .icon{color:var(--highcontrast-closebutton-icon-color-focus,var(--mod-closebutton-icon-color-focus,var(--spectrum-closebutton-icon-color-focus)))}:host([disabled]){background-color:var(--mod-closebutton-background-color-default,var(--spectrum-closebutton-background-color-default))}:host([disabled]) .icon{color:var(--highcontrast-closebutton-icon-color-disabled,var(--mod-closebutton-icon-color-disabled,var(--spectrum-closebutton-icon-color-disabled)))}:host([static-color=black]:not([disabled])),:host([static-color=white]:not([disabled])){background-color:var(--highcontrast-closebutton-static-background-color-default,var(--mod-closebutton-static-background-color-default,var(--spectrum-closebutton-static-background-color-default)))}@media (hover:hover){:host(:not([disabled]):hover){background-color:var(--mod-closebutton-background-color-hover,var(--spectrum-closebutton-background-color-hover))}:host(:not([disabled]):hover) .icon{color:var(--highcontrast-closebutton-icon-color-hover,var(--mod-closebutton-icon-color-hover,var(--spectrum-closebutton-icon-color-hover)))}:host([static-color=black]:not([disabled]):hover),:host([static-color=white]:not([disabled]):hover){background-color:var(--mod-closebutton-static-background-color-hover,var(--spectrum-closebutton-static-background-color-hover))}:host([static-color=black]:not([disabled]):hover) .icon,:host([static-color=white]:not([disabled]):hover) .icon{color:var(--highcontrast-closebutton-icon-color-default,var(--mod-closebutton-icon-color-default,var(--spectrum-closebutton-icon-color-default)))}}:host([static-color=black]:not([disabled]):is(:active,[active])),:host([static-color=white]:not([disabled]):is(:active,[active])){background-color:var(--mod-closebutton-static-background-color-down,var(--spectrum-closebutton-static-background-color-down))}:host([static-color=black]:not([disabled]):is(:active,[active])) .icon,:host([static-color=white]:not([disabled]):is(:active,[active])) .icon{color:var(--highcontrast-closebutton-icon-color-default,var(--mod-closebutton-icon-color-default,var(--spectrum-closebutton-icon-color-default)))}:host([static-color=black][focused]:not([disabled])),:host([static-color=black]:not([disabled]):focus-visible),:host([static-color=white][focused]:not([disabled])),:host([static-color=white]:not([disabled]):focus-visible){background-color:var(--mod-closebutton-static-background-color-focus,var(--spectrum-closebutton-static-background-color-focus))}:host([static-color=black][focused]:not([disabled])) .icon,:host([static-color=black][focused]:not([disabled])) .icon,:host([static-color=black]:not([disabled]):focus) .icon,:host([static-color=black]:not([disabled]):focus-visible) .icon,:host([static-color=white][focused]:not([disabled])) .icon,:host([static-color=white][focused]:not([disabled])) .icon,:host([static-color=white]:not([disabled]):focus) .icon,:host([static-color=white]:not([disabled]):focus-visible) .icon{color:var(--highcontrast-closebutton-icon-color-default,var(--mod-closebutton-icon-color-default,var(--spectrum-closebutton-icon-color-default)))}:host([static-color=black]:not([disabled])) .icon,:host([static-color=white]:not([disabled])) .icon{color:var(--mod-closebutton-icon-color-default,var(--spectrum-closebutton-icon-color-default))}:host([static-color=black][disabled]) .icon,:host([static-color=white][disabled]) .icon{color:var(--mod-closebutton-icon-color-disabled,var(--spectrum-closebutton-icon-color-disabled))}.icon{margin:0}:host{--spectrum-closebutton-background-color-default:var(--system-close-button-background-color-default);--spectrum-closebutton-background-color-hover:var(--system-close-button-background-color-hover);--spectrum-closebutton-background-color-down:var(--system-close-button-background-color-down);--spectrum-closebutton-background-color-focus:var(--system-close-button-background-color-focus)}:host([static-color=white]){--spectrum-closebutton-static-background-color-hover:var(--system-close-button-static-white-static-background-color-hover);--spectrum-closebutton-static-background-color-down:var(--system-close-button-static-white-static-background-color-down);--spectrum-closebutton-static-background-color-focus:var(--system-close-button-static-white-static-background-color-focus)}:host([static-color=black]){--spectrum-closebutton-static-background-color-hover:var(--system-close-button-static-black-static-background-color-hover);--spectrum-closebutton-static-background-color-down:var(--system-close-button-static-black-static-background-color-down);--spectrum-closebutton-static-background-color-focus:var(--system-close-button-static-black-static-background-color-focus)}
`;
var close_button_css_default = t15;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross400.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Cross400.js
var Cross400Icon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Cross400" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m7.398 6 3.932-3.932A.989.989 0 0 0 9.932.67L6 4.602 2.068.67A.989.989 0 0 0 .67 2.068L4.602 6 .67 9.932a.989.989 0 1 0 1.398 1.398L6 7.398l3.932 3.932a.989.989 0 0 0 1.398-1.398z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Cross400.js
var Cross400Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Cross400" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m7.398 6 3.932-3.932A.989.989 0 0 0 9.932.67L6 4.602 2.068.67A.989.989 0 0 0 .67 2.068L4.602 6 .67 9.932a.989.989 0 1 0 1.398 1.398L6 7.398l3.932 3.932a.989.989 0 0 0 1.398-1.398z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross400.js
var IconCross400 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Cross400Icon({ hidden: !this.label, title: this.label }) : Cross400Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-cross400.js
init_define_element();
defineElement("sp-icon-cross400", IconCross400);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross500.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Cross500.js
var Cross500Icon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: l16 = "Cross500" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 14 14"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m8.457 7 4.54-4.54a1.03 1.03 0 0 0-1.458-1.456L7 5.543l-4.54-4.54a1.03 1.03 0 0 0-1.457 1.458L5.543 7l-4.54 4.54a1.03 1.03 0 1 0 1.457 1.456L7 8.457l4.54 4.54a1.03 1.03 0 0 0 1.456-1.458z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Cross500.js
var Cross500Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: l16 = "Cross500" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 14 14"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="m8.457 7 4.54-4.54a1.03 1.03 0 0 0-1.458-1.456L7 5.543l-4.54-4.54a1.03 1.03 0 0 0-1.457 1.458L5.543 7l-4.54 4.54a1.03 1.03 0 1 0 1.457 1.456L7 8.457l4.54 4.54a1.03 1.03 0 0 0 1.456-1.458z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCross500.js
var IconCross500 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Cross500Icon({ hidden: !this.label, title: this.label }) : Cross500Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-cross500.js
init_define_element();
defineElement("sp-icon-cross500", IconCross500);

// node_modules/@spectrum-web-components/button/src/CloseButton.js
var m7 = Object.defineProperty;
var u12 = Object.getOwnPropertyDescriptor;
var l7 = (c33, s19, e36, o52) => {
  for (var t34 = o52 > 1 ? void 0 : o52 ? u12(s19, e36) : s19, i21 = c33.length - 1, n25; i21 >= 0; i21--) (n25 = c33[i21]) && (t34 = (o52 ? n25(s19, e36, t34) : n25(t34)) || t34);
  return o52 && t34 && m7(s19, e36, t34), t34;
};
var C2 = { s: () => x`
        <sp-icon-cross200
            slot="icon"
            class="icon spectrum-UIIcon-Cross200"
        ></sp-icon-cross200>
    `, m: () => x`
        <sp-icon-cross300
            slot="icon"
            class="icon spectrum-UIIcon-Cross300"
        ></sp-icon-cross300>
    `, l: () => x`
        <sp-icon-cross400
            slot="icon"
            class="icon spectrum-UIIcon-Cross400"
        ></sp-icon-cross400>
    `, xl: () => x`
        <sp-icon-cross500
            slot="icon"
            class="icon spectrum-UIIcon-Cross500"
        ></sp-icon-cross500>
    ` };
var CloseButton = class extends SizedMixin(StyledButton, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.variant = "";
  }
  static get styles() {
    return [...super.styles, close_button_css_default, spectrum_icon_cross_css_default];
  }
  get buttonContent() {
    return [C2[this.size]()];
  }
};
l7([n4({ reflect: true })], CloseButton.prototype, "variant", 2), l7([n4({ reflect: true, attribute: "static-color" })], CloseButton.prototype, "staticColor", 2);

// node_modules/@spectrum-web-components/action-button/src/action-button.css.js
init_src();
var o17 = i`
    :host{cursor:pointer;-webkit-user-select:none;user-select:none;box-sizing:border-box;font-family:var(--mod-button-font-family,var(--mod-sans-font-family-stack,var(--spectrum-sans-font-family-stack)));-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;line-height:var(--mod-button-line-height,var(--mod-line-height-100,var(--spectrum-line-height-100)));text-transform:none;vertical-align:top;-webkit-appearance:button;transition:background var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,border-color var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,color var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,box-shadow var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out;border-style:solid;justify-content:center;align-items:center;margin:0;-webkit-text-decoration:none;text-decoration:none;display:inline-flex;overflow:visible}:host(:focus){outline:none}:host([disabled]),:host([disabled]){cursor:default}::slotted([slot=icon]){flex-shrink:0;max-block-size:100%}#label{text-align:center;place-self:center}#label:empty{display:none}@media (forced-colors:active){:host{--highcontrast-actionbutton-focus-indicator-color:ButtonText;--highcontrast-actionbutton-content-color:ButtonText}:host:after{forced-color-adjust:none}:host([selected]){--highcontrast-actionbutton-background-color:Highlight;--highcontrast-actionbutton-border-color:HighlightText;--highcontrast-actionbutton-content-color:HighlightText}:host([selected]) .hold-affordance,:host([selected]) ::slotted([slot=icon]),:host([selected]) #label{forced-color-adjust:none}:host([disabled]),:host([disabled]){--highcontrast-actionbutton-content-color:GrayText;--highcontrast-actionbutton-border-color:GrayText;--highcontrast-actionbutton-background-color:ButtonFace}}:host{--spectrum-actionbutton-background-color:var(--highcontrast-actionbutton-background-color,var(--mod-actionbutton-background-color-default,var(--spectrum-actionbutton-background-color-default)));--spectrum-actionbutton-border-color:var(--highcontrast-actionbutton-border-color,var(--mod-actionbutton-border-color-default,var(--spectrum-actionbutton-border-color-default)));--spectrum-actionbutton-content-color:var(--highcontrast-actionbutton-content-color,var(--mod-actionbutton-content-color-default,var(--spectrum-neutral-content-color-default)));--spectrum-actionbutton-border-radius:var(--mod-actionbutton-border-radius,var(--spectrum-actionbutton-border-radius-default));--spectrum-actionbutton-border-width:var(--mod-actionbutton-border-width,var(--spectrum-border-width-100));--spectrum-actionbutton-focus-indicator-gap:var(--mod-actionbutton-focus-indicator-gap,var(--spectrum-focus-indicator-gap));--spectrum-actionbutton-focus-indicator-thickness:var(--mod-actionbutton-focus-indicator-thickness,var(--spectrum-focus-indicator-thickness));--spectrum-actionbutton-focus-indicator-color:var(--highcontrast-actionbutton-focus-indicator-color,var(--mod-actionbutton-focus-indicator-color,var(--spectrum-focus-indicator-color)))}:host:dir(rtl),:host([dir=rtl]){--spectrum-logical-rotation:matrix(-1,0,0,1,0,0)}:host([quiet]){--spectrum-actionbutton-border-color:transparent}:host([emphasized]:not([static-color=black],[static-color=white])){--mod-actionbutton-background-color-default-selected:var(--mod-actionbutton-background-color-default-selected-emphasized,var(--spectrum-accent-background-color-default));--mod-actionbutton-background-color-hover-selected:var(--mod-actionbutton-background-color-hover-selected-emphasized,var(--spectrum-accent-background-color-hover));--mod-actionbutton-background-color-down-selected:var(--mod-actionbutton-background-color-down-selected-emphasized,var(--spectrum-accent-background-color-down));--mod-actionbutton-background-color-focus-selected:var(--mod-actionbutton-background-color-focus-selected-emphasized,var(--spectrum-accent-background-color-key-focus));--mod-actionbutton-content-color-default-selected:var(--mod-actionbutton-content-color-default-selected-emphasized,var(--spectrum-white));--mod-actionbutton-content-color-hover-selected:var(--mod-actionbutton-content-color-hover-selected-emphasized,var(--spectrum-white));--mod-actionbutton-content-color-down-selected:var(--mod-actionbutton-content-color-down-selected-emphasized,var(--spectrum-white));--mod-actionbutton-content-color-focus-selected:var(--mod-actionbutton-content-color-focus-selected-emphasized,var(--spectrum-white))}:host([static-color=black]){--mod-actionbutton-background-color-default-selected:var(--spectrum-transparent-black-800);--mod-actionbutton-background-color-hover-selected:var(--spectrum-transparent-black-900);--mod-actionbutton-background-color-down-selected:var(--spectrum-transparent-black-900);--mod-actionbutton-background-color-focus-selected:var(--spectrum-transparent-black-900);--mod-actionbutton-content-color-default:var(--spectrum-black);--mod-actionbutton-content-color-hover:var(--spectrum-black);--mod-actionbutton-content-color-down:var(--spectrum-black);--mod-actionbutton-content-color-focus:var(--spectrum-black);--mod-actionbutton-content-color-disabled:var(--spectrum-disabled-static-black-content-color);--mod-actionbutton-content-color-default-selected:var(--mod-actionbutton-static-content-color,var(--spectrum-white));--mod-actionbutton-content-color-hover-selected:var(--mod-actionbutton-static-content-color,var(--spectrum-white));--mod-actionbutton-content-color-down-selected:var(--mod-actionbutton-static-content-color,var(--spectrum-white));--mod-actionbutton-content-color-focus-selected:var(--mod-actionbutton-static-content-color,var(--spectrum-white));--mod-actionbutton-focus-indicator-color:var(--spectrum-static-black-focus-indicator-color)}:host([static-color=white]){--mod-actionbutton-background-color-default-selected:var(--spectrum-transparent-white-800);--mod-actionbutton-background-color-hover-selected:var(--spectrum-transparent-white-900);--mod-actionbutton-background-color-down-selected:var(--spectrum-transparent-white-900);--mod-actionbutton-background-color-focus-selected:var(--spectrum-transparent-white-900);--mod-actionbutton-content-color-default:var(--spectrum-white);--mod-actionbutton-content-color-hover:var(--spectrum-white);--mod-actionbutton-content-color-down:var(--spectrum-white);--mod-actionbutton-content-color-focus:var(--spectrum-white);--mod-actionbutton-content-color-disabled:var(--spectrum-disabled-static-white-content-color);--mod-actionbutton-content-color-default-selected:var(--mod-actionbutton-static-content-color,var(--spectrum-black));--mod-actionbutton-content-color-hover-selected:var(--mod-actionbutton-static-content-color,var(--spectrum-black));--mod-actionbutton-content-color-down-selected:var(--mod-actionbutton-static-content-color,var(--spectrum-black));--mod-actionbutton-content-color-focus-selected:var(--mod-actionbutton-static-content-color,var(--spectrum-black));--mod-actionbutton-focus-indicator-color:var(--spectrum-static-white-focus-indicator-color)}:host([selected]){--mod-actionbutton-background-color-default:var(--mod-actionbutton-background-color-default-selected,var(--spectrum-actionbutton-background-color-selected));--mod-actionbutton-background-color-hover:var(--mod-actionbutton-background-color-hover-selected,var(--spectrum-actionbutton-background-color-selected-hover));--mod-actionbutton-background-color-down:var(--mod-actionbutton-background-color-down-selected,var(--spectrum-actionbutton-background-color-selected-down));--mod-actionbutton-background-color-focus:var(--mod-actionbutton-background-color-focus-selected,var(--spectrum-actionbutton-background-color-selected-focus));--mod-actionbutton-background-color-disabled:var(--spectrum-actionbutton-background-color-selected-disabled);--mod-actionbutton-border-color-default:transparent;--mod-actionbutton-border-color-hover:transparent;--mod-actionbutton-border-color-down:transparent;--mod-actionbutton-border-color-focus:transparent;--mod-actionbutton-border-color-disabled:transparent;--mod-actionbutton-content-color-default:var(--mod-actionbutton-content-color-default-selected,var(--spectrum-actionbutton-content-color-selected));--mod-actionbutton-content-color-hover:var(--mod-actionbutton-content-color-hover-selected,var(--spectrum-actionbutton-content-color-selected));--mod-actionbutton-content-color-down:var(--mod-actionbutton-content-color-down-selected,var(--spectrum-actionbutton-content-color-selected));--mod-actionbutton-content-color-focus:var(--mod-actionbutton-content-color-focus-selected,var(--spectrum-actionbutton-content-color-selected))}@media (hover:hover){:host(:hover){--mod-actionbutton-background-color-default:var(--mod-actionbutton-background-color-hover,var(--spectrum-actionbutton-background-color-hover));--mod-actionbutton-border-color-default:var(--mod-actionbutton-border-color-hover,var(--spectrum-actionbutton-border-color-hover));--mod-actionbutton-content-color-default:var(--mod-actionbutton-content-color-hover,var(--spectrum-neutral-content-color-hover))}}:host(:focus-visible){--mod-actionbutton-background-color-default:var(--mod-actionbutton-background-color-focus,var(--spectrum-actionbutton-background-color-focus));--mod-actionbutton-border-color-default:var(--mod-actionbutton-border-color-focus,var(--spectrum-actionbutton-border-color-focus));--mod-actionbutton-content-color-default:var(--mod-actionbutton-content-color-focus,var(--spectrum-neutral-content-color-key-focus))}:host(:is(:active,[active])){--mod-actionbutton-background-color-default:var(--mod-actionbutton-background-color-down,var(--spectrum-actionbutton-background-color-down));--mod-actionbutton-border-color-default:var(--mod-actionbutton-border-color-down,var(--spectrum-actionbutton-border-color-down));--mod-actionbutton-content-color-default:var(--mod-actionbutton-content-color-down,var(--spectrum-neutral-content-color-down))}:host([disabled]),:host([disabled]){--mod-actionbutton-background-color-default:var(--mod-actionbutton-background-color-disabled,var(--spectrum-actionbutton-background-color-disabled));--mod-actionbutton-border-color-default:var(--mod-actionbutton-border-color-disabled,var(--spectrum-actionbutton-border-color-disabled));--mod-actionbutton-content-color-default:var(--mod-actionbutton-content-color-disabled,var(--spectrum-disabled-content-color))}:host,:host{--spectrum-actionbutton-sized-height:var(--spectrum-component-height-100);--spectrum-actionbutton-sized-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-actionbutton-sized-font-size:var(--spectrum-font-size-100);--spectrum-actionbutton-sized-text-to-visual:var(--spectrum-text-to-visual-100);--spectrum-actionbutton-sized-edge-to-hold-icon:var(--spectrum-action-button-edge-to-hold-icon-medium);--spectrum-actionbutton-sized-edge-to-visual:var(--spectrum-component-edge-to-visual-100);--spectrum-actionbutton-sized-edge-to-text:var(--spectrum-component-edge-to-text-100);--spectrum-actionbutton-sized-edge-to-visual-only:var(--spectrum-component-edge-to-visual-only-100)}:host([size=xs]){--spectrum-actionbutton-sized-height:var(--spectrum-component-height-50);--spectrum-actionbutton-sized-icon-size:var(--spectrum-workflow-icon-size-50);--spectrum-actionbutton-sized-font-size:var(--spectrum-font-size-50);--spectrum-actionbutton-sized-text-to-visual:var(--spectrum-text-to-visual-50);--spectrum-actionbutton-sized-edge-to-hold-icon:var(--spectrum-action-button-edge-to-hold-icon-extra-small);--spectrum-actionbutton-sized-edge-to-visual:var(--spectrum-component-edge-to-visual-50);--spectrum-actionbutton-sized-edge-to-text:var(--spectrum-component-edge-to-text-50);--spectrum-actionbutton-sized-edge-to-visual-only:var(--spectrum-component-edge-to-visual-only-50)}:host([size=s]){--spectrum-actionbutton-sized-height:var(--spectrum-component-height-75);--spectrum-actionbutton-sized-icon-size:var(--spectrum-workflow-icon-size-75);--spectrum-actionbutton-sized-font-size:var(--spectrum-font-size-75);--spectrum-actionbutton-sized-text-to-visual:var(--spectrum-text-to-visual-75);--spectrum-actionbutton-sized-edge-to-hold-icon:var(--spectrum-action-button-edge-to-hold-icon-small);--spectrum-actionbutton-sized-edge-to-visual:var(--spectrum-component-edge-to-visual-75);--spectrum-actionbutton-sized-edge-to-text:var(--spectrum-component-edge-to-text-75);--spectrum-actionbutton-sized-edge-to-visual-only:var(--spectrum-component-edge-to-visual-only-75)}:host([size=l]){--spectrum-actionbutton-sized-height:var(--spectrum-component-height-200);--spectrum-actionbutton-sized-icon-size:var(--spectrum-workflow-icon-size-200);--spectrum-actionbutton-sized-font-size:var(--spectrum-font-size-200);--spectrum-actionbutton-sized-text-to-visual:var(--spectrum-text-to-visual-200);--spectrum-actionbutton-sized-edge-to-hold-icon:var(--spectrum-action-button-edge-to-hold-icon-large);--spectrum-actionbutton-sized-edge-to-visual:var(--spectrum-component-edge-to-visual-200);--spectrum-actionbutton-sized-edge-to-text:var(--spectrum-component-edge-to-text-200);--spectrum-actionbutton-sized-edge-to-visual-only:var(--spectrum-component-edge-to-visual-only-200)}:host([size=xl]){--spectrum-actionbutton-sized-height:var(--spectrum-component-height-300);--spectrum-actionbutton-sized-icon-size:var(--spectrum-workflow-icon-size-300);--spectrum-actionbutton-sized-font-size:var(--spectrum-font-size-300);--spectrum-actionbutton-sized-text-to-visual:var(--spectrum-text-to-visual-300);--spectrum-actionbutton-sized-edge-to-hold-icon:var(--spectrum-action-button-edge-to-hold-icon-extra-large);--spectrum-actionbutton-sized-edge-to-visual:var(--spectrum-component-edge-to-visual-300);--spectrum-actionbutton-sized-edge-to-text:var(--spectrum-component-edge-to-text-300);--spectrum-actionbutton-sized-edge-to-visual-only:var(--spectrum-component-edge-to-visual-only-300)}:host{--spectrum-actionbutton-height:var(--mod-actionbutton-height,var(--spectrum-actionbutton-sized-height));--spectrum-actionbutton-icon-size:var(--mod-actionbutton-icon-size,var(--spectrum-actionbutton-sized-icon-size));--spectrum-actionbutton-font-size:var(--mod-actionbutton-font-size,var(--spectrum-actionbutton-sized-font-size));--spectrum-actionbutton-text-to-visual:var(--mod-actionbutton-text-to-visual,var(--spectrum-actionbutton-sized-text-to-visual));--spectrum-actionbutton-edge-to-hold-icon:var(--mod-actionbutton-edge-to-hold-icon,var(--spectrum-actionbutton-sized-edge-to-hold-icon));--spectrum-actionbutton-edge-to-visual:var(--mod-actionbutton-edge-to-visual,calc(var(--spectrum-actionbutton-sized-edge-to-visual) - var(--spectrum-actionbutton-border-width)));--spectrum-actionbutton-edge-to-text:var(--mod-actionbutton-edge-to-text,calc(var(--spectrum-actionbutton-sized-edge-to-text) - var(--spectrum-actionbutton-border-width)));--spectrum-actionbutton-edge-to-visual-only:var(--mod-actionbutton-edge-to-visual-only,calc(var(--spectrum-actionbutton-sized-edge-to-visual-only) - var(--spectrum-actionbutton-border-width)));min-inline-size:var(--mod-actionbutton-min-width,calc(var(--mod-actionbutton-edge-to-visual-only,var(--spectrum-actionbutton-sized-edge-to-visual-only))*2 + var(--spectrum-actionbutton-icon-size)));block-size:var(--spectrum-actionbutton-height);border-radius:var(--spectrum-actionbutton-border-radius);border-width:var(--spectrum-actionbutton-border-width);gap:calc(var(--spectrum-actionbutton-text-to-visual) + var(--spectrum-actionbutton-edge-to-text) - var(--spectrum-actionbutton-edge-to-visual-only));padding-inline:var(--spectrum-actionbutton-edge-to-text);background-color:var(--spectrum-actionbutton-background-color);border-color:var(--spectrum-actionbutton-border-color);color:var(--spectrum-actionbutton-content-color);transition:border-color var(--mod-actionbutton-animation-duration,var(--spectrum-animation-duration-100))ease-in-out;position:relative}:host:after{margin:calc((var(--spectrum-actionbutton-focus-indicator-gap) + var(--spectrum-actionbutton-border-width))*-1);border-radius:var(--mod-actionbutton-focus-indicator-border-radius,calc(var(--spectrum-actionbutton-border-radius) + var(--spectrum-actionbutton-focus-indicator-gap)));transition:box-shadow var(--mod-actionbutton-animation-duration,var(--spectrum-animation-duration-100))ease-in-out;pointer-events:none;content:"";position:absolute;inset:0}:host(:focus-visible){box-shadow:none;outline:none}:host(:focus-visible):after{box-shadow:0 0 0 var(--spectrum-actionbutton-focus-indicator-thickness)var(--spectrum-actionbutton-focus-indicator-color)}::slotted([slot=icon]){inline-size:var(--spectrum-actionbutton-icon-size);block-size:var(--spectrum-actionbutton-icon-size);color:inherit;margin-inline-start:calc(var(--spectrum-actionbutton-edge-to-visual) - var(--spectrum-actionbutton-edge-to-text));margin-inline-end:calc(var(--spectrum-actionbutton-edge-to-visual-only) - var(--spectrum-actionbutton-edge-to-text))}.hold-affordance+::slotted([slot=icon]),[icon-only]::slotted([slot=icon]){margin-inline-start:calc(var(--spectrum-actionbutton-edge-to-visual-only) - var(--spectrum-actionbutton-edge-to-text))}#label{pointer-events:none;line-height:var(--spectrum-actionbutton-height);font-size:var(--spectrum-actionbutton-font-size);white-space:nowrap;color:var(--mod-actionbutton-label-color,inherit);text-overflow:ellipsis;overflow:hidden}.hold-affordance{color:inherit;transform:var(--spectrum-logical-rotation,);position:absolute;inset-block-end:calc(var(--spectrum-actionbutton-edge-to-hold-icon) - var(--spectrum-actionbutton-border-width));inset-inline-end:calc(var(--spectrum-actionbutton-edge-to-hold-icon) - var(--spectrum-actionbutton-border-width))}:host{--spectrum-actionbutton-background-color-default:var(--system-action-button-background-color-default);--spectrum-actionbutton-background-color-hover:var(--system-action-button-background-color-hover);--spectrum-actionbutton-background-color-down:var(--system-action-button-background-color-down);--spectrum-actionbutton-background-color-focus:var(--system-action-button-background-color-focus);--spectrum-actionbutton-background-color-disabled:var(--system-action-button-background-color-disabled);--spectrum-actionbutton-background-color-selected:var(--system-action-button-background-color-selected);--spectrum-actionbutton-background-color-selected-hover:var(--system-action-button-background-color-selected-hover);--spectrum-actionbutton-background-color-selected-down:var(--system-action-button-background-color-selected-down);--spectrum-actionbutton-background-color-selected-focus:var(--system-action-button-background-color-selected-focus);--spectrum-actionbutton-border-color-default:var(--system-action-button-border-color-default);--spectrum-actionbutton-border-color-hover:var(--system-action-button-border-color-hover);--spectrum-actionbutton-border-color-down:var(--system-action-button-border-color-down);--spectrum-actionbutton-border-color-focus:var(--system-action-button-border-color-focus);--spectrum-actionbutton-border-color-disabled:var(--system-action-button-border-color-disabled);--spectrum-actionbutton-content-color-selected:var(--system-action-button-content-color-selected);--spectrum-actionbutton-background-color-selected-disabled:var(--system-action-button-background-color-selected-disabled);--spectrum-actionbutton-border-radius-default:var(--system-action-button-size-m-border-radius-default)}:host([size=xs]){--spectrum-actionbutton-border-radius-default:var(--system-action-button-size-xs-border-radius-default)}:host([size=s]){--spectrum-actionbutton-border-radius-default:var(--system-action-button-size-s-border-radius-default)}:host([size=l]){--spectrum-actionbutton-border-radius-default:var(--system-action-button-size-l-border-radius-default)}:host([size=xl]){--spectrum-actionbutton-border-radius-default:var(--system-action-button-size-xl-border-radius-default)}:host([quiet]){--spectrum-actionbutton-background-color-default:var(--system-action-button-quiet-background-color-default);--spectrum-actionbutton-background-color-hover:var(--system-action-button-quiet-background-color-hover);--spectrum-actionbutton-background-color-down:var(--system-action-button-quiet-background-color-down);--spectrum-actionbutton-background-color-focus:var(--system-action-button-quiet-background-color-focus);--spectrum-actionbutton-background-color-disabled:var(--system-action-button-quiet-background-color-disabled);--spectrum-actionbutton-background-color-selected-disabled:var(--system-action-button-quiet-background-color-selected-disabled)}:host([static-color=black]){--spectrum-actionbutton-border-color-default:var(--system-action-button-static-black-border-color-default);--spectrum-actionbutton-border-color-hover:var(--system-action-button-static-black-border-color-hover);--spectrum-actionbutton-border-color-down:var(--system-action-button-static-black-border-color-down);--spectrum-actionbutton-border-color-focus:var(--system-action-button-static-black-border-color-focus);--spectrum-actionbutton-border-color-disabled:var(--system-action-button-static-black-border-color-disabled);--spectrum-actionbutton-background-color-disabled:var(--system-action-button-static-black-background-color-disabled);--spectrum-actionbutton-background-color-selected-disabled:var(--system-action-button-static-black-background-color-selected-disabled);--spectrum-actionbutton-background-color-default:var(--system-action-button-static-black-background-color-default);--spectrum-actionbutton-background-color-hover:var(--system-action-button-static-black-background-color-hover);--spectrum-actionbutton-background-color-down:var(--system-action-button-static-black-background-color-down);--spectrum-actionbutton-background-color-focus:var(--system-action-button-static-black-background-color-focus)}:host([static-color=black][quiet]){--spectrum-actionbutton-background-color-default:var(--system-action-button-static-black-quiet-background-color-default);--spectrum-actionbutton-background-color-hover:var(--system-action-button-static-black-quiet-background-color-hover);--spectrum-actionbutton-background-color-down:var(--system-action-button-static-black-quiet-background-color-down);--spectrum-actionbutton-background-color-focus:var(--system-action-button-static-black-quiet-background-color-focus);--spectrum-actionbutton-background-color-disabled:var(--system-action-button-static-black-quiet-background-color-disabled)}:host([static-color=white]){--spectrum-actionbutton-border-color-default:var(--system-action-button-static-white-border-color-default);--spectrum-actionbutton-border-color-hover:var(--system-action-button-static-white-border-color-hover);--spectrum-actionbutton-border-color-down:var(--system-action-button-static-white-border-color-down);--spectrum-actionbutton-border-color-focus:var(--system-action-button-static-white-border-color-focus);--spectrum-actionbutton-border-color-disabled:var(--system-action-button-static-white-border-color-disabled);--spectrum-actionbutton-background-color-disabled:var(--system-action-button-static-white-background-color-disabled);--spectrum-actionbutton-background-color-selected-disabled:var(--system-action-button-static-white-background-color-selected-disabled);--spectrum-actionbutton-background-color-default:var(--system-action-button-static-white-background-color-default);--spectrum-actionbutton-background-color-hover:var(--system-action-button-static-white-background-color-hover);--spectrum-actionbutton-background-color-down:var(--system-action-button-static-white-background-color-down);--spectrum-actionbutton-background-color-focus:var(--system-action-button-static-white-background-color-focus)}:host([static-color=white][quiet]){--spectrum-actionbutton-background-color-default:var(--system-action-button-static-white-quiet-background-color-default);--spectrum-actionbutton-background-color-hover:var(--system-action-button-static-white-quiet-background-color-hover);--spectrum-actionbutton-background-color-down:var(--system-action-button-static-white-quiet-background-color-down);--spectrum-actionbutton-background-color-focus:var(--system-action-button-static-white-quiet-background-color-focus);--spectrum-actionbutton-background-color-disabled:var(--system-action-button-static-white-quiet-background-color-disabled)}::slotted([slot=icon]){flex-shrink:0}#label{flex-grow:var(--spectrum-actionbutton-label-flex-grow);text-align:var(--spectrum-actionbutton-label-text-align);pointer-events:none!important}:host([size=xs]){min-width:var(--spectrum-actionbutton-height,0);--spectrum-actionbutton-edge-to-visual-only:calc(var(--spectrum-component-edge-to-visual-only-50) - var(--spectrum-actionbutton-border-width))}:host([size=s]){--spectrum-actionbutton-edge-to-visual-only:calc(var(--spectrum-component-edge-to-visual-only-75) - var(--spectrum-actionbutton-border-width))}:host([size=m]){--spectrum-actionbutton-edge-to-visual-only:calc(var(--spectrum-component-edge-to-visual-only-100) - var(--spectrum-actionbutton-border-width))}:host([size=l]){--spectrum-actionbutton-edge-to-visual-only:calc(var(--spectrum-component-edge-to-visual-only-200) - var(--spectrum-actionbutton-border-width))}:host([size=xl]){--spectrum-actionbutton-edge-to-visual-only:calc(var(--spectrum-component-edge-to-visual-only-300) - var(--spectrum-actionbutton-border-width))}@media (forced-colors:active){:host{--highcontrast-actionbutton-border-color-disabled:GrayText;--highcontrast-actionbutton-content-color-disabled:GrayText}}
`;
var action_button_css_default = o17;

// node_modules/@spectrum-web-components/icon/src/spectrum-icon-corner-triangle.css.js
init_src();
var e17 = i`
    .spectrum-UIIcon-CornerTriangle75{--spectrum-icon-size:var(--spectrum-corner-triangle-icon-size-75)}.spectrum-UIIcon-CornerTriangle100{--spectrum-icon-size:var(--spectrum-corner-triangle-icon-size-100)}.spectrum-UIIcon-CornerTriangle200{--spectrum-icon-size:var(--spectrum-corner-triangle-icon-size-200)}.spectrum-UIIcon-CornerTriangle300{--spectrum-icon-size:var(--spectrum-corner-triangle-icon-size-300)}
`;
var spectrum_icon_corner_triangle_css_default = e17;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCornerTriangle300.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/CornerTriangle300.js
var CornerTriangle300Icon = ({ width: e36 = 24, height: r25 = 24, hidden: t34 = false, title: a23 = "Corner Triangle300" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 7 7"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${e36}"
    height="${r25}"
  >
    <path
      d="M6.683.67a.32.32 0 0 0-.223.093l-5.7 5.7a.316.316 0 0 0 .224.54h5.7A.316.316 0 0 0 7 6.687V.986A.316.316 0 0 0 6.684.67z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/CornerTriangle300.js
var CornerTriangle300Icon2 = ({ width: e36 = 24, height: r25 = 24, hidden: t34 = false, title: a23 = "Corner Triangle300" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 7 7"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${e36}"
    height="${r25}"
  >
    <path
      d="M6.683.67a.32.32 0 0 0-.223.093l-5.7 5.7a.316.316 0 0 0 .224.54h5.7A.316.316 0 0 0 7 6.687V.986A.316.316 0 0 0 6.684.67z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCornerTriangle300.js
var IconCornerTriangle300 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? CornerTriangle300Icon({ hidden: !this.label, title: this.label }) : CornerTriangle300Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-corner-triangle300.js
init_define_element();
defineElement("sp-icon-corner-triangle300", IconCornerTriangle300);

// node_modules/@spectrum-web-components/action-button/src/ActionButton.js
var p7 = Object.defineProperty;
var u13 = Object.getOwnPropertyDescriptor;
var o18 = (n25, i21, e36, t34) => {
  for (var r25 = t34 > 1 ? void 0 : t34 ? u13(i21, e36) : i21, l16 = n25.length - 1, a23; l16 >= 0; l16--) (a23 = n25[l16]) && (r25 = (t34 ? a23(i21, e36, r25) : a23(r25)) || r25);
  return t34 && r25 && p7(i21, e36, r25), r25;
};
var m8 = { xs: "spectrum-UIIcon-CornerTriangle75", s: "spectrum-UIIcon-CornerTriangle75", m: "spectrum-UIIcon-CornerTriangle100", l: "spectrum-UIIcon-CornerTriangle200", xl: "spectrum-UIIcon-CornerTriangle300" };
var LONGPRESS_DURATION = 300;
var d6;
var ActionButton = class extends SizedMixin(ButtonBase, { validSizes: ["xs", "s", "m", "l", "xl"], noDefaultSize: true }) {
  constructor() {
    super();
    this.emphasized = false;
    this.holdAffordance = false;
    this.quiet = false;
    this.role = "button";
    this.selected = false;
    this.toggles = false;
    this._value = "";
    this.onClick = () => {
      if (!this.toggles) return;
      this.selected = !this.selected, this.dispatchEvent(new Event("change", { cancelable: true, bubbles: true, composed: true })) || (this.selected = !this.selected);
    };
    this.addEventListener("click", this.onClick);
  }
  static get styles() {
    return [...super.styles, action_button_css_default, spectrum_icon_corner_triangle_css_default];
  }
  get value() {
    return this._value || this.itemText;
  }
  set value(e36) {
    e36 !== this._value && (this._value = e36 || "", this._value ? this.setAttribute("value", this._value) : this.removeAttribute("value"));
  }
  get itemText() {
    return (this.textContent || "").trim();
  }
  handlePointerdownHoldAffordance(e36) {
    e36.button === 0 && (this.addEventListener("pointerup", this.handlePointerupHoldAffordance), this.addEventListener("pointercancel", this.handlePointerupHoldAffordance), d6 = setTimeout(() => {
      this.dispatchEvent(new CustomEvent("longpress", { bubbles: true, composed: true, detail: { source: "pointer" } }));
    }, LONGPRESS_DURATION));
  }
  handlePointerupHoldAffordance() {
    clearTimeout(d6), this.removeEventListener("pointerup", this.handlePointerupHoldAffordance), this.removeEventListener("pointercancel", this.handlePointerupHoldAffordance);
  }
  handleKeydown(e36) {
    if (!this.holdAffordance) return super.handleKeydown(e36);
    const { code: t34, altKey: r25 } = e36;
    (t34 === "Space" || r25 && t34 === "ArrowDown") && (e36.preventDefault(), t34 === "ArrowDown" && (e36.stopPropagation(), e36.stopImmediatePropagation()), this.addEventListener("keyup", this.handleKeyup), this.active = true);
  }
  handleKeyup(e36) {
    if (!this.holdAffordance) return super.handleKeyup(e36);
    const { code: t34, altKey: r25 } = e36;
    (t34 === "Space" || r25 && t34 === "ArrowDown") && (e36.stopPropagation(), this.dispatchEvent(new CustomEvent("longpress", { bubbles: true, composed: true, detail: { source: "keyboard" } })), this.active = false);
  }
  get buttonContent() {
    const e36 = super.buttonContent;
    return this.holdAffordance && e36.unshift(x`
                <sp-icon-corner-triangle300
                    class="hold-affordance ${m8[this.size]}"
                ></sp-icon-corner-triangle300>
            `), e36;
  }
  updated(e36) {
    super.updated(e36);
    const t34 = this.role === "button", r25 = t34 && (this.selected || this.toggles) && !(this.hasAttribute("aria-haspopup") && this.hasAttribute("aria-expanded"));
    (e36.has("selected") || e36.has("role")) && (r25 ? this.setAttribute("aria-pressed", this.selected ? "true" : "false") : (this.removeAttribute("aria-pressed"), t34 && this.toggles && this.hasAttribute("aria-expanded") && this.setAttribute("aria-expanded", this.selected ? "true" : "false"))), e36.has("holdAffordance") && (this.holdAffordance ? this.addEventListener("pointerdown", this.handlePointerdownHoldAffordance) : (this.removeEventListener("pointerdown", this.handlePointerdownHoldAffordance), this.handlePointerupHoldAffordance()));
  }
};
o18([n4({ type: Boolean, reflect: true })], ActionButton.prototype, "emphasized", 2), o18([n4({ type: Boolean, reflect: true, attribute: "hold-affordance" })], ActionButton.prototype, "holdAffordance", 2), o18([n4({ type: Boolean, reflect: true })], ActionButton.prototype, "quiet", 2), o18([n4({ reflect: true })], ActionButton.prototype, "role", 2), o18([n4({ type: Boolean, reflect: true })], ActionButton.prototype, "selected", 2), o18([n4({ type: Boolean, reflect: true })], ActionButton.prototype, "toggles", 2), o18([n4({ reflect: true, attribute: "static-color" })], ActionButton.prototype, "staticColor", 2), o18([n4({ type: String })], ActionButton.prototype, "value", 1);

// node_modules/@spectrum-web-components/action-button/sp-action-button.js
init_define_element();
defineElement("sp-action-button", ActionButton);

// node_modules/@spectrum-web-components/action-group/src/ActionGroup.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/reactive-controllers/src/FocusGroup.js
function o19(r25, e36, t34) {
  return typeof r25 === e36 ? () => r25 : typeof r25 == "function" ? r25 : t34;
}
var FocusGroupController = class {
  constructor(e36, { hostDelegatesFocus: t34, direction: n25, elementEnterAction: s19, elements: i21, focusInIndex: h16, isFocusableElement: c33, listenerScope: l16 } = { elements: () => [] }) {
    this._currentIndex = -1;
    this.prevIndex = -1;
    this._direction = () => "both";
    this.directionLength = 5;
    this.hostDelegatesFocus = false;
    this.elementEnterAction = (e37) => {
    };
    this._focused = false;
    this._focusInIndex = (e37) => 0;
    this.isFocusableElement = (e37) => true;
    this._listenerScope = () => this.host;
    this.offset = 0;
    this.recentlyConnected = false;
    this.handleFocusin = (e37) => {
      if (!this.isEventWithinListenerScope(e37)) return;
      const t35 = e37.composedPath();
      let n26 = -1;
      t35.find((s20) => (n26 = this.elements.indexOf(s20), n26 !== -1)), this.prevIndex = this.currentIndex, this.currentIndex = n26 > -1 ? n26 : this.currentIndex, this.isRelatedTargetOrContainAnElement(e37) && this.hostContainsFocus();
    };
    this.handleClick = () => {
      var n26;
      const e37 = this.elements;
      if (!e37.length) return;
      let t35 = e37[this.currentIndex];
      this.currentIndex < 0 || ((!t35 || !this.isFocusableElement(t35)) && (this.setCurrentIndexCircularly(1), t35 = e37[this.currentIndex]), t35 && this.isFocusableElement(t35) && ((n26 = e37[this.prevIndex]) == null || n26.setAttribute("tabindex", "-1"), t35.setAttribute("tabindex", "0")));
    };
    this.handleFocusout = (e37) => {
      this.isRelatedTargetOrContainAnElement(e37) && this.hostNoLongerContainsFocus();
    };
    this.handleKeydown = (e37) => {
      if (!this.acceptsEventKey(e37.key) || e37.defaultPrevented) return;
      let t35 = 0;
      switch (this.prevIndex = this.currentIndex, e37.key) {
        case "ArrowRight":
          t35 += 1;
          break;
        case "ArrowDown":
          t35 += this.direction === "grid" ? this.directionLength : 1;
          break;
        case "ArrowLeft":
          t35 -= 1;
          break;
        case "ArrowUp":
          t35 -= this.direction === "grid" ? this.directionLength : 1;
          break;
        case "End":
          this.currentIndex = 0, t35 -= 1;
          break;
        case "Home":
          this.currentIndex = this.elements.length - 1, t35 += 1;
          break;
      }
      e37.preventDefault(), this.direction === "grid" && this.currentIndex + t35 < 0 ? this.currentIndex = 0 : this.direction === "grid" && this.currentIndex + t35 > this.elements.length - 1 ? this.currentIndex = this.elements.length - 1 : this.setCurrentIndexCircularly(t35), this.elementEnterAction(this.elements[this.currentIndex]), this.focus();
    };
    this.mutationObserver = new MutationObserver(() => {
      this.handleItemMutation();
    }), this.hostDelegatesFocus = t34 || false, this.host = e36, this.host.addController(this), this._elements = i21, this.isFocusableElement = c33 || this.isFocusableElement, this._direction = o19(n25, "string", this._direction), this.elementEnterAction = s19 || this.elementEnterAction, this._focusInIndex = o19(h16, "number", this._focusInIndex), this._listenerScope = o19(l16, "object", this._listenerScope);
  }
  get currentIndex() {
    return this._currentIndex === -1 && (this._currentIndex = this.focusInIndex), this._currentIndex - this.offset;
  }
  set currentIndex(e36) {
    this._currentIndex = e36 + this.offset;
  }
  get direction() {
    return this._direction();
  }
  get elements() {
    return this.cachedElements || (this.cachedElements = this._elements()), this.cachedElements;
  }
  set focused(e36) {
    e36 !== this.focused && (this._focused = e36);
  }
  get focused() {
    return this._focused;
  }
  get focusInElement() {
    return this.elements[this.focusInIndex];
  }
  get focusInIndex() {
    return this._focusInIndex(this.elements);
  }
  isEventWithinListenerScope(e36) {
    return this._listenerScope() === this.host ? true : e36.composedPath().includes(this._listenerScope());
  }
  handleItemMutation() {
    if (this._currentIndex == -1 || this.elements.length <= this._elements().length) return;
    const e36 = this.elements[this.currentIndex];
    if (this.clearElementCache(), this.elements.includes(e36)) return;
    const t34 = this.currentIndex !== this.elements.length, n25 = t34 ? 1 : -1;
    t34 && this.setCurrentIndexCircularly(-1), this.setCurrentIndexCircularly(n25), this.focus();
  }
  update({ elements: e36 } = { elements: () => [] }) {
    this.unmanage(), this._elements = e36, this.clearElementCache(), this.manage();
  }
  reset() {
    var n25;
    const e36 = this.elements;
    if (!e36.length) return;
    this.setCurrentIndexCircularly(this.focusInIndex - this.currentIndex);
    let t34 = e36[this.currentIndex];
    this.currentIndex < 0 || ((!t34 || !this.isFocusableElement(t34)) && (this.setCurrentIndexCircularly(1), t34 = e36[this.currentIndex]), t34 && this.isFocusableElement(t34) && ((n25 = e36[this.prevIndex]) == null || n25.setAttribute("tabindex", "-1"), t34.setAttribute("tabindex", "0")));
  }
  focusOnItem(e36, t34) {
    var i21;
    const n25 = this.elements || [], s19 = !e36 || !this.isFocusableElement(e36) ? -1 : n25.indexOf(e36);
    s19 > -1 && (this.currentIndex = s19, (i21 = n25[this.prevIndex]) == null || i21.setAttribute("tabindex", "-1")), this.focus(t34);
  }
  focus(e36) {
    var s19;
    const t34 = this.elements;
    if (!t34.length) return;
    let n25 = t34[this.currentIndex];
    (!n25 || !this.isFocusableElement(n25)) && (this.setCurrentIndexCircularly(1), n25 = t34[this.currentIndex]), n25 && this.isFocusableElement(n25) && ((!this.hostDelegatesFocus || t34[this.prevIndex] !== n25) && ((s19 = t34[this.prevIndex]) == null || s19.setAttribute("tabindex", "-1")), n25.tabIndex = 0, n25.focus(e36), this.hostDelegatesFocus && !this.focused && this.hostContainsFocus());
  }
  clearElementCache(e36 = 0) {
    this.mutationObserver.disconnect(), delete this.cachedElements, this.offset = e36, requestAnimationFrame(() => {
      this.elements.forEach((t34) => {
        this.mutationObserver.observe(t34, { attributes: true });
      });
    });
  }
  setCurrentIndexCircularly(e36) {
    const { length: t34 } = this.elements;
    let n25 = t34;
    this.prevIndex = this.currentIndex;
    let s19 = (t34 + this.currentIndex + e36) % t34;
    for (; n25 && this.elements[s19] && !this.isFocusableElement(this.elements[s19]); ) s19 = (t34 + s19 + e36) % t34, n25 -= 1;
    this.currentIndex = s19;
  }
  hostContainsFocus() {
    this.host.addEventListener("focusout", this.handleFocusout), this.host.addEventListener("keydown", this.handleKeydown), this.focused = true;
  }
  hostNoLongerContainsFocus() {
    this.host.addEventListener("focusin", this.handleFocusin), this.host.removeEventListener("focusout", this.handleFocusout), this.host.removeEventListener("keydown", this.handleKeydown), this.focused = false;
  }
  isRelatedTargetOrContainAnElement(e36) {
    const t34 = e36.relatedTarget, n25 = this.elements.includes(t34), s19 = this.elements.some((i21) => i21.contains(t34));
    return !(n25 || s19);
  }
  acceptsEventKey(e36) {
    if (e36 === "End" || e36 === "Home") return true;
    switch (this.direction) {
      case "horizontal":
        return e36 === "ArrowLeft" || e36 === "ArrowRight";
      case "vertical":
        return e36 === "ArrowUp" || e36 === "ArrowDown";
      case "both":
      case "grid":
        return e36.startsWith("Arrow");
    }
  }
  manage() {
    this.addEventListeners();
  }
  unmanage() {
    this.removeEventListeners();
  }
  addEventListeners() {
    this.host.addEventListener("focusin", this.handleFocusin), this.host.addEventListener("click", this.handleClick);
  }
  removeEventListeners() {
    this.host.removeEventListener("focusin", this.handleFocusin), this.host.removeEventListener("focusout", this.handleFocusout), this.host.removeEventListener("keydown", this.handleKeydown), this.host.removeEventListener("click", this.handleClick);
  }
  hostConnected() {
    this.recentlyConnected = true, this.addEventListeners();
  }
  hostDisconnected() {
    this.mutationObserver.disconnect(), this.removeEventListeners();
  }
  hostUpdated() {
    this.recentlyConnected && (this.recentlyConnected = false, this.elements.forEach((e36) => {
      this.mutationObserver.observe(e36, { attributes: true });
    }));
  }
};

// node_modules/@spectrum-web-components/reactive-controllers/src/RovingTabindex.js
var RovingTabindexController = class extends FocusGroupController {
  constructor() {
    super(...arguments);
    this.managed = true;
    this.manageIndexesAnimationFrame = 0;
  }
  set focused(e36) {
    e36 !== this.focused && (super.focused = e36, this.manageTabindexes());
  }
  get focused() {
    return super.focused;
  }
  clearElementCache(e36 = 0) {
    cancelAnimationFrame(this.manageIndexesAnimationFrame), super.clearElementCache(e36), this.managed && (this.manageIndexesAnimationFrame = requestAnimationFrame(() => this.manageTabindexes()));
  }
  manageTabindexes() {
    this.focused && !this.hostDelegatesFocus ? this.updateTabindexes(() => ({ tabIndex: -1 })) : this.updateTabindexes((e36) => ({ removeTabIndex: e36.contains(this.focusInElement) && e36 !== this.focusInElement, tabIndex: e36 === this.focusInElement ? 0 : -1 }));
  }
  updateTabindexes(e36) {
    this.elements.forEach((a23) => {
      const { tabIndex: n25, removeTabIndex: s19 } = e36(a23);
      if (!s19) {
        this.focused ? a23 !== this.elements[this.currentIndex] && (a23.tabIndex = n25) : a23.tabIndex = n25;
        return;
      }
      const t34 = a23;
      t34.requestUpdate && t34.requestUpdate();
    });
  }
  manage() {
    this.managed = true, this.manageTabindexes(), super.manage();
  }
  unmanage() {
    this.managed = false, this.updateTabindexes(() => ({ tabIndex: 0 })), super.unmanage();
  }
  hostUpdated() {
    super.hostUpdated(), this.host.hasUpdated || this.manageTabindexes();
  }
};

// node_modules/@spectrum-web-components/action-group/src/ActionGroup.js
init_mutation_controller();

// node_modules/@spectrum-web-components/action-group/src/action-group.css.js
init_src();
var o20 = i`
    :host{--spectrum-actiongroup-button-spacing-reset:0;--spectrum-actiongroup-border-radius-reset:0;--spectrum-actiongroup-border-radius:var(--spectrum-corner-radius-100)}:host([size=s]),:host([size=xs]){--spectrum-actiongroup-horizontal-spacing-regular:var(--spectrum-spacing-75);--spectrum-actiongroup-vertical-spacing-regular:var(--spectrum-spacing-75)}:host([size=l]),:host,:host([size=xl]){--spectrum-actiongroup-horizontal-spacing-regular:var(--spectrum-spacing-100);--spectrum-actiongroup-vertical-spacing-regular:var(--spectrum-spacing-100)}:host{gap:var(--mod-actiongroup-horizontal-spacing-regular,var(--spectrum-actiongroup-horizontal-spacing-regular));flex-wrap:wrap;display:flex}::slotted(*){flex-shrink:0}::slotted(:focus-visible){z-index:3}:host(:not([vertical=true][compact=true])) ::slotted(*){flex-shrink:0}:host([vertical]){gap:var(--mod-actiongroup-vertical-spacing-regular,var(--spectrum-actiongroup-vertical-spacing-regular));flex-direction:column;display:inline-flex}:host([compact]){gap:var(--mod-actiongroup-gap-size-compact,var(--spectrum-actiongroup-gap-size-compact))}:host([compact]:not([quiet])){flex-wrap:nowrap}:host([compact]:not([quiet])) ::slotted(*){border-radius:var(--mod-actiongroup-border-radius-reset,var(--spectrum-actiongroup-border-radius-reset));z-index:0;position:relative}:host([compact]:not([quiet])) ::slotted(:first-child){--mod-actionbutton-focus-indicator-border-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0px 0px var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));border-start-start-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));border-end-start-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));margin-inline-start:var(--mod-actiongroup-button-spacing-reset,var(--spectrum-actiongroup-button-spacing-reset))}:host([compact]:not([quiet])) ::slotted(:not(:first-child)){--mod-actionbutton-focus-indicator-border-radius:0px;margin-inline-start:var(--mod-actiongroup-horizontal-spacing-compact,var(--spectrum-actiongroup-horizontal-spacing-compact));margin-inline-end:var(--mod-actiongroup-horizontal-spacing-compact,var(--spectrum-actiongroup-horizontal-spacing-compact))}:host([compact]:not([quiet])) ::slotted(:last-child){--mod-actionbutton-focus-indicator-border-radius:0px var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0px;border-start-end-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));border-end-end-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));margin-inline-start:var(--mod-actiongroup-horizontal-spacing-compact,var(--spectrum-actiongroup-horizontal-spacing-compact));margin-inline-end:var(--mod-actiongroup-border-radius-reset,var(--spectrum-actiongroup-border-radius-reset))}:host([compact]:not([quiet])) ::slotted([selected]){z-index:1}@media (hover:hover){:host([compact]:not([quiet])) ::slotted(:hover){z-index:2}}:host([compact]:not([quiet])) ::slotted(:focus-visible){z-index:3}:host([compact][vertical]:not([quiet])){gap:var(--mod-actiongroup-gap-size-compact,var(--spectrum-actiongroup-gap-size-compact))}:host([compact][vertical]:not([quiet])) ::slotted(*){border-radius:var(--mod-actiongroup-border-radius-reset,var(--spectrum-actiongroup-border-radius-reset))}:host([compact][vertical]:not([quiet])) ::slotted(:first-child){--mod-actionbutton-focus-indicator-border-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0px 0px;border-start-start-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));border-start-end-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));margin-block-start:var(--mod-actiongroup-vertical-spacing-compact,var(--spectrum-actiongroup-vertical-spacing-compact));margin-block-end:var(--mod-actiongroup-vertical-spacing-compact,var(--spectrum-actiongroup-vertical-spacing-compact));margin-inline-end:var(--mod-actiongroup-button-spacing-reset,var(--spectrum-actiongroup-button-spacing-reset))}:host([compact][vertical]:not([quiet])) ::slotted(:not(:first-child)){margin-block-start:var(--mod-actiongroup-button-spacing-reset,var(--spectrum-actiongroup-button-spacing-reset));margin-block-end:var(--mod-actiongroup-vertical-spacing-compact,var(--spectrum-actiongroup-vertical-spacing-compact));margin-inline-start:var(--mod-actiongroup-button-spacing-reset,var(--spectrum-actiongroup-button-spacing-reset));margin-inline-end:var(--mod-actiongroup-button-spacing-reset,var(--spectrum-actiongroup-button-spacing-reset))}:host([compact][vertical]:not([quiet])) ::slotted(:last-child){--mod-actionbutton-focus-indicator-border-radius:0px 0px var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));border-end-end-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));border-end-start-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius));margin-block-start:var(--mod-actiongroup-vertical-spacing-compact,var(--spectrum-actiongroup-vertical-spacing-compact));margin-block-end:var(--mod-actiongroup-button-spacing-reset,var(--spectrum-actiongroup-button-spacing-reset))}:host([justified]) ::slotted(*){flex-grow:1}:host{--spectrum-actiongroup-gap-size-compact:var(--system-action-group-gap-size-compact);--spectrum-actiongroup-horizontal-spacing-compact:var(--system-action-group-horizontal-spacing-compact);--spectrum-actiongroup-vertical-spacing-compact:var(--system-action-group-vertical-spacing-compact)}:host([size=xs]){--spectrum-actiongroup-horizontal-spacing-regular:var(--spectrum-spacing-75);--spectrum-actiongroup-vertical-spacing-regular:var(--spectrum-spacing-75)}:host([dir][compact][vertical]) ::slotted(:nth-child(n)){margin-left:0;margin-right:0}:host([justified]) ::slotted(:not([role])),:host([vertical]) ::slotted(:not([role])){flex-direction:column;align-items:stretch;display:flex}:host([compact]:not([quiet])) ::slotted(:not([role])){--overriden-border-radius:0;--mod-actionbutton-border-radius:var(--overriden-border-radius)}:host([compact][vertical]:not([quiet])) ::slotted(:not([role]):first-child){--overriden-border-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0 0}:host([compact][vertical]:not([quiet])) ::slotted(:not([role]):last-child){--overriden-border-radius:0 0 var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))}:host([dir=ltr][compact]:not([quiet],[vertical])) ::slotted(:not([role]):first-child){--overriden-border-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0 0 var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))}:host([dir=rtl][compact]:not([quiet],[vertical])) ::slotted(:not([role]):first-child),:host([dir=ltr][compact]:not([quiet],[vertical])) ::slotted(:not([role]):last-child){--overriden-border-radius:0 var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0}:host([dir=rtl][compact]:not([quiet],[vertical])) ::slotted(:not([role]):last-child){--overriden-border-radius:var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0 0 var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))}:host([compact]:not([quiet])) ::slotted(*){--mod-actionbutton-focus-ring-border-radius:0}:host([compact][vertical]:not([quiet])) ::slotted(:first-child){--mod-actionbutton-focus-ring-border-radius:var(--spectrum-alias-component-border-radius)var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0 0}:host([compact][vertical]:not([quiet])) ::slotted(:last-child){--mod-actionbutton-focus-ring-border-radius:0 0 var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))}:host([dir=ltr][compact]:not([quiet],[vertical])) ::slotted(:first-child){--mod-actionbutton-focus-ring-border-radius:var(--spectrum-alias-component-border-radius)0 0 var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))}:host([dir=rtl][compact]:not([quiet],[vertical])) ::slotted(:first-child),:host([dir=ltr][compact]:not([quiet],[vertical])) ::slotted(:last-child){--mod-actionbutton-focus-ring-border-radius:0 var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))0}:host([dir=rtl][compact]:not([quiet],[vertical])) ::slotted(:last-child){--mod-actionbutton-focus-ring-border-radius:var(--spectrum-alias-component-border-radius)0 0 var(--mod-actiongroup-border-radius,var(--spectrum-actiongroup-border-radius))}:host([justified]) ::slotted(*){flex:1}
`;
var action_group_css_default = o20;

// node_modules/@spectrum-web-components/action-group/src/ActionGroup.js
var f6 = Object.defineProperty;
var b5 = Object.getOwnPropertyDescriptor;
var a5 = (d22, u36, e36, s19) => {
  for (var t34 = s19 > 1 ? void 0 : s19 ? b5(u36, e36) : u36, i21 = d22.length - 1, l16; i21 >= 0; i21--) (l16 = d22[i21]) && (t34 = (s19 ? l16(u36, e36, t34) : l16(t34)) || t34);
  return s19 && t34 && f6(u36, e36, t34), t34;
};
var h8 = [];
var ActionGroup = class extends SizedMixin(SpectrumElement, { validSizes: ["xs", "s", "m", "l", "xl"], noDefaultSize: true }) {
  constructor() {
    super();
    this._buttons = [];
    this._buttonSelector = "sp-action-button, sp-action-menu";
    this.rovingTabindexController = new RovingTabindexController(this, { focusInIndex: (e36) => {
      let s19 = -1;
      const t34 = e36.findIndex((i21, l16) => (!e36[s19] && !i21.disabled && (s19 = l16), i21.selected && !i21.disabled));
      return e36[t34] ? t34 : s19;
    }, elements: () => this.buttons, hostDelegatesFocus: true, isFocusableElement: (e36) => !e36.disabled });
    this.compact = false;
    this.emphasized = false;
    this.justified = false;
    this.label = "";
    this.quiet = false;
    this.vertical = false;
    this._selected = h8;
    this.hasManaged = false;
    this.manageButtons = () => {
      if (!this.slotElement) return;
      const s19 = this.slotElement.assignedElements({ flatten: true }).reduce((t34, i21) => {
        if (i21.matches(this._buttonSelector)) t34.push(i21);
        else {
          const l16 = Array.from(i21.querySelectorAll(`:scope > ${this._buttonSelector}`));
          t34.push(...l16);
        }
        return t34;
      }, []);
      if (this.buttons = s19, this.selects || !this.hasManaged) {
        const t34 = [];
        this.buttons.forEach((i21) => {
          i21.selected && t34.push(i21.value);
        }), this.setSelected(this.selected.concat(t34));
      }
      this.manageChildren(), this.manageSelects(), this.hasManaged = true;
    };
    new t12(this, { config: { childList: true, subtree: true }, callback: () => {
      this.manageButtons();
    }, skipInitial: true });
  }
  static get styles() {
    return [action_group_css_default];
  }
  set buttons(e36) {
    e36 !== this.buttons && (this._buttons = e36, this.rovingTabindexController.clearElementCache());
  }
  get buttons() {
    return this._buttons;
  }
  set selected(e36) {
    this.requestUpdate("selected", this._selected), this._selected = e36, this.updateComplete.then(() => {
      this.applySelects(), this.manageChildren();
    });
  }
  get selected() {
    return this._selected;
  }
  dispatchChange(e36) {
    this.dispatchEvent(new Event("change", { bubbles: true, composed: true, cancelable: true })) || (this.setSelected(e36), this.buttons.map((t34) => {
      t34.selected = this.selected.includes(t34.value);
    }));
  }
  setSelected(e36, s19) {
    if (e36 === this.selected) return;
    const t34 = this.selected;
    this.requestUpdate("selected", t34), this._selected = e36, s19 && this.dispatchChange(t34);
  }
  focus(e36) {
    this.rovingTabindexController.focus(e36);
  }
  deselectSelectedButtons() {
    this.buttons.forEach((e36) => {
      e36.selected && (e36.selected = false, e36.tabIndex = -1, e36.setAttribute(this.selects ? "aria-checked" : "aria-pressed", "false"));
    });
  }
  handleActionButtonChange(e36) {
    e36.stopPropagation(), e36.preventDefault();
  }
  handleClick(e36) {
    const s19 = e36.target;
    if (typeof s19.value != "undefined") switch (this.selects) {
      case "single": {
        this.deselectSelectedButtons(), s19.selected = true, s19.tabIndex = 0, s19.setAttribute("aria-checked", "true"), this.setSelected([s19.value], true);
        break;
      }
      case "multiple": {
        const t34 = [...this.selected];
        s19.selected = !s19.selected, s19.setAttribute("aria-checked", s19.selected ? "true" : "false"), s19.selected ? t34.push(s19.value) : t34.splice(this.selected.indexOf(s19.value), 1), this.setSelected(t34, true), this.buttons.forEach((i21) => {
          i21.tabIndex = -1;
        }), s19.tabIndex = 0;
        break;
      }
      default:
        break;
    }
  }
  async applySelects() {
    await this.manageSelects(true);
  }
  async manageSelects(e36) {
    if (!this.buttons.length) return;
    const s19 = this.buttons;
    switch (this.selects) {
      case "single": {
        this.setAttribute("role", "radiogroup");
        const t34 = [], i21 = s19.map(async (r25) => {
          await r25.updateComplete, r25 instanceof ActionButton && r25.setAttribute("role", "radio"), r25.setAttribute("aria-checked", r25.selected ? "true" : "false"), r25.selected && t34.push(r25);
        });
        if (e36) break;
        await Promise.all(i21);
        const l16 = t34.map((r25) => r25.value);
        this.setSelected(l16 || h8);
        break;
      }
      case "multiple": {
        this.getAttribute("role") === "radiogroup" && this.removeAttribute("role");
        const t34 = [], i21 = [], l16 = s19.map(async (n25) => {
          await n25.updateComplete, n25 instanceof ActionButton && n25.setAttribute("role", "checkbox"), n25.setAttribute("aria-checked", n25.selected ? "true" : "false"), n25.selected && (t34.push(n25.value), i21.push(n25));
        });
        if (e36) break;
        await Promise.all(l16);
        const r25 = t34.length ? t34 : h8;
        this.setSelected(r25);
        break;
      }
      default:
        if (this.selected.length) {
          const t34 = [], i21 = s19.map(async (l16) => {
            await l16.updateComplete, l16 instanceof ActionButton && l16.setAttribute("role", "button"), l16.selected ? (l16.setAttribute("aria-pressed", "true"), t34.push(l16)) : l16.removeAttribute("aria-pressed");
          });
          if (e36) break;
          await Promise.all(i21), this.setSelected(t34.map((l16) => l16.value));
        } else {
          this.buttons.forEach((t34) => {
            t34 instanceof ActionButton && t34.setAttribute("role", "button");
          });
          break;
        }
    }
    this.hasAttribute("role") || this.setAttribute("role", "toolbar");
  }
  render() {
    return x`
            <slot role="presentation" @slotchange=${this.manageButtons}></slot>
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.addEventListener("click", this.handleClick);
  }
  updated(e36) {
    super.updated(e36), e36.has("selects") && (this.manageSelects(), this.manageChildren(), this.selects ? this.shadowRoot.addEventListener("change", this.handleActionButtonChange) : this.shadowRoot.removeEventListener("change", this.handleActionButtonChange)), (e36.has("quiet") || e36.has("emphasized") || e36.has("size") || e36.has("staticColor")) && this.manageChildren(e36), e36.has("label") && (this.label || typeof e36.get("label") != "undefined") && (this.label.length ? this.setAttribute("aria-label", this.label) : this.removeAttribute("aria-label"));
  }
  manageChildren(e36) {
    this.buttons.forEach((s19) => {
      (this.quiet || e36 != null && e36.get("quiet")) && (s19.quiet = this.quiet), (this.emphasized || e36 != null && e36.get("emphasized")) && (s19.emphasized = this.emphasized), (this.staticColor || e36 != null && e36.get("staticColor")) && (s19.staticColor = this.staticColor), (this.selects || !this.hasManaged) && (s19.selected = this.selected.includes(s19.value)), this.size && (this.size !== "m" || typeof (e36 == null ? void 0 : e36.get("size")) != "undefined") && (s19.size = this.size);
    });
  }
};
ActionGroup.shadowRootOptions = { ...SpectrumElement.shadowRootOptions, delegatesFocus: true }, a5([n4({ type: Boolean, reflect: true })], ActionGroup.prototype, "compact", 2), a5([n4({ type: Boolean, reflect: true })], ActionGroup.prototype, "emphasized", 2), a5([n4({ type: Boolean, reflect: true })], ActionGroup.prototype, "justified", 2), a5([n4({ type: String })], ActionGroup.prototype, "label", 2), a5([n4({ type: Boolean, reflect: true })], ActionGroup.prototype, "quiet", 2), a5([n4({ type: String })], ActionGroup.prototype, "selects", 2), a5([n4({ reflect: true, attribute: "static-color" })], ActionGroup.prototype, "staticColor", 2), a5([n4({ type: Boolean, reflect: true })], ActionGroup.prototype, "vertical", 2), a5([n4({ type: Array })], ActionGroup.prototype, "selected", 1), a5([e5("slot")], ActionGroup.prototype, "slotElement", 2);

// node_modules/@spectrum-web-components/action-group/sp-action-group.js
init_define_element();
defineElement("sp-action-group", ActionGroup);

// node_modules/@spectrum-web-components/overlay/overlay-trigger.js
init_define_element();

// node_modules/@spectrum-web-components/overlay/src/OverlayTrigger.js
init_src();
init_decorators2();
init_sp_overlay();

// node_modules/@spectrum-web-components/overlay/src/overlay-trigger.css.js
init_src();
var e20 = i`
    slot[name=longpress-describedby-descriptor]{display:none}
`;
var overlay_trigger_css_default = e20;

// node_modules/@spectrum-web-components/overlay/src/OverlayTrigger.js
var m9 = Object.defineProperty;
var u14 = Object.getOwnPropertyDescriptor;
var n15 = (p30, l16, e36, r25) => {
  for (var t34 = r25 > 1 ? void 0 : r25 ? u14(l16, e36) : l16, s19 = p30.length - 1, i21; s19 >= 0; s19--) (i21 = p30[s19]) && (t34 = (r25 ? i21(l16, e36, t34) : i21(t34)) || t34);
  return r25 && t34 && m9(l16, e36, t34), t34;
};
var OverlayTrigger = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.offset = 6;
    this.disabled = false;
    this.receivesFocus = "auto";
    this.clickContent = [];
    this.longpressContent = [];
    this.hoverContent = [];
    this.targetContent = [];
  }
  static get styles() {
    return [overlay_trigger_css_default];
  }
  getAssignedElementsFromSlot(e36) {
    return e36.assignedElements({ flatten: true });
  }
  handleTriggerContent(e36) {
    this.targetContent = this.getAssignedElementsFromSlot(e36.target);
  }
  handleSlotContent(e36) {
    switch (e36.target.name) {
      case "click-content":
        this.clickContent = this.getAssignedElementsFromSlot(e36.target);
        break;
      case "longpress-content":
        this.longpressContent = this.getAssignedElementsFromSlot(e36.target);
        break;
      case "hover-content":
        this.hoverContent = this.getAssignedElementsFromSlot(e36.target);
        break;
    }
  }
  handleBeforetoggle(e36) {
    const { target: r25 } = e36;
    let t34;
    if (r25 === this.clickOverlayElement) t34 = "click";
    else if (r25 === this.longpressOverlayElement) t34 = "longpress";
    else if (r25 === this.hoverOverlayElement) t34 = "hover";
    else return;
    e36.newState === "open" ? this.open = t34 : this.open === t34 && (this.open = void 0);
  }
  update(e36) {
    var r25, t34, s19, i21, d22, g8;
    e36.has("clickContent") && (this.clickPlacement = ((r25 = this.clickContent[0]) == null ? void 0 : r25.getAttribute("placement")) || ((t34 = this.clickContent[0]) == null ? void 0 : t34.getAttribute("direction")) || void 0), e36.has("hoverContent") && (this.hoverPlacement = ((s19 = this.hoverContent[0]) == null ? void 0 : s19.getAttribute("placement")) || ((i21 = this.hoverContent[0]) == null ? void 0 : i21.getAttribute("direction")) || void 0), e36.has("longpressContent") && (this.longpressPlacement = ((d22 = this.longpressContent[0]) == null ? void 0 : d22.getAttribute("placement")) || ((g8 = this.longpressContent[0]) == null ? void 0 : g8.getAttribute("direction")) || void 0), super.update(e36);
  }
  renderSlot(e36) {
    return x`
            <slot name=${e36} @slotchange=${this.handleSlotContent}></slot>
        `;
  }
  renderClickOverlay() {
    var t34;
    const e36 = this.renderSlot("click-content"), r25 = x`
            <sp-overlay
                id="click-overlay"
                ?disabled=${this.disabled || !this.clickContent.length}
                ?open=${this.open === "click" && !!this.clickContent.length}
                .offset=${this.offset}
                .placement=${this.clickPlacement || this.placement}
                .triggerElement=${this.targetContent[0]}
                .triggerInteraction=${"click"}
                .type=${this.type !== "modal" ? "auto" : "modal"}
                @beforetoggle=${this.handleBeforetoggle}
                .receivesFocus=${this.receivesFocus}
            >
                ${e36}
            </sp-overlay>
        `;
    return (t34 = this.triggeredBy) != null && t34.includes("click") || this.clickContent.length ? r25 : e36;
  }
  renderHoverOverlay() {
    var t34;
    const e36 = this.renderSlot("hover-content"), r25 = x`
            <sp-overlay
                id="hover-overlay"
                ?open=${this.open === "hover" && !!this.hoverContent.length}
                ?disabled=${this.disabled || !this.hoverContent.length || !!this.open && this.open !== "hover"}
                .offset=${this.offset}
                .placement=${this.hoverPlacement || this.placement}
                .triggerElement=${this.targetContent[0]}
                .triggerInteraction=${"hover"}
                .type=${"hint"}
                @beforetoggle=${this.handleBeforetoggle}
                .receivesFocus=${this.receivesFocus}
            >
                ${e36}
            </sp-overlay>
        `;
    return (t34 = this.triggeredBy) != null && t34.includes("hover") || this.hoverContent.length ? r25 : e36;
  }
  renderLongpressOverlay() {
    var t34;
    const e36 = this.renderSlot("longpress-content"), r25 = x`
            <sp-overlay
                id="longpress-overlay"
                ?disabled=${this.disabled || !this.longpressContent.length}
                ?open=${this.open === "longpress" && !!this.longpressContent.length}
                .offset=${this.offset}
                .placement=${this.longpressPlacement || this.placement}
                .triggerElement=${this.targetContent[0]}
                .triggerInteraction=${"longpress"}
                .type=${"auto"}
                @beforetoggle=${this.handleBeforetoggle}
                .receivesFocus=${this.receivesFocus}
            >
                ${e36}
            </sp-overlay>
            <slot name="longpress-describedby-descriptor"></slot>
        `;
    return (t34 = this.triggeredBy) != null && t34.includes("longpress") || this.longpressContent.length ? r25 : e36;
  }
  render() {
    return x`
            <slot
                id="trigger"
                name="trigger"
                @slotchange=${this.handleTriggerContent}
            ></slot>
            ${[this.renderClickOverlay(), this.renderHoverOverlay(), this.renderLongpressOverlay()]}
        `;
  }
  updated(e36) {
    if (super.updated(e36), this.disabled && e36.has("disabled")) {
      this.open = void 0;
      return;
    }
  }
  async getUpdateComplete() {
    return await super.getUpdateComplete();
  }
};
n15([n4({ attribute: "triggered-by" })], OverlayTrigger.prototype, "triggeredBy", 2), n15([n4({ reflect: true })], OverlayTrigger.prototype, "placement", 2), n15([n4()], OverlayTrigger.prototype, "type", 2), n15([n4({ type: Number })], OverlayTrigger.prototype, "offset", 2), n15([n4({ reflect: true })], OverlayTrigger.prototype, "open", 2), n15([n4({ type: Boolean, reflect: true })], OverlayTrigger.prototype, "disabled", 2), n15([n4({ attribute: "receives-focus" })], OverlayTrigger.prototype, "receivesFocus", 2), n15([r5()], OverlayTrigger.prototype, "clickContent", 2), n15([r5()], OverlayTrigger.prototype, "longpressContent", 2), n15([r5()], OverlayTrigger.prototype, "hoverContent", 2), n15([r5()], OverlayTrigger.prototype, "targetContent", 2), n15([e5("#click-overlay", true)], OverlayTrigger.prototype, "clickOverlayElement", 2), n15([e5("#longpress-overlay", true)], OverlayTrigger.prototype, "longpressOverlayElement", 2), n15([e5("#hover-overlay", true)], OverlayTrigger.prototype, "hoverOverlayElement", 2);

// node_modules/@spectrum-web-components/overlay/overlay-trigger.js
defineElement("overlay-trigger", OverlayTrigger);

// src/custom-elements/core/spectrum-color-palette.js
init_sp_popover();

// node_modules/@spectrum-web-components/field-label/src/FieldLabel.js
init_src();
init_decorators2();
init_random_id();

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconAsterisk100.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Asterisk100.js
var Asterisk100Icon = ({ width: l16 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Asterisk100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 8 8"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${l16}"
    height="${t34}"
  >
    <path
      d="M6.575 6.555c.055.056.092.13 0 .2l-1.149.741c-.092.056-.129.019-.166-.074L3.834 4.94 1.963 7c-.019.036-.074.073-.129 0l-.889-.927c-.093-.055-.074-.111 0-.166l2.111-1.76L.648 3.24c-.037 0-.092-.074-.056-.167l.63-1.259a.097.097 0 0 1 .167-.036L3.5 3.148l.13-2.7a.1.1 0 0 1 .081-.111h.03l1.537.2c.093 0 .111.037.093.13l-.723 2.647 2.445-.741c.055-.037.111-.037.148.074l.241 1.37c.018.093 0 .13-.074.13l-2.556.2z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Asterisk100.js
var Asterisk100Icon2 = ({ width: l16 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Asterisk100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 8 8"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${l16}"
    height="${t34}"
  >
    <path
      d="M6.575 6.555c.055.056.092.13 0 .2l-1.149.741c-.092.056-.129.019-.166-.074L3.834 4.94 1.963 7c-.019.036-.074.073-.129 0l-.889-.927c-.093-.055-.074-.111 0-.166l2.111-1.76L.648 3.24c-.037 0-.092-.074-.056-.167l.63-1.259a.097.097 0 0 1 .167-.036L3.5 3.148l.13-2.7a.1.1 0 0 1 .081-.111h.03l1.537.2c.093 0 .111.037.093.13l-.723 2.647 2.445-.741c.055-.037.111-.037.148.074l.241 1.37c.018.093 0 .13-.074.13l-2.556.2z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconAsterisk100.js
var IconAsterisk100 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Asterisk100Icon({ hidden: !this.label, title: this.label }) : Asterisk100Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-asterisk100.js
init_define_element();
defineElement("sp-icon-asterisk100", IconAsterisk100);

// node_modules/@spectrum-web-components/icon/src/spectrum-icon-asterisk.css.js
init_src();
var e21 = i`
    .spectrum-UIIcon-Asterisk75{--spectrum-icon-size:var(--spectrum-asterisk-icon-size-75)}.spectrum-UIIcon-Asterisk100{--spectrum-icon-size:var(--spectrum-asterisk-icon-size-100)}.spectrum-UIIcon-Asterisk200{--spectrum-icon-size:var(--spectrum-asterisk-icon-size-200)}.spectrum-UIIcon-Asterisk300{--spectrum-icon-size:var(--spectrum-asterisk-icon-size-300)}
`;
var spectrum_icon_asterisk_css_default = e21;

// node_modules/@spectrum-web-components/field-label/src/FieldLabel.js
init_condition_attribute_with_id();
init_ElementResolution();

// node_modules/@spectrum-web-components/field-label/src/field-label.css.js
init_src();
var t18 = i`
    :host,:host{--spectrum-field-label-min-height:var(--spectrum-component-height-75);--spectrum-field-label-font-size:var(--spectrum-font-size-75);--spectrum-field-label-side-margin-block-start:var(--spectrum-field-label-top-margin-medium);--spectrum-field-label-side-padding-right:var(--spectrum-spacing-200);--spectrum-field-label-text-to-asterisk:var(--spectrum-field-label-text-to-asterisk-medium)}:host([size=s]){--spectrum-field-label-min-height:var(--spectrum-component-height-75);--spectrum-field-label-font-size:var(--spectrum-font-size-75);--spectrum-field-label-side-margin-block-start:var(--spectrum-field-label-top-margin-small);--spectrum-field-label-side-padding-right:var(--spectrum-spacing-100);--spectrum-field-label-text-to-asterisk:var(--spectrum-field-label-text-to-asterisk-small)}:host([size=l]){--spectrum-field-label-min-height:var(--spectrum-component-height-100);--spectrum-field-label-font-size:var(--spectrum-font-size-100);--spectrum-field-label-side-margin-block-start:var(--spectrum-field-label-top-margin-large);--spectrum-field-label-side-padding-right:var(--spectrum-spacing-200);--spectrum-field-label-text-to-asterisk:var(--spectrum-field-label-text-to-asterisk-large)}:host([size=xl]){--spectrum-field-label-min-height:var(--spectrum-component-height-200);--spectrum-field-label-font-size:var(--spectrum-font-size-200);--spectrum-field-label-side-margin-block-start:var(--spectrum-field-label-top-margin-extra-large);--spectrum-field-label-side-padding-right:var(--spectrum-spacing-200);--spectrum-field-label-text-to-asterisk:var(--spectrum-field-label-text-to-asterisk-extra-large)}:host{box-sizing:border-box;min-block-size:var(--mod-fieldlabel-min-height,var(--spectrum-field-label-min-height));padding-block:var(--mod-fieldlabel-padding-block,var(--mod-field-label-top-to-text,var(--spectrum-field-label-top-to-text))var(--mod-field-label-bottom-to-text,var(--spectrum-field-label-bottom-to-text)));padding-inline:0;padding-inline:var(--mod-fieldlabel-padding-inline,0);margin-block:0;margin-block:var(--mod-fieldlabel-margin-block,var(--mod-fieldlabel-margin-block-start,0)var(--mod-fieldlabel-margin-block-end,0));margin-inline:0;margin-inline:var(--mod-fieldlabel-margin-inline,var(--mod-fieldlabel-margin-inline-start,0)var(--mod-fieldlabel-margin-inline-end,0));font-size:var(--mod-fieldlabel-font-size,var(--spectrum-field-label-font-size));font-weight:var(--mod-fieldlabel-font-weight,var(--spectrum-regular-font-weight));line-height:var(--mod-fieldlabel-line-height,var(--spectrum-line-height-100));-webkit-font-smoothing:subpixel-antialiased;-moz-osx-font-smoothing:auto;color:var(--highcontrast-field-label-content-color,var(--mod-fieldlabel-color,var(--spectrum-neutral-subdued-content-color-default)));display:block}:host(:lang(ja)),:host(:lang(ko)),:host(:lang(zh)){--mod-fieldlabel-line-height:var(--mod-fieldlabel-line-height-cjk,var(--spectrum-cjk-line-height-100))}:host([disabled]){--mod-fieldlabel-color:var(--mod-disabled-content-color,var(--spectrum-disabled-content-color))}.required-icon{color:inherit;margin-block:0;margin-inline:var(--mod-field-label-text-to-asterisk,var(--spectrum-field-label-text-to-asterisk))0;vertical-align:initial;vertical-align:var(--mod-field-label-asterisk-vertical-align,baseline)}:host([side-aligned=start]),:host([side-aligned=end]){vertical-align:top;margin-block-start:var(--mod-fieldlabel-side-margin-block-start,var(--spectrum-field-label-side-margin-block-start));margin-block-end:0;margin-inline-end:var(--mod-fieldlabel-side-padding-right,var(--spectrum-field-label-side-padding-right));display:inline-block}:host([side-aligned=end]){text-align:end}@media (forced-colors:active){:host([disabled]){--highcontrast-field-label-content-color:GrayText}}:host{--spectrum-field-label-top-to-text:var(--system-field-label-top-to-text);--spectrum-field-label-bottom-to-text:var(--system-field-label-bottom-to-text)}:host([size=s]){--spectrum-field-label-top-to-text:var(--system-field-label-top-to-text-small);--spectrum-field-label-bottom-to-text:var(--system-field-label-bottom-to-text-small)}:host([size=l]){--spectrum-field-label-top-to-text:var(--system-field-label-top-to-text-large);--spectrum-field-label-bottom-to-text:var(--system-field-label-bottom-to-text-large)}:host([size=xl]){--spectrum-field-label-top-to-text:var(--system-field-label-top-to-text-extra-large);--spectrum-field-label-bottom-to-text:var(--system-field-label-bottom-to-text-extra-large)}label{display:inline-block}
`;
var field_label_css_default = t18;

// node_modules/@spectrum-web-components/field-label/src/FieldLabel.js
var c14 = Object.defineProperty;
var d8 = Object.getOwnPropertyDescriptor;
var o25 = (n25, l16, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? d8(l16, e36) : l16, s19 = n25.length - 1, r25; s19 >= 0; s19--) (r25 = n25[s19]) && (t34 = (i21 ? r25(l16, e36, t34) : r25(t34)) || t34);
  return i21 && t34 && c14(l16, e36, t34), t34;
};
var FieldLabel = class extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.id = "";
    this.for = "";
    this.required = false;
    this.resolvedElement = new ElementResolutionController(this);
  }
  static get styles() {
    return [field_label_css_default, spectrum_icon_asterisk_css_default];
  }
  handleClick(e36) {
    if (!this.target || this.disabled || e36.defaultPrevented) return;
    this.target.focus();
    const i21 = this.getRootNode(), t34 = this.target, s19 = t34.getRootNode(), r25 = s19.host;
    s19 === i21 && t34.forceFocusVisible ? t34.forceFocusVisible() : r25 && r25.forceFocusVisible && r25.forceFocusVisible();
  }
  applyTargetLabel(e36) {
    if (this.target = e36 || this.target, this.target) {
      const i21 = this.target.applyFocusElementLabel, t34 = this.target.focusElement || this.target, s19 = t34.getRootNode();
      typeof i21 != "undefined" ? i21(this.labelText, this) : s19 === this.getRootNode() ? (e36 ? conditionAttributeWithId : conditionAttributeWithoutId)(t34, "aria-labelledby", [this.id]) : e36 ? t34.setAttribute("aria-label", this.labelText) : t34.removeAttribute("aria-label");
    }
  }
  async manageTarget() {
    this.applyTargetLabel();
    const e36 = this.resolvedElement.element;
    if (!e36) {
      this.target = e36;
      return;
    }
    e36.localName.search("-") > 0 && await customElements.whenDefined(e36.localName), typeof e36.updateComplete != "undefined" && await e36.updateComplete, this.applyTargetLabel(e36);
  }
  get labelText() {
    const e36 = this.slotEl.assignedNodes({ flatten: true });
    return e36.length ? e36.map((t34) => (t34.textContent || "").trim()).join(" ") : "";
  }
  render() {
    return x`
            <label>
                <slot></slot>
                ${this.required ? x`
                          <sp-icon-asterisk100
                              class="required-icon spectrum-UIIcon-Asterisk100"
                          ></sp-icon-asterisk100>
                      ` : E}
            </label>
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.addEventListener("click", this.handleClick);
  }
  willUpdate(e36) {
    this.hasAttribute("id") || this.setAttribute("id", `${this.tagName.toLowerCase()}-${randomID()}`), e36.has("for") && (this.resolvedElement.selector = this.for ? `#${this.for}` : ""), (e36.has("id") || e36.has(elementResolverUpdatedSymbol)) && this.manageTarget();
  }
};
o25([n4({ type: Boolean, reflect: true })], FieldLabel.prototype, "disabled", 2), o25([n4({ type: String })], FieldLabel.prototype, "id", 2), o25([n4({ type: String })], FieldLabel.prototype, "for", 2), o25([n4({ type: Boolean, reflect: true })], FieldLabel.prototype, "required", 2), o25([e5("slot")], FieldLabel.prototype, "slotEl", 2), o25([n4({ type: String, reflect: true, attribute: "side-aligned" })], FieldLabel.prototype, "sideAligned", 2);

// node_modules/@spectrum-web-components/field-label/sp-field-label.js
init_define_element();
defineElement("sp-field-label", FieldLabel);

// node_modules/@spectrum-web-components/tooltip/src/Tooltip.js
init_src();
init_decorators2();
init_directives();

// node_modules/@spectrum-web-components/reactive-controllers/src/DependencyManger.js
var dependencyManagerLoadedSymbol = Symbol("dependency manager loaded");
var DependencyManagerController = class {
  constructor(e36) {
    this.dependencies = {};
    this._loaded = false;
    this.host = e36;
  }
  get loaded() {
    return this._loaded;
  }
  set loaded(e36) {
    e36 !== this.loaded && (this._loaded = e36, this.host.requestUpdate(dependencyManagerLoadedSymbol, !this.loaded));
  }
  add(e36, o52) {
    const t34 = !!o52 || !!customElements.get(e36) || this.dependencies[e36];
    t34 || customElements.whenDefined(e36).then(() => {
      this.add(e36, true);
    }), this.dependencies = { ...this.dependencies, [e36]: t34 }, this.loaded = Object.values(this.dependencies).every((d22) => d22);
  }
};

// node_modules/@spectrum-web-components/tooltip/src/Tooltip.js
init_focusable_selectors();

// node_modules/@spectrum-web-components/tooltip/src/tooltip.css.js
init_src();
var o26 = i`
    #tooltip{pointer-events:none;visibility:hidden;opacity:0;transition:transform .13s ease-in-out,opacity .13s ease-in-out,visibility 0s linear .13s;transition:transform var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s))ease-in-out,opacity var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s))ease-in-out,visibility 0s linear var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s))}:host([open]) #tooltip{pointer-events:auto;visibility:visible;opacity:1;transition-delay:0s;transition-delay:var(--mod-overlay-animation-duration-opened,var(--spectrum-animation-duration-0,0s))}#tooltip{--spectrum-tooltip-animation-duration:var(--spectrum-animation-duration-100);--spectrum-tooltip-margin:0px;--spectrum-tooltip-height:var(--spectrum-component-height-75);--spectrum-tooltip-max-inline-size:var(--spectrum-tooltip-maximum-width);--spectrum-tooltip-border-radius:var(--spectrum-corner-radius-100);--spectrum-tooltip-icon-width:var(--spectrum-workflow-icon-size-50);--spectrum-tooltip-icon-height:var(--spectrum-workflow-icon-size-50);--spectrum-tooltip-font-size:var(--spectrum-font-size-75);--spectrum-tooltip-line-height:var(--spectrum-line-height-100);--spectrum-tooltip-cjk-line-height:var(--spectrum-cjk-line-height-100);--spectrum-tooltip-font-weight:var(--spectrum-regular-font-weight);--spectrum-tooltip-spacing-inline:var(--spectrum-component-edge-to-text-75);--spectrum-tooltip-spacing-block-start:var(--spectrum-component-top-to-text-75);--spectrum-tooltip-spacing-block-end:var(--spectrum-component-bottom-to-text-75);--spectrum-tooltip-icon-spacing-inline-start:var(--spectrum-text-to-visual-75);--spectrum-tooltip-icon-spacing-inline-end:var(--spectrum-text-to-visual-75);--spectrum-tooltip-icon-spacing-block-start:var(--spectrum-component-top-to-workflow-icon-75);--spectrum-tooltip-background-color-informative:var(--spectrum-informative-background-color-default);--spectrum-tooltip-background-color-positive:var(--spectrum-positive-background-color-default);--spectrum-tooltip-background-color-negative:var(--spectrum-negative-background-color-default);--spectrum-tooltip-content-color:var(--spectrum-white);--spectrum-tooltip-tip-inline-size:var(--spectrum-tooltip-tip-width);--spectrum-tooltip-tip-block-size:var(--spectrum-tooltip-tip-height);--spectrum-tooltip-tip-square-size:var(--spectrum-tooltip-tip-inline-size);--spectrum-tooltip-tip-height-percentage:50%;--spectrum-tooltip-tip-antialiasing-inset:.5px;--spectrum-tooltip-pointer-corner-spacing:var(--spectrum-corner-radius-100);--spectrum-tooltip-background-color-default:var(--spectrum-tooltip-backgound-color-default-neutral)}@media (forced-colors:active){#tooltip{border:1px solid #0000}#tip{--highcontrast-tooltip-background-color-default:CanvasText;--highcontrast-tooltip-background-color-informative:CanvasText;--highcontrast-tooltip-background-color-positive:CanvasText;--highcontrast-tooltip-background-color-negative:CanvasText;forced-color-adjust:none}}#tooltip{box-sizing:border-box;vertical-align:top;inline-size:auto;padding-inline:var(--mod-tooltip-spacing-inline,var(--spectrum-tooltip-spacing-inline));border-radius:var(--mod-tooltip-border-radius,var(--spectrum-tooltip-border-radius));block-size:auto;min-block-size:var(--mod-tooltip-height,var(--spectrum-tooltip-height));max-inline-size:var(--mod-tooltip-max-inline-size,var(--spectrum-tooltip-max-inline-size));background-color:var(--highcontrast-tooltip-background-color-default,var(--mod-tooltip-background-color-default,var(--spectrum-tooltip-background-color-default)));color:var(--mod-tooltip-content-color,var(--spectrum-tooltip-content-color));font-size:var(--mod-tooltip-font-size,var(--spectrum-tooltip-font-size));font-weight:var(--mod-tooltip-font-weight,var(--spectrum-tooltip-font-weight));line-height:var(--mod-tooltip-line-height,var(--spectrum-tooltip-line-height));overflow-wrap:break-word;-webkit-font-smoothing:antialiased;cursor:default;-webkit-user-select:none;user-select:none;flex-direction:row;align-items:center;display:inline-flex;position:relative}:host(:lang(ja)) #tooltip,:host(:lang(ko)) #tooltip,:host(:lang(zh)) #tooltip{line-height:var(--mod-tooltip-cjk-line-height,var(--spectrum-tooltip-cjk-line-height))}#tooltip p{margin:0}:host([variant=info]) #tooltip{background-color:var(--highcontrast-tooltip-background-color-informative,var(--mod-tooltip-background-color-informative,var(--spectrum-tooltip-background-color-informative)))}:host([variant=positive]) #tooltip{background-color:var(--highcontrast-tooltip-background-color-positive,var(--mod-tooltip-background-color-positive,var(--spectrum-tooltip-background-color-positive)))}:host([variant=negative]) #tooltip{background-color:var(--highcontrast-tooltip-background-color-negative,var(--mod-tooltip-background-color-negative,var(--spectrum-tooltip-background-color-negative)))}#tip{block-size:var(--mod-tooltip-tip-square-size,var(--spectrum-tooltip-tip-square-size));inline-size:var(--mod-tooltip-tip-square-size,var(--spectrum-tooltip-tip-square-size));background-color:var(--highcontrast-tooltip-background-color-default,var(--mod-tooltip-background-color-default,var(--spectrum-tooltip-background-color-default)));clip-path:polygon(0 calc(0% - var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset))),50% var(--mod-tooltip-tip-height-percentage,var(--spectrum-tooltip-tip-height-percentage)),100% calc(0% - var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset))));inset-block-start:100%;position:absolute;left:50%;transform:translate(-50%)}:host([variant=info]) #tooltip #tip{background-color:var(--highcontrast-tooltip-background-color-informative,var(--mod-tooltip-background-color-informative,var(--spectrum-tooltip-background-color-informative)))}:host([variant=positive]) #tooltip #tip{background-color:var(--highcontrast-tooltip-background-color-positive,var(--mod-tooltip-background-color-positive,var(--spectrum-tooltip-background-color-positive)))}:host([variant=negative]) #tooltip #tip{background-color:var(--highcontrast-tooltip-background-color-negative,var(--mod-tooltip-background-color-negative,var(--spectrum-tooltip-background-color-negative)))}:host([placement*=top]) #tooltip #tip,.spectrum-Tooltip--top-end #tip,.spectrum-Tooltip--top-left #tip,.spectrum-Tooltip--top-right #tip,.spectrum-Tooltip--top-start #tip{inset-block-start:100%}:host([placement*=bottom]) #tooltip #tip,.spectrum-Tooltip--bottom-end #tip,.spectrum-Tooltip--bottom-left #tip,.spectrum-Tooltip--bottom-right #tip,.spectrum-Tooltip--bottom-start #tip{clip-path:polygon(50% calc(100% - var(--mod-tooltip-tip-height-percentage,var(--spectrum-tooltip-tip-height-percentage))),0 calc(100% + var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset))),100% calc(100% + var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset))));inset-block:auto 100%}.spectrum-Tooltip--bottom-end #tip,.spectrum-Tooltip--bottom-left #tip,.spectrum-Tooltip--bottom-right #tip,.spectrum-Tooltip--bottom-start #tip,.spectrum-Tooltip--top-end #tip,.spectrum-Tooltip--top-left #tip,.spectrum-Tooltip--top-right #tip,.spectrum-Tooltip--top-start #tip{transform:none}.spectrum-Tooltip--bottom-left #tip,.spectrum-Tooltip--top-left #tip{inset-inline-start:var(--mod-tooltip-pointer-corner-spacing,var(--spectrum-tooltip-pointer-corner-spacing))}.spectrum-Tooltip--bottom-right #tip,.spectrum-Tooltip--top-right #tip{inset-inline:auto var(--mod-tooltip-pointer-corner-spacing,var(--spectrum-tooltip-pointer-corner-spacing))}.spectrum-Tooltip--bottom-start #tip,.spectrum-Tooltip--top-start #tip{inset-inline:var(--mod-tooltip-pointer-corner-spacing,var(--spectrum-tooltip-pointer-corner-spacing))auto}.spectrum-Tooltip--bottom-start #tip:dir(rtl),.spectrum-Tooltip--top-start #tip:dir(rtl),:host([dir=rtl]) .spectrum-Tooltip--bottom-start #tip,:host([dir=rtl]) .spectrum-Tooltip--top-start #tip{right:var(--mod-tooltip-pointer-corner-spacing,var(--spectrum-tooltip-pointer-corner-spacing));left:auto}.spectrum-Tooltip--bottom-end #tip,.spectrum-Tooltip--top-end #tip{inset-inline:auto var(--mod-tooltip-pointer-corner-spacing,var(--spectrum-tooltip-pointer-corner-spacing))}.spectrum-Tooltip--bottom-end #tip:dir(rtl),.spectrum-Tooltip--top-end #tip:dir(rtl),:host([dir=rtl]) .spectrum-Tooltip--bottom-end #tip,:host([dir=rtl]) .spectrum-Tooltip--top-end #tip{left:var(--mod-tooltip-pointer-corner-spacing,var(--spectrum-tooltip-pointer-corner-spacing));right:auto}.spectrum-Tooltip--end #tip,.spectrum-Tooltip--end-bottom #tip,.spectrum-Tooltip--end-top #tip,:host([placement*=left]) #tooltip #tip,.spectrum-Tooltip--left-bottom #tip,.spectrum-Tooltip--left-top #tip,:host([placement*=right]) #tooltip #tip,.spectrum-Tooltip--right-bottom #tip,.spectrum-Tooltip--right-top #tip,.spectrum-Tooltip--start #tip,.spectrum-Tooltip--start-bottom #tip,.spectrum-Tooltip--start-top #tip{inset-block-start:50%;transform:translateY(-50%)}.spectrum-Tooltip--end-bottom #tip,.spectrum-Tooltip--end-top #tip,.spectrum-Tooltip--left-bottom #tip,.spectrum-Tooltip--left-top #tip,.spectrum-Tooltip--right-bottom #tip,.spectrum-Tooltip--right-top #tip,.spectrum-Tooltip--start-bottom #tip,.spectrum-Tooltip--start-top #tip{inset-block-start:auto;transform:none}.spectrum-Tooltip--end #tip,.spectrum-Tooltip--end-bottom #tip,.spectrum-Tooltip--end-top #tip,:host([placement*=right]) #tooltip #tip,.spectrum-Tooltip--right-bottom #tip,.spectrum-Tooltip--right-top #tip{clip-path:polygon(calc(100% - var(--mod-tooltip-tip-height-percentage,var(--spectrum-tooltip-tip-height-percentage)))50%,calc(100% + var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset)))100%,calc(100% + var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset)))0);inset-inline:auto 100%}:host([placement*=left]) #tooltip #tip,.spectrum-Tooltip--left-bottom #tip,.spectrum-Tooltip--left-top #tip,.spectrum-Tooltip--start #tip,.spectrum-Tooltip--start-bottom #tip,.spectrum-Tooltip--start-top #tip{clip-path:polygon(calc(0% - var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset)))0,calc(0% - var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset)))100%,var(--mod-tooltip-tip-height-percentage,var(--spectrum-tooltip-tip-height-percentage))50%);inset-inline-start:100%}.spectrum-Tooltip--end-top #tip,.spectrum-Tooltip--left-top #tip,.spectrum-Tooltip--right-top #tip,.spectrum-Tooltip--start-top #tip{inset-block-start:var(--mod-tooltip-pointer-corner-spacing,var(--spectrum-tooltip-pointer-corner-spacing))}.spectrum-Tooltip--end-bottom #tip,.spectrum-Tooltip--left-bottom #tip,.spectrum-Tooltip--right-bottom #tip,.spectrum-Tooltip--start-bottom #tip{inset-block-end:var(--mod-tooltip-pointer-corner-spacing,var(--spectrum-tooltip-pointer-corner-spacing))}.spectrum-Tooltip--end #tip:dir(rtl),.spectrum-Tooltip--end-bottom #tip:dir(rtl),.spectrum-Tooltip--end-top #tip:dir(rtl),:host([placement*=left]) #tooltip #tip:dir(rtl),.spectrum-Tooltip--left-bottom #tip:dir(rtl),.spectrum-Tooltip--left-top #tip:dir(rtl),:host([dir=rtl]) .spectrum-Tooltip--end #tip,:host([dir=rtl]) .spectrum-Tooltip--end-bottom #tip,:host([dir=rtl]) .spectrum-Tooltip--end-top #tip,:host([dir=rtl][placement*=left]) #tooltip #tip,:host([dir=rtl]) .spectrum-Tooltip--left-bottom #tip,:host([dir=rtl]) .spectrum-Tooltip--left-top #tip{clip-path:polygon(calc(0% - var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset)))0,calc(0% - var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset)))100%,var(--mod-tooltip-tip-height-percentage,var(--spectrum-tooltip-tip-height-percentage))50%);left:100%;right:auto}:host([placement*=right]) #tooltip #tip:dir(rtl),.spectrum-Tooltip--right-bottom #tip:dir(rtl),.spectrum-Tooltip--right-top #tip:dir(rtl),.spectrum-Tooltip--start #tip:dir(rtl),.spectrum-Tooltip--start-bottom #tip:dir(rtl),.spectrum-Tooltip--start-top #tip:dir(rtl),:host([dir=rtl][placement*=right]) #tooltip #tip,:host([dir=rtl]) .spectrum-Tooltip--right-bottom #tip,:host([dir=rtl]) .spectrum-Tooltip--right-top #tip,:host([dir=rtl]) .spectrum-Tooltip--start #tip,:host([dir=rtl]) .spectrum-Tooltip--start-bottom #tip,:host([dir=rtl]) .spectrum-Tooltip--start-top #tip{clip-path:polygon(var(--mod-tooltip-tip-height-percentage,var(--spectrum-tooltip-tip-height-percentage))50%,calc(100% + var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset)))100%,calc(100% + var(--mod-tooltip-tip-antialiasing-inset,var(--spectrum-tooltip-tip-antialiasing-inset)))0);left:auto;right:100%}::slotted([slot=icon]){inline-size:var(--mod-tooltip-icon-width,var(--spectrum-tooltip-icon-width));block-size:var(--mod-tooltip-icon-height,var(--spectrum-tooltip-icon-height));flex-shrink:0;align-self:flex-start;margin-block-start:var(--mod-tooltip-icon-spacing-block-start,var(--spectrum-tooltip-icon-spacing-block-start));margin-inline-start:calc(var(--mod-tooltip-icon-spacing-inline-start,var(--spectrum-tooltip-icon-spacing-inline-start)) - var(--mod-tooltip-spacing-inline,var(--spectrum-tooltip-spacing-inline)));margin-inline-end:var(--mod-tooltip-icon-spacing-inline-end,var(--spectrum-tooltip-icon-spacing-inline-end))}#label{line-height:var(--mod-tooltip-line-height,var(--spectrum-tooltip-line-height));margin-block-start:var(--mod-tooltip-spacing-block-start,var(--spectrum-tooltip-spacing-block-start));margin-block-end:var(--mod-tooltip-spacing-block-end,var(--spectrum-tooltip-spacing-block-end))}#tooltip,:host([placement*=top]) #tooltip,.spectrum-Tooltip--top-end,.spectrum-Tooltip--top-left,.spectrum-Tooltip--top-right,.spectrum-Tooltip--top-start{margin-block-end:calc(var(--mod-tooltip-tip-block-size,var(--spectrum-tooltip-tip-block-size)) + var(--mod-tooltip-margin,var(--spectrum-tooltip-margin)))}:host([open]) .spectrum-Tooltip--top-end,:host([open]) .spectrum-Tooltip--top-left,:host([open]) .spectrum-Tooltip--top-right,:host([open]) .spectrum-Tooltip--top-start,:host([placement*=top][open]) #tooltip,:host([open]) #tooltip{transform:translateY(calc(var(--mod-tooltip-animation-distance,var(--spectrum-tooltip-animation-distance))*-1))}:host([placement*=bottom]) #tooltip,.spectrum-Tooltip--bottom-end,.spectrum-Tooltip--bottom-left,.spectrum-Tooltip--bottom-right,.spectrum-Tooltip--bottom-start{margin-block-start:calc(var(--mod-tooltip-tip-block-size,var(--spectrum-tooltip-tip-block-size)) + var(--mod-tooltip-margin,var(--spectrum-tooltip-margin)))}:host([open]) .spectrum-Tooltip--bottom-end,:host([open]) .spectrum-Tooltip--bottom-left,:host([open]) .spectrum-Tooltip--bottom-right,:host([open]) .spectrum-Tooltip--bottom-start,:host([placement*=bottom][open]) #tooltip{transform:translateY(var(--mod-tooltip-animation-distance,var(--spectrum-tooltip-animation-distance)))}:host([placement*=right]) #tooltip,.spectrum-Tooltip--right-bottom,.spectrum-Tooltip--right-top{margin-left:calc(var(--mod-tooltip-tip-block-size,var(--spectrum-tooltip-tip-block-size)) + var(--mod-tooltip-margin,var(--spectrum-tooltip-margin)))}:host([open]) .spectrum-Tooltip--right-bottom,:host([open]) .spectrum-Tooltip--right-top,:host([placement*=right][open]) #tooltip{transform:translateX(var(--mod-tooltip-animation-distance,var(--spectrum-tooltip-animation-distance)))}:host([placement*=left]) #tooltip,.spectrum-Tooltip--left-bottom,.spectrum-Tooltip--left-top{margin-right:calc(var(--mod-tooltip-tip-block-size,var(--spectrum-tooltip-tip-block-size)) + var(--mod-tooltip-margin,var(--spectrum-tooltip-margin)))}:host([open]) .spectrum-Tooltip--left-bottom,:host([open]) .spectrum-Tooltip--left-top,:host([placement*=left][open]) #tooltip{transform:translateX(calc(var(--mod-tooltip-animation-distance,var(--spectrum-tooltip-animation-distance))*-1))}.spectrum-Tooltip--start,.spectrum-Tooltip--start-bottom,.spectrum-Tooltip--start-top{margin-inline-end:calc(var(--mod-tooltip-tip-block-size,var(--spectrum-tooltip-tip-block-size)) + var(--mod-tooltip-margin,var(--spectrum-tooltip-margin)))}:host([open]) .spectrum-Tooltip--start-bottom,:host([open]) .spectrum-Tooltip--start-top,:host([open]) .spectrum-Tooltip--start{transform:translateX(calc(var(--mod-tooltip-animation-distance,var(--spectrum-tooltip-animation-distance))*-1))}:host([open]) .spectrum-Tooltip--start-bottom:dir(rtl),:host([open]) .spectrum-Tooltip--start-top:dir(rtl),:host([open]) .spectrum-Tooltip--start:dir(rtl),:host([dir=rtl][open]) .spectrum-Tooltip--start-bottom,:host([dir=rtl][open]) .spectrum-Tooltip--start-top,:host([dir=rtl][open]) .spectrum-Tooltip--start{transform:translateX(var(--mod-tooltip-animation-distance,var(--spectrum-tooltip-animation-distance)))}.spectrum-Tooltip--end,.spectrum-Tooltip--end-bottom,.spectrum-Tooltip--end-top{margin-inline-start:calc(var(--mod-tooltip-tip-block-size,var(--spectrum-tooltip-tip-block-size)) + var(--mod-tooltip-margin,var(--spectrum-tooltip-margin)))}:host([open]) .spectrum-Tooltip--end-bottom,:host([open]) .spectrum-Tooltip--end-top,:host([open]) .spectrum-Tooltip--end{transform:translateX(var(--mod-tooltip-animation-distance,var(--spectrum-tooltip-animation-distance)))}:host([open]) .spectrum-Tooltip--end-bottom:dir(rtl),:host([open]) .spectrum-Tooltip--end-top:dir(rtl),:host([open]) .spectrum-Tooltip--end:dir(rtl),:host([dir=rtl][open]) .spectrum-Tooltip--end-bottom,:host([dir=rtl][open]) .spectrum-Tooltip--end-top,:host([dir=rtl][open]) .spectrum-Tooltip--end{transform:translateX(calc(var(--mod-tooltip-animation-distance,var(--spectrum-tooltip-animation-distance))*-1))}#tooltip{--spectrum-tooltip-backgound-color-default-neutral:var(--system-tooltip-backgound-color-default-neutral)}:host{display:contents}#tooltip{width:fit-content;white-space:initial;max-width:var(--spectrum-tooltip-max-inline-size)}#tip{clip-path:polygon(0 -5%,50% 50%,100% -5%);width:var(--spectrum-tooltip-tip-inline-size)!important;height:var(--spectrum-tooltip-tip-inline-size)!important}#tip[style]{transform:none!important}:host(:not([placement*=top])) #tooltip{margin-bottom:0}:host([placement*=top]) #tooltip #tip{inset-block-start:100%}:host([placement*=bottom]) #tooltip #tip{clip-path:polygon(50% 50%,0 105%,100% 105%);inset-block-end:100%;top:auto}:host([placement*=left]) #tooltip #tip,:host([placement*=right]) #tooltip #tip{inset-block-start:50%;transform:translateY(-50%)}:host([placement*=right]) #tooltip #tip{clip-path:polygon(50% 50%,105% 100%,105% 0);inset-inline:calc(var(--mod-tooltip-tip-block-size,var(--spectrum-tooltip-tip-block-size))*-2)100%}:host([placement*=left]) #tooltip #tip{clip-path:polygon(-5% 0,-5% 100%,50% 50%);inset-inline-start:100%}sp-overlay:not(:defined){display:none}
`;
var tooltip_css_default = o26;

// node_modules/@spectrum-web-components/tooltip/src/Tooltip.js
var c15 = Object.defineProperty;
var m11 = Object.getOwnPropertyDescriptor;
var o27 = (l16, s19, e36, t34) => {
  for (var n25 = t34 > 1 ? void 0 : t34 ? m11(s19, e36) : s19, i21 = l16.length - 1, r25; i21 >= 0; i21--) (r25 = l16[i21]) && (n25 = (t34 ? r25(s19, e36, n25) : r25(n25)) || n25);
  return t34 && n25 && c15(s19, e36, n25), n25;
};
var g4 = class extends HTMLElement {
  constructor() {
    super();
    this._open = false;
    this._placement = "top";
    this.addEventListener("sp-opened", this.redispatchEvent), this.addEventListener("sp-closed", this.redispatchEvent);
  }
  redispatchEvent(e36) {
    e36.stopPropagation(), this.tooltip.dispatchEvent(new CustomEvent(e36.type, { bubbles: e36.bubbles, composed: e36.composed, detail: e36.detail }));
  }
  get tooltip() {
    return this.getRootNode().host;
  }
  static get observedAttributes() {
    return ["open", "placement"];
  }
  attributeChangedCallback(e36, t34, n25) {
    switch (e36) {
      case "open":
        this.open = n25 !== null;
        break;
      case "placement":
        this.placement = n25;
        break;
    }
  }
  set open(e36) {
    this._open = e36;
    const { tooltip: t34 } = this;
    t34 && (t34.open = e36);
  }
  get open() {
    return this._open;
  }
  set placement(e36) {
    this._placement = e36;
    const { tooltip: t34 } = this;
    t34 && (t34.placement = e36);
  }
  get placement() {
    return this._placement;
  }
  get tipElement() {
    return this.tooltip.tipElement;
  }
};
customElements.get("sp-tooltip-openable") || customElements.define("sp-tooltip-openable", g4);
var Tooltip = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.delayed = false;
    this.dependencyManager = new DependencyManagerController(this);
    this.disabled = false;
    this.selfManaged = false;
    this.offset = 0;
    this.open = false;
    this._variant = "";
    this.handleOpenOverlay = () => {
      this.open = true;
    };
    this.handleCloseOverlay = () => {
      this.open = false;
    };
  }
  static get styles() {
    return [tooltip_css_default];
  }
  get variant() {
    return this._variant;
  }
  set variant(e36) {
    if (e36 !== this.variant) {
      if (["info", "positive", "negative"].includes(e36)) {
        this.setAttribute("variant", e36), this._variant = e36;
        return;
      }
      this.removeAttribute("variant"), this._variant = "";
    }
  }
  forwardTransitionEvent(e36) {
    this.dispatchEvent(new TransitionEvent(e36.type, { bubbles: true, composed: true, propertyName: e36.propertyName }));
  }
  get triggerElement() {
    var i21;
    let e36 = this.assignedSlot || this, t34 = e36.getRootNode();
    if (t34 === document) return null;
    let n25 = e36.parentElement || t34.host || t34;
    for (; !((i21 = n25 == null ? void 0 : n25.matches) != null && i21.call(n25, focusableSelector)); ) {
      if (e36 = n25.assignedSlot || n25, t34 = e36.getRootNode(), t34 === document) return null;
      n25 = e36.parentElement || t34.host || t34;
    }
    return n25;
  }
  render() {
    const e36 = x`
            <sp-tooltip-openable
                id="tooltip"
                placement=${o9(this.placement)}
                @transitionrun=${this.forwardTransitionEvent}
                @transitionend=${this.forwardTransitionEvent}
                @transitioncancel=${this.forwardTransitionEvent}
            >
                <slot name="icon"></slot>
                <span id="label"><slot></slot></span>
                <span id="tip" aria-hidden="true"></span>
            </sp-tooltip-openable>
        `;
    return this.selfManaged ? (this.dependencyManager.add("sp-overlay"), Promise.resolve().then(() => init_sp_overlay()), x`
                <sp-overlay
                    ?open=${this.open && !this.disabled && this.dependencyManager.loaded}
                    ?delayed=${this.delayed}
                    ?disabled=${this.disabled}
                    offset=${this.offset}
                    .placement=${this.placement}
                    type="hint"
                    .tipPadding=${this.tipPadding}
                    .triggerInteraction=${"hover"}
                    @sp-opened=${this.handleOpenOverlay}
                    @sp-closed=${this.handleCloseOverlay}
                >
                    ${e36}
                </sp-overlay>
            `) : e36;
  }
  connectedCallback() {
    super.connectedCallback(), this.updateComplete.then(() => {
      if (!this.selfManaged) return;
      const e36 = this.overlayElement;
      if (e36) {
        const t34 = this.triggerElement;
        e36.triggerElement = t34;
      }
    });
  }
};
o27([n4({ type: Boolean })], Tooltip.prototype, "delayed", 2), o27([n4({ type: Boolean })], Tooltip.prototype, "disabled", 2), o27([n4({ type: Boolean, attribute: "self-managed" })], Tooltip.prototype, "selfManaged", 2), o27([n4({ type: Number })], Tooltip.prototype, "offset", 2), o27([n4({ type: Boolean, reflect: true })], Tooltip.prototype, "open", 2), o27([e5("sp-overlay")], Tooltip.prototype, "overlayElement", 2), o27([n4({ reflect: true })], Tooltip.prototype, "placement", 2), o27([e5("#tip")], Tooltip.prototype, "tipElement", 2), o27([n4({ type: Number })], Tooltip.prototype, "tipPadding", 2), o27([n4({ type: String })], Tooltip.prototype, "variant", 1);

// node_modules/@spectrum-web-components/tooltip/sp-tooltip.js
init_define_element();
defineElement("sp-tooltip", Tooltip);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconColorHarmony.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ColorHarmony.js
var ColorHarmonyIcon = ({ width: t34 = 24, height: r25 = 24, hidden: e36 = false, title: l16 = "Color Harmony" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m15.75,2H4.25c-1.24023,0-2.25,1.00928-2.25,2.25v11.5c0,1.24072,1.00977,2.25,2.25,2.25h11.5c1.24023,0,2.25-1.00928,2.25-2.25V4.25c0-1.24072-1.00977-2.25-2.25-2.25Zm0,1.5c.41309,0,.75.33643.75.75v5h-5.75V3.5h5Zm-12.25.75c0-.41357.33691-.75.75-.75h5v5.75H3.5v-5Zm.75,12.25c-.41309,0-.75-.33643-.75-.75v-5h5.75v5.75h-5Zm12.25-.75c0,.41357-.33691.75-.75.75h-5v-5.75h5.75v5Z"
      fill="currentColor"
    />
    <rect
      x="10.0687"
      y="3.11436"
      width="6.95914"
      height="6.69751"
      fill="currentColor"
      opacity=".5"
    />
    <rect
      x="10.0687"
      y="10.11436"
      width="6.95914"
      height="6.69751"
      fill="currentColor"
      opacity=".12"
    />
    <rect
      x="3.0687"
      y="10.11436"
      width="6.95914"
      height="6.69751"
      fill="currentColor"
      opacity=".3"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/DefaultIcon.js
var DefaultIcon = ({ width: e36 = 24, height: l16 = 24, hidden: t34 = false, title: r25 = "Default" } = {}) => tag`
        <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            role="img"
            fill="currentColor"
            width=${e36}
            height=${l16}
            aria-hidden=${t34 ? "true" : "false"}
            aria-label=${t34 ? void 0 : r25}
        >
            <path
                d="m10,18.75c-4.82471,0-8.75-3.9248-8.75-8.75S5.17529,1.25,10,1.25s8.75,3.9248,8.75,8.75-3.92529,8.75-8.75,8.75Zm0-16c-3.99756,0-7.25,3.25195-7.25,7.25s3.25244,7.25,7.25,7.25,7.25-3.25195,7.25-7.25-3.25244-7.25-7.25-7.25Z"
                fill="currentColor"
                stroke-width="0"
            ></path>
        </svg>
    `;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconColorHarmony.js
var IconColorHarmony = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ColorHarmonyIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-color-harmony.js
init_define_element();
defineElement("sp-icon-color-harmony", IconColorHarmony);

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "\xB0",
      "ja-JP": " \u5EA6",
      "zh-TW": "\u5EA6",
      "sl-SI": " \xB0"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} \u2013 ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p30) => ({
        ...p30,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " \u2013 ",
        source: "shared"
      },
      ...endParts.map((p30) => ({
        ...p30,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a23, b12) => a23[0] < b12[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng",
  "fullwide"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a23, b12) => a23[0] < b12[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      fullySanitizedValue = fullySanitizedValue.replace("+", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.symbols.group === "\u2019" && value.includes("'")) value = $6c7bd7858deea686$var$replaceAll(value, "'", this.symbols.group);
    if (this.options.locale === "fr-FR" && this.symbols.group) {
      value = $6c7bd7858deea686$var$replaceAll(value, " ", this.symbols.group);
      value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
    }
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    if (options.roundingIncrement !== 1 && options.roundingIncrement != null) {
      if (options.maximumFractionDigits == null && options.minimumFractionDigits == null) {
        options.maximumFractionDigits = 0;
        options.minimumFractionDigits = 0;
      } else if (options.maximumFractionDigits == null) options.maximumFractionDigits = options.minimumFractionDigits;
      else if (options.minimumFractionDigits == null) options.minimumFractionDigits = options.maximumFractionDigits;
    }
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n25) => symbolFormatter.formatToParts(n25));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p30) => p30.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p30) => p30.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p30) => p30.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group = (_allParts_find1 = allParts.find((p30) => p30.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p30) => !$6c7bd7858deea686$var$nonLiteralParts.has(p30.type)).map((p30) => $6c7bd7858deea686$var$escapeRegex(p30.value));
  let pluralPartsLiterals = pluralParts.flatMap((p30) => p30.filter((p31) => !$6c7bd7858deea686$var$nonLiteralParts.has(p31.type)).map((p31) => $6c7bd7858deea686$var$escapeRegex(p31.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a23, b12) => b12.length - a23.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d22, i21) => [
    d22,
    i21
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d22) => String(indexes.get(d22));
  return {
    minusSign,
    plusSign,
    decimal,
    group,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace2) {
  if (str.replaceAll) return str.replaceAll(find, replace2);
  return str.split(find).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@spectrum-web-components/number-field/src/NumberField.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/base/src/streaming-listener.js
init_lit();

// node_modules/lit/async-directive.js
init_async_directive();

// node_modules/@spectrum-web-components/base/src/streaming-listener.js
var i12 = ["", () => {
}];
var m12 = class extends f4 {
  constructor() {
    super(...arguments);
    this.start = i12;
    this.streamInside = i12;
    this.end = i12;
    this.streamOutside = i12;
    this.state = "off";
    this.handleStart = (e36) => {
      this.clearStream(), this.callHandler(this.start[1], e36), !e36.defaultPrevented && (this.removeListeners(), this.addListeners("on"));
    };
    this.handleInside = (e36) => {
      this.handleStream(this.streamInside[1], e36);
    };
    this.handleEnd = (e36) => {
      this.clearStream(), this.callHandler(this.end[1], e36), this.removeListeners(), this.addListeners("off");
    };
    this.handleOutside = (e36) => {
      this.handleStream(this.streamOutside[1], e36);
    };
  }
  render(e36) {
    return E;
  }
  update(e36, [{ start: t34, end: s19, streamInside: r25 = i12, streamOutside: d22 = i12 }]) {
    var n25;
    this.element !== e36.element && (this.element = e36.element, this.removeListeners()), this.host = ((n25 = e36.options) == null ? void 0 : n25.host) || this.element, this.start = t34, this.end = s19, this.streamInside = r25, this.streamOutside = d22, this.addListeners();
  }
  addListeners(e36) {
    this.state = e36 || this.state, this.state === "off" ? (this.addListener(this.streamOutside[0], this.handleOutside), this.addListener(this.start[0], this.handleStart)) : this.state === "on" && (this.addListener(this.streamInside[0], this.handleInside), this.addListener(this.end[0], this.handleEnd));
  }
  callHandler(e36, t34) {
    typeof e36 == "function" ? e36.call(this.host, t34) : e36.handleEvent(t34);
  }
  handleStream(e36, t34) {
    this.stream || (this.callHandler(e36, t34), this.stream = requestAnimationFrame(() => {
      this.stream = void 0;
    }));
  }
  clearStream() {
    this.stream != null && (cancelAnimationFrame(this.stream), this.stream = void 0);
  }
  addListener(e36, t34) {
    Array.isArray(e36) ? e36.map((s19) => {
      this.element.addEventListener(s19, t34);
    }) : this.element.addEventListener(e36, t34);
  }
  removeListener(e36, t34) {
    Array.isArray(e36) ? e36.map((s19) => {
      this.element.removeEventListener(s19, t34);
    }) : this.element.removeEventListener(e36, t34);
  }
  removeListeners() {
    this.removeListener(this.start[0], this.handleStart), this.removeListener(this.streamInside[0], this.handleInside), this.removeListener(this.end[0], this.handleEnd), this.removeListener(this.streamOutside[0], this.handleOutside);
  }
  disconnected() {
    this.removeListeners();
  }
  reconnected() {
    this.addListeners();
  }
};
var streamingListener = e9(m12);

// node_modules/@spectrum-web-components/reactive-controllers/src/LanguageResolution.js
var languageResolverUpdatedSymbol = Symbol("language resolver updated");
var LanguageResolutionController = class {
  constructor(e36) {
    this.language = document.documentElement.lang || navigator.language || "en-US";
    this.host = e36, this.host.addController(this);
  }
  hostConnected() {
    this.resolveLanguage();
  }
  hostDisconnected() {
    var e36;
    (e36 = this.unsubscribe) == null || e36.call(this);
  }
  resolveLanguage() {
    try {
      Intl.DateTimeFormat.supportedLocalesOf([this.language]);
    } catch (t34) {
      this.language = "en-US";
    }
    const e36 = new CustomEvent("sp-language-context", { bubbles: true, composed: true, detail: { callback: (t34, o52) => {
      const a23 = this.language;
      this.language = t34, this.unsubscribe = o52, this.host.requestUpdate(languageResolverUpdatedSymbol, a23);
    } }, cancelable: true });
    this.host.dispatchEvent(e36);
  }
};

// node_modules/@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js
init_src();
var r10 = i`
    .spectrum-UIIcon-ChevronRight50{--spectrum-icon-size:var(--spectrum-chevron-icon-size-50)}.spectrum-UIIcon-ChevronRight75{--spectrum-icon-size:var(--spectrum-chevron-icon-size-75)}.spectrum-UIIcon-ChevronRight100{--spectrum-icon-size:var(--spectrum-chevron-icon-size-100)}.spectrum-UIIcon-ChevronRight200{--spectrum-icon-size:var(--spectrum-chevron-icon-size-200)}.spectrum-UIIcon-ChevronRight300{--spectrum-icon-size:var(--spectrum-chevron-icon-size-300)}.spectrum-UIIcon-ChevronRight400{--spectrum-icon-size:var(--spectrum-chevron-icon-size-400)}.spectrum-UIIcon-ChevronRight500{--spectrum-icon-size:var(--spectrum-chevron-icon-size-500)}.spectrum-UIIcon-ChevronDown50{--spectrum-icon-size:var(--spectrum-chevron-icon-size-50);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown75{--spectrum-icon-size:var(--spectrum-chevron-icon-size-75);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown100{--spectrum-icon-size:var(--spectrum-chevron-icon-size-100);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown200{--spectrum-icon-size:var(--spectrum-chevron-icon-size-200);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown300{--spectrum-icon-size:var(--spectrum-chevron-icon-size-300);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown400{--spectrum-icon-size:var(--spectrum-chevron-icon-size-400);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown500{--spectrum-icon-size:var(--spectrum-chevron-icon-size-500);transform:rotate(90deg)}.spectrum-UIIcon-ChevronLeft50{--spectrum-icon-size:var(--spectrum-chevron-icon-size-50);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft75{--spectrum-icon-size:var(--spectrum-chevron-icon-size-75);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft100{--spectrum-icon-size:var(--spectrum-chevron-icon-size-100);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft200{--spectrum-icon-size:var(--spectrum-chevron-icon-size-200);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft300{--spectrum-icon-size:var(--spectrum-chevron-icon-size-300);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft400{--spectrum-icon-size:var(--spectrum-chevron-icon-size-400);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft500{--spectrum-icon-size:var(--spectrum-chevron-icon-size-500);transform:rotate(180deg)}.spectrum-UIIcon-ChevronUp50{--spectrum-icon-size:var(--spectrum-chevron-icon-size-50);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp75{--spectrum-icon-size:var(--spectrum-chevron-icon-size-75);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp100{--spectrum-icon-size:var(--spectrum-chevron-icon-size-100);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp200{--spectrum-icon-size:var(--spectrum-chevron-icon-size-200);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp300{--spectrum-icon-size:var(--spectrum-chevron-icon-size-300);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp400{--spectrum-icon-size:var(--spectrum-chevron-icon-size-400);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp500{--spectrum-icon-size:var(--spectrum-chevron-icon-size-500);transform:rotate(270deg)}
`;
var spectrum_icon_chevron_css_default = r10;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconChevron100.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Chevron100.js
var Chevron100Icon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Chevron100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M3 9.95a.875.875 0 0 1-.615-1.498L5.88 5 2.385 1.547A.875.875 0 0 1 3.615.302L7.74 4.377a.876.876 0 0 1 0 1.246L3.615 9.698A.87.87 0 0 1 3 9.95"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Chevron100.js
var Chevron100Icon2 = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Chevron100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M3 9.95a.875.875 0 0 1-.615-1.498L5.88 5 2.385 1.547A.875.875 0 0 1 3.615.302L7.74 4.377a.876.876 0 0 1 0 1.246L3.615 9.698A.87.87 0 0 1 3 9.95"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconChevron100.js
var IconChevron100 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Chevron100Icon({ hidden: !this.label, title: this.label }) : Chevron100Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js
init_define_element();
defineElement("sp-icon-chevron100", IconChevron100);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconChevron200.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Chevron200.js
var Chevron200Icon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Chevron200" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M9.034 5.356 4.343.663a.911.911 0 0 0-1.29 1.289L7.102 6l-4.047 4.047a.911.911 0 1 0 1.289 1.29l4.691-4.692a.91.91 0 0 0 0-1.29z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Chevron200.js
var Chevron200Icon2 = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Chevron200" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M9.034 5.356 4.343.663a.911.911 0 0 0-1.29 1.289L7.102 6l-4.047 4.047a.911.911 0 1 0 1.289 1.29l4.691-4.692a.91.91 0 0 0 0-1.29z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconChevron200.js
var IconChevron200 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Chevron200Icon({ hidden: !this.label, title: this.label }) : Chevron200Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-chevron200.js
init_define_element();
defineElement("sp-icon-chevron200", IconChevron200);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconChevron50.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Chevron50.js
var Chevron50Icon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Chevron50" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M1.985 5.961a.695.695 0 0 1-.7-.704.7.7 0 0 1 .209-.493L3.279 3 1.51 1.251A.7.7 0 0 1 1.3.757.696.696 0 0 1 2.492.255l2.275 2.247a.7.7 0 0 1 0 .996L2.477 5.76a.7.7 0 0 1-.492.201"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Chevron50.js
var Chevron50Icon2 = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Chevron50" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M1.985 5.961a.695.695 0 0 1-.7-.704.7.7 0 0 1 .209-.493L3.279 3 1.51 1.251A.7.7 0 0 1 1.3.757.696.696 0 0 1 2.492.255l2.275 2.247a.7.7 0 0 1 0 .996L2.477 5.76a.7.7 0 0 1-.492.201"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconChevron50.js
var IconChevron50 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Chevron50Icon({ hidden: !this.label, title: this.label }) : Chevron50Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-chevron50.js
init_define_element();
defineElement("sp-icon-chevron50", IconChevron50);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconChevron75.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Chevron75.js
var Chevron75Icon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: l16 = "Chevron75" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="m7.482 4.406-.001-.001L3.86.783a.84.84 0 0 0-1.188 1.188L5.702 5l-3.03 3.03A.84.84 0 0 0 3.86 9.216l3.621-3.622h.001a.84.84 0 0 0 0-1.19z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Chevron75.js
var Chevron75Icon2 = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: l16 = "Chevron75" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="m7.482 4.406-.001-.001L3.86.783a.84.84 0 0 0-1.188 1.188L5.702 5l-3.03 3.03A.84.84 0 0 0 3.86 9.216l3.621-3.622h.001a.84.84 0 0 0 0-1.19z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconChevron75.js
var IconChevron75 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Chevron75Icon({ hidden: !this.label, title: this.label }) : Chevron75Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-chevron75.js
init_define_element();
defineElement("sp-icon-chevron75", IconChevron75);

// node_modules/@spectrum-web-components/infield-button/src/InfieldButton.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/infield-button/src/infield-button.css.js
init_src();
var o28 = i`
    :host{--spectrum-infield-button-height:var(--spectrum-component-height-100);--spectrum-infield-button-width:var(--spectrum-component-height-100);--spectrum-infield-button-stacked-border-radius-reset:var(--spectrum-in-field-button-fill-stacked-inner-border-rounding);--spectrum-infield-button-edge-to-fill:var(--spectrum-in-field-button-edge-to-fill);--spectrum-infield-button-inner-edge-to-fill:var(--spectrum-in-field-button-stacked-inner-edge-to-fill);--spectrum-infield-button-fill-padding:0px;--spectrum-infield-button-stacked-fill-padding-inline:var(--spectrum-in-field-button-edge-to-disclosure-icon-stacked-medium);--spectrum-infield-button-stacked-fill-padding-outer:var(--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-medium);--spectrum-infield-button-stacked-fill-padding-inner:var(--spectrum-in-field-button-inner-edge-to-disclosure-icon-stacked-medium);--spectrum-infield-button-icon-color:var(--spectrum-neutral-content-color-default);--spectrum-infield-button-icon-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-infield-button-icon-color-down:var(--spectrum-neutral-content-color-down);--spectrum-infield-button-icon-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-infield-button-fill-justify-content:center}:host([disabled]){--mod-infield-button-background-color:var(--mod-infield-button-background-color-disabled,var(--spectrum-disabled-background-color));--mod-infield-button-background-color-hover:var(--mod-infield-button-background-color-hover-disabled,var(--spectrum-disabled-background-color));--mod-infield-button-background-color-down:var(--mod-infield-button-background-color-down-disabled,var(--spectrum-disabled-background-color));--mod-infield-button-border-color:var(--mod-infield-button-border-color-disabled,var(--spectrum-infield-button-border-color));--mod-infield-button-icon-color:var(--mod-infield-button-icon-color-disabled,var(--spectrum-disabled-content-color));--mod-infield-button-icon-color-hover:var(--mod-infield-button-icon-color-hover-disabled,var(--spectrum-disabled-content-color));--mod-infield-button-icon-color-down:var(--mod-infield-button-icon-color-down-disabled,var(--spectrum-disabled-content-color));--mod-infield-button-icon-color-key-focus:var(--mod-infield-button-icon-color-key-focus-disabled,var(--spectrum-disabled-content-color))}:host([size=s]){--spectrum-infield-button-height:var(--spectrum-component-height-75);--spectrum-infield-button-width:var(--spectrum-component-height-75);--spectrum-infield-button-stacked-fill-padding-inline:var(--spectrum-in-field-button-edge-to-disclosure-icon-stacked-small);--spectrum-infield-button-stacked-fill-padding-outer:var(--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-small);--spectrum-infield-button-stacked-fill-padding-inner:var(--spectrum-in-field-button-inner-edge-to-disclosure-icon-stacked-small)}:host([size=l]){--spectrum-infield-button-height:var(--spectrum-component-height-200);--spectrum-infield-button-width:var(--spectrum-component-height-200);--spectrum-infield-button-stacked-fill-padding-inline:var(--spectrum-in-field-button-edge-to-disclosure-icon-stacked-large);--spectrum-infield-button-stacked-fill-padding-outer:var(--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-large);--spectrum-infield-button-stacked-fill-padding-inner:var(--spectrum-in-field-button-inner-edge-to-disclosure-icon-stacked-large)}:host([size=xl]){--spectrum-infield-button-height:var(--spectrum-component-height-300);--spectrum-infield-button-width:var(--spectrum-component-height-300);--spectrum-infield-button-stacked-fill-padding-inline:var(--spectrum-in-field-button-edge-to-disclosure-icon-stacked-extra-large);--spectrum-infield-button-stacked-fill-padding-outer:var(--spectrum-in-field-button-outer-edge-to-disclosure-icon-stacked-extra-large);--spectrum-infield-button-stacked-fill-padding-inner:var(--spectrum-in-field-button-inner-edge-to-disclosure-icon-stacked-extra-large)}:host([block=end]),:host([block=start]){--mod-infield-button-width:var(--mod-infield-button-width-stacked,var(--spectrum-in-field-button-width-stacked-medium))}:host([block=end][size=s]),:host([block=start][size=s]){--mod-infield-button-width:var(--mod-infield-button-width-stacked,var(--spectrum-in-field-button-width-stacked-small))}:host([block=end][size=l]),:host([block=start][size=l]){--mod-infield-button-width:var(--mod-infield-button-width-stacked,var(--spectrum-in-field-button-width-stacked-large))}:host([block=end][size=xl]),:host([block=start][size=xl]){--mod-infield-button-width:var(--mod-infield-button-width-stacked,var(--spectrum-in-field-button-width-stacked-extra-large))}:host([quiet]){--mod-infield-button-background-color:var(--mod-infield-button-background-color-quiet,transparent);--mod-infield-button-background-color-hover:var(--mod-infield-button-background-color-hover-quiet,transparent);--mod-infield-button-background-color-down:var(--mod-infield-button-background-color-down-quiet,transparent);--mod-infield-button-background-color-key-focus:var(--mod-infield-button-background-color-key-focus-quiet,transparent);--mod-infield-border-color:var(--mod-infield-border-color-quiet,transparent);--mod-infield-button-border-width:var(--mod-infield-button-border-width-quiet,0)}:host([quiet][disabled]){--mod-infield-button-background-color:var(--mod-infield-button-background-color-quiet-disabled,transparent);--mod-infield-button-border-color:var(--mod-infield-button-border-color-quiet-disabled,transparent)}@media (hover:hover){:host(:hover){--mod-infield-button-background-color:var(--mod-infield-button-background-color-hover,var(--spectrum-infield-button-background-color-hover));--mod-infield-button-icon-color:var(--mod-infield-button-icon-color-hover,var(--spectrum-infield-button-icon-color-hover))}}:host(:is(:active,[active])){--mod-infield-button-background-color:var(--mod-infield-button-background-color-down,var(--spectrum-infield-button-background-color-down));--mod-infield-button-icon-color:var(--mod-infield-button-icon-color-down,var(--spectrum-infield-button-icon-color-down))}:host(:focus-visible){--mod-infield-button-background-color:var(--mod-infield-button-background-color-key-focus,var(--spectrum-infield-button-background-color-key-focus));--mod-infield-button-icon-color:var(--mod-infield-button-icon-color-key-focus,var(--spectrum-infield-button-icon-color-key-focus))}@media (forced-colors:active){:host{--highcontrast-infield-button-border-color:ButtonText;--highcontrast-infield-button-border-color-active:Highlight}:host([disabled]){--highcontrast-infield-button-border-color:inherit}:host(:is(:active,[active])):not(:disabled),:host:not(:disabled):focus-visible{--highcontrast-infield-button-border-color:var(--highcontrast-infield-button-border-color-active)}@media (hover:hover){:host:not(:disabled):hover{--highcontrast-infield-button-border-color:var(--highcontrast-infield-button-border-color-active)}}}:host{background-color:initial;cursor:pointer;block-size:var(--mod-infield-button-height,var(--spectrum-infield-button-height));inline-size:var(--mod-infield-button-width,var(--spectrum-infield-button-width));padding:var(--mod-infield-button-edge-to-fill,var(--spectrum-infield-button-edge-to-fill));border-style:none;justify-content:center;align-items:center;display:flex}:host([disabled]){cursor:auto}:host(:focus-visible){outline:none}:host([block=end]),:host([block=start]){block-size:calc(var(--mod-infield-button-height,var(--spectrum-infield-button-height))/2)}:host([block=start]){padding-block-end:var(--mod-infield-button-inner-edge-to-fill,var(--spectrum-infield-button-inner-edge-to-fill))}:host([block=end]){padding-block-start:var(--mod-infield-button-inner-edge-to-fill,var(--spectrum-infield-button-inner-edge-to-fill))}.fill{background-color:var(--mod-infield-button-background-color,var(--spectrum-infield-button-background-color));border-width:var(--mod-infield-button-border-width,var(--spectrum-infield-button-border-width));border-style:solid;border-color:var(--highcontrast-infield-button-border-color,var(--mod-infield-button-border-color,var(--spectrum-infield-button-border-color)));block-size:100%;inline-size:100%;padding:var(--mod-infield-button-fill-padding,var(--spectrum-infield-button-fill-padding));align-items:center;justify-content:var(--mod-infield-button-fill-justify-content,var(--spectrum-infield-button-fill-justify-content));transition:border-color var(--spectrum-animation-duration-100)ease-in-out;border-start-start-radius:var(--mod-infield-button-border-radius,var(--spectrum-infield-button-border-radius));border-start-end-radius:var(--mod-infield-button-border-radius,var(--spectrum-infield-button-border-radius));border-end-end-radius:var(--mod-infield-button-border-radius,var(--spectrum-infield-button-border-radius));border-end-start-radius:var(--mod-infield-button-border-radius,var(--spectrum-infield-button-border-radius));display:flex}:host([inline=end]) .fill{border-start-start-radius:var(--mod-infield-button-border-radius-reset,var(--spectrum-infield-button-border-radius-reset));border-end-start-radius:var(--mod-infield-button-border-radius-reset,var(--spectrum-infield-button-border-radius-reset))}:host([inline=start]) .fill{border-start-end-radius:var(--mod-infield-button-border-radius-reset,var(--spectrum-infield-button-border-radius-reset));border-end-end-radius:var(--mod-infield-button-border-radius-reset,var(--spectrum-infield-button-border-radius-reset))}:host([block=end]) .fill,:host([block=start]) .fill{box-sizing:border-box;padding-inline-start:calc(var(--mod-infield-button-stacked-fill-padding-inline,var(--spectrum-infield-button-stacked-fill-padding-inline)) - var(--mod-infield-button-edge-to-fill,var(--spectrum-infield-button-edge-to-fill)) - var(--mod-infield-button-border-width,var(--spectrum-infield-button-border-width)));padding-inline-end:calc(var(--mod-infield-button-stacked-fill-padding-inline,var(--spectrum-infield-button-stacked-fill-padding-inline)) - var(--mod-infield-button-edge-to-fill,var(--spectrum-infield-button-edge-to-fill)) - var(--mod-infield-button-border-width,var(--spectrum-infield-button-border-width)))}:host([block=start]) .fill{border-block-end:none;border-start-start-radius:var(--mod-infield-button-stacked-top-border-radius-start-start,var(--spectrum-infield-button-stacked-top-border-radius-start-start));border-end-end-radius:var(--mod-infield-button-stacked-border-radius-reset,var(--spectrum-infield-button-stacked-border-radius-reset));border-end-start-radius:var(--mod-infield-button-stacked-border-radius-reset,var(--spectrum-infield-button-stacked-border-radius-reset));padding-block-start:calc(var(--mod-infield-button-stacked-fill-padding-outer,var(--spectrum-infield-button-stacked-fill-padding-outer)) - var(--mod-infield-button-edge-to-fill,var(--spectrum-infield-button-edge-to-fill)) - var(--mod-infield-button-border-width,var(--spectrum-infield-button-border-width)));padding-block-end:calc(var(--mod-infield-button-stacked-fill-padding-inner,var(--spectrum-infield-button-stacked-fill-padding-inner)) - var(--mod-infield-button-inner-edge-to-fill,var(--spectrum-infield-button-inner-edge-to-fill)))}:host([block=end]) .fill{border-block-end-width:var(--mod-infield-button-stacked-bottom-border-block-end-width,var(--mod-infield-button-border-width,var(--spectrum-infield-button-border-width)));border-start-start-radius:var(--mod-infield-button-stacked-border-radius-reset,var(--spectrum-infield-button-stacked-border-radius-reset));border-start-end-radius:var(--mod-infield-button-stacked-border-radius-reset,var(--spectrum-infield-button-stacked-border-radius-reset));border-end-end-radius:var(--mod-infield-button-stacked-bottom-border-radius-end-end,var(--mod-infield-button-border-radius,var(--spectrum-infield-button-border-radius)));border-end-start-radius:var(--mod-infield-button-stacked-bottom-border-radius-end-start,var(--spectrum-infield-button-stacked-bottom-border-radius-end-start));padding-block-start:calc(var(--mod-infield-button-stacked-fill-padding-inner,var(--spectrum-infield-button-stacked-fill-padding-inner)) - var(--mod-infield-button-edge-to-fill,var(--spectrum-infield-button-edge-to-fill)) - var(--mod-infield-button-border-width,var(--spectrum-infield-button-border-width)));padding-block-end:calc(var(--mod-infield-button-stacked-fill-padding-outer,var(--spectrum-infield-button-stacked-fill-padding-outer)) - var(--mod-infield-button-inner-edge-to-fill,var(--spectrum-infield-button-inner-edge-to-fill)) - var(--mod-infield-button-border-width,var(--spectrum-infield-button-border-width)))}::slotted(*){display:initial;color:var(--mod-infield-button-icon-color,var(--spectrum-infield-button-icon-color));flex-shrink:0;margin:0!important}:host{--spectrum-infield-button-border-width:var(--system-infield-button-border-width);--spectrum-infield-button-border-color:var(--system-infield-button-border-color);--spectrum-infield-button-border-radius:var(--system-infield-button-border-radius);--spectrum-infield-button-border-radius-reset:var(--system-infield-button-border-radius-reset);--spectrum-infield-button-stacked-top-border-radius-start-start:var(--system-infield-button-stacked-top-border-radius-start-start);--spectrum-infield-button-stacked-bottom-border-radius-end-start:var(--system-infield-button-stacked-bottom-border-radius-end-start);--spectrum-infield-button-background-color:var(--system-infield-button-background-color);--spectrum-infield-button-background-color-hover:var(--system-infield-button-background-color-hover);--spectrum-infield-button-background-color-down:var(--system-infield-button-background-color-down);--spectrum-infield-button-background-color-key-focus:var(--system-infield-button-background-color-key-focus)}:host([disabled]){--spectrum-infield-button-border-color:var(--system-infield-button-disabled-border-color)}:host{box-sizing:border-box;user-select:none}::slotted(*){--spectrum-icon-size:inherit}
`;
var infield_button_css_default = o28;

// node_modules/@spectrum-web-components/infield-button/src/InfieldButton.js
var u15 = Object.defineProperty;
var p10 = Object.getOwnPropertyDescriptor;
var o29 = (l16, e36, r25, s19) => {
  for (var t34 = s19 > 1 ? void 0 : s19 ? p10(e36, r25) : e36, i21 = l16.length - 1, n25; i21 >= 0; i21--) (n25 = l16[i21]) && (t34 = (s19 ? n25(e36, r25, t34) : n25(t34)) || t34);
  return s19 && t34 && u15(e36, r25, t34), t34;
};
var InfieldButton = class extends SizedMixin(ButtonBase, { noDefaultSize: true, validSizes: ["s", "m", "l", "xl"] }) {
  constructor() {
    super(...arguments);
    this.quiet = false;
  }
  static get styles() {
    return [...super.styles, infield_button_css_default];
  }
  get buttonContent() {
    return [x`
            <div class="fill">
                <slot></slot>
            </div>
        `];
  }
};
o29([n4()], InfieldButton.prototype, "block", 2), o29([n4()], InfieldButton.prototype, "inline", 2), o29([n4({ type: Boolean, reflect: true })], InfieldButton.prototype, "quiet", 2);

// node_modules/@spectrum-web-components/infield-button/sp-infield-button.js
customElements.define("sp-infield-button", InfieldButton);

// node_modules/@spectrum-web-components/textfield/src/Textfield.js
init_src();
init_directives();
init_decorators2();

// node_modules/@spectrum-web-components/help-text/src/HelpTextManager.js
init_src();
init_directives();
init_condition_attribute_with_id();
init_random_id();
var HelpTextManager = class {
  constructor(e36, { mode: i21 } = { mode: "internal" }) {
    this.mode = "internal";
    this.handleSlotchange = ({ target: e37 }) => {
      this.handleHelpText(e37), this.handleNegativeHelpText(e37);
    };
    this.host = e36, this.id = `sp-help-text-${randomID()}`, this.mode = i21;
  }
  get isInternal() {
    return this.mode === "internal";
  }
  render(e36) {
    return x`
            <div
                id=${o9(this.isInternal ? this.id : void 0)}
                aria-live="assertive"
            >
                <slot
                    name=${e36 ? "negative-help-text" : `pass-through-help-text-${randomID()}`}
                    @slotchange=${this.handleSlotchange}
                >
                    <slot name="help-text"></slot>
                </slot>
            </div>
        `;
  }
  addId() {
    const e36 = this.helpTextElement ? this.helpTextElement.id : this.id;
    this.conditionId = conditionAttributeWithId(this.host, "aria-describedby", e36), this.host.hasAttribute("tabindex") && (this.previousTabindex = parseFloat(this.host.getAttribute("tabindex"))), this.host.tabIndex = 0;
  }
  removeId() {
    this.conditionId && (this.conditionId(), delete this.conditionId), !this.helpTextElement && (this.previousTabindex ? this.host.tabIndex = this.previousTabindex : this.host.removeAttribute("tabindex"));
  }
  handleHelpText(e36) {
    if (this.isInternal) return;
    this.helpTextElement && this.helpTextElement.id === this.id && this.helpTextElement.removeAttribute("id"), this.removeId();
    const t34 = e36.assignedElements()[0];
    this.helpTextElement = t34, t34 && (t34.id || (t34.id = this.id), this.addId());
  }
  handleNegativeHelpText(e36) {
    if (e36.name !== "negative-help-text") return;
    e36.assignedElements().forEach((t34) => t34.variant = "negative");
  }
};

// node_modules/@spectrum-web-components/help-text/src/manage-help-text.js
function ManageHelpText(e36, { mode: t34 } = { mode: "internal" }) {
  class n25 extends e36 {
    constructor() {
      super(...arguments);
      this.helpTextManager = new HelpTextManager(this, { mode: t34 });
    }
    get helpTextId() {
      return this.helpTextManager.id;
    }
    renderHelpText(r25) {
      return this.helpTextManager.render(r25);
    }
  }
  return n25;
}

// node_modules/@spectrum-web-components/textfield/src/Textfield.js
init_focusable();

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCheckmark100.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Checkmark100.js
var Checkmark100Icon = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: l16 = "Checkmark100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M3.5 9.5a1 1 0 0 1-.774-.368l-2.45-3a1 1 0 1 1 1.548-1.264l1.657 2.028 4.68-6.01A1 1 0 0 1 9.74 2.114l-5.45 7a1 1 0 0 1-.777.386z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Checkmark100.js
var Checkmark100Icon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: l16 = "Checkmark100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M3.5 9.5a1 1 0 0 1-.774-.368l-2.45-3a1 1 0 1 1 1.548-1.264l1.657 2.028 4.68-6.01A1 1 0 0 1 9.74 2.114l-5.45 7a1 1 0 0 1-.777.386z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCheckmark100.js
var IconCheckmark100 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Checkmark100Icon({ hidden: !this.label, title: this.label }) : Checkmark100Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-checkmark100.js
init_define_element();
defineElement("sp-icon-checkmark100", IconCheckmark100);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconAlert.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Alert.js
var AlertIcon = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Alert" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M17.127 2.579.4 32.512A1 1 0 0 0 1.272 34h33.456a1 1 0 0 0 .872-1.488L18.873 2.579a1 1 0 0 0-1.746 0ZM20 29.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5Zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-12a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/AlertTriangle.js
var AlertTriangleIcon = ({ width: l16 = 24, height: r25 = 24, hidden: t34 = false, title: e36 = "Alert Triangle" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="m9.99936,15.12334c-.23065.00812-.45538-.07378-.62661-.22835-.33033-.36462-.33033-.91993,0-1.28455.16935-.15832.39483-.24279.62664-.23476.23635-.00947.46589.08026.63302.24745.16207.1677.24916.39386.24137.62681.01238.23469-.06959.4646-.2277.63864-.17358.16455-.40786.24959-.64671.23475Z"
      fill="currentColor"
    />
    <path
      d="m10,11.75c-.41406,0-.75-.33594-.75-.75v-4c0-.41406.33594-.75.75-.75s.75.33594.75.75v4c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m16.7334,18H3.2666c-.80029,0-1.52295-.41016-1.93262-1.09766s-.42725-1.51855-.04639-2.22266L8.021,2.23242c.39355-.72754,1.15186-1.17969,1.979-1.17969s1.58545.45215,1.979,1.17969l6.7334,12.44727c.38086.7041.36328,1.53516-.04639,2.22266s-1.13232,1.09766-1.93262,1.09766ZM10,2.55273c-.13428,0-.46777.03809-.65967.39258L2.60693,15.39258c-.18311.33887-.05029.63184.01562.74121.06543.11035.25928.36621.64404.36621h13.4668c.38477,0,.57861-.25586.64404-.36621.06592-.10938.19873-.40234.01562-.74121L10.65967,2.94531c-.19189-.35449-.52539-.39258-.65967-.39258Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconAlert.js
var IconAlert = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? AlertIcon({ hidden: !this.label, title: this.label }) : AlertTriangleIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-alert.js
init_define_element();
defineElement("sp-icon-alert", IconAlert);

// node_modules/@spectrum-web-components/textfield/src/textfield.css.js
init_src();
var t19 = i`
    :host{--spectrum-textfield-input-line-height:var(--spectrum-textfield-height);--spectrum-texfield-animation-duration:var(--spectrum-animation-duration-100);--spectrum-textfield-width:240px;--spectrum-textfield-min-width:var(--spectrum-text-field-minimum-width-multiplier);--spectrum-textfield-spacing-inline-quiet:var(--spectrum-field-edge-to-text-quiet);--spectrum-textfield-spacing-block-quiet:var(--spectrum-field-edge-to-border-quiet);--spectrum-textfield-label-spacing-block:var(--spectrum-field-label-to-component);--spectrum-textfield-helptext-spacing-block:var(--spectrum-help-text-to-component);--spectrum-textfield-icon-spacing-inline-end-quiet-invalid:var(--spectrum-field-edge-to-alert-icon-quiet);--spectrum-textfield-icon-spacing-inline-end-quiet-valid:var(--spectrum-field-edge-to-validation-icon-quiet);--spectrum-textfield-font-family:var(--spectrum-sans-font-family-stack);--spectrum-textfield-font-weight:var(--spectrum-regular-font-weight);--spectrum-textfield-character-count-font-family:var(--spectrum-sans-font-family-stack);--spectrum-textfield-character-count-font-weight:var(--spectrum-regular-font-weight);--spectrum-textfield-character-count-spacing-inline:var(--spectrum-spacing-200);--spectrum-textfield-character-count-spacing-inline-side:var(--spectrum-side-label-character-count-to-field);--spectrum-textfield-focus-indicator-width:var(--spectrum-focus-indicator-thickness);--spectrum-textfield-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--spectrum-textfield-text-color-default:var(--spectrum-neutral-content-color-default);--spectrum-textfield-text-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-textfield-text-color-focus:var(--spectrum-neutral-content-color-focus);--spectrum-textfield-text-color-focus-hover:var(--spectrum-neutral-content-color-focus-hover);--spectrum-textfield-text-color-keyboard-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-textfield-text-color-readonly:var(--spectrum-neutral-content-color-default);--spectrum-textfield-text-color-disabled:var(--spectrum-disabled-content-color);--spectrum-textfield-border-color-invalid-default:var(--spectrum-negative-border-color-default);--spectrum-textfield-border-color-invalid-hover:var(--spectrum-negative-border-color-hover);--spectrum-textfield-border-color-invalid-focus:var(--spectrum-negative-border-color-focus);--spectrum-textfield-border-color-invalid-focus-hover:var(--spectrum-negative-border-color-focus-hover);--spectrum-textfield-border-color-invalid-keyboard-focus:var(--spectrum-negative-border-color-key-focus);--spectrum-textfield-icon-color-invalid:var(--spectrum-negative-visual-color);--spectrum-textfield-text-color-invalid:var(--spectrum-neutral-content-color-default);--spectrum-textfield-text-color-valid:var(--spectrum-neutral-content-color-default);--spectrum-textfield-icon-color-valid:var(--spectrum-positive-visual-color);--spectrum-textfield-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-text-area-min-inline-size:var(--spectrum-text-area-minimum-width);--spectrum-text-area-min-block-size:var(--spectrum-text-area-minimum-height);--spectrum-textfield-height:var(--spectrum-component-height-100);--spectrum-textfield-label-spacing-block-quiet:var(--spectrum-field-label-to-component-quiet-medium);--spectrum-textfield-label-spacing-inline-side-label:var(--spectrum-spacing-200);--spectrum-textfield-placeholder-font-size:var(--spectrum-font-size-100);--spectrum-textfield-spacing-inline:var(--spectrum-component-edge-to-text-100);--spectrum-textfield-icon-size-invalid:var(--spectrum-workflow-icon-size-100);--spectrum-textfield-icon-size-valid:var(--spectrum-checkmark-icon-size-100);--spectrum-textfield-icon-spacing-inline-end-invalid:var(--spectrum-field-edge-to-alert-icon-medium);--spectrum-textfield-icon-spacing-inline-end-valid:var(--spectrum-field-edge-to-validation-icon-medium);--spectrum-textfield-icon-spacing-block-valid:var(--spectrum-field-top-to-validation-icon-medium);--spectrum-textfield-icon-spacing-inline-start-invalid:var(--spectrum-field-text-to-alert-icon-medium);--spectrum-textfield-icon-spacing-inline-start-valid:var(--spectrum-field-text-to-validation-icon-medium);--spectrum-textfield-character-count-font-size:var(--spectrum-font-size-75);--spectrum-textfield-character-count-spacing-block:var(--spectrum-component-bottom-to-text-75);--spectrum-textfield-character-count-spacing-block-quiet:var(--spectrum-character-count-to-field-quiet-medium);--spectrum-textfield-character-count-spacing-block-side:var(--spectrum-side-label-character-count-top-margin-medium);--spectrum-text-area-min-block-size-quiet:var(--spectrum-component-height-100)}:host([size=s]) #textfield{--spectrum-textfield-height:var(--spectrum-component-height-75);--spectrum-textfield-label-spacing-block-quiet:var(--spectrum-field-label-to-component-quiet-small);--spectrum-textfield-label-spacing-inline-side-label:var(--spectrum-spacing-100);--spectrum-textfield-placeholder-font-size:var(--spectrum-font-size-75);--spectrum-textfield-spacing-inline:var(--spectrum-component-edge-to-text-75);--spectrum-textfield-icon-size-invalid:var(--spectrum-workflow-icon-size-75);--spectrum-textfield-icon-size-valid:var(--spectrum-checkmark-icon-size-75);--spectrum-textfield-icon-spacing-inline-end-invalid:var(--spectrum-field-edge-to-alert-icon-small);--spectrum-textfield-icon-spacing-inline-end-valid:var(--spectrum-field-edge-to-validation-icon-small);--spectrum-textfield-icon-spacing-block-valid:var(--spectrum-field-top-to-validation-icon-small);--spectrum-textfield-icon-spacing-inline-start-invalid:var(--spectrum-field-text-to-alert-icon-small);--spectrum-textfield-icon-spacing-inline-start-valid:var(--spectrum-field-text-to-validation-icon-small);--spectrum-textfield-character-count-font-size:var(--spectrum-font-size-75);--spectrum-textfield-character-count-spacing-block:var(--spectrum-component-bottom-to-text-75);--spectrum-textfield-character-count-spacing-block-quiet:var(--spectrum-character-count-to-field-quiet-small);--spectrum-textfield-character-count-spacing-block-side:var(--spectrum-side-label-character-count-top-margin-small);--spectrum-text-area-min-block-size-quiet:var(--spectrum-component-height-75)}:host([size=l]) #textfield{--spectrum-textfield-height:var(--spectrum-component-height-200);--spectrum-textfield-label-spacing-block-quiet:var(--spectrum-field-label-to-component-quiet-large);--spectrum-textfield-label-spacing-inline-side-label:var(--spectrum-spacing-200);--spectrum-textfield-placeholder-font-size:var(--spectrum-font-size-200);--spectrum-textfield-spacing-inline:var(--spectrum-component-edge-to-text-200);--spectrum-textfield-icon-size-invalid:var(--spectrum-workflow-icon-size-200);--spectrum-textfield-icon-size-valid:var(--spectrum-checkmark-icon-size-200);--spectrum-textfield-icon-spacing-inline-end-invalid:var(--spectrum-field-edge-to-alert-icon-large);--spectrum-textfield-icon-spacing-inline-end-valid:var(--spectrum-field-edge-to-validation-icon-large);--spectrum-textfield-icon-spacing-block-valid:var(--spectrum-field-top-to-validation-icon-large);--spectrum-textfield-icon-spacing-inline-start-invalid:var(--spectrum-field-text-to-alert-icon-large);--spectrum-textfield-icon-spacing-inline-start-valid:var(--spectrum-field-text-to-validation-icon-large);--spectrum-textfield-character-count-font-size:var(--spectrum-font-size-100);--spectrum-textfield-character-count-spacing-block:var(--spectrum-component-bottom-to-text-100);--spectrum-textfield-character-count-spacing-block-quiet:var(--spectrum-character-count-to-field-quiet-large);--spectrum-textfield-character-count-spacing-block-side:var(--spectrum-side-label-character-count-top-margin-large);--spectrum-text-area-min-block-size-quiet:var(--spectrum-component-height-200)}:host([size=xl]) #textfield{--spectrum-textfield-height:var(--spectrum-component-height-300);--spectrum-textfield-label-spacing-block-quiet:var(--spectrum-field-label-to-component-quiet-extra-large);--spectrum-textfield-label-spacing-inline-side-label:var(--spectrum-spacing-200);--spectrum-textfield-placeholder-font-size:var(--spectrum-font-size-300);--spectrum-textfield-spacing-inline:var(--spectrum-component-edge-to-text-200);--spectrum-textfield-icon-size-invalid:var(--spectrum-workflow-icon-size-300);--spectrum-textfield-icon-size-valid:var(--spectrum-checkmark-icon-size-300);--spectrum-textfield-icon-spacing-inline-end-invalid:var(--spectrum-field-edge-to-alert-icon-extra-large);--spectrum-textfield-icon-spacing-inline-end-valid:var(--spectrum-field-edge-to-validation-icon-extra-large);--spectrum-textfield-icon-spacing-block-valid:var(--spectrum-field-top-to-validation-icon-extra-large);--spectrum-textfield-icon-spacing-inline-start-invalid:var(--spectrum-field-text-to-alert-icon-extra-large);--spectrum-textfield-icon-spacing-inline-start-valid:var(--spectrum-field-text-to-validation-icon-extra-large);--spectrum-textfield-character-count-font-size:var(--spectrum-font-size-200);--spectrum-textfield-character-count-spacing-block:var(--spectrum-component-bottom-to-text-200);--spectrum-textfield-character-count-spacing-block-quiet:var(--spectrum-character-count-to-field-quiet-extra-large);--spectrum-textfield-character-count-spacing-block-side:var(--spectrum-side-label-character-count-top-margin-extra-large);--spectrum-text-area-min-block-size-quiet:var(--spectrum-component-height-300)}#textfield{text-overflow:ellipsis;inline-size:var(--mod-textfield-width,var(--spectrum-textfield-width));grid-template-rows:auto auto auto;grid-template-columns:auto auto;margin:0;display:inline-grid;position:relative;overflow:visible}:host([invalid]) #textfield .icon,:host([valid]) #textfield .icon{pointer-events:all;grid-area:2/2;margin-inline-start:auto;position:absolute;inset-block-start:0}#textfield.spectrum-Textfield--sideLabel .icon{grid-area:1/2/span 1/span 1}:host([valid]) #textfield .icon{color:var(--mod-textfield-icon-color-valid,var(--spectrum-textfield-icon-color-valid));inset-block-start:var(--mod-textfield-icon-spacing-block-valid,var(--spectrum-textfield-icon-spacing-block-valid));inset-block-end:var(--mod-textfield-icon-spacing-block-valid,var(--spectrum-textfield-icon-spacing-block-valid));inset-inline-end:var(--mod-textfield-icon-spacing-inline-end-valid,var(--spectrum-textfield-icon-spacing-inline-end-valid))}:host([invalid]) #textfield .icon{block-size:var(--mod-textfield-icon-size-invalid,var(--spectrum-textfield-icon-size-invalid));inline-size:var(--mod-textfield-icon-size-invalid,var(--spectrum-textfield-icon-size-invalid));color:var(--mod-textfield-icon-color-invalid,var(--spectrum-textfield-icon-color-invalid));inset-block-start:var(--mod-textfield-icon-spacing-block-invalid,var(--spectrum-textfield-icon-spacing-block-invalid));inset-block-end:var(--mod-textfield-icon-spacing-block-invalid,var(--spectrum-textfield-icon-spacing-block-invalid));inset-inline-end:var(--mod-textfield-icon-spacing-inline-end-invalid,var(--spectrum-textfield-icon-spacing-inline-end-invalid))}:host([disabled]) #textfield .icon,:host([readonly]) #textfield .icon{color:#0000}:host([quiet]) .icon{padding-inline-end:0}:host([quiet][valid]) .icon{inset-inline-end:var(--mod-textfield-icon-spacing-inline-end-quiet-valid,var(--spectrum-textfield-icon-spacing-inline-end-quiet-valid))}:host([quiet][invalid]) .icon{inset-inline-end:var(--mod-textfield-icon-spacing-inline-end-quiet-invalid,var(--spectrum-textfield-icon-spacing-inline-end-quiet-invalid))}#textfield .spectrum-FieldLabel{grid-area:1/1/auto/span 1;margin-block-end:var(--mod-textfield-label-spacing-block,var(--spectrum-textfield-label-spacing-block))}:host([quiet]) .spectrum-FieldLabel{margin-block-end:var(--mod-textfield-label-spacing-block-quiet,var(--spectrum-textfield-label-spacing-block-quiet))}:host([disabled]) #textfield .spectrum-FieldLabel{color:var(--spectrum-textfield-text-color-disabled)}#textfield .spectrum-HelpText{grid-area:3/1/auto/span 2;margin-block-start:var(--mod-textfield-helptext-spacing-block,var(--spectrum-textfield-helptext-spacing-block))}.spectrum-Textfield-characterCount{inline-size:auto;font-size:var(--mod-textfield-character-count-font-size,var(--spectrum-textfield-character-count-font-size));font-family:var(--mod-textfield-character-count-font-family,var(--spectrum-textfield-character-count-font-family));font-weight:var(--mod-textfield-character-count-font-weight,var(--spectrum-textfield-character-count-font-weight));grid-area:1/2/auto/span 1;justify-content:flex-end;align-items:flex-end;margin-block-end:var(--mod-textfield-character-count-spacing-block,var(--spectrum-textfield-character-count-spacing-block));margin-inline-start:var(--mod-textfield-character-count-spacing-inline,var(--spectrum-textfield-character-count-spacing-inline));margin-inline-end:0;padding-inline-end:calc(var(--mod-textfield-corner-radius,var(--spectrum-textfield-corner-radius))/2);display:inline-flex}:host([quiet]) .spectrum-Textfield-characterCount{margin-block-end:var(--mod-textfield-character-count-spacing-block-quiet,var(--spectrum-textfield-character-count-spacing-block-quiet))}.input{line-height:var(--spectrum-textfield-input-line-height);box-sizing:border-box;inline-size:100%;min-inline-size:var(--mod-textfield-min-width,var(--spectrum-textfield-min-width));block-size:var(--mod-textfield-height,var(--spectrum-textfield-height));padding-block-start:calc(var(--mod-textfield-spacing-block-start,var(--spectrum-textfield-spacing-block-start)) - var(--mod-textfield-border-width,var(--spectrum-textfield-border-width)));padding-block-end:calc(var(--mod-textfield-spacing-block-end,var(--spectrum-textfield-spacing-block-end)) - var(--mod-textfield-border-width,var(--spectrum-textfield-border-width)));padding-inline:calc(var(--mod-textfield-spacing-inline,var(--spectrum-textfield-spacing-inline)) - var(--mod-textfield-border-width,var(--spectrum-textfield-border-width)));vertical-align:top;background-color:var(--mod-textfield-background-color,var(--spectrum-textfield-background-color));border-width:var(--mod-textfield-border-width,var(--spectrum-textfield-border-width));border-style:solid;border-color:var(--highcontrast-textfield-border-color,var(--mod-textfield-border-color,var(--spectrum-textfield-border-color)));border-radius:var(--mod-textfield-corner-radius,var(--spectrum-textfield-corner-radius));transition:border-color var(--mod-texfield-animation-duration,var(--spectrum-texfield-animation-duration))ease-in-out;font-size:var(--mod-textfield-placeholder-font-size,var(--spectrum-textfield-placeholder-font-size));font-family:var(--mod-textfield-font-family,var(--spectrum-textfield-font-family));font-weight:var(--mod-textfield-font-weight,var(--spectrum-textfield-font-weight));color:var(--highcontrast-textfield-text-color-default,var(--mod-textfield-text-color-default,var(--spectrum-textfield-text-color-default)));text-overflow:ellipsis;appearance:none;outline:none;grid-area:2/1/auto/span 2;margin:0}:host([type=number]) .input{-moz-appearance:textfield}:host([type=number]) .input::-webkit-inner-spin-button,:host([type=number]) .input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.input:-moz-ui-invalid{box-shadow:none}.input::placeholder{opacity:1;font-size:var(--mod-textfield-placeholder-font-size,var(--spectrum-textfield-placeholder-font-size));font-family:var(--mod-textfield-font-family,var(--spectrum-textfield-font-family));font-weight:var(--mod-textfield-font-weight,var(--spectrum-textfield-font-weight));color:var(--highcontrast-textfield-text-color-default,var(--mod-textfield-text-color-default,var(--spectrum-textfield-text-color-default)));transition:color var(--mod-texfield-animation-duration,var(--spectrum-texfield-animation-duration))ease-in-out}.input:lang(ja)::placeholder,.input:lang(ko)::placeholder,.input:lang(zh)::placeholder{font-style:normal}:host([focused]) .input,.input:focus{border-color:var(--highcontrast-textfield-border-color-focus,var(--mod-textfield-border-color-focus,var(--spectrum-textfield-border-color-focus)))}:host([focused]) .input,:host([focused]) .input::placeholder,.input:focus,.input:focus::placeholder{color:var(--mod-textfield-text-color-focus,var(--spectrum-textfield-text-color-focus))}:host([focused]) .input{border-color:var(--highcontrast-textfield-border-color-keyboard-focus,var(--mod-textfield-border-color-keyboard-focus,var(--spectrum-textfield-border-color-keyboard-focus)));outline:var(--mod-textfield-focus-indicator-width,var(--spectrum-textfield-focus-indicator-width))solid;outline-color:var(--highcontrast-textfield-focus-indicator-color,var(--mod-textfield-focus-indicator-color,var(--spectrum-textfield-focus-indicator-color)));outline-offset:var(--mod-textfield-focus-indicator-gap,var(--spectrum-textfield-focus-indicator-gap))}:host([focused]) .input,:host([focused]) .input::placeholder{color:var(--highcontrast-textfield-text-color-keyboard-focus,var(--mod-textfield-text-color-keyboard-focus,var(--spectrum-textfield-text-color-keyboard-focus)))}:host([valid]) .input{color:var(--highcontrast-textfield-text-color-valid,var(--mod-textfield-text-color-valid,var(--spectrum-textfield-text-color-valid)));padding-inline-end:calc(var(--mod-textfield-icon-spacing-inline-start-valid,var(--spectrum-textfield-icon-spacing-inline-start-valid)) + var(--mod-textfield-icon-size-valid,var(--spectrum-textfield-icon-size-valid)) + var(--mod-textfield-icon-spacing-inline-end-valid,var(--spectrum-textfield-icon-spacing-inline-end-valid)) - var(--mod-textfield-border-width,var(--spectrum-textfield-border-width)))}:host([invalid]) .input{color:var(--highcontrast-textfield-text-color-invalid,var(--mod-textfield-text-color-invalid,var(--spectrum-textfield-text-color-invalid)));border-color:var(--highcontrast-textfield-border-color-invalid-default,var(--mod-textfield-border-color-invalid-default,var(--spectrum-textfield-border-color-invalid-default)));padding-inline-end:calc(var(--mod-textfield-icon-spacing-inline-start-invalid,var(--spectrum-textfield-icon-spacing-inline-start-invalid)) + var(--mod-textfield-icon-size-invalid,var(--spectrum-textfield-icon-size-invalid)) + var(--mod-textfield-icon-spacing-inline-end-invalid,var(--spectrum-textfield-icon-spacing-inline-end-invalid)) - var(--mod-textfield-border-width,var(--spectrum-textfield-border-width)))}:host([invalid]) .input:focus,:host([invalid][focused]) .input,:host([invalid]:focus) .input{border-color:var(--highcontrast-textfield-border-color-invalid-focus,var(--mod-textfield-border-color-invalid-focus,var(--spectrum-textfield-border-color-invalid-focus)))}:host([invalid]) .input:focus-visible,:host([invalid][focused]) .input{border-color:var(--highcontrast-textfield-border-color-invalid-keyboard-focus,var(--mod-textfield-border-color-invalid-keyboard-focus,var(--spectrum-textfield-border-color-invalid-keyboard-focus)))}.input:disabled,:host([disabled]) #textfield .input{background-color:var(--mod-textfield-background-color-disabled,var(--spectrum-textfield-background-color-disabled));border-color:var(--mod-textfield-border-color-disabled,var(--spectrum-textfield-border-color-disabled));resize:none;opacity:1}.input:disabled,.input:disabled::placeholder,:host([disabled]) #textfield .input,:host([disabled]) #textfield .input::placeholder{color:var(--highcontrast-textfield-text-color-disabled,var(--mod-textfield-text-color-disabled,var(--spectrum-textfield-text-color-disabled)))}:host([quiet]) .input{padding-block-start:var(--mod-textfield-spacing-block-start,var(--spectrum-textfield-spacing-block-start));padding-inline:var(--mod-textfield-spacing-inline-quiet,var(--spectrum-textfield-spacing-inline-quiet));background-color:initial;resize:none;border-block-start-width:0;border-inline-width:0;border-radius:0;outline:none;margin-block-end:var(--mod-textfield-spacing-block-quiet,var(--spectrum-textfield-spacing-block-quiet));overflow-y:hidden}:host([quiet][disabled]) .input,.input:disabled{background-color:initial;border-color:var(--mod-textfield-border-color-disabled,var(--spectrum-textfield-border-color-disabled))}:host([quiet][disabled]) .input,:host([quiet][disabled]) .input::placeholder,.input:disabled,.input:disabled::placeholder{color:var(--highcontrast-textfield-text-color-disabled,var(--mod-textfield-text-color-disabled,var(--spectrum-textfield-text-color-disabled)))}.input:read-only,:host([readonly]) #textfield .input{background-color:initial;color:var(--highcontrast-textfield-text-color-readonly,var(--mod-textfield-text-color-readonly,var(--spectrum-textfield-text-color-readonly)));border-color:#0000;outline:none}.input:read-only::placeholder,:host([readonly]) #textfield .input::placeholder{color:var(--highcontrast-textfield-text-color-readonly,var(--mod-textfield-text-color-readonly,var(--spectrum-textfield-text-color-readonly)));background-color:initial}@media (hover:hover){.input:hover,#textfield:hover .input{border-color:var(--highcontrast-textfield-border-color-hover,var(--mod-textfield-border-color-hover,var(--spectrum-textfield-border-color-hover)))}.input:hover,.input:hover::placeholder,#textfield:hover .input,#textfield:hover .input::placeholder{color:var(--highcontrast-textfield-text-color-hover,var(--mod-textfield-text-color-hover,var(--spectrum-textfield-text-color-hover)))}:host([focused]) .input:hover,.input:focus:hover{border-color:var(--mod-textfield-border-color-focus-hover,var(--spectrum-textfield-border-color-focus-hover))}:host([focused]) .input:hover,:host([focused]) .input:hover::placeholder,.input:focus:hover,.input:focus:hover::placeholder{color:var(--mod-textfield-text-color-focus-hover,var(--spectrum-textfield-text-color-focus-hover))}:host([invalid]) .input:hover:not(.is-disabled),:host([invalid]:hover):not(.is-disabled) .input{border-color:var(--highcontrast-textfield-border-color-invalid-hover,var(--mod-textfield-border-color-invalid-hover,var(--spectrum-textfield-border-color-invalid-hover)))}:host([invalid]) .input:focus:hover,:host([invalid][focused]) .input:hover,:host([invalid]:focus) .input:hover{border-color:var(--mod-textfield-border-color-invalid-focus-hover,var(--spectrum-textfield-border-color-invalid-focus-hover))}:host([disabled]) #textfield:hover .input{background-color:var(--mod-textfield-background-color-disabled,var(--spectrum-textfield-background-color-disabled));border-color:var(--mod-textfield-border-color-disabled,var(--spectrum-textfield-border-color-disabled));resize:none;opacity:1}:host([quiet][disabled]:hover) .input,:host([disabled]) #textfield:hover .input,:host([disabled]) #textfield:hover .input::placeholder{color:var(--highcontrast-textfield-text-color-disabled,var(--mod-textfield-text-color-disabled,var(--spectrum-textfield-text-color-disabled)))}:host([quiet][disabled]:hover) .input{background-color:initial;border-color:var(--mod-textfield-border-color-disabled,var(--spectrum-textfield-border-color-disabled))}:host([quiet][disabled]:hover) .input::placeholder{color:var(--highcontrast-textfield-text-color-disabled,var(--mod-textfield-text-color-disabled,var(--spectrum-textfield-text-color-disabled)))}:host([readonly]) #textfield:hover .input{border-color:#0000;outline:none}:host([readonly]) #textfield:hover .input,:host([readonly]) #textfield:hover .input::placeholder{background-color:initial;color:var(--highcontrast-textfield-text-color-readonly,var(--mod-textfield-text-color-readonly,var(--spectrum-textfield-text-color-readonly)))}}.spectrum-Textfield--sideLabel{grid-template-rows:auto auto;grid-template-columns:auto auto auto}.spectrum-Textfield--sideLabel:after{grid-area:1/2/span 1/span 1}.spectrum-Textfield--sideLabel .spectrum-FieldLabel{grid-area:1/1/span 2/span 1;margin-inline-end:var(--mod-textfield-label-spacing-inline-side-label,var(--spectrum-textfield-label-spacing-inline-side-label))}.spectrum-Textfield--sideLabel .spectrum-Textfield-characterCount{grid-area:1/3/auto/span 1;align-items:flex-start;margin-block-start:var(--mod-textfield-character-count-spacing-block-side,var(--spectrum-textfield-character-count-spacing-block-side));margin-inline-start:var(--mod-textfield-character-count-spacing-inline-side,var(--spectrum-textfield-character-count-spacing-inline-side))}.spectrum-Textfield--sideLabel .spectrum-HelpText{grid-area:2/2/auto/span 1}.spectrum-Textfield--sideLabel .input,.spectrum-Textfield--sideLabel .icon{grid-area:1/2/span 1/span 1}:host([multiline]){--spectrum-textfield-input-line-height:normal}:host([multiline]) .input{min-inline-size:var(--mod-text-area-min-inline-size,var(--spectrum-text-area-min-inline-size));min-block-size:var(--mod-text-area-min-block-size,var(--spectrum-text-area-min-block-size));resize:inherit}:host([multiline][grows]) .input{grid-row:2}:host([multiline][grows]) .spectrum-Textfield--sideLabel .input{grid-row:1}:host([multiline][quiet]) .input{min-block-size:var(--mod-text-area-min-block-size-quiet,var(--spectrum-text-area-min-block-size-quiet));resize:none;overflow-y:hidden}:host([quiet]) #textfield:after{content:"";pointer-events:none;inline-size:100%;block-size:var(--mod-textfield-focus-indicator-width,var(--spectrum-textfield-focus-indicator-width));position:absolute;inset-block-end:calc((var(--mod-textfield-focus-indicator-gap,var(--spectrum-textfield-focus-indicator-gap)) + var(--mod-textfield-focus-indicator-width,var(--spectrum-textfield-focus-indicator-width)))*-1);inset-inline-start:0}:host([quiet][focused]) #textfield:after{background-color:var(--highcontrast-textfield-focus-indicator-color,var(--mod-textfield-focus-indicator-color,var(--spectrum-textfield-focus-indicator-color)))}:host([quiet][invalid]) .input{padding-inline-end:calc(var(--mod-textfield-icon-spacing-inline-start-invalid,var(--spectrum-textfield-icon-spacing-inline-start-invalid)) + var(--mod-textfield-icon-size-invalid,var(--spectrum-textfield-icon-size-invalid)))}:host([quiet][valid]) .input{padding-inline-end:calc(var(--mod-textfield-icon-spacing-inline-start-valid,var(--spectrum-textfield-icon-spacing-inline-start-valid)) + var(--mod-textfield-icon-size-valid,var(--spectrum-textfield-icon-size-valid)))}@media (forced-colors:active){:host{--highcontrast-textfield-border-color:CanvasText;--highcontrast-textfield-border-color-hover:Highlight;--highcontrast-textfield-border-color-focus:Highlight;--highcontrast-textfield-border-color-keyboard-focus:CanvasText;--highcontrast-textfield-focus-indicator-color:Highlight;--highcontrast-textfield-border-color-invalid-default:Highlight;--highcontrast-textfield-border-color-invalid-hover:Highlight;--highcontrast-textfield-border-color-invalid-focus:Highlight;--highcontrast-textfield-border-color-invalid-keyboard-focus:Highlight;--highcontrast-textfield-text-color-valid:CanvasText;--highcontrast-textfield-text-color-invalid:CanvasText}#textfield .input{--highcontrast-textfield-text-color-default:CanvasText;--highcontrast-textfield-text-color-hover:CanvasText;--highcontrast-textfield-text-color-keyboard-focus:CanvasText;--highcontrast-textfield-text-color-disabled:GrayText;--highcontrast-textfield-text-color-readonly:CanvasText}#textfield .input::placeholder{--highcontrast-textfield-text-color-default:GrayText;--highcontrast-textfield-text-color-hover:GrayText;--highcontrast-textfield-text-color-keyboard-focus:GrayText;--highcontrast-textfield-text-color-disabled:GrayText;--highcontrast-textfield-text-color-readonly:CanvasText}}:host{--spectrum-textfield-background-color:var(--system-textfield-background-color);--spectrum-textfield-background-color-disabled:var(--system-textfield-background-color-disabled);--spectrum-textfield-border-color:var(--system-textfield-border-color);--spectrum-textfield-border-color-hover:var(--system-textfield-border-color-hover);--spectrum-textfield-border-color-focus:var(--system-textfield-border-color-focus);--spectrum-textfield-border-color-focus-hover:var(--system-textfield-border-color-focus-hover);--spectrum-textfield-border-color-keyboard-focus:var(--system-textfield-border-color-keyboard-focus);--spectrum-textfield-border-color-disabled:var(--system-textfield-border-color-disabled);--spectrum-textfield-border-width:var(--system-textfield-border-width);--spectrum-textfield-spacing-block-start:var(--system-textfield-spacing-block-start);--spectrum-textfield-spacing-block-end:var(--system-textfield-spacing-block-end);--spectrum-textfield-corner-radius:var(--system-textfield-corner-radius);--spectrum-textfield-icon-spacing-block-invalid:var(--system-textfield-icon-spacing-block-invalid)}:host([size=s]) #textfield#textfield{--spectrum-textfield-spacing-block-start:var(--system-textfield-spacing-block-start-small);--spectrum-textfield-spacing-block-end:var(--system-textfield-spacing-block-end-small);--spectrum-textfield-icon-spacing-block-invalid:var(--system-textfield-size-s-icon-spacing-block-invalid);--spectrum-textfield-corner-radius:var(--system-textfield-corner-radius-small)}:host([size=l]) #textfield#textfield{--spectrum-textfield-spacing-block-start:var(--system-textfield-spacing-block-start-large);--spectrum-textfield-spacing-block-end:var(--system-textfield-spacing-block-end-large);--spectrum-textfield-icon-spacing-block-invalid:var(--system-textfield-size-l-icon-spacing-block-invalid);--spectrum-textfield-corner-radius:var(--system-textfield-corner-radius-large)}:host([size=xl]) #textfield#textfield{--spectrum-textfield-spacing-block-start:var(--system-textfield-spacing-block-start-extra-large);--spectrum-textfield-spacing-block-end:var(--system-textfield-spacing-block-end-extra-large);--spectrum-textfield-icon-spacing-block-invalid:var(--system-textfield-size-xl-icon-spacing-block-invalid);--spectrum-textfield-corner-radius:var(--system-textfield-corner-radius-extra-large)}:host([quiet]) #textfield{--spectrum-textfield-border-color-disabled:var(--system-textfield-quiet-border-color-disabled)}:host{inline-size:var(--mod-textfield-width,var(--spectrum-textfield-width));flex-direction:column;display:inline-flex}:host([multiline]){resize:both}:host([multiline][readonly]){resize:none}:host([disabled]:focus-visible){outline:none}#textfield{inline-size:100%}#textfield,textarea{resize:inherit}.input{min-inline-size:var(--spectrum-textfield-min-width)}:host([focused]) .input{caret-color:var(--swc-test-caret-color);forced-color-adjust:var(--swc-test-forced-color-adjust)}:host([focused]) #textfield:hover .input,:host([focused]) .input:hover{border-color:var(--mod-textfield-border-color-focus-hover,var(--spectrum-textfield-border-color-focus-hover))}#sizer{overflow-wrap:break-word;opacity:0;white-space:pre-line;block-size:auto}.icon,.icon-workflow{pointer-events:none}:host([multiline]) #textfield{--spectrum-textfield-input-line-height:normal;display:inline-grid}:host([multiline]) textarea{transition:box-shadow var(--spectrum-animation-duration-100,.13s)ease-in-out,border-color var(--spectrum-animation-duration-100,.13s)ease-in-out}:host([multiline]:not([quiet])) #textfield:after{box-shadow:none}:host([multiline][rows]) .input{resize:none;block-size:auto}:host([multiline][rows="1"]) .input{min-block-size:auto}:host([disabled][quiet]) #textfield .input,:host([disabled][quiet]) #textfield:hover .input,:host([quiet]) .input :disabled{border-color:var(--mod-textfield-border-color-disabled,var(--spectrum-textfield-border-color-disabled));color:var(--highcontrast-textfield-text-color-disabled,var(--mod-textfield-text-color-disabled,var(--spectrum-textfield-text-color-disabled)));background-color:#0000}:host([disabled]) #textfield .icon.icon-search,:host([readonly]) #textfield .icon.icon-search{color:var(--highcontrast-textfield-text-color-disabled,var(--mod-textfield-text-color-disabled,var(--spectrum-textfield-text-color-disabled)))}:host([focused]) #textfield .icon.icon-search{--spectrum-search-color:var(--highcontrast-search-color-focus,var(--mod-search-color-focus,var(--spectrum-search-color-focus)))}:host([multiline][grows]:not([quiet])) #textfield:after{grid-area:unset;min-block-size:calc(var(--mod-text-area-min-block-size,var(--spectrum-text-area-min-block-size)) + var(--mod-textfield-focus-indicator-gap,var(--spectrum-textfield-focus-indicator-gap))*2)}:host([multiline][grows]:not([rows])) .input:not(#sizer){resize:none;height:100%;position:absolute;top:0;left:0;overflow:hidden}
`;
var textfield_css_default = t19;

// node_modules/@spectrum-web-components/icon/src/spectrum-icon-checkmark.css.js
init_src();
var e22 = i`
    .spectrum-UIIcon-Checkmark50{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-50)}.spectrum-UIIcon-Checkmark75{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-75)}.spectrum-UIIcon-Checkmark100{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-100)}.spectrum-UIIcon-Checkmark200{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-200)}.spectrum-UIIcon-Checkmark300{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-300)}.spectrum-UIIcon-Checkmark400{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-400)}.spectrum-UIIcon-Checkmark500{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-500)}.spectrum-UIIcon-Checkmark600{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-600)}
`;
var spectrum_icon_checkmark_css_default = e22;

// node_modules/@spectrum-web-components/textfield/src/Textfield.js
var c16 = Object.defineProperty;
var m13 = Object.getOwnPropertyDescriptor;
var t20 = (p30, a23, e36, n25) => {
  for (var r25 = n25 > 1 ? void 0 : n25 ? m13(a23, e36) : a23, u36 = p30.length - 1, h16; u36 >= 0; u36--) (h16 = p30[u36]) && (r25 = (n25 ? h16(a23, e36, r25) : h16(r25)) || r25);
  return n25 && r25 && c16(a23, e36, r25), r25;
};
var S3 = ["text", "url", "tel", "email", "password"];
var TextfieldBase = class extends ManageHelpText(SizedMixin(Focusable, { noDefaultSize: true })) {
  constructor() {
    super(...arguments);
    this.allowedKeys = "";
    this.focused = false;
    this.invalid = false;
    this.label = "";
    this.placeholder = "";
    this._type = "text";
    this.grows = false;
    this.maxlength = -1;
    this.minlength = -1;
    this.multiline = false;
    this.readonly = false;
    this.rows = -1;
    this.valid = false;
    this._value = "";
    this.quiet = false;
    this.required = false;
  }
  static get styles() {
    return [textfield_css_default, spectrum_icon_checkmark_css_default];
  }
  set type(e36) {
    const n25 = this._type;
    this._type = e36, this.requestUpdate("type", n25);
  }
  get type() {
    var e36;
    return (e36 = S3.find((n25) => n25 === this._type)) != null ? e36 : "text";
  }
  set value(e36) {
    if (e36 === this.value) return;
    const n25 = this._value;
    this._value = e36, this.requestUpdate("value", n25);
  }
  get value() {
    return this._value;
  }
  get focusElement() {
    return this.inputElement;
  }
  setSelectionRange(e36, n25, r25 = "none") {
    this.inputElement.setSelectionRange(e36, n25, r25);
  }
  select() {
    this.inputElement.select();
  }
  handleInput(e36) {
    if (this.allowedKeys && this.inputElement.value && !new RegExp(`^[${this.allowedKeys}]*$`, "u").test(this.inputElement.value)) {
      const u36 = this.inputElement.selectionStart - 1;
      this.inputElement.value = this.value.toString(), this.inputElement.setSelectionRange(u36, u36);
      return;
    }
    this.value = this.inputElement.value;
  }
  handleChange() {
    this.dispatchEvent(new Event("change", { bubbles: true, composed: true }));
  }
  onFocus() {
    this.focused = !this.readonly && true;
  }
  onBlur(e36) {
    this.focused = !this.readonly && false;
  }
  handleInputElementPointerdown() {
  }
  renderStateIcons() {
    return this.invalid ? x`
                <sp-icon-alert id="invalid" class="icon"></sp-icon-alert>
            ` : this.valid ? x`
                <sp-icon-checkmark100
                    id="valid"
                    class="icon spectrum-UIIcon-Checkmark100"
                ></sp-icon-checkmark100>
            ` : E;
  }
  get displayValue() {
    return this.value.toString();
  }
  get renderMultiline() {
    return x`
            ${this.multiline && this.grows && this.rows === -1 ? x`
                      <div id="sizer" class="input" aria-hidden="true">${this.value}&#8203;
                      </div>
                  ` : E}
            <!-- @ts-ignore -->
            <textarea
                name=${o9(this.name || void 0)}
                aria-describedby=${this.helpTextId}
                aria-label=${this.label || this.appliedLabel || this.placeholder}
                aria-invalid=${o9(this.invalid || void 0)}
                class="input"
                maxlength=${o9(this.maxlength > -1 ? this.maxlength : void 0)}
                minlength=${o9(this.minlength > -1 ? this.minlength : void 0)}
                title=${this.invalid ? "" : E}
                pattern=${o9(this.pattern)}
                placeholder=${this.placeholder}
                .value=${this.displayValue}
                @change=${this.handleChange}
                @input=${this.handleInput}
                @focus=${this.onFocus}
                @blur=${this.onBlur}
                ?disabled=${this.disabled}
                ?required=${this.required}
                ?readonly=${this.readonly}
                rows=${o9(this.rows > -1 ? this.rows : void 0)}
                autocomplete=${o9(this.autocomplete)}
            ></textarea>
        `;
  }
  get renderInput() {
    return x`
            <!-- @ts-ignore -->
            <input
                name=${o9(this.name || void 0)}
                type=${this.type}
                aria-describedby=${this.helpTextId}
                aria-label=${this.label || this.appliedLabel || this.placeholder}
                aria-invalid=${o9(this.invalid || void 0)}
                class="input"
                title=${this.invalid ? "" : E}
                maxlength=${o9(this.maxlength > -1 ? this.maxlength : void 0)}
                minlength=${o9(this.minlength > -1 ? this.minlength : void 0)}
                pattern=${o9(this.pattern)}
                placeholder=${this.placeholder}
                .value=${l3(this.displayValue)}
                @change=${this.handleChange}
                @input=${this.handleInput}
                @pointerdown=${this.handleInputElementPointerdown}
                @focus=${this.onFocus}
                @blur=${this.onBlur}
                ?disabled=${this.disabled}
                ?required=${this.required}
                ?readonly=${this.readonly}
                autocomplete=${o9(this.autocomplete)}
            />
        `;
  }
  renderField() {
    return x`
            ${this.renderStateIcons()}
            ${this.multiline ? this.renderMultiline : this.renderInput}
        `;
  }
  render() {
    return x`
            <div id="textfield">${this.renderField()}</div>
            ${this.renderHelpText(this.invalid)}
        `;
  }
  update(e36) {
    (e36.has("value") || e36.has("required") && this.required) && this.updateComplete.then(() => {
      this.checkValidity();
    }), super.update(e36);
  }
  checkValidity() {
    let e36 = this.inputElement.checkValidity();
    return (this.required || this.value && this.pattern) && ((this.disabled || this.multiline) && this.pattern && (e36 = new RegExp(`^${this.pattern}$`, "u").test(this.value.toString())), typeof this.minlength != "undefined" && (e36 = e36 && this.value.toString().length >= this.minlength), this.valid = e36, this.invalid = !e36), e36;
  }
};
t20([r5()], TextfieldBase.prototype, "appliedLabel", 2), t20([n4({ attribute: "allowed-keys" })], TextfieldBase.prototype, "allowedKeys", 2), t20([n4({ type: Boolean, reflect: true })], TextfieldBase.prototype, "focused", 2), t20([e5(".input:not(#sizer)")], TextfieldBase.prototype, "inputElement", 2), t20([n4({ type: Boolean, reflect: true })], TextfieldBase.prototype, "invalid", 2), t20([n4()], TextfieldBase.prototype, "label", 2), t20([n4({ type: String, reflect: true })], TextfieldBase.prototype, "name", 2), t20([n4()], TextfieldBase.prototype, "placeholder", 2), t20([r5()], TextfieldBase.prototype, "type", 1), t20([n4({ attribute: "type", reflect: true })], TextfieldBase.prototype, "_type", 2), t20([n4()], TextfieldBase.prototype, "pattern", 2), t20([n4({ type: Boolean, reflect: true })], TextfieldBase.prototype, "grows", 2), t20([n4({ type: Number })], TextfieldBase.prototype, "maxlength", 2), t20([n4({ type: Number })], TextfieldBase.prototype, "minlength", 2), t20([n4({ type: Boolean, reflect: true })], TextfieldBase.prototype, "multiline", 2), t20([n4({ type: Boolean, reflect: true })], TextfieldBase.prototype, "readonly", 2), t20([n4({ type: Number })], TextfieldBase.prototype, "rows", 2), t20([n4({ type: Boolean, reflect: true })], TextfieldBase.prototype, "valid", 2), t20([n4({ type: String })], TextfieldBase.prototype, "value", 1), t20([n4({ type: Boolean, reflect: true })], TextfieldBase.prototype, "quiet", 2), t20([n4({ type: Boolean, reflect: true })], TextfieldBase.prototype, "required", 2), t20([n4({ type: String, reflect: true })], TextfieldBase.prototype, "autocomplete", 2);
var Textfield = class extends TextfieldBase {
  constructor() {
    super(...arguments);
    this._value = "";
  }
  set value(e36) {
    if (e36 === this.value) return;
    const n25 = this._value;
    this._value = e36, this.requestUpdate("value", n25);
  }
  get value() {
    return this._value;
  }
};
t20([n4({ type: String })], Textfield.prototype, "value", 1);

// node_modules/@spectrum-web-components/number-field/src/number-field.css.js
init_src();
var e23 = i`
    @media (forced-colors:active){:host{--highcontrast-stepper-border-color:CanvasText;--highcontrast-stepper-border-color-hover:Highlight;--highcontrast-stepper-border-color-focus:Highlight;--highcontrast-stepper-border-color-focus-hover:Highlight;--highcontrast-stepper-border-color-keyboard-focus:CanvasText;--highcontrast-stepper-focus-indicator-color:Highlight}:host([invalid]) #textfield{--highcontrast-stepper-border-color:Highlight;--highcontrast-stepper-border-color-hover:Highlight;--highcontrast-stepper-border-color-focus:Highlight;--highcontrast-stepper-border-color-focus-hover:Highlight;--highcontrast-stepper-border-color-keyboard-focus:Highlight}:host([disabled]) #textfield{--highcontrast-stepper-border-color:GrayText;--highcontrast-stepper-buttons-border-width:var(--mod-stepper-border-width,var(--spectrum-stepper-border-width))}:host([focused]:not([disabled])) #textfield,:host(:not([disabled])) #textfield:focus{--highcontrast-stepper-border-color:var(--highcontrast-stepper-border-color-focus)}@media (hover:hover){:host(:not([disabled]):hover) #textfield{--highcontrast-stepper-border-color:var(--highcontrast-stepper-border-color-hover)}:host([focused]:not([disabled]):hover) #textfield,:host(:not([disabled]):hover) #textfield:focus{--highcontrast-stepper-border-color:var(--highcontrast-stepper-border-color-focus-hover)}}:host([keyboard-focused]:not([disabled])) #textfield,:host(:not([disabled])) #textfield:focus-visible{--highcontrast-stepper-border-color:var(--highcontrast-stepper-border-color-keyboard-focus)}.input{--highcontrast-textfield-border-color:var(--highcontrast-stepper-border-color)}.button{--highcontrast-infield-button-border-color:var(--highcontrast-stepper-border-color);--highcontrast-infield-button-border-color-active:var(--highcontrast-stepper-border-color)}}:host{--spectrum-stepper-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color,var(--spectrum-stepper-border-color-default)));--spectrum-stepper-border-radius:var(--mod-stepper-border-radius,var(--spectrum-corner-radius-100));--spectrum-stepper-focus-indicator-width:var(--mod-stepper-focus-indicator-width,var(--spectrum-focus-indicator-thickness));--spectrum-stepper-focus-indicator-gap:var(--mod-stepper-focus-indicator-gap,var(--spectrum-focus-indicator-gap));--spectrum-stepper-focus-indicator-color:var(--highcontrast-stepper-focus-indicator-color,var(--mod-stepper-focus-indicator-color,var(--spectrum-focus-indicator-color)));--spectrum-stepper-animation-duration:var(--mod-stepper-animation-duration,var(--spectrum-animation-duration-100))}#textfield,:host([size=m]) #textfield{--spectrum-stepper-button-width:var(--mod-stepper-button-width,var(--spectrum-in-field-button-width-stacked-medium));--spectrum-stepper-height:var(--mod-stepper-height,var(--spectrum-component-height-100))}:host([size=s]) #textfield{--spectrum-stepper-button-width:var(--mod-stepper-button-width,var(--spectrum-in-field-button-width-stacked-small));--spectrum-stepper-height:var(--mod-stepper-height,var(--spectrum-component-height-75))}:host([size=l]) #textfield{--spectrum-stepper-button-width:var(--mod-stepper-button-width,var(--spectrum-in-field-button-width-stacked-large));--spectrum-stepper-height:var(--mod-stepper-height,var(--spectrum-component-height-200))}:host([size=xl]) #textfield{--spectrum-stepper-button-width:var(--mod-stepper-button-width,var(--spectrum-in-field-button-width-stacked-extra-large));--spectrum-stepper-height:var(--mod-stepper-height,var(--spectrum-component-height-300))}:host([disabled]) #textfield{--spectrum-stepper-buttons-border-width:var(--spectrum-stepper-button-border-width-disabled);--spectrum-stepper-buttons-background-color:var(--spectrum-stepper-buttons-background-color-disabled)}:host([invalid]) #textfield{--mod-stepper-border-color:var(--mod-stepper-border-color-invalid,var(--spectrum-negative-border-color-default));--mod-stepper-border-color-hover:var(--mod-stepper-border-color-hover-invalid,var(--spectrum-negative-border-color-hover));--mod-stepper-border-color-focus:var(--mod-stepper-border-color-focus-invalid,var(--spectrum-negative-border-color-focus));--mod-stepper-border-color-focus-hover:var(--mod-stepper-border-color-focus-hover-invalid,var(--spectrum-negative-border-color-focus-hover));--mod-stepper-border-color-keyboard-focus:var(--mod-stepper-border-color-keyboard-focus-invalid,var(--spectrum-negative-border-color-key-focus))}:host([focused]:not([disabled])) #textfield,:host(:not([disabled])) #textfield:focus{--mod-stepper-border-color:var(--highcontrast-stepper-border-color-focus,var(--mod-stepper-border-color-focus,var(--spectrum-stepper-border-color-focus)));--mod-stepper-buttons-border-color:var(--highcontrast-stepper-border-color-focus,var(--mod-stepper-border-color-focus,var(--spectrum-stepper-border-color-focus)))}:host([keyboard-focused]:not([disabled])) #textfield{--mod-stepper-border-color:var(--highcontrast-stepper-border-color-focus,var(--mod-stepper-border-color-focus,var(--spectrum-stepper-border-color-keyboard-focus)))}:host([quiet]) #textfield{--mod-stepper-buttons-background-color:transparent}:host([quiet][keyboard-focused]:not([disabled])) #textfield{--mod-stepper-focus-indicator-visibility:visible}:host([quiet][invalid]) #textfield{--mod-stepper-border-color:var(--mod-stepper-border-color-invalid,var(--spectrum-negative-border-color-default))}:host{--mod-infield-button-border-color:var(--mod-stepper-buttons-border-color,var(--spectrum-stepper-buttons-border-color));--mod-infield-button-border-color-quiet-disabled:var(--spectrum-disabled-border-color);--mod-infield-button-border-width:var(--mod-stepper-button-border-width,var(--spectrum-stepper-button-border-width));--mod-textfield-border-width:var(--mod-stepper-border-width,var(--spectrum-stepper-border-width));--mod-textfield-border-color:var(--spectrum-stepper-border-color)}#textfield:not(.spectrum-Stepper--quiet){--mod-textfield-border-color-disabled:var(--spectrum-stepper-border-color-disabled)}:host(:not([disabled])[focused]) #textfield,:host(:not([disabled])) #textfield:focus{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color-focus,var(--mod-stepper-buttons-border-color-focus,var(--spectrum-stepper-buttons-border-color-focus)));--mod-textfield-focus-indicator-width:0}:host([keyboard-focused]:not([disabled])) #textfield,:host(:not([disabled])) #textfield:focus-visible{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color-keyboard-focus,var(--mod-stepper-buttons-border-color-keyboard-focus,var(--spectrum-stepper-buttons-border-color-keyboard-focus)));--mod-textfield-focus-indicator-width:0;--mod-textfield-border-color:var(--highcontrast-stepper-border-color-keyboard-focus,var(--mod-stepper-border-color-keyboard-focus,var(--spectrum-stepper-border-color-keyboard-focus)));outline:var(--spectrum-stepper-focus-indicator-width)solid;outline-color:var(--spectrum-stepper-focus-indicator-color);outline-offset:var(--spectrum-stepper-focus-indicator-gap)}:host([invalid]) #textfield{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-invalid,var(--spectrum-stepper-border-color-invalid)));--mod-textfield-icon-spacing-inline-start-invalid:0}:host([invalid][focused]) #textfield,:host([invalid]) #textfield:focus{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-focus-invalid,var(--spectrum-stepper-border-color-focus-invalid)))}:host([invalid][keyboard-focused]) #textfield,:host([invalid]) #textfield:focus-visible{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-keyboard-focus-invalid,var(--spectrum-stepper-border-color-keyboard-focus-invalid)))}:host([quiet]) #textfield{--mod-infield-button-width-stacked:var(--mod-stepper-button-width-quiet,var(--spectrum-stepper-button-width));--mod-infield-button-border-color:var(--spectrum-stepper-border-color);--mod-infield-button-border-color-quiet:var(--spectrum-stepper-border-color);--mod-infield-button-border-block-end-width:var(--mod-stepper-border-width,var(--spectrum-stepper-border-width));--mod-infield-button-stacked-bottom-border-block-end-width:var(--mod-stepper-border-width,var(--spectrum-stepper-border-width));--mod-infield-button-stacked-bottom-border-radius-end-end:0;--mod-infield-button-stacked-bottom-border-radius-end-start:0;--mod-infield-button-fill-justify-content:flex-end;--mod-infield-button-inner-edge-to-fill:var(--spectrum-stepper-button-edge-to-fill);--mod-infield-button-edge-to-fill:var(--spectrum-stepper-button-edge-to-fill);--mod-textfield-focus-indicator-color:transparent;--mod-textfield-background-color:transparent;--mod-textfield-border-color-hover:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-hover,var(--spectrum-stepper-border-color-hover)))}:host([quiet][focused]:not([disabled])) #textfield,:host([quiet]:not([disabled])) #textfield:focus{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-focus,var(--spectrum-stepper-border-color-focus)))}:host([quiet][keyboard-focused]:not([disabled])) #textfield{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-keyboard-focus,var(--spectrum-stepper-border-color-keyboard-focus)))}@media (hover:hover){:host(:not([disabled]):hover) #textfield{--mod-stepper-border-color:var(--highcontrast-stepper-border-color-hover,var(--mod-stepper-border-color-hover,var(--spectrum-stepper-border-color-hover)))}:host([focused]:not([disabled]):hover) #textfield,:host(:not([disabled]):hover) #textfield:focus{--mod-stepper-border-color:var(--highcontrast-stepper-border-color-focus-hover,var(--mod-stepper-border-color-focus-hover,var(--spectrum-stepper-border-color-focus-hover)));--mod-stepper-buttons-border-color:var(--highcontrast-stepper-border-color-focus-hover,var(--mod-stepper-border-color-focus-hover,var(--spectrum-stepper-border-color-focus-hover)))}:host([quiet]:not([disabled]):hover) #textfield{--mod-stepper-buttons-background-color:transparent}:host(:hover) #textfield:not(.is-invalid,.is-disabled,.is-focused){--mod-infield-button-border-color:var(--mod-stepper-buttons-border-color-hover,var(--spectrum-stepper-buttons-border-color-hover))}:host(:not([disabled])[focused]:hover) #textfield,:host(:not([disabled]):hover) #textfield:focus{--mod-infield-button-border-color:var(--mod-stepper-buttons-border-color-focus-hover,var(--spectrum-stepper-buttons-border-color-focus-hover));--mod-textfield-focus-indicator-width:0;--mod-textfield-border-color:var(--highcontrast-stepper-border-color-focus-hover,var(--mod-stepper-border-color-focus-hover,var(--spectrum-stepper-border-color-focus-hover)))}:host([invalid]:hover) #textfield{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-hover-invalid,var(--spectrum-negative-border-color-hover)))}:host([invalid][focused]:hover) #textfield,:host([invalid]:hover) #textfield:focus{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-focus-hover-invalid,var(--spectrum-stepper-border-color-focus-hover-invalid)))}:host([quiet]:not([disabled]):hover) #textfield{--mod-textfield-border-color-hover:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-hover,var(--spectrum-stepper-border-color-hover)));--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-hover,var(--spectrum-stepper-border-color-hover)))}:host([quiet][focused]:not([disabled]):hover) #textfield,:host([quiet]:not([disabled]):hover) #textfield:focus{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-focus-hover,var(--spectrum-stepper-border-color-focus-hover)))}:host([quiet][keyboard-focused]:not([disabled]):hover) #textfield{--mod-infield-button-border-color:var(--highcontrast-stepper-border-color,var(--mod-stepper-border-color-hover,var(--spectrum-stepper-border-color-hover)))}}#textfield{--spectrum-stepper-width:var(--mod-stepper-width,calc(var(--spectrum-stepper-height)*var(--mod-stepper-min-width-multiplier,var(--spectrum-text-field-minimum-width-multiplier)) + var(--spectrum-stepper-button-width) + var(--mod-stepper-border-width,var(--spectrum-stepper-border-width))*2));inline-size:var(--spectrum-stepper-width);block-size:var(--spectrum-stepper-height);border-radius:var(--spectrum-stepper-border-radius);flex-flow:row;display:inline-flex;position:relative}#textfield:before{content:""}.input{border-inline-end-width:0;border-start-end-radius:0;border-end-end-radius:0}.buttons{box-sizing:border-box;block-size:var(--spectrum-stepper-height);inline-size:var(--spectrum-stepper-button-width);border-color:var(--spectrum-stepper-border-color);border-style:var(--mod-stepper-buttons-border-style,var(--spectrum-stepper-buttons-border-style));border-width:var(--highcontrast-stepper-buttons-border-width,var(--mod-stepper-buttons-border-width,var(--spectrum-stepper-buttons-border-width)));background-color:var(--mod-stepper-buttons-background-color,var(--spectrum-stepper-buttons-background-color));transition:border-color var(--spectrum-stepper-animation-duration)ease-in-out;border-inline-start-width:0;flex-direction:column;justify-content:center;display:flex}.buttons,#textfield.hide-stepper .input{border-start-end-radius:var(--spectrum-stepper-border-radius);border-end-end-radius:var(--spectrum-stepper-border-radius)}#textfield.hide-stepper .input{border-inline-end-width:var(--mod-stepper-border-width,var(--spectrum-stepper-border-width))}:host([quiet]) #textfield{border-start-start-radius:0;border-start-end-radius:0;border-end-end-radius:0;border-end-start-radius:0}:host([quiet]) .hide-stepper .input{border-inline-end-width:0;border-end-end-radius:0}:host([quiet]):after{visibility:hidden;visibility:var(--mod-stepper-focus-indicator-visibility,hidden);content:"";inline-size:100%;block-size:var(--spectrum-stepper-focus-indicator-width);background-color:var(--spectrum-stepper-focus-indicator-color);position:absolute;inset-block-end:calc((var(--spectrum-stepper-focus-indicator-gap) + var(--spectrum-stepper-focus-indicator-width))*-1);inset-inline-start:0}:host([quiet][keyboard-focused]:not([disabled])){outline:none}:host{--spectrum-stepper-border-width:var(--system-stepper-border-width);--spectrum-stepper-border-color-default:var(--system-stepper-border-color-default);--spectrum-stepper-border-color-hover:var(--system-stepper-border-color-hover);--spectrum-stepper-border-color-focus:var(--system-stepper-border-color-focus);--spectrum-stepper-border-color-focus-hover:var(--system-stepper-border-color-focus-hover);--spectrum-stepper-border-color-keyboard-focus:var(--system-stepper-border-color-keyboard-focus);--spectrum-stepper-buttons-border-style:var(--system-stepper-buttons-border-style);--spectrum-stepper-buttons-border-width:var(--system-stepper-buttons-border-width);--spectrum-stepper-buttons-border-color:var(--system-stepper-buttons-border-color);--spectrum-stepper-buttons-background-color:var(--system-stepper-buttons-background-color);--spectrum-stepper-buttons-border-color-hover:var(--system-stepper-buttons-border-color-hover);--spectrum-stepper-buttons-border-color-focus:var(--system-stepper-buttons-border-color-focus);--spectrum-stepper-buttons-border-color-keyboard-focus:var(--system-stepper-buttons-border-color-keyboard-focus);--spectrum-stepper-button-border-width:var(--system-stepper-button-border-width);--spectrum-stepper-border-color-invalid:var(--system-stepper-border-color-invalid);--spectrum-stepper-border-color-focus-invalid:var(--system-stepper-border-color-focus-invalid);--spectrum-stepper-border-color-focus-hover-invalid:var(--system-stepper-border-color-focus-hover-invalid);--spectrum-stepper-border-color-keyboard-focus-invalid:var(--system-stepper-border-color-keyboard-focus-invalid);--spectrum-stepper-border-color-disabled:var(--system-stepper-border-color-disabled);--spectrum-stepper-button-border-width-disabled:var(--system-stepper-button-border-width-disabled);--spectrum-stepper-buttons-background-color-disabled:var(--system-stepper-buttons-background-color-disabled)}:host([quiet]) #textfield{--spectrum-stepper-buttons-border-style:var(--system-stepper-quiet-buttons-border-style);--spectrum-stepper-button-edge-to-fill:var(--system-stepper-quiet-button-edge-to-fill)}:host,:host([size=m]){--spectrum-stepper-button-width:var(--mod-stepper-button-width,var(--spectrum-in-field-button-width-stacked-medium));--spectrum-stepper-height:var(--mod-stepper-height,var(--spectrum-component-height-100))}:host([size=s]){--spectrum-stepper-button-width:var(--mod-stepper-button-width,var(--spectrum-in-field-button-width-stacked-small));--spectrum-stepper-height:var(--mod-stepper-height,var(--spectrum-component-height-75))}:host([size=l]){--spectrum-stepper-button-width:var(--mod-stepper-button-width,var(--spectrum-in-field-button-width-stacked-large));--spectrum-stepper-height:var(--mod-stepper-height,var(--spectrum-component-height-200))}:host([size=xl]){--spectrum-stepper-button-width:var(--mod-stepper-button-width,var(--spectrum-in-field-button-width-stacked-extra-large));--spectrum-stepper-height:var(--mod-stepper-height,var(--spectrum-component-height-300))}:host{--spectrum-stepper-width:calc(var(--mod-stepper-height,var(--spectrum-stepper-height))*var(--mod-stepper-min-width-multiplier,var(--spectrum-text-field-minimum-width-multiplier)) + var(--mod-stepper-button-width,var(--spectrum-stepper-button-width))*2 + var(--mod-stepper-border-width,var(--spectrum-stepper-border-width))*2);inline-size:var(--mod-stepper-width,var(--spectrum-stepper-width))}:host([hide-stepper]){--spectrum-stepper-width:calc(var(--mod-stepper-height,var(--spectrum-stepper-height))*var(--mod-stepper-min-width-multiplier,var(--spectrum-text-field-minimum-width-multiplier)) + var(--mod-stepper-button-width,var(--spectrum-stepper-button-width)) + var(--mod-stepper-border-width,var(--spectrum-stepper-border-width))*2)}#textfield{inline-size:100%}.input{font-variant-numeric:tabular-nums}:host([readonly]) .buttons{pointer-events:none;visibility:hidden}:host([readonly]:not([disabled],[invalid],[focused],[keyboard-focused])) #textfield:hover .input{border-color:#0000}:host([hide-stepper]:not([quiet])) #textfield input{border:var(--mod-textfield-border-width,var(--spectrum-textfield-border-width))solid var(--mod-textfield-border-color,var(--spectrum-textfield-border-color));border-radius:var(--spectrum-textfield-corner-radius)}:host([quiet]) #textfield .button{--mod-infield-button-border-color:var(--mod-infield-border-color-quiet,transparent);--mod-infield-button-edge-to-fill:0;--mod-infield-button-border-width:var(--mod-infield-button-border-width-quiet,0)}:host([focused]:not([disabled])) #textfield:hover{--mod-stepper-buttons-border-color-focus-hover:var(--mod-stepper-border-color-focus-hover,var(--spectrum-stepper-border-color-focus-hover))}:host([invalid]:not([hide-stepper])) #textfield .icon,:host([valid]:not([hide-stepper])) #textfield .icon{inset-inline-end:calc(var(--spectrum-stepper-button-width) + var(--spectrum-textfield-icon-spacing-inline-end-invalid))}:host([invalid]) .input{padding-inline-end:calc(var(--mod-textfield-icon-spacing-inline-start-valid,var(--spectrum-textfield-icon-spacing-inline-start-valid)) + var(--mod-textfield-icon-size-valid,var(--spectrum-textfield-icon-size-valid)) + var(--mod-textfield-icon-spacing-inline-end-valid,var(--spectrum-textfield-icon-spacing-inline-end-valid)) - var(--mod-textfield-border-width,var(--spectrum-textfield-border-width)))}
`;
var number_field_css_default = e23;

// node_modules/@spectrum-web-components/number-field/src/NumberField.js
init_src2();
var y4 = Object.defineProperty;
var F = Object.getOwnPropertyDescriptor;
var a6 = (o52, p30, e36, t34) => {
  for (var s19 = t34 > 1 ? void 0 : t34 ? F(p30, e36) : p30, i21 = o52.length - 1, r25; i21 >= 0; i21--) (r25 = o52[i21]) && (s19 = (t34 ? r25(p30, e36, s19) : r25(s19)) || s19);
  return t34 && s19 && y4(p30, e36, s19), s19;
};
var FRAMES_PER_CHANGE = 5;
var CHANGE_DEBOUNCE_MS = 100;
var indeterminatePlaceholder = "-";
var remapMultiByteCharacters = { "\uFF11": "1", "\uFF12": "2", "\uFF13": "3", "\uFF14": "4", "\uFF15": "5", "\uFF16": "6", "\uFF17": "7", "\uFF18": "8", "\uFF19": "9", "\uFF10": "0", "\u3001": ",", "\uFF0C": ",", "\u3002": ".", "\uFF0E": ".", "\uFF05": "%", "\uFF0B": "+", \u30FC: "-", \u4E00: "1", \u4E8C: "2", \u4E09: "3", \u56DB: "4", \u4E94: "5", \u516D: "6", \u4E03: "7", \u516B: "8", \u4E5D: "9", \u96F6: "0" };
var g5 = { s: (o52) => x`
        <sp-icon-chevron50
            class="stepper-icon spectrum-UIIcon-Chevron${o52}50"
        ></sp-icon-chevron50>
    `, m: (o52) => x`
        <sp-icon-chevron75
            class="stepper-icon spectrum-UIIcon-Chevron${o52}75"
        ></sp-icon-chevron75>
    `, l: (o52) => x`
        <sp-icon-chevron100
            class="stepper-icon spectrum-UIIcon-Chevron${o52}100"
        ></sp-icon-chevron100>
    `, xl: (o52) => x`
        <sp-icon-chevron200
            class="stepper-icon spectrum-UIIcon-Chevron${o52}200"
        ></sp-icon-chevron200>
    ` };
var NumberField = class extends TextfieldBase {
  constructor() {
    super(...arguments);
    this.focused = false;
    this._forcedUnit = "";
    this.formatOptions = {};
    this.hideStepper = false;
    this.indeterminate = false;
    this.keyboardFocused = false;
    this.managedInput = false;
    this.stepModifier = 10;
    this._value = NaN;
    this._trackingValue = "";
    this.decimalsChars = /* @__PURE__ */ new Set([".", ","]);
    this.valueBeforeFocus = "";
    this.isIntentDecimal = false;
    this.changeCount = 0;
    this.languageResolver = new LanguageResolutionController(this);
    this.wasIndeterminate = false;
    this.hasRecentlyReceivedPointerDown = false;
    this.applyFocusElementLabel = (e36) => {
      this.appliedLabel = e36;
    };
    this.isComposing = false;
  }
  static get styles() {
    return [...super.styles, number_field_css_default, spectrum_icon_chevron_css_default];
  }
  set value(e36) {
    const t34 = this.validateInput(e36);
    if (t34 === this.value) return;
    this.lastCommitedValue = t34;
    const s19 = this._value;
    this._value = t34, this.requestUpdate("value", s19);
  }
  get value() {
    return this._value;
  }
  get inputValue() {
    return this.indeterminate ? this.formattedValue : this.inputElement.value;
  }
  setValue(e36 = this.value) {
    const t34 = this.lastCommitedValue;
    this.value = e36, !(typeof t34 == "undefined" || t34 === this.value) && (this.lastCommitedValue = this.value, this.dispatchEvent(new Event("change", { bubbles: true, composed: true })));
  }
  get valueAsString() {
    return this._value.toString();
  }
  set valueAsString(e36) {
    this.value = this.numberParser.parse(e36);
  }
  get formattedValue() {
    return isNaN(this.value) ? "" : this.numberFormatter.format(this.value) + (this.focused ? "" : this._forcedUnit);
  }
  convertValueToNumber(e36) {
    let t34 = e36.split("").map((r25) => remapMultiByteCharacters[r25] || r25).join("");
    const s19 = this.valueBeforeFocus.split("").filter((r25) => this.decimalsChars.has(r25)), i21 = new Set(s19);
    if (isIOS() && this.inputElement.inputMode === "decimal" && t34 !== this.valueBeforeFocus) {
      const d22 = this.numberFormatter.formatToParts(1000.1).find((n25) => n25.type === "decimal").value;
      for (const n25 of i21) !(n25 === d22) && !this.isIntentDecimal && (t34 = t34.replace(new RegExp(n25, "g"), ""));
      let m18 = false;
      const l16 = t34.split("");
      for (let n25 = l16.length - 1; n25 >= 0; n25--) {
        const f11 = l16[n25];
        this.decimalsChars.has(f11) && (m18 ? l16[n25] = "" : (l16[n25] = d22, m18 = true));
      }
      t34 = l16.join("");
    }
    return this.numberParser.parse(t34);
  }
  get _step() {
    var e36;
    return typeof this.step != "undefined" ? this.step : ((e36 = this.formatOptions) == null ? void 0 : e36.style) === "percent" ? 0.01 : 1;
  }
  handlePointerdown(e36) {
    if (e36.button !== 0) {
      e36.preventDefault();
      return;
    }
    this.managedInput = true, this.buttons.setPointerCapture(e36.pointerId);
    const t34 = this.buttons.children[0].getBoundingClientRect(), s19 = this.buttons.children[1].getBoundingClientRect();
    this.findChange = (i21) => {
      i21.clientX >= t34.x && i21.clientY >= t34.y && i21.clientX <= t34.x + t34.width && i21.clientY <= t34.y + t34.height ? this.change = (r25) => this.increment(r25.shiftKey ? this.stepModifier : 1) : i21.clientX >= s19.x && i21.clientY >= s19.y && i21.clientX <= s19.x + s19.width && i21.clientY <= s19.y + s19.height && (this.change = (r25) => this.decrement(r25.shiftKey ? this.stepModifier : 1));
    }, this.findChange(e36), this.startChange(e36);
  }
  startChange(e36) {
    this.changeCount = 0, this.doChange(e36), this.safty = setTimeout(() => {
      this.doNextChange(e36);
    }, 400);
  }
  doChange(e36) {
    this.change(e36);
  }
  handlePointermove(e36) {
    this.findChange(e36);
  }
  handlePointerup(e36) {
    this.buttons.releasePointerCapture(e36.pointerId), cancelAnimationFrame(this.nextChange), clearTimeout(this.safty), this.managedInput = false, this.setValue();
  }
  doNextChange(e36) {
    return this.changeCount += 1, this.changeCount % FRAMES_PER_CHANGE === 0 && this.doChange(e36), requestAnimationFrame(() => {
      this.nextChange = this.doNextChange(e36);
    });
  }
  stepBy(e36) {
    if (this.disabled || this.readonly) return;
    const t34 = typeof this.min != "undefined" ? this.min : 0;
    let s19 = this.value;
    s19 += e36 * this._step, isNaN(this.value) && (s19 = t34), s19 = this.valueWithLimits(s19), this.requestUpdate(), this._value = this.validateInput(s19), this.inputElement.value = this.numberFormatter.format(s19);
    const i21 = new Event("input", { bubbles: true, composed: true });
    this.inputElement.readOnly = true, this.inputElement.dispatchEvent(i21), this.indeterminate = false, this.focus(), this.inputElement.readOnly = false;
  }
  increment(e36 = 1) {
    this.stepBy(1 * e36);
  }
  decrement(e36 = 1) {
    this.stepBy(-1 * e36);
  }
  handleKeydown(e36) {
    if (!this.isComposing) switch (e36.code) {
      case "ArrowUp":
        e36.preventDefault(), this.increment(e36.shiftKey ? this.stepModifier : 1), this.setValue();
        break;
      case "ArrowDown":
        e36.preventDefault(), this.decrement(e36.shiftKey ? this.stepModifier : 1), this.setValue();
        break;
    }
  }
  onScroll(e36) {
    e36.preventDefault(), this.managedInput = true;
    const t34 = e36.shiftKey ? e36.deltaX / Math.abs(e36.deltaX) : e36.deltaY / Math.abs(e36.deltaY);
    t34 !== 0 && !isNaN(t34) && (this.stepBy(t34 * (e36.shiftKey ? this.stepModifier : 1)), clearTimeout(this.queuedChangeEvent), this.queuedChangeEvent = setTimeout(() => {
      this.setValue();
    }, CHANGE_DEBOUNCE_MS)), this.managedInput = false;
  }
  onFocus() {
    super.onFocus(), this._trackingValue = this.inputValue, this.keyboardFocused = !this.readonly && true, this.addEventListener("wheel", this.onScroll, { passive: false }), this.valueBeforeFocus = this.inputElement.value;
  }
  onBlur(e36) {
    super.onBlur(e36), this.keyboardFocused = !this.readonly && false, this.removeEventListener("wheel", this.onScroll), this.isIntentDecimal = false;
  }
  handleFocusin() {
    this.focused = !this.readonly && true, this.keyboardFocused = !this.readonly && true;
  }
  handleFocusout() {
    this.focused = !this.readonly && false, this.keyboardFocused = !this.readonly && false;
  }
  handleChange() {
    const e36 = this.convertValueToNumber(this.inputValue);
    if (this.wasIndeterminate && (this.wasIndeterminate = false, this.indeterminateValue = void 0, isNaN(e36))) {
      this.indeterminate = true;
      return;
    }
    this.setValue(e36), this.inputElement.value = this.formattedValue;
  }
  handleCompositionStart() {
    this.isComposing = true;
  }
  handleCompositionEnd() {
    this.isComposing = false, requestAnimationFrame(() => {
      this.inputElement.dispatchEvent(new Event("input", { composed: true, bubbles: true }));
    });
  }
  handleInputElementPointerdown() {
    this.hasRecentlyReceivedPointerDown = true, this.updateComplete.then(() => {
      requestAnimationFrame(() => {
        this.hasRecentlyReceivedPointerDown = false;
      });
    });
  }
  handleInput(e36) {
    var l16;
    if (this.isComposing) {
      if (e36.data) {
        const n25 = this.convertValueToNumber(e36.data);
        Number.isNaN(n25) && (this.inputElement.value = this.indeterminate ? indeterminatePlaceholder : this._trackingValue, this.isComposing = false);
      }
      e36.stopPropagation();
      return;
    }
    this.indeterminate && (this.wasIndeterminate = true, this.indeterminateValue = this.value, this.inputElement.value = this.inputElement.value.replace(indeterminatePlaceholder, "")), e36.data && this.decimalsChars.has(e36.data) && (this.isIntentDecimal = true);
    const { value: t34, selectionStart: s19 } = this.inputElement, i21 = t34.split("").map((n25) => remapMultiByteCharacters[n25] || n25).join("");
    if (this.numberParser.isValidPartialNumber(i21)) {
      this.lastCommitedValue = (l16 = this.lastCommitedValue) != null ? l16 : this.value;
      const n25 = this.convertValueToNumber(i21);
      !i21 && this.indeterminateValue ? (this.indeterminate = true, this._value = this.indeterminateValue) : (this.indeterminate = false, this._value = this.validateInput(n25)), this._trackingValue = i21, this.inputElement.value = i21, this.inputElement.setSelectionRange(s19, s19);
      return;
    } else this.inputElement.value = this.indeterminate ? indeterminatePlaceholder : this._trackingValue, e36.stopPropagation();
    const r25 = i21.length, d22 = this._trackingValue.length, m18 = (s19 || r25) - (r25 - d22);
    this.inputElement.setSelectionRange(m18, m18);
  }
  valueWithLimits(e36) {
    let t34 = e36;
    return typeof this.min != "undefined" && (t34 = Math.max(this.min, t34)), typeof this.max != "undefined" && (t34 = Math.min(this.max, t34)), t34;
  }
  validateInput(e36) {
    e36 = this.valueWithLimits(e36);
    const t34 = e36 < 0 ? -1 : 1;
    if (e36 *= t34, this.step) {
      const s19 = typeof this.min != "undefined" ? this.min : 0, i21 = parseFloat(this.valueFormatter.format((e36 - s19) % this.step));
      if (i21 === 0 || (Math.round(i21 / this.step) === 1 ? e36 += this.step - i21 : e36 -= i21), typeof this.max != "undefined") for (; e36 > this.max; ) e36 -= this.step;
      e36 = parseFloat(this.valueFormatter.format(e36));
    }
    return e36 *= t34, e36;
  }
  get displayValue() {
    const e36 = this.focused ? "" : indeterminatePlaceholder;
    return this.indeterminate ? e36 : this.formattedValue;
  }
  clearNumberFormatterCache() {
    this._numberFormatter = void 0, this._numberParser = void 0;
  }
  get numberFormatter() {
    if (!this._numberFormatter || !this._numberFormatterFocused) {
      const { style: e36, unit: t34, unitDisplay: s19, ...i21 } = this.formatOptions;
      e36 !== "unit" && (i21.style = e36), this._numberFormatterFocused = new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(this.languageResolver.language, i21);
      try {
        this._numberFormatter = new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(this.languageResolver.language, this.formatOptions), this._forcedUnit = "", this._numberFormatter.format(1);
      } catch (r25) {
        e36 === "unit" && (this._forcedUnit = t34), this._numberFormatter = this._numberFormatterFocused;
      }
    }
    return this.focused ? this._numberFormatterFocused : this._numberFormatter;
  }
  clearValueFormatterCache() {
    this._valueFormatter = void 0;
  }
  get valueFormatter() {
    if (!this._valueFormatter) {
      const e36 = this.step && this.step != Math.floor(this.step) ? this.step.toString().split(".")[1].length : 0;
      this._valueFormatter = new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5("en", { useGrouping: false, maximumFractionDigits: e36 });
    }
    return this._valueFormatter;
  }
  get numberParser() {
    if (!this._numberParser || !this._numberParserFocused) {
      const { style: e36, unit: t34, unitDisplay: s19, ...i21 } = this.formatOptions;
      e36 !== "unit" && (i21.style = e36), this._numberParserFocused = new $6c7bd7858deea686$export$cd11ab140839f11d(this.languageResolver.language, i21);
      try {
        this._numberParser = new $6c7bd7858deea686$export$cd11ab140839f11d(this.languageResolver.language, this.formatOptions), this._forcedUnit = "", this._numberParser.parse("0");
      } catch (r25) {
        e36 === "unit" && (this._forcedUnit = t34), this._numberParser = this._numberParserFocused;
      }
    }
    return this.focused ? this._numberParserFocused : this._numberParser;
  }
  renderField() {
    return this.autocomplete = "off", x`
            ${super.renderField()}
            ${this.hideStepper ? E : x`
                      <span
                          class="buttons"
                          @focusin=${this.handleFocusin}
                          @focusout=${this.handleFocusout}
                          ${streamingListener({ start: ["pointerdown", this.handlePointerdown], streamInside: [["pointermove", "pointerenter", "pointerleave", "pointerover", "pointerout"], this.handlePointermove], end: [["pointerup", "pointercancel", "pointerleave"], this.handlePointerup] })}
                      >
                          <sp-infield-button
                              inline="end"
                              block="start"
                              class="button step-up"
                              aria-hidden="true"
                              label=${"Increase " + this.appliedLabel}
                              size=${this.size}
                              tabindex="-1"
                              ?focused=${this.focused}
                              ?disabled=${this.disabled || this.readonly || typeof this.max != "undefined" && this.value === this.max}
                              ?quiet=${this.quiet}
                          >
                              ${g5[this.size]("Up")}
                          </sp-infield-button>
                          <sp-infield-button
                              inline="end"
                              block="end"
                              class="button step-down"
                              aria-hidden="true"
                              label=${"Decrease " + this.appliedLabel}
                              size=${this.size}
                              tabindex="-1"
                              ?focused=${this.focused}
                              ?disabled=${this.disabled || this.readonly || typeof this.min != "undefined" && this.value === this.min}
                              ?quiet=${this.quiet}
                          >
                              ${g5[this.size]("Down")}
                          </sp-infield-button>
                      </span>
                  `}
        `;
  }
  update(e36) {
    if ((e36.has("formatOptions") || e36.has("resolvedLanguage")) && this.clearNumberFormatterCache(), e36.has("value") || e36.has("max") || e36.has("min") || e36.has("step")) {
      const t34 = this.numberParser.parse(this.formattedValue.replace(this._forcedUnit, ""));
      this.value = t34, this.clearValueFormatterCache();
    }
    super.update(e36);
  }
  willUpdate(e36) {
    this.multiline = false, e36.has(languageResolverUpdatedSymbol) && this.clearNumberFormatterCache();
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.addEventListener("keydown", this.handleKeydown), this.addEventListener("compositionstart", this.handleCompositionStart), this.addEventListener("compositionend", this.handleCompositionEnd);
  }
  updated(e36) {
    if (!(!this.inputElement || !this.isConnected)) {
      if (e36.has("min") || e36.has("formatOptions")) {
        const t34 = typeof this.min != "undefined" && this.min >= 0, { maximumFractionDigits: s19 } = this.numberFormatter.resolvedOptions(), i21 = s19 && s19 > 0;
        let r25 = "numeric";
        isIPhone() && !t34 ? r25 = "text" : (isIOS() && i21 || isAndroid() && i21 && t34) && (r25 = "decimal"), this.inputElement.inputMode = r25;
      }
      e36.has("focused") && this.focused && !this.hasRecentlyReceivedPointerDown && this.formatOptions.unit && this.setSelectionRange(0, this.displayValue.length);
    }
  }
};
a6([e5(".buttons")], NumberField.prototype, "buttons", 2), a6([n4({ type: Boolean, reflect: true })], NumberField.prototype, "focused", 2), a6([n4({ type: Object, attribute: "format-options" })], NumberField.prototype, "formatOptions", 2), a6([n4({ type: Boolean, reflect: true, attribute: "hide-stepper" })], NumberField.prototype, "hideStepper", 2), a6([n4({ type: Boolean, reflect: true })], NumberField.prototype, "indeterminate", 2), a6([n4({ type: Boolean, reflect: true, attribute: "keyboard-focused" })], NumberField.prototype, "keyboardFocused", 2), a6([n4({ type: Number })], NumberField.prototype, "max", 2), a6([n4({ type: Number })], NumberField.prototype, "min", 2), a6([n4({ type: Number })], NumberField.prototype, "step", 2), a6([n4({ type: Number, reflect: true, attribute: "step-modifier" })], NumberField.prototype, "stepModifier", 2), a6([n4({ type: Number })], NumberField.prototype, "value", 1);

// node_modules/@spectrum-web-components/number-field/sp-number-field.js
init_define_element();
defineElement("sp-number-field", NumberField);

// node_modules/@spectrum-web-components/textfield/sp-textfield.js
init_define_element();
defineElement("sp-textfield", Textfield);

// src/features/editor/utils/selection-attribute.js
var resolveEditorStore = (store) => {
  if (store) return store;
  const editor = document.querySelector("experience-elements-editor");
  return editor?.editorStore || null;
};
var applyAttributeToSelection = ({ store, attr, value }) => {
  const editorStore = resolveEditorStore(store);
  if (!editorStore) return;
  const target = editorStore?.editingElement || null;
  if (!target) return;
  const name = (attr || "").trim();
  if (!target || !name) return;
  const normalized = typeof value === "string" ? value.trim() : value;
  if (!normalized) {
    target.removeAttribute(name);
  } else {
    target.setAttribute(name, String(normalized));
  }
  editorStore.scheduleSnapshot?.();
};

// src/custom-elements/core/spectrum-color-palette.js
var SpectrumColorPalette = class extends i4 {
  static properties = {
    color: { type: String, reflect: true },
    // Editor store for direct updates (optional; will resolve from editor context if not provided)
    store: { type: Object, attribute: false },
    // Attribute name to write on the current editing element
    attr: { type: String },
    swatchSize: { type: Number, attribute: "swatch-size" },
    includeInherit: { type: Boolean, attribute: "include-inherit", converter: booleanConverter },
    label: { type: String },
    allowGradient: { type: Boolean, attribute: "allow-gradient", converter: booleanConverter }
  };
  static styles = i`
    :host {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      text-align: left;
      background-color: var(--spectrum-alias-component-background-color);
      box-sizing: border-box;
      padding: 2px 2px; /* unify with icon palette */
      border-radius: var(--spectrum-global-dimension-size-100);
    }

    button.swatch {
      display: inline-block;
      border: 1px solid var(--spectrum-global-color-gray-200);
      padding: 0;
      margin: 0 2px; /* remove vertical margin to normalize height */
      width: 34px; /* 10% smaller baseline */
      height: 34px; /* 10% smaller baseline */
      cursor: pointer;
      background: transparent;
      vertical-align: middle;
    }

    overlay-trigger[placement="bottom-start"] {
      display: inline-block;
      vertical-align: middle;
    }
    button.swatch[aria-current="true"] {
      outline: 2px solid var(--spectrum-global-color-blue-600);
    }
    /* Inherit swatch: show a neutral placeholder tile */
    button.swatch.inherit {
      background: var(--spectrum-global-color-gray-75);
      border-color: var(--spectrum-global-color-gray-300);
      position: relative;
    }
    button.swatch.inherit::after {
      content: "";
      position: absolute;
      inset: 20%;
      border-radius: var(--spectrum-global-dimension-size-50);
      background: var(--spectrum-global-color-gray-200);
      border: 1px solid var(--spectrum-global-color-gray-400);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    /* Popover content layout */
    .popover-content {
      background-color: var(--spectrum-global-color-gray-50);
      padding: var(--spectrum-global-dimension-size-200);
      max-height: 75vh;
      overflow: auto;
    }
    .inherit-row {
      display: flex;
      align-items: center;
      gap: var(--spectrum-global-dimension-size-150);
      margin-bottom: var(--spectrum-global-dimension-size-200);
    }
    table.color-table {
      border-collapse: separate;
      border-spacing: 6px;
    }
    table.color-table thead th {
      font-size: 11px;
      font-weight: 600;
      color: var(--spectrum-global-color-gray-800);
      text-align: center;
      padding: 2px 4px;
      white-space: nowrap;
    }
    table.color-table tbody th {
      font-size: 12px;
      font-weight: 500;
      color: var(--spectrum-global-color-gray-900);
      text-align: left;
      padding: 2px 6px;
      white-space: nowrap;
    }
    table.color-table td {
      padding: 0;
      text-align: center;
    }
    /* Swatch icon used inside the action button */
    .button-swatch {
      display: inline-block;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      box-sizing: border-box;
      border: 1px solid var(--spectrum-global-color-gray-300);
      background-clip: padding-box;
    }
    .mode-toggle {
      display: flex;
      justify-content: flex-start;
      margin-bottom: var(--spectrum-global-dimension-size-150);
    }
    .gradient-editor {
      display: grid;
      gap: var(--spectrum-global-dimension-size-200);
    }
    .gradient-stop-group sp-action-button {
      min-width: 0;
    }
    .stop-chip {
      display: inline-block;
      width: 18px;
      height: 18px;
      border-radius: var(--spectrum-global-dimension-size-50);
      border: 1px solid var(--spectrum-global-color-gray-300);
      margin-right: var(--spectrum-global-dimension-size-100);
      box-sizing: border-box;
    }
    .gradient-stop-fields {
      display: grid;
      gap: var(--spectrum-global-dimension-size-150);
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .gradient-cta-row {
      display: flex;
      gap: var(--spectrum-global-dimension-size-150);
      flex-wrap: wrap;
    }
    .gradient-swatches {
      padding-top: var(--spectrum-global-dimension-size-200);
      border-top: 1px solid var(--spectrum-global-color-gray-200);
    }
    .gradient-token-grid {
      overflow-x: auto;
    }
  `;
  constructor() {
    super();
    this.color = "";
    this.attr = "color";
    this.swatchSize = 29;
    this.includeInherit = true;
    this.allowGradient = false;
    this.#gradientState = this.#defaultGradient();
    this.#previousSolidValue = "";
  }
  #expanded = false;
  #mode = "solid";
  #gradientState = null;
  #activeStopIndex = 0;
  #previousSolidValue = "";
  get #tones() {
    return [
      100,
      200,
      300,
      400,
      500,
      600,
      700,
      800,
      900,
      1e3,
      1100,
      1200,
      1300,
      1400
    ];
  }
  get #mainColors() {
    return ["yellow", "green", "blue", "red"];
  }
  get #allColors() {
    const others = [
      "gray",
      "orange",
      "chartreuse",
      "celery",
      "seafoam",
      "indigo",
      "purple",
      "fuchsia",
      "magenta"
    ];
    return [...this.#mainColors, ...others];
  }
  get #orderedColors() {
    return this.#allColors;
  }
  get #selectedToken() {
    const value = (this.color || "").trim();
    if (!value || this.#isGradient(value)) return "";
    if (value === "rgb(0,0,0)" || value === "#000000" || value === "#000") return "black";
    const match = value.match(/^var\((--[^)]+)\)$/);
    if (match) return match[1];
    return value;
  }
  #defaultGradient() {
    return {
      angle: 135,
      stops: [
        { color: "var(--spectrum-global-color-blue-600)", position: 0 },
        { color: "var(--spectrum-global-color-purple-700)", position: 100 }
      ]
    };
  }
  #isGradient(value) {
    if (typeof value !== "string") return false;
    const trimmed = value.trim().toLowerCase();
    return trimmed.startsWith("linear-gradient");
  }
  #normalizeCssValue(value) {
    if (!value) return "";
    const trimmed = value.trim();
    if (!trimmed) return "";
    if (this.#isGradient(trimmed)) return trimmed;
    if (trimmed.startsWith("var(")) return trimmed;
    if (trimmed.startsWith("--")) {
      return `var(${trimmed})`;
    }
    return trimmed;
  }
  #tokenFromCssValue(value) {
    if (!value) return "";
    const match = value.match(/^var\((--[^)]+)\)$/);
    if (match) return match[1];
    return value;
  }
  #selectedDisplayValue() {
    if (this.#mode === "gradient" && this.allowGradient) {
      return this.#buildGradientCss();
    }
    const token = this.#selectedToken;
    if (!token) {
      const value = (this.color || "").trim();
      return value && !this.#isGradient(value) ? value : "";
    }
    return token.startsWith("--") ? `var(${token})` : token;
  }
  #clampAngle(angle) {
    const fixed = Number(angle);
    if (!Number.isFinite(fixed)) return 0;
    const mod = fixed % 360;
    return mod < 0 ? mod + 360 : mod;
  }
  #clampPosition(position) {
    const fixed = Number(position);
    if (!Number.isFinite(fixed)) return 0;
    return Math.min(100, Math.max(0, fixed));
  }
  #defaultStopPosition(index, total) {
    if (index <= 0) return 0;
    if (index >= total - 1) return 100;
    const step = 100 / (total - 1);
    return Math.round(step * index);
  }
  #normalizeAngle(input) {
    const value = (input || "").trim().toLowerCase();
    if (!value) return 180;
    const match = value.match(/(-?\d+(?:\.\d+)?)\s*deg/);
    if (match) return this.#clampAngle(Number(match[1]));
    switch (value) {
      case "to top":
        return 0;
      case "to top right":
      case "to right top":
        return 45;
      case "to right":
        return 90;
      case "to bottom right":
      case "to right bottom":
        return 135;
      case "to bottom":
        return 180;
      case "to bottom left":
      case "to left bottom":
        return 225;
      case "to left":
        return 270;
      case "to top left":
      case "to left top":
        return 315;
      default:
        return 180;
    }
  }
  #parseGradientStop(stop, index, total) {
    const raw = (stop || "").trim();
    if (!raw) return null;
    const match = raw.match(/^(.*?)(?:\s+(-?\d+(?:\.\d+)?))?(?:%|\s*)$/);
    const colorPart = (match?.[1] || "").trim();
    if (!colorPart) return null;
    const color = this.#normalizeCssValue(colorPart);
    if (!color) return null;
    const hasPosition = match && match[2] !== void 0;
    const position = hasPosition ? this.#clampPosition(Number(match[2])) : this.#defaultStopPosition(index, total);
    return { color, position };
  }
  #parseGradient(value) {
    const trimmed = (value || "").trim();
    if (!this.#isGradient(trimmed)) {
      return this.#defaultGradient();
    }
    const start = trimmed.indexOf("(");
    const end = trimmed.lastIndexOf(")");
    if (start === -1 || end === -1) {
      return this.#defaultGradient();
    }
    const body = trimmed.slice(start + 1, end);
    const segments = [];
    let depth = 0;
    let current = "";
    for (const ch of body) {
      if (ch === "(") {
        depth += 1;
      } else if (ch === ")") {
        depth = Math.max(0, depth - 1);
      }
      if (ch === "," && depth === 0) {
        segments.push(current.trim());
        current = "";
        continue;
      }
      current += ch;
    }
    if (current.trim()) {
      segments.push(current.trim());
    }
    if (!segments.length) {
      return this.#defaultGradient();
    }
    let angle = 180;
    let stopSegments = segments;
    const first = segments[0] || "";
    if (/deg/i.test(first) || /^to\s+/i.test(first)) {
      angle = this.#normalizeAngle(first);
      stopSegments = segments.slice(1);
    }
    const total = stopSegments.length;
    const stops = stopSegments.map((segment, index) => this.#parseGradientStop(segment, index, total)).filter((stop) => stop !== null);
    if (stops.length < 2) {
      return { angle, stops: this.#defaultGradient().stops };
    }
    return { angle, stops };
  }
  #ensureGradientState() {
    if (!this.#gradientState || !Array.isArray(this.#gradientState.stops)) {
      this.#gradientState = this.#defaultGradient();
    }
    if (!Array.isArray(this.#gradientState.stops) || this.#gradientState.stops.length < 2) {
      this.#gradientState = this.#defaultGradient();
    }
    if (this.#activeStopIndex >= this.#gradientState.stops.length) {
      this.#activeStopIndex = this.#gradientState.stops.length - 1;
    }
    if (this.#activeStopIndex < 0) {
      this.#activeStopIndex = 0;
    }
  }
  #buildGradientCss() {
    this.#ensureGradientState();
    const angle = this.#clampAngle(this.#gradientState.angle ?? 180);
    const sortedStops = [...this.#gradientState.stops || []].sort(
      (a23, b12) => this.#clampPosition(a23.position) - this.#clampPosition(b12.position)
    );
    const stopParts = sortedStops.map((stop) => {
      const color = stop.color || "";
      const position = this.#clampPosition(stop.position);
      return `${color} ${position}%`;
    });
    return `linear-gradient(${angle}deg, ${stopParts.join(", ")})`;
  }
  #applyGradientUpdate() {
    const css = this.#buildGradientCss();
    this.color = css;
    this.applyToEditingElement(css);
  }
  #setGradientStopColor(index, cssValue) {
    this.#ensureGradientState();
    const stops = [...this.#gradientState.stops];
    if (!stops[index]) return;
    stops[index] = {
      ...stops[index],
      color: cssValue || stops[index].color
    };
    this.#gradientState = { ...this.#gradientState, stops };
    this.#applyGradientUpdate();
    this.requestUpdate();
  }
  #setGradientStopPosition(index, position) {
    this.#ensureGradientState();
    const stops = [...this.#gradientState.stops];
    if (!stops[index]) return;
    stops[index] = {
      ...stops[index],
      position: this.#clampPosition(position)
    };
    this.#gradientState = { ...this.#gradientState, stops };
    this.#applyGradientUpdate();
    this.requestUpdate();
  }
  #setGradientAngle(angle) {
    this.#ensureGradientState();
    const clamped = this.#clampAngle(angle);
    this.#gradientState = { ...this.#gradientState, angle: clamped };
    this.#applyGradientUpdate();
    this.requestUpdate();
  }
  #selectGradientStop(index) {
    this.#ensureGradientState();
    const next = Math.max(0, Math.min(index, this.#gradientState.stops.length - 1));
    if (this.#activeStopIndex === next) return;
    this.#activeStopIndex = next;
    this.requestUpdate();
  }
  #addGradientStop() {
    this.#ensureGradientState();
    const stops = [...this.#gradientState.stops];
    if (stops.length >= 5) return;
    const currentIndex = Math.max(
      0,
      Math.min(this.#activeStopIndex, stops.length - 1)
    );
    const current = stops[currentIndex];
    const next = stops[currentIndex + 1] || stops[stops.length - 1];
    const start = this.#clampPosition(current?.position ?? 0);
    const end = this.#clampPosition(next?.position ?? 100);
    const position = this.#clampPosition((start + end) / 2);
    const newStop = {
      color: current?.color || "var(--spectrum-global-color-blue-600)",
      position
    };
    stops.splice(currentIndex + 1, 0, newStop);
    this.#gradientState = { ...this.#gradientState, stops };
    this.#activeStopIndex = currentIndex + 1;
    this.#applyGradientUpdate();
    this.requestUpdate();
  }
  #removeGradientStop() {
    this.#ensureGradientState();
    const stops = [...this.#gradientState.stops];
    if (stops.length <= 2) return;
    stops.splice(this.#activeStopIndex, 1);
    this.#activeStopIndex = Math.max(0, this.#activeStopIndex - 1);
    this.#gradientState = { ...this.#gradientState, stops };
    this.#applyGradientUpdate();
    this.requestUpdate();
  }
  #setMode(mode) {
    if (mode === this.#mode) return;
    if (mode === "gradient" && !this.allowGradient) {
      return;
    }
    if (mode === "gradient") {
      if (!this.#isGradient(this.color)) {
        const base2 = this.#selectedDisplayValue() || "var(--spectrum-global-color-blue-600)";
        this.#gradientState = {
          angle: this.#gradientState?.angle ?? 135,
          stops: [
            { color: base2, position: 0 },
            { color: base2, position: 100 }
          ]
        };
        this.#activeStopIndex = 0;
        this.#applyGradientUpdate();
      } else {
        this.#gradientState = this.#parseGradient(this.color);
      }
      this.#mode = "gradient";
    } else {
      this.#mode = "solid";
      const restore = (this.#previousSolidValue || "").trim();
      this.color = restore;
      this.applyToEditingElement(restore);
    }
    this.requestUpdate();
  }
  #handleStopColorInput(event, index) {
    const value = this.#normalizeCssValue(event?.target?.value || "");
    if (!value) return;
    this.#setGradientStopColor(index, value);
  }
  #handleStopPositionInput(event, index) {
    const raw = event?.target?.value;
    const position = raw === "" ? 0 : Number(raw);
    this.#setGradientStopPosition(index, position);
  }
  #handleAngleInput(event) {
    const raw = event?.target?.value;
    const angle = raw === "" ? 0 : Number(raw);
    this.#setGradientAngle(angle);
  }
  #handleSwatchSelection(event, token, onSelect) {
    event.preventDefault();
    event.stopPropagation();
    if (typeof event.stopImmediatePropagation === "function") {
      event.stopImmediatePropagation();
    }
    if (typeof onSelect === "function") {
      onSelect(token);
    }
  }
  willUpdate(changed) {
    if (changed.has("color")) {
      const value = (this.color || "").trim();
      if (this.allowGradient && this.#isGradient(value)) {
        this.#mode = "gradient";
        this.#gradientState = this.#parseGradient(value);
      } else {
        if (value) {
          this.#previousSolidValue = value;
        }
        if (this.#mode !== "solid") {
          this.#mode = "solid";
        }
      }
    }
  }
  handlePick(token) {
    const cssValue = this.#normalizeCssValue(token || "");
    this.#mode = "solid";
    this.color = cssValue;
    this.#previousSolidValue = cssValue;
    this.applyToEditingElement(cssValue);
  }
  toggleMore() {
    this.#expanded = !this.#expanded;
  }
  renderSwatch(token, options = {}) {
    const size3 = `${this.swatchSize}px`;
    const selectedToken = options.selectedToken ?? this.#selectedToken;
    const onSelect = typeof options.onSelect === "function" ? options.onSelect : (nextToken) => this.handlePick(nextToken);
    const isCurrent = token ? selectedToken === token : !selectedToken;
    const isBlack = token === "black";
    const isDirectColor = isBlack || token && !token.startsWith("--");
    const style = isBlack ? o10({
      width: size3,
      height: size3,
      background: "rgb(0,0,0)"
    }) : token && !isDirectColor ? o10({
      width: size3,
      height: size3,
      background: `var(${token})`
    }) : token ? o10({
      width: size3,
      height: size3,
      background: token
    }) : o10({
      width: size3,
      height: size3
    });
    const cls = token ? isBlack ? "swatch" : token ? "swatch" : "swatch inherit" : "swatch inherit";
    if (!token) {
      return x`<overlay-trigger triggered-by="click hover" placement="top" offset="6">
        <button
          class="${cls}"
          slot="trigger"
          title="Inherit"
          aria-current=${isCurrent ? "true" : "false"}
          style=${style}
          @click=${(e36) => this.#handleSwatchSelection(e36, token, onSelect)}
        ></button>
        <sp-tooltip slot="hover-content">Inherit</sp-tooltip>
      </overlay-trigger>`;
    }
    if (isBlack) {
      return x`<overlay-trigger triggered-by="click hover" placement="top" offset="6">
        <button
          class="${cls}"
          slot="trigger"
          title="Black"
          aria-label="Black"
          aria-current=${isCurrent ? "true" : "false"}
          style=${style}
          @click=${(e36) => this.#handleSwatchSelection(e36, "rgb(0,0,0)", onSelect)}
        ></button>
        <sp-tooltip slot="hover-content">Black</sp-tooltip>
      </overlay-trigger>`;
    }
    const [, colorName, tone] = token.match(/^--spectrum-([a-z]+)-(\d{3,4})$/) || [
      null,
      token,
      ""
    ];
    const label = `${colorName} ${tone}`;
    return x`<overlay-trigger triggered-by="click hover" placement="top" offset="6">
      <button
        class="${cls}"
        slot="trigger"
        title=${label}
        aria-label=${label}
        aria-current=${isCurrent ? "true" : "false"}
        style=${style}
        @click=${(e36) => this.#handleSwatchSelection(e36, token, onSelect)}
      ></button>
      <sp-tooltip slot="hover-content">${label}</sp-tooltip>
    </overlay-trigger>`;
  }
  #renderSolidPalette(tones, colors, selectedToken) {
    return x`<table class="color-table" role="grid" aria-label="Spectrum color tokens">
      <thead>
        <tr>
          <th scope="col">Color</th>
          ${tones.map((t34) => x`<th scope="col">${t34}</th>`)}
        </tr>
      </thead>
      <tbody>
        ${colors.map(
      (name) => x`<tr>
            <th scope="row">${this.#formatLabel(name)}</th>
            ${tones.map(
        (tone) => x`<td>
                ${this.renderSwatch(`--spectrum-${name}-${tone}`, {
          selectedToken
        })}
              </td>`
      )}
          </tr>`
    )}
      </tbody>
    </table>`;
  }
  #renderGradientSwatches(tones, colors, selectedToken) {
    const onSelect = (token) => {
      if (!token) return;
      const cssValue = token === "black" ? "rgb(0,0,0)" : this.#normalizeCssValue(token);
      this.#setGradientStopColor(this.#activeStopIndex, cssValue);
    };
    return x`<table class="color-table" role="grid" aria-label="Spectrum gradient tokens">
      <thead>
        <tr>
          <th scope="col">Color</th>
          ${tones.map((t34) => x`<th scope="col">${t34}</th>`)}
        </tr>
      </thead>
      <tbody>
        ${colors.map(
      (name) => x`<tr>
            <th scope="row">${this.#formatLabel(name)}</th>
            ${tones.map(
        (tone) => x`<td>
                ${this.renderSwatch(`--spectrum-${name}-${tone}`, {
          selectedToken,
          onSelect
        })}
              </td>`
      )}
          </tr>`
    )}
      </tbody>
    </table>`;
  }
  #renderGradientEditor(tones, colors) {
    this.#ensureGradientState();
    const activeStop = this.#gradientState.stops[this.#activeStopIndex] || this.#gradientState.stops[0];
    const stopToken = this.#tokenFromCssValue(activeStop?.color || "");
    return x`<div class="gradient-editor">
      <sp-number-field
        label="Angle"
        min="0"
        max="360"
        step="1"
        .value=${String(Math.round(this.#gradientState.angle ?? 0))}
        @change=${(event) => {
      event.stopPropagation();
      this.#handleAngleInput(event);
    }}
        @input=${(event) => {
      event.stopPropagation();
      this.#handleAngleInput(event);
    }}
      ></sp-number-field>
      <div>
        <sp-field-label size="s">Stops</sp-field-label>
        <sp-action-group quiet selects="none" class="gradient-stop-group">
          ${this.#gradientState.stops.map(
      (stop, index) => x`<sp-action-button
              quiet
              ?selected=${index === this.#activeStopIndex}
              @click=${(event) => {
        event.stopPropagation();
        this.#selectGradientStop(index);
      }}
            >
              <span
                class="stop-chip"
                style=${o10({ background: stop.color || "transparent" })}
              ></span>
              Stop ${index + 1}
            </sp-action-button>`
    )}
        </sp-action-group>
        <div class="gradient-stop-fields">
          <sp-textfield
            label="Color"
            .value=${activeStop?.color || ""}
            @change=${(event) => {
      event.stopPropagation();
      this.#handleStopColorInput(event, this.#activeStopIndex);
    }}
          ></sp-textfield>
          <sp-number-field
            label="Position (%)"
            min="0"
            max="100"
            step="1"
            .value=${String(Math.round(activeStop?.position ?? 0))}
            @change=${(event) => {
      event.stopPropagation();
      this.#handleStopPositionInput(event, this.#activeStopIndex);
    }}
            @input=${(event) => {
      event.stopPropagation();
      this.#handleStopPositionInput(event, this.#activeStopIndex);
    }}
          ></sp-number-field>
        </div>
        <div class="gradient-cta-row">
          <sp-button
            size="s"
            variant="secondary"
            quiet
            @click=${(event) => {
      event.stopPropagation();
      this.#addGradientStop();
    }}
            ?disabled=${this.#gradientState.stops.length >= 5}
          >
            Add stop
          </sp-button>
          <sp-button
            size="s"
            variant="secondary"
            quiet
            @click=${(event) => {
      event.stopPropagation();
      this.#removeGradientStop();
    }}
            ?disabled=${this.#gradientState.stops.length <= 2}
          >
            Remove stop
          </sp-button>
        </div>
      </div>
      <div class="gradient-swatches">
        <sp-field-label size="s">Token palette</sp-field-label>
        <div class="inherit-row" style="margin-bottom: var(--spectrum-global-dimension-size-200);">
          ${this.renderSwatch("black", {
      selectedToken: stopToken,
      onSelect: (token) => {
        const cssValue = token === "black" ? "rgb(0,0,0)" : this.#normalizeCssValue(token);
        this.#setGradientStopColor(this.#activeStopIndex, cssValue);
      }
    })}
        </div>
        <div class="gradient-token-grid">
          ${this.#renderGradientSwatches(tones, colors, stopToken)}
        </div>
      </div>
    </div>`;
  }
  render() {
    const tones = this.#tones;
    const colors = this.#orderedColors;
    const selectedToken = this.#selectedToken;
    const previewValue = this.#selectedDisplayValue();
    const swatchIcon = previewValue ? x`<span
          slot="icon"
          class="button-swatch"
          style=${o10({ background: previewValue })}
        ></span>` : x`<sp-icon-color-harmony slot="icon" size="l"></sp-icon-color-harmony>`;
    return x`
      ${this.label ? x`<sp-field-label>${this.label}</sp-field-label>` : E}
      <overlay-trigger placement="bottom-start" offset="6">
        <sp-action-button
          slot="trigger"
          size="l"
          quiet
          title="Choose color"
        >
          ${swatchIcon}
        </sp-action-button>
        <sp-popover slot="click-content" open>
          <div class="popover-content" @click=${(event) => event.stopPropagation()}>
            ${this.includeInherit ? x`<div class="inherit-row">
                  <sp-field-label size="s">Inherit</sp-field-label>
                  ${this.renderSwatch("", {
      selectedToken,
      onSelect: () => this.handlePick("")
    })}
                  ${this.renderSwatch("black", {
      selectedToken,
      onSelect: () => this.handlePick("rgb(0,0,0)")
    })}
                </div>` : x`<div class="inherit-row">
                  <sp-field-label size="s">Black</sp-field-label>
                  ${this.renderSwatch("black", {
      selectedToken,
      onSelect: () => this.handlePick("rgb(0,0,0)")
    })}
                </div>`}
            ${this.allowGradient ? x`<div class="mode-toggle">
                    <sp-action-group quiet selects="none">
                      <sp-action-button
                        quiet
                        ?selected=${this.#mode === "solid"}
                        @click=${(event) => {
      event.stopPropagation();
      this.#setMode("solid");
    }}
                      >
                        Solid
                      </sp-action-button>
                      <sp-action-button
                        quiet
                        ?selected=${this.#mode === "gradient"}
                        @click=${(event) => {
      event.stopPropagation();
      this.#setMode("gradient");
    }}
                      >
                        Gradient
                      </sp-action-button>
                    </sp-action-group>
                  </div>
                  ${this.#mode === "gradient" ? this.#renderGradientEditor(tones, colors) : this.#renderSolidPalette(tones, colors, selectedToken)}` : this.#renderSolidPalette(tones, colors, selectedToken)}
          </div>
        </sp-popover>
      </overlay-trigger>
    `;
  }
  #formatLabel(name) {
    return name.charAt(0).toUpperCase() + name.slice(1);
  }
  // Apply current palette value to the editor's selected element
  applyToEditingElement(value = this.color) {
    const normalized = typeof value === "string" ? value.trim() : value;
    applyAttributeToSelection({
      store: this.store,
      attr: this.attr || "color",
      value: normalized
    });
  }
};
customElements.define("spectrum-color-palette", SpectrumColorPalette);

// src/custom-elements/core/spectrum-icon-palette.js
init_lit();

// node_modules/lit-html/static.js
init_lit_html();
var a7 = Symbol.for("");
var o30 = (t34) => {
  if (t34?.r === a7) return t34?._$litStatic$;
};
var s9 = (t34) => ({ _$litStatic$: t34, r: a7 });
var l8 = /* @__PURE__ */ new Map();
var n16 = (t34) => (r25, ...e36) => {
  const a23 = e36.length;
  let s19, i21;
  const n25 = [], u36 = [];
  let c33, $4 = 0, f11 = false;
  for (; $4 < a23; ) {
    for (c33 = r25[$4]; $4 < a23 && void 0 !== (i21 = e36[$4], s19 = o30(i21)); ) c33 += s19 + r25[++$4], f11 = true;
    $4 !== a23 && u36.push(i21), n25.push(c33), $4++;
  }
  if ($4 === a23 && n25.push(r25[a23]), f11) {
    const t35 = n25.join("$$lit$$");
    void 0 === (r25 = l8.get(t35)) && (n25.raw = n25, l8.set(t35, r25 = n25)), e36 = u36;
  }
  return t34(r25, ...e36);
};
var u16 = n16(x);
var c17 = n16(b2);
var $2 = n16(w);

// src/custom-elements/core/spectrum-icon-palette.js
init_sp_popover();

// node_modules/@spectrum-web-components/divider/src/Divider.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/divider/src/divider.css.js
init_src();
var i13 = i`
    @media (forced-colors:active){:host{--highcontrast-divider-background-color:CanvasText}}:host{--spectrum-divider-thickness:var(--spectrum-divider-thickness-medium)}:host([size=s]){--spectrum-divider-thickness:var(--spectrum-divider-thickness-small)}:host([size=l]){--spectrum-divider-thickness:var(--spectrum-divider-thickness-large);--spectrum-divider-background-color:var(--spectrum-gray-800)}:host([static-color=white]){--mod-divider-background-color:var(--mod-divider-background-color-medium-static-white,var(--spectrum-divider-background-color-static-white))}:host([static-color=white][size=s]){--mod-divider-background-color:var(--mod-divider-background-color-small-static-white,var(--spectrum-divider-background-color-static-white))}:host([static-color=white][size=l]){--mod-divider-background-color:var(--mod-divider-background-color-large-static-white,var(--spectrum-transparent-white-800))}:host([static-color=black]){--mod-divider-background-color:var(--mod-divider-background-color-medium-static-black,var(--spectrum-divider-background-color-static-black))}:host([static-color=black][size=s]){--mod-divider-background-color:var(--mod-divider-background-color-small-static-black,var(--spectrum-divider-background-color-static-black))}:host([static-color=black][size=l]){--mod-divider-background-color:var(--mod-divider-background-color-large-static-black,var(--spectrum-transparent-black-800))}:host{block-size:var(--mod-divider-thickness,var(--spectrum-divider-thickness));border:none;border-width:var(--mod-divider-thickness,var(--spectrum-divider-thickness));border-radius:var(--mod-divider-thickness,var(--spectrum-divider-thickness));background-color:var(--highcontrast-divider-background-color,var(--mod-divider-background-color,var(--spectrum-divider-background-color)));inline-size:100%;overflow:visible}:host([vertical]){inline-size:var(--mod-divider-thickness,var(--spectrum-divider-thickness));block-size:100%;block-size:var(--mod-divider-vertical-height,100%);margin-block:var(--mod-divider-vertical-margin);align-self:var(--mod-divider-vertical-align)}:host{--spectrum-divider-background-color:var(--system-divider-background-color);--spectrum-divider-background-color-static-white:var(--system-divider-background-color-static-white);--spectrum-divider-background-color-static-black:var(--system-divider-background-color-static-black)}:host{display:block}hr{border:none;margin:0}
`;
var divider_css_default = i13;

// node_modules/@spectrum-web-components/divider/src/Divider.js
var u17 = Object.defineProperty;
var c18 = Object.getOwnPropertyDescriptor;
var l9 = (s19, r25, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? c18(r25, e36) : r25, o52 = s19.length - 1, a23; o52 >= 0; o52--) (a23 = s19[o52]) && (t34 = (i21 ? a23(r25, e36, t34) : a23(t34)) || t34);
  return i21 && t34 && u17(r25, e36, t34), t34;
};
var Divider = class extends SizedMixin(SpectrumElement, { validSizes: ["s", "m", "l"], noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.vertical = false;
  }
  render() {
    return x``;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.setAttribute("role", "separator");
  }
  updated(e36) {
    super.updated(e36), e36.has("vertical") && (this.vertical ? this.setAttribute("aria-orientation", "vertical") : this.removeAttribute("aria-orientation"));
  }
};
Divider.styles = [divider_css_default], l9([n4({ type: Boolean, reflect: true })], Divider.prototype, "vertical", 2), l9([n4({ reflect: true, attribute: "static-color" })], Divider.prototype, "staticColor", 2);

// node_modules/@spectrum-web-components/divider/sp-divider.js
init_define_element();
defineElement("sp-divider", Divider);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconAdd.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Add.js
var AddIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: l16 = "Add" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m16.25,9.25h-5.5V3.75c0-.41406-.33594-.75-.75-.75s-.75.33594-.75.75v5.5H3.75c-.41406,0-.75.33594-.75.75s.33594.75.75.75h5.5v5.5c0,.41406.33594.75.75.75s.75-.33594.75-.75v-5.5h5.5c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Add.js
var AddIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Add" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M29 16h-9V7a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v9H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h9v9a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-9h9a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconAdd.js
var IconAdd = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? AddIcon({ hidden: !this.label, title: this.label }) : AddIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-add.js
init_define_element();
defineElement("sp-icon-add", IconAdd);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCheckmark.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Checkmark.js
var CheckmarkIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Checkmark" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M7.86426,15.73438c-.22266,0-.43359-.09863-.57617-.26953l-3.74707-4.49805c-.26562-.31836-.22168-.79199.0957-1.05664.31738-.26562.79004-.22363,1.05664.0957l3.15332,3.78613,7.43945-9.46875c.25586-.32617.72852-.38184,1.05273-.12695.32617.25586.38281.72754.12695,1.05273l-8.01172,10.19824c-.13965.17871-.35254.28418-.5791.28711h-.01074Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Checkmark.js
var CheckmarkIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Checkmark" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m31.312 7.725-1.455-1.133a1 1 0 0 0-1.4.175L14.822 24.283l-6.647-6.612a1 1 0 0 0-1.414 0L5.436 19a1 1 0 0 0 0 1.414l8.926 8.9a1 1 0 0 0 1.5-.093L31.487 9.128a1 1 0 0 0-.175-1.403Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCheckmark.js
var IconCheckmark = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? CheckmarkIcon({ hidden: !this.label, title: this.label }) : CheckmarkIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-checkmark.js
init_define_element();
defineElement("sp-icon-checkmark", IconCheckmark);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCheckmarkCircle.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/CheckmarkCircle.js
var CheckmarkCircleIcon = ({ width: e36 = 24, height: l16 = 24, hidden: r25 = false, title: t34 = "Checkmark Circle" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="M10,18.75c-4.8252,0-8.75-3.9248-8.75-8.75S5.1748,1.25,10,1.25s8.75,3.9248,8.75,8.75-3.9248,8.75-8.75,8.75ZM10,2.75c-3.99805,0-7.25,3.25195-7.25,7.25s3.25195,7.25,7.25,7.25,7.25-3.25195,7.25-7.25-3.25195-7.25-7.25-7.25Z"
      fill="currentColor"
    />
    <path
      d="M9.22266,13.5c-.21191,0-.41504-.08984-.55762-.24805l-2.51074-2.79199c-.27734-.30859-.25195-.78223.05566-1.05957s.78125-.25195,1.05957.05566l1.89355,2.10645,3.4873-4.75586c.24316-.33398.71094-.40918,1.04785-.16113.33398.24414.40625.71387.16113,1.04785l-4.03223,5.5c-.13281.18262-.3418.29492-.56738.30566-.01172.00098-.02441.00098-.03711.00098Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/CheckmarkCircle.js
var CheckmarkCircleIcon2 = ({ width: e36 = 24, height: a23 = 24, hidden: t34 = false, title: l16 = "Checkmark Circle" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${a23}"
    viewBox="0 0 36 36"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2Zm10.666 9.08L16.018 27.341a1.208 1.208 0 0 1-.875.461c-.024.002-.05.002-.073.002a1.2 1.2 0 0 1-.85-.351l-7.784-7.795a1.2 1.2 0 0 1 0-1.698l1.326-1.325a1.201 1.201 0 0 1 1.695 0l5.346 5.347L25.314 8.473A1.203 1.203 0 0 1 27 8.263l1.455 1.133a1.205 1.205 0 0 1 .211 1.684Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCheckmarkCircle.js
var IconCheckmarkCircle = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? CheckmarkCircleIcon({ hidden: !this.label, title: this.label }) : CheckmarkCircleIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-checkmark-circle.js
init_define_element();
defineElement("sp-icon-checkmark-circle", IconCheckmarkCircle);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconClose.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Close.js
var CloseIcon = ({ width: l16 = 24, height: e36 = 24, hidden: t34 = false, title: r25 = "Close" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m11.06061,10l5.20648-5.20605c.29297-.29297.29297-.76758,0-1.06055s-.76758-.29297-1.06055,0l-5.20654,5.20605L4.79346,3.7334c-.29297-.29297-.76758-.29297-1.06055,0s-.29297.76758,0,1.06055l5.20648,5.20605-5.20648,5.20605c-.29297.29297-.29297.76758,0,1.06055.14648.14648.33838.21973.53027.21973s.38379-.07324.53027-.21973l5.20654-5.20605,5.20654,5.20605c.14648.14648.33838.21973.53027.21973s.38379-.07324.53027-.21973c.29297-.29297.29297-.76758,0-1.06055l-5.20648-5.20605Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Close.js
var CloseIcon2 = ({ width: e36 = 24, height: l16 = 24, hidden: a23 = false, title: t34 = "Close" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${l16}"
    viewBox="0 0 36 36"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="M26.485 6.686 18 15.172 9.515 6.686a1 1 0 0 0-1.414 0L6.686 8.101a1 1 0 0 0 0 1.414L15.172 18l-8.486 8.485a1 1 0 0 0 0 1.414l1.415 1.415a1 1 0 0 0 1.414 0L18 20.828l8.485 8.486a1 1 0 0 0 1.414 0l1.415-1.415a1 1 0 0 0 0-1.414L20.828 18l8.486-8.485a1 1 0 0 0 0-1.414l-1.415-1.415a1 1 0 0 0-1.414 0Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconClose.js
var IconClose = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? CloseIcon({ hidden: !this.label, title: this.label }) : CloseIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-close.js
init_define_element();
defineElement("sp-icon-close", IconClose);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCloseCircle.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/CloseCircle.js
var CloseCircleIcon = ({ width: l16 = 24, height: e36 = 24, hidden: t34 = false, title: r25 = "Close Circle" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M11.06055,10l2.21973-2.21973c.29297-.29297.29297-.76758,0-1.06055s-.76758-.29297-1.06055,0l-2.21973,2.21973-2.21973-2.21973c-.29297-.29297-.76758-.29297-1.06055,0s-.29297.76758,0,1.06055l2.21973,2.21973-2.21973,2.21973c-.29297.29297-.29297.76758,0,1.06055.14648.14648.33789.21973.53027.21973s.38379-.07324.53027-.21973l2.21973-2.21973,2.21973,2.21973c.14648.14648.33789.21973.53027.21973s.38379-.07324.53027-.21973c.29297-.29297.29297-.76758,0-1.06055l-2.21973-2.21973Z"
      fill="currentColor"
    />
    <path
      d="M10,18.75c-4.8252,0-8.75-3.9248-8.75-8.75S5.1748,1.25,10,1.25s8.75,3.9248,8.75,8.75-3.9248,8.75-8.75,8.75ZM10,2.75c-3.99805,0-7.25,3.25195-7.25,7.25s3.25195,7.25,7.25,7.25,7.25-3.25195,7.25-7.25-3.25195-7.25-7.25-7.25Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/CloseCircle.js
var CloseCircleIcon2 = ({ width: l16 = 24, height: e36 = 24, hidden: a23 = false, title: t34 = "Close Circle" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${l16}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="M29.314 6.686a16 16 0 1 0 0 22.627 16 16 0 0 0 0-22.627Zm-2.687 18.527-1.414 1.414a1.2 1.2 0 0 1-1.7 0L18 21.111l-5.516 5.516a1.2 1.2 0 0 1-1.7 0l-1.409-1.415a1.2 1.2 0 0 1 0-1.7L14.889 18l-5.514-5.516a1.2 1.2 0 0 1 0-1.7l1.414-1.414a1.2 1.2 0 0 1 1.7 0L18 14.888l5.516-5.515a1.2 1.2 0 0 1 1.7 0l1.414 1.414a1.2 1.2 0 0 1 0 1.7L21.111 18l5.516 5.516a1.2 1.2 0 0 1 0 1.7Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCloseCircle.js
var IconCloseCircle = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? CloseCircleIcon({ hidden: !this.label, title: this.label }) : CloseCircleIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-close-circle.js
init_define_element();
defineElement("sp-icon-close-circle", IconCloseCircle);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconEdit.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Edit.js
var EditIcon = ({ width: t34 = 24, height: l16 = 24, hidden: e36 = false, title: r25 = "Edit" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m17.78076,1.75684c-1.27197-1.04102-3.22705-.89844-4.4502.32324L3.07764,12.33398c-.32031.31934-.55859.7168-.68896,1.15039l-1.38428,4.58398c-.08008.26465-.00781.55176.1875.74707.14258.14258.33447.21973.53027.21973.07227,0,.14551-.01074.2168-.03223l4.58252-1.38379c.43359-.12988.83154-.36816,1.15088-.68848,0,0,10.16846-10.16797,10.35547-10.35547.64795-.64746.99316-1.54492.94775-2.45996-.0459-.91504-.48145-1.77539-1.19482-2.3584ZM2.84473,17.16309l.97998-3.24609c.02716-.09033.06714-.17578.11377-.25732l2.40869,2.40918c-.08154.04639-.16718.08643-.25781.11377l-3.24463.98047Zm14.12158-11.64746c-.15472.15552-7.09985,7.1001-9.52545,9.52588l-2.47461-2.4751L14.39111,3.14062c.38623-.38672.896-.58594,1.38965-.58594.38086,0,.75244.11914,1.05029.3623.3916.32129.62109.77246.646,1.27246.0249.49316-.16113.97656-.51074,1.32617Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Edit.js
var EditIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: l16 = "Edit" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M33.567 8.2 27.8 2.432a1.215 1.215 0 0 0-.866-.353H26.9a1.371 1.371 0 0 0-.927.406L5.084 23.372a.99.99 0 0 0-.251.422L2.055 33.1c-.114.377.459.851.783.851a.251.251 0 0 0 .062-.007c.276-.063 7.866-2.344 9.311-2.778a.972.972 0 0 0 .414-.249l20.888-20.889a1.372 1.372 0 0 0 .4-.883 1.221 1.221 0 0 0-.346-.945ZM11.4 29.316c-2.161.649-4.862 1.465-6.729 2.022l2.009-6.73Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconEdit.js
var IconEdit = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? EditIcon({ hidden: !this.label, title: this.label }) : EditIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-edit.js
init_define_element();
defineElement("sp-icon-edit", IconEdit);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconMore.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/More.js
var MoreIcon = ({ width: r25 = 24, height: l16 = 24, hidden: e36 = false, title: c33 = "More" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${r25}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${c33}"
  >
    <circle cx="10" cy="10.02114" r="1.5" fill="currentColor" />
    <path
      d="m10,8.5c-.82843,0-1.5.67157-1.5,1.5s.67157,1.5,1.5,1.5,1.5-.67157,1.5-1.5-.67157-1.5-1.5-1.5Z"
      fill="currentColor"
    />
    <circle cx="4" cy="10.02114" r="1.5" fill="currentColor" />
    <circle cx="4" cy="10" r="1.5" fill="currentColor" />
    <circle cx="16" cy="10.02114" r="1.5" fill="currentColor" />
    <circle cx="16" cy="10" r="1.5" fill="currentColor" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/More.js
var MoreIcon2 = ({ width: e36 = 24, height: r25 = 24, hidden: t34 = false, title: l16 = "More" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${r25}"
    viewBox="0 0 36 36"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <circle cx="17.8" cy="18.2" r="3.4" />
    <circle cx="29.5" cy="18.2" r="3.4" />
    <circle cx="6.1" cy="18.2" r="3.4" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconMore.js
var IconMore = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? MoreIcon({ hidden: !this.label, title: this.label }) : MoreIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-more.js
init_define_element();
defineElement("sp-icon-more", IconMore);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconInfo.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Info.js
var InfoIcon = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Info" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2Zm-.3 4.3a2.718 2.718 0 0 1 2.864 2.824 2.664 2.664 0 0 1-2.864 2.863 2.705 2.705 0 0 1-2.864-2.864A2.717 2.717 0 0 1 17.7 6.3ZM22 27a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1v-6h-1a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v9h1a1 1 0 0 1 1 1Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/InfoCircle.js
var InfoCircleIcon = ({ width: r25 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "Info Circle" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${r25}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m10,18.75c-4.8252,0-8.75-3.9248-8.75-8.75S5.1748,1.25,10,1.25s8.75,3.9248,8.75,8.75-3.9248,8.75-8.75,8.75Zm0-16c-3.99805,0-7.25,3.25195-7.25,7.25s3.25195,7.25,7.25,7.25,7.25-3.25195,7.25-7.25-3.25195-7.25-7.25-7.25Z"
      fill="currentColor"
    />
    <path
      d="m10.00064,5.26036c.23065-.00813.45538.07387.62661.22862.33033.36505.33033.92102,0,1.28607-.16935.15851-.39483.24308-.62664.23504-.23635.00948-.46589-.08035-.63302-.24775-.16207-.1679-.24916-.39432-.24137-.62755-.01238-.23497.06959-.46515.2277-.6394.17358-.16474.40786-.24988.64671-.23503Z"
      fill="currentColor"
    />
    <path
      d="m10,15.0625c-.41406,0-.75-.33594-.75-.75v-4.83496c0-.41406.33594-.75.75-.75s.75.33594.75.75v4.83496c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconInfo.js
var IconInfo = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? InfoIcon({ hidden: !this.label, title: this.label }) : InfoCircleIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-info.js
init_define_element();
defineElement("sp-icon-info", IconInfo);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconStar.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Star.js
var StarIcon = ({ width: l16 = 24, height: c33 = 24, hidden: t34 = false, title: e36 = "Star" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${c33}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="M5.50586,18.63037c-.35938.00049-.71875-.1123-1.02734-.33691-.59375-.43164-.85352-1.16797-.66016-1.87646l.97754-3.57715c.0791-.28906-.02051-.5957-.25391-.78271l-2.89258-2.31934c-.57324-.45947-.79688-1.20801-.57031-1.90674.22754-.69824.84766-1.17188,1.58203-1.20654l3.70312-.17529c.29883-.01416.55957-.2041.66504-.4834l1.3125-3.46875c.25977-.6875.90234-1.13135,1.63672-1.13135s1.37695.44385,1.63672,1.13086v.00049l1.31055,3.46826c.10645.2793.36816.46973.66602.48389l3.7041.17529c.7334.03467,1.35449.5083,1.58203,1.20703.22656.69873.00293,1.44727-.57031,1.90625l-2.89355,2.31934c-.23242.18652-.33301.49414-.25391.78271l.97656,3.57422c.19336.70996-.06641,1.44775-.66211,1.87891-.59766.43359-1.37891.44727-1.99316.0415l-3.07129-2.03662c-.25098-.16553-.5752-.16602-.82617-.00146l-3.11719,2.04443c-.29492.19336-.62793.28955-.96094.28955ZM9.97852,2.86572c-.0791,0-.18359.02832-.23438.16211l-1.31152,3.46777c-.31641.83936-1.10059,1.40918-1.99805,1.45166l-3.70312.17529c-.14258.00684-.20117.09766-.22559.17236-.02441.0752-.03027.18311.08105.27295l2.89258,2.31885c.70117.56055,1.00098,1.48291.76367,2.34912l-.97754,3.57617c-.03809.13721.03027.22168.09473.26807.0625.04492.16211.08545.28418.00684l3.11719-2.04492c.75293-.49316,1.72559-.4917,2.47656.00537l3.07129,2.03662c.12109.0791.22168.04004.28516-.00635.06445-.04639.13281-.13037.09473-.26807l-.97656-3.57471c-.23633-.86572.06348-1.78711.76367-2.34814l2.89355-2.31934c.11133-.08887.10547-.19727.08105-.27197-.02441-.0752-.08301-.16602-.22559-.17285l-3.7041-.17529c-.89551-.04248-1.67969-.61182-1.99805-1.45117l-1.31055-3.46826c-.05078-.13379-.15527-.16211-.23438-.16211Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/StarOutline.js
var StarOutlineIcon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: l16 = "Star Outline" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m18.059 5.082 3.554 9.5 10.219.481-7.974 6.4 2.671 9.837-8.535-5.568-8.557 5.615 2.7-9.873-7.974-6.4 10.2-.489Zm.023-4.259a.737.737 0 0 0-.7.479l-4.411 11.349-12.2.586a.75.75 0 0 0-.433 1.334l9.523 7.642-3.229 11.8a.752.752 0 0 0 .724.951.74.74 0 0 0 .41-.126L18 28.122l10.187 6.648a.742.742 0 0 0 .408.125.752.752 0 0 0 .725-.95l-3.189-11.732 9.528-7.653a.75.75 0 0 0-.434-1.334l-12.2-.575-4.24-11.34a.738.738 0 0 0-.703-.488Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconStar.js
var IconStar = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? StarIcon({ hidden: !this.label, title: this.label }) : StarOutlineIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-star.js
init_define_element();
defineElement("sp-icon-star", IconStar);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTag.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Tag.js
var TagIcon = ({ width: l16 = 24, height: e36 = 24, hidden: r25 = false, title: t34 = "Tag" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="m11.86424,18.8042c-.55176,0-1.10352-.20752-1.52344-.62207l-7.63281-7.4668c-.4502-.43994-.70801-1.05322-.70801-1.68262v-4.6792c0-1.29785,1.05566-2.35352,2.35352-2.35352h4.7793c.62793,0,1.21777.24414,1.66211.68701l7.57129,7.54834c.4082.40234.63379.94141.63379,1.51514s-.22559,1.11279-.63672,1.51758l-4.97559,4.91406c-.41992.41455-.97168.62207-1.52344.62207ZM4.3535,3.5c-.4707,0-.85352.38281-.85352.85352v4.6792c0,.22803.09375.45068.25684.61035l7.63574,7.46924c.26172.2583.68262.25781.94043.00244l4.97656-4.91406c.12305-.12109.19043-.28076.19043-.4502s-.06738-.3291-.18945-.4502l-7.5752-7.55127c-.15918-.1582-.37793-.24902-.60254-.24902h-4.7793Z"
      fill="currentColor"
    />
    <circle cx="5.99998" cy="6" r="1" fill="currentColor" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Label.js
var LabelIcon = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: l16 = "Label" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m35.293 19.292-17-17A1 1 0 0 0 17.586 2H3a1 1 0 0 0-1 1v14.585a1 1 0 0 0 .293.708l17 17a1 1 0 0 0 1.414 0l14.586-14.586a1 1 0 0 0 0-1.415ZM8 10.6A2.6 2.6 0 1 1 10.6 8 2.6 2.6 0 0 1 8 10.6Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTag.js
var IconTag = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TagIcon({ hidden: !this.label, title: this.label }) : LabelIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-tag.js
init_define_element();
defineElement("sp-icon-tag", IconTag);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconEmail.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Email.js
var EmailIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Email" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M16.75,2.99316H3.25c-1.24023,0-2.25,1.00977-2.25,2.25v9.5c0,1.24023,1.00977,2.25,2.25,2.25h13.5c1.24023,0,2.25-1.00977,2.25-2.25V5.24316c0-1.24023-1.00977-2.25-2.25-2.25ZM16.32935,4.49316l-5.83716,5.08301c-.2793.24414-.7041.24414-.98535,0L3.67065,4.49316h12.65869ZM16.75,15.49316H3.25c-.41309,0-.75-.33691-.75-.75V5.46191l6.02148,5.24512c.42188.36719.9502.55078,1.47852.55078s1.05664-.18359,1.47754-.55078l6.02246-5.24512v9.28125c0,.41309-.33691.75-.75.75Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/EmailOutline.js
var EmailOutlineIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: a23 = "Email Outline" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M35 4H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h34a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1Zm-1 2v1.506L18 19.741 2 7.506V6Zm0 4.023v15.9l-10.4-7.95Zm-21.6 7.95L2 25.923v-15.9ZM2 30v-1.56l12.042-9.208 2.743 2.1a2 2 0 0 0 2.43 0l2.743-2.1L34 28.44V30Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconEmail.js
var IconEmail = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? EmailIcon({ hidden: !this.label, title: this.label }) : EmailOutlineIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-email.js
init_define_element();
defineElement("sp-icon-email", IconEmail);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUser.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/User.js
var UserIcon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: l16 = "User" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m10,11.25c-2.61914,0-4.75-2.24316-4.75-5S7.38086,1.25,10,1.25s4.75,2.24316,4.75,5-2.13086,5-4.75,5Zm0-8.5c-1.79199,0-3.25,1.57031-3.25,3.5s1.45801,3.5,3.25,3.5,3.25-1.57031,3.25-3.5-1.45801-3.5-3.25-3.5Z"
      fill="currentColor"
    />
    <path
      d="m17.24902,18.75c-.37793,0-.70312-.28516-.74463-.66895-.2627-2.42871-3.12012-4.33105-6.50439-4.33105-3.41357,0-6.27051,1.89844-6.50342,4.32227-.04004.41211-.40967.72754-.81836.67383-.41211-.03906-.71436-.40527-.6748-.81836.30615-3.18359,3.81885-5.67773,7.99658-5.67773,4.2085,0,7.646,2.4375,7.99561,5.66895.04443.41211-.25293.78223-.66504.82715-.02734.00293-.05469.00391-.08154.00391Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/User.js
var UserIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "User" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M32.949 34a.993.993 0 0 0 1-1.053c-.661-7.184-8.027-9.631-10.278-9.827C22.026 22.977 22 21.652 22 20c0 0 3.532-3.943 3.532-8.958C25.532 5.617 22.445 2 18 2s-7.532 3.617-7.532 9.042C10.468 16.057 14 20 14 20c0 1.652-.026 2.977-1.674 3.12-2.251.2-9.617 2.643-10.278 9.827a.993.993 0 0 0 1 1.053Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUser.js
var IconUser = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? UserIcon({ hidden: !this.label, title: this.label }) : UserIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-user.js
init_define_element();
defineElement("sp-icon-user", IconUser);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconDownload.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Download.js
var DownloadIcon = ({ width: l16 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Download" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m13.53027,9.42676c-.29199-.29199-.7666-.29395-1.06055,0l-1.7168,1.71411V2.75c0-.41406-.33594-.75-.75-.75s-.75.33594-.75.75v8.39941l-1.72266-1.72266c-.29297-.29297-.76758-.29297-1.06055,0s-.29297.76758,0,1.06055l2.99805,2.99805c.14648.14648.33789.21973.53027.21973.19141,0,.38379-.07324.53027-.21973l3.00195-2.99805c.29297-.29199.29297-.76758,0-1.06055Z"
      fill="currentColor"
    />
    <path
      d="m15.75,18H4.25c-1.24023,0-2.25-1.00977-2.25-2.25v-2.02148c0-.41406.33594-.75.75-.75s.75.33594.75.75v2.02148c0,.41309.33691.75.75.75h11.5c.41309,0,.75-.33691.75-.75v-2.02148c0-.41406.33594-.75.75-.75s.75.33594.75.75v2.02148c0,1.24023-1.00977,2.25-2.25,2.25Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/SaveTo.js
var SaveToIcon = ({ width: a23 = 24, height: e36 = 24, hidden: t34 = false, title: l16 = "Save To" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M33 10h-6a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h3v16H6V14h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1Z"
    />
    <path
      d="m10.2 17.331 7.445 7.525a.5.5 0 0 0 .7 0l7.455-7.525a.782.782 0 0 0 .2-.526.8.8 0 0 0-.8-.8H20V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v13h-5.2a.8.8 0 0 0-.8.8.782.782 0 0 0 .2.531Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconDownload.js
var IconDownload = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? DownloadIcon({ hidden: !this.label, title: this.label }) : SaveToIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-download.js
init_define_element();
defineElement("sp-icon-download", IconDownload);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUpload.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Upload.js
var UploadIcon = ({ width: t34 = 24, height: l16 = 24, hidden: e36 = false, title: r25 = "Upload" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m13.52734,10.49121l-3.00244-2.99805c-.29297-.29297-.76709-.29297-1.06006,0l-2.99756,2.99805c-.29297.29297-.29297.76758,0,1.06055.14648.14648.33838.21973.53027.21973s.38379-.07324.53027-.21973l1.72217-1.72217v8.18018c0,.41406.33594.75.75.75s.75-.33594.75-.75v-8.17285l1.71777,1.71484c.29297.29297.76758.29297,1.06055,0,.29248-.29297.29248-.76855-.00098-1.06055Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="m15.75,17h-2.79883c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h2.79883c.41357,0,.75-.33691.75-.75V4.25c0-.41309-.33643-.75-.75-.75H4.25c-.41357,0-.75.33691-.75.75v10.5c0,.41309.33643.75.75.75h2.72559c.41406,0,.75.33594.75.75s-.33594.75-.75.75h-2.72559c-1.24072,0-2.25-1.00977-2.25-2.25V4.25c0-1.24023,1.00928-2.25,2.25-2.25h11.5c1.24072,0,2.25,1.00977,2.25,2.25v10.5c0,1.24023-1.00928,2.25-2.25,2.25Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUpload.js
var IconUpload = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? UploadIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-upload.js
init_define_element();
defineElement("sp-icon-upload", IconUpload);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSearch.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Search.js
var SearchIcon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: l16 = "Search" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m18.53027,17.46973l-5.08325-5.08325c.96936-1.20142,1.55298-2.72644,1.55298-4.38647,0-3.85938-3.14062-7-7-7S1,4.14062,1,8s3.14062,7,7,7c1.66003,0,3.18506-.58362,4.38647-1.55298l5.08325,5.08325c.14648.14648.33789.21973.53027.21973s.38379-.07324.53027-.21973c.29297-.29297.29297-.76758,0-1.06055Zm-10.53027-3.96973c-3.03223,0-5.5-2.46777-5.5-5.5s2.46777-5.5,5.5-5.5,5.5,2.46777,5.5,5.5-2.46777,5.5-5.5,5.5Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Magnify.js
var MagnifyIcon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: l16 = "Magnify" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M33.173 30.215 25.4 22.443a12.826 12.826 0 1 0-2.957 2.957l7.772 7.772a2.1 2.1 0 0 0 2.958-2.958ZM6 15a9 9 0 1 1 9 9 9 9 0 0 1-9-9Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSearch.js
var IconSearch = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? SearchIcon({ hidden: !this.label, title: this.label }) : MagnifyIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-search.js
init_define_element();
defineElement("sp-icon-search", IconSearch);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCalendar.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Calendar.js
var CalendarIcon = ({ width: r25 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "Calendar" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${r25}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m15.75,3h-2v-1c0-.41406-.33594-.75-.75-.75s-.75.33594-.75.75v1h-4.5v-1c0-.41406-.33594-.75-.75-.75s-.75.33594-.75.75v1h-2c-1.24072,0-2.25,1.00977-2.25,2.25v10.5c0,1.24023,1.00928,2.25,2.25,2.25h11.5c1.24072,0,2.25-1.00977,2.25-2.25V5.25c0-1.24023-1.00928-2.25-2.25-2.25Zm-11.5,1.5h2v.5c0,.41406.33594.75.75.75s.75-.33594.75-.75v-.5h4.5v.5c0,.41406.33594.75.75.75s.75-.33594.75-.75v-.5h2c.41357,0,.75.33691.75.75v1.75H3.5v-1.75c0-.41309.33643-.75.75-.75Zm11.5,12H4.25c-.41357,0-.75-.33691-.75-.75v-7.25h13v7.25c0,.41309-.33643.75-.75.75Z"
      fill="currentColor"
    />
    <rect x="5" y="10" width="2" height="2" rx="1" ry="1" fill="currentColor" />
    <rect x="9" y="10" width="2" height="2" rx="1" ry="1" fill="currentColor" />
    <rect x="13" y="10" width="2" height="2" rx="1" ry="1" fill="currentColor" />
    <rect x="5" y="13" width="2" height="2" rx="1" ry="1" fill="currentColor" />
    <rect x="9" y="13" width="2" height="2" rx="1" ry="1" fill="currentColor" />
    <rect x="13" y="13" width="2" height="2" rx="1" ry="1" fill="currentColor" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Calendar.js
var CalendarIcon2 = ({ width: h16 = 24, height: a23 = 24, hidden: e36 = false, title: t34 = "Calendar" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${h16}"
    height="${a23}"
    viewBox="0 0 36 36"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <g>
      <path
        d="M33 6h-5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H10V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v3H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h32a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Zm-1 26H2V8h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h14v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h4Z"
      />
      <path
        d="M6 12h4v4H6zM12 12h4v4h-4zM18 12h4v4h-4zM24 12h4v4h-4zM6 18h4v4H6zM12 18h4v4h-4zM18 18h4v4h-4zM24 18h4v4h-4zM6 24h4v4H6zM12 24h4v4h-4zM18 24h4v4h-4zM24 24h4v4h-4z"
      />
    </g>
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCalendar.js
var IconCalendar = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? CalendarIcon({ hidden: !this.label, title: this.label }) : CalendarIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-calendar.js
init_define_element();
defineElement("sp-icon-calendar", IconCalendar);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconHome.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Home.js
var HomeIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Home" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m17.13086,5.73438L11.38086,1.26172c-.8125-.63086-1.94922-.63184-2.76172.00098L2.86914,5.73438h-.00098c-.54395.42285-.86816,1.08691-.86816,1.77637v8.23926c0,1.24023,1.00977,2.25,2.25,2.25h11.5c1.24023,0,2.25-1.00977,2.25-2.25V7.51074c0-.68945-.32422-1.35352-.86914-1.77637Zm-5.63086,10.76562h-3v-4.75c0-.41309.33691-.75.75-.75h1.5c.41309,0,.75.33691.75.75v4.75Zm5-.75c0,.41309-.33691.75-.75.75h-2.75v-4.75c0-1.24023-1.00977-2.25-2.25-2.25h-1.5c-1.24023,0-2.25,1.00977-2.25,2.25v4.75h-2.75c-.41309,0-.75-.33691-.75-.75V7.51074c0-.22949.1084-.45117.28906-.59277l5.75-4.4707c.27246-.21191.65137-.20898.92188-.00098l5.74902,4.47168c.18164.1416.29004.36328.29004.59277v8.23926Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Home.js
var HomeIcon2 = ({ width: e36 = 24, height: a23 = 24, hidden: t34 = false, title: l16 = "Home" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${a23}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M35.332 20.25 18.75 3.668a1.063 1.063 0 0 0-1.5 0L.668 20.25a1.061 1.061 0 0 0 0 1.5l1.958 1.957a1 1 0 0 0 .707.293H4v9a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V23a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v10a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-9h.667a1 1 0 0 0 .707-.293l1.958-1.957a1.061 1.061 0 0 0 0-1.5Z"
      fill-rule="evenodd"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconHome.js
var IconHome = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? HomeIcon({ hidden: !this.label, title: this.label }) : HomeIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-home.js
init_define_element();
defineElement("sp-icon-home", IconHome);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconHeart.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Heart.js
var HeartIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: l16 = "Heart" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m10,18c-.48877,0-.97754-.16016-1.38574-.48047h0c-1.58594-1.24414-5.20264-4.51172-6.37451-6.42871-.93262-1.52539-1.25293-3.41309-.85693-5.04883.33984-1.4043,1.16211-2.53711,2.37842-3.27832,1.37402-.83887,3.02295-.99707,4.30176-.41309.66016.30176,1.36328.82715,1.92871,1.4209.57812-.62988,1.27295-1.13965,1.96729-1.42969,1.31152-.55176,2.95264-.3877,4.28027.42188,1.21582.74121,2.03809,1.87402,2.37793,3.27832.396,1.63574.07568,3.52344-.85693,5.04883-1.16943,1.91309-4.78711,5.18262-6.37451,6.42871-.40771.32031-.89697.48047-1.38574.48047ZM6.38721,3.49902c-.60645,0-1.25537.18555-1.84521.5459-.86914.5293-1.45703,1.3418-1.70117,2.34961-.30469,1.25781-.05078,2.7207.67822,3.91309.95312,1.55859,4.14941,4.56348,6.021,6.03223h.00049c.27051.21289.64844.21289.91895,0,1.87354-1.4707,5.07031-4.47656,6.021-6.03223.72949-1.19238.9834-2.65527.67871-3.91309-.24414-1.00781-.83203-1.82031-1.70068-2.34961-.92578-.56445-2.04492-.68652-2.91992-.32031-.68213.28613-1.43311.9375-1.91406,1.66016-.27832.41797-.9707.41797-1.24902,0-.43506-.65332-1.24902-1.35547-1.93555-1.66895-.31836-.14551-.67725-.2168-1.05273-.2168Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Heart.js
var HeartIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Heart" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M24.364 6.509A8.013 8.013 0 0 0 18 10.327a8.013 8.013 0 0 0-6.364-3.818A7.636 7.636 0 0 0 4 14.145c0 7.292 14 16.546 14 16.546s14-9.156 14-16.546a7.636 7.636 0 0 0-7.636-7.636Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconHeart.js
var IconHeart = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? HeartIcon({ hidden: !this.label, title: this.label }) : HeartIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-heart.js
init_define_element();
defineElement("sp-icon-heart", IconHeart);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSettings.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Settings.js
var SettingsIcon = ({ width: l16 = 24, height: c33 = 24, hidden: t34 = false, title: e36 = "Settings" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${c33}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="M10.00391,12.58887c-.88818,0-1.75293-.45996-2.22803-1.2832h0c-.70801-1.22754-.28613-2.80078.93994-3.50879.59326-.34375,1.28516-.43359,1.94922-.25684.6626.17773,1.21631.60352,1.55908,1.19727.34326.59375.43408,1.28613.25684,1.94824-.17773.66309-.60254,1.2168-1.19678,1.55957-.40332.2334-.84473.34375-1.28027.34375ZM9.07471,10.55566c.29443.50879.94824.68359,1.45947.39062.24707-.14258.42383-.37305.49756-.64844s.03613-.56348-.10645-.81055c-.14307-.24707-.37305-.42383-.64893-.49805-.2749-.07324-.56299-.03516-.81055.10645-.51025.29492-.68555.94922-.39111,1.45996h0Z"
      fill="currentColor"
    />
    <path
      d="M6.90674,18.31836c-.33936,0-.68213-.08496-.99219-.26465l-.81982-.47266c-.89307-.51367-1.25-1.64941-.81104-2.58301l.58008-1.2334c-.26514-.36328-.48975-.75098-.67188-1.16113l-1.35693-.1123c-1.02881-.08496-1.83447-.95996-1.83447-1.99121l-.00098-.94629c0-1.0332.80518-1.90918,1.8335-1.99414l1.35449-.11426c.0918-.20898.19238-.40918.30176-.59961.10986-.19141.2334-.37891.36914-.56445l-.58057-1.22949c-.44092-.93262-.08643-2.06836.80713-2.58496l.82031-.47363c.89258-.5166,2.05371-.25879,2.64258.58984l.77734,1.11816c.44385-.0498.89209-.04785,1.34082,0l.77539-1.11914c.58887-.84961,1.75098-1.10938,2.64355-.59375l.81982.47266c.89404.51562,1.24951,1.65137.81055,2.58398l-.58008,1.23242c.26562.36426.49023.75195.67188,1.16113l1.35693.1123c1.02832.08496,1.83398.95996,1.83496,1.99121l.00049.94727c.00098,1.03125-.80371,1.90723-1.83203,1.99414l-1.35547.11426c-.09131.20898-.19189.4082-.30273.59961h0c-.10938.18945-.23242.37793-.36816.56348l.58057,1.22949c.44043.93164.08643,2.06738-.80664,2.58496l-.8208.47461c-.89355.51855-2.05371.25781-2.64258-.59082l-.77734-1.11816c-.4458.04883-.89404.04785-1.34082.00098l-.77637,1.12012c-.38379.55371-1.01172.85645-1.65039.85645ZM6.9043,3.22461c-.08496,0-.17041.02148-.24805.06641l-.8208.47461c-.22266.12891-.31152.41211-.20117.64551l.77881,1.65039c.12598.2666.08398.58203-.10742.80664-.2041.23926-.37305.47656-.5166.72559-.14111.24609-.26514.51855-.36816.80957-.09814.27832-.3501.47266-.64404.49707l-1.81885.15332c-.26172.02246-.4585.23633-.4585.49902l.00098.94629c0,.25781.20117.47656.4585.49805l1.81934.15039c.29395.02441.54639.21875.64502.49707.19873.56055.49707,1.07617.88672,1.53223.19189.22363.23438.54004.10889.80664l-.77783,1.65234c-.10938.2334-.021.51758.20264.64551l.82031.47363c.22412.12988.51416.06348.66016-.14746l1.04102-1.50195c.16748-.24219.45898-.36914.75244-.30957.58838.10742,1.18457.1084,1.77002-.00098.28955-.05469.58496.06641.75342.30957l1.04199,1.49902c.14648.20996.43848.27637.66064.14746l.82031-.47363c.22607-.13086.31348-.40918.20117-.64648l-.77881-1.65039c-.12598-.2666-.08398-.58203.10742-.80664.2041-.24023.37305-.47656.51562-.72461l.00049-.00098c.14258-.24707.26318-.51172.36865-.80957.09863-.27832.35059-.47266.64453-.49707l1.81885-.15234c.25635-.02246.45752-.24121.45752-.49902l-.00049-.94727c0-.26172-.19727-.47559-.45898-.49805l-1.81885-.15039c-.29395-.02441-.54639-.21875-.64502-.49707-.19775-.55957-.49658-1.0752-.88721-1.53223-.19141-.22461-.23389-.54004-.1084-.80664l.77734-1.65234c.10986-.2334.021-.51758-.20264-.64648l-.81982-.47266c-.22461-.12695-.51416-.06152-.66113.14941l-1.03955,1.5c-.16797.24316-.45898.36816-.75293.31055-.59131-.10938-1.1875-.10938-1.77002,0-.29199.05176-.58545-.06738-.75342-.30957l-1.04199-1.49902c-.09619-.1377-.25293-.21387-.41211-.21387Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Settings.js
var SettingsIcon2 = ({ width: a23 = 24, height: l16 = 24, hidden: t34 = false, title: e36 = "Settings" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${l16}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="M32.9 15.793h-3.111a11.953 11.953 0 0 0-1.842-4.507l2.205-2.206a1.1 1.1 0 0 0 0-1.56l-1.673-1.672a1.1 1.1 0 0 0-1.56 0l-2.205 2.205a11.925 11.925 0 0 0-4.507-1.841V3.1A1.1 1.1 0 0 0 19.1 2h-2.2a1.1 1.1 0 0 0-1.1 1.1v3.112a11.925 11.925 0 0 0-4.507 1.841l-2.2-2.205a1.1 1.1 0 0 0-1.56 0L5.848 7.52a1.1 1.1 0 0 0 0 1.56l2.205 2.206a11.953 11.953 0 0 0-1.842 4.507H3.1A1.1 1.1 0 0 0 2 16.9v2.2a1.1 1.1 0 0 0 1.1 1.1h3.111a11.934 11.934 0 0 0 1.842 4.507l-2.205 2.212a1.1 1.1 0 0 0 0 1.56l1.673 1.673a1.1 1.1 0 0 0 1.56 0l2.205-2.205a11.925 11.925 0 0 0 4.507 1.841V32.9A1.1 1.1 0 0 0 16.9 34h2.2a1.1 1.1 0 0 0 1.1-1.1v-3.112a11.925 11.925 0 0 0 4.507-1.841l2.205 2.205a1.1 1.1 0 0 0 1.56 0l1.673-1.673a1.1 1.1 0 0 0 0-1.56l-2.205-2.205a11.934 11.934 0 0 0 1.842-4.507H32.9A1.1 1.1 0 0 0 34 19.1v-2.2a1.1 1.1 0 0 0-1.1-1.107ZM22.414 18A4.414 4.414 0 1 1 18 13.586 4.414 4.414 0 0 1 22.414 18Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSettings.js
var IconSettings = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? SettingsIcon({ hidden: !this.label, title: this.label }) : SettingsIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-settings.js
init_define_element();
defineElement("sp-icon-settings", IconSettings);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFlag.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Flag.js
var FlagIcon = ({ width: l16 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Flag" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m17.68945,2.67773c-.19482-.14062-.44629-.18066-.67432-.10449l-.5874.19434c-1.0957.30566-2.25.28516-3.33643-.06641l-2.72754-.87988c-1.20947-.38965-2.50342-.45898-3.74072-.19531l-2.12305.44922v-.3252c0-.41406-.33594-.75-.75-.75s-.75.33594-.75.75v16.5c0,.41406.33594.75.75.75s.75-.33594.75-.75v-4.61719l2.43311-.51562c.9834-.20605,2.01025-.1543,2.96973.15625l2.72803.88086c.72559.2334,1.47461.35156,2.22852.35156.66895,0,1.34229-.09277,2.00586-.28027l.61963-.2041c.30713-.10059.51514-.3877.51514-.71191V3.28516c0-.24023-.11523-.4668-.31055-.60742Zm-1.18945,10.08984l-.07275.02441c-1.09375.30859-2.24805.28516-3.33594-.06543l-2.72754-.88086c-1.20801-.38965-2.50098-.45605-3.74072-.19531l-2.12305.44971V3.60767l2.43359-.51489c.98193-.20801,2.00977-.15332,2.96924.15625l2.72754.87988c1.24951.4043,2.57178.46191,3.86963.16602v8.47266Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Flag.js
var FlagIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Flag" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 36 36"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <g>
      <path
        d="M33.249 6.42a19.446 19.446 0 0 0-4.666-.566 19.033 19.033 0 0 0-4.113.453 1.093 1.093 0 0 1-1.3-1.084V3.609a1.087 1.087 0 0 0-.815-1.061A19.494 19.494 0 0 0 17.75 2 19.153 19.153 0 0 0 8 4.648v15.165a19.1 19.1 0 0 1 9.76-2.646 1.1 1.1 0 0 1 1.073 1.1v3.739a.991.991 0 0 0 1.406.908 19.28 19.28 0 0 1 12.515-1.435A1.007 1.007 0 0 0 34 20.511V7.4a1 1 0 0 0-.751-.98Z"
      />
      <rect x="2" y="2" width="4" height="34" rx=".5" />
    </g>
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFlag.js
var IconFlag = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? FlagIcon({ hidden: !this.label, title: this.label }) : FlagIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-flag.js
init_define_element();
defineElement("sp-icon-flag", IconFlag);

// src/custom-elements/core/spectrum-icon-palette.js
var DEFAULT_ICONS = [
  "sp-icon-info",
  "sp-icon-add",
  "sp-icon-checkmark",
  "sp-icon-checkmark-circle",
  "sp-icon-close",
  "sp-icon-close-circle",
  "sp-icon-edit",
  "sp-icon-more",
  "sp-icon-alert",
  "sp-icon-star",
  "sp-icon-tag",
  "sp-icon-link",
  "sp-icon-email",
  "sp-icon-user",
  "sp-icon-download",
  "sp-icon-upload",
  "sp-icon-search",
  "sp-icon-calendar",
  "sp-icon-home",
  "sp-icon-heart",
  "sp-icon-settings",
  "sp-icon-flag"
];
var SpectrumIconPalette = class extends i4 {
  static properties = {
    name: { type: String, reflect: true },
    size: { type: String, reflect: true },
    color: { type: String, reflect: true },
    rotate: { type: Number, reflect: true },
    // Flip controls
    flipH: { type: Boolean, reflect: true, attribute: "flip-h", converter: booleanConverter },
    flipV: { type: Boolean, reflect: true, attribute: "flip-v", converter: booleanConverter },
    icons: { type: Array },
    label: { type: String },
    // Editor store for direct updates (optional; resolves from editor context if not provided)
    store: { type: Object, attribute: false },
    // Attribute names to update on the current editing element
    nameAttr: { type: String, attribute: "name-attr" },
    sizeAttr: { type: String, attribute: "size-attr" },
    rotateAttr: { type: String, attribute: "rotate-attr" },
    flipHAttr: { type: String, attribute: "flip-h-attr" },
    flipVAttr: { type: String, attribute: "flip-v-attr" }
  };
  static styles = i`
    :host {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      max-width: 560px;
      background-color: var(--spectrum-alias-component-background-color);
      box-sizing: border-box;
      padding: 2px 2px; /* unify with color palette */
      border-radius: var(--spectrum-global-dimension-size-100);
    }
    button.icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--spectrum-global-color-gray-300);
      background: var(--spectrum-global-color-gray-50);
      width: 29px; /* unify height with color swatch */
      height: 29px; /* unify height with color swatch */
      border-radius: 6px;
      cursor: pointer;
    }
    button.icon[aria-current="true"] {
      outline: 2px solid var(--spectrum-global-color-blue-600);
    }
    /* Inherit icon tile: neutral placeholder */
    button.icon.inherit {
      position: relative;
      background: var(--spectrum-global-color-gray-75);
      border-color: var(--spectrum-global-color-gray-300);
    }
    button.icon.inherit::after {
      content: "";
      position: absolute;
      inset: 22%;
      border-radius: var(--spectrum-global-dimension-size-50);
      background: var(--spectrum-global-color-gray-200);
      border: 1px solid var(--spectrum-global-color-gray-400);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    .grid {
      display: grid;
      background-color: var(--spectrum-global-color-gray-50);
      grid-template-columns: repeat(8, 36px); /* 10% smaller cells */
      gap: 6px;
      padding: 8px;
    }
    /* Compose preview transform via CSS variables so rotate + flips can combine */
    sp-action-button [slot="icon"] {
      transform:
        var(--ee-icon-rotate, none)
        var(--ee-icon-flipx, none)
        var(--ee-icon-flipy, none);
    }
    :host([rotate="90"])  { --ee-icon-rotate: rotate(90deg); }
    :host([rotate="180"]) { --ee-icon-rotate: rotate(180deg); }
    :host([rotate="270"]) { --ee-icon-rotate: rotate(270deg); }
    :host([flip-h]) { --ee-icon-flipx: scaleX(-1); }
    :host([flip-v]) { --ee-icon-flipy: scaleY(-1); }
  `;
  constructor() {
    super();
    this.name = "";
    this.icons = DEFAULT_ICONS;
    this.size = "m";
    this.color = "";
    this.rotate = 0;
    this.flipH = false;
    this.flipV = false;
    this.nameAttr = "name";
    this.sizeAttr = "size";
    this.rotateAttr = "rotate";
    this.flipHAttr = "flip-h";
    this.flipVAttr = "flip-v";
  }
  firstUpdated() {
    const store = this.store || document.querySelector("experience-elements-editor")?.editorStore || null;
    const current = store?.editingElement || null;
    if (!current) return;
    const actions = store && (store.toolbarActions || store.toolbarActionsData) || null;
    const el = actions && actions.isSlotContent && actions.parentElement ? actions.parentElement : current;
    const get2 = (attr) => (el.getAttribute(attr) ?? "").toString();
    this.name = get2(this.nameAttr || "name") || this.name;
    this.size = (get2(this.sizeAttr || "size") || this.size || "m").toLowerCase();
    const r25 = Number(get2(this.rotateAttr || "rotate"));
    this.rotate = Number.isFinite(r25) ? r25 : this.rotate;
    this.flipH = el.hasAttribute(this.flipHAttr || "flip-h");
    this.flipV = el.hasAttribute(this.flipVAttr || "flip-v");
  }
  handlePick(tag3) {
    this.name = tag3 || "";
    if (!tag3) {
      this.size = "";
      this.rotate = 0;
      this.flipH = false;
      this.flipV = false;
      this.applyToEditingElement();
    } else {
      this.applyToEditingElement("name");
    }
  }
  renderIcon(tag3) {
    const isCurrent = this.name === tag3;
    if (!tag3) {
      return x`<overlay-trigger triggered-by="click hover" placement="top" offset="6">
        <button
          class="icon inherit"
          slot="trigger"
          aria-current=${isCurrent ? "true" : "false"}
          title="Inherit"
          @click=${() => this.handlePick("")}
        ></button>
        <sp-tooltip slot="hover-content">Inherit</sp-tooltip>
      </overlay-trigger>`;
    }
    const t34 = s9(tag3);
    return u16`<button class="icon" aria-current=${isCurrent ? "true" : "false"} title=${tag3} @click=${() => this.handlePick(tag3)}>
      <${t34}></${t34}>
    </button>`;
  }
  render() {
    const selectedTag = this.name && this.icons.includes(this.name) ? this.name : "";
    const SelectedIcon = selectedTag ? s9(selectedTag) : null;
    return x`
      ${this.label ? x`<sp-field-label>${this.label}</sp-field-label>` : null}
      <overlay-trigger triggered-by="click hover" placement="bottom-start" offset="6">
        <sp-action-button slot="trigger" size="l" quiet title="Choose icon">
          ${SelectedIcon ? u16`<${SelectedIcon} slot="icon" ${this.color ? `style="color: ${this.color};"` : ""}></${SelectedIcon}>` : x`<sp-icon-more slot="icon" size="l"></sp-icon-more>`}
        </sp-action-button>
        <sp-popover slot="click-content" open>
          <div class="grid">
            ${this.renderIcon("")}
            ${this.icons.map((t34) => this.renderIcon(t34))}
          </div>
          <sp-divider size="s"></sp-divider>
          <div class="size-controls" style="padding: 8px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
            <sp-field-label size="s">Size</sp-field-label>
            <sp-action-group
              quiet
              selects="single"
              @change=${(e36) => {
      e36.stopPropagation();
    }}
              @click=${(e36) => {
      e36.stopPropagation();
    }}
            >
              ${["xxs", "xs", "s", "m", "l", "xl", "xxl"].map((sz) => x`
                <sp-action-button
                  quiet
                  ?selected=${(this.size || "m") === sz}
                  @click=${() => {
      this.size = (sz || "").toLowerCase();
      this.applyToEditingElement("size");
    }}
                >${sz}</sp-action-button>
              `)}
            </sp-action-group>
          </div>
          <div class="rotate-controls" style="padding: 8px; display: flex; align-items: center; gap: 8px;">
            <sp-field-label size="s">Rotate</sp-field-label>
            <sp-action-group quiet selects="none">
              ${[0, 90, 180, 270].map((deg) => x`
                <sp-action-button
                  quiet
                  ?selected=${Number(this.rotate) === deg}
                  @click=${() => {
      this.rotate = deg;
      this.applyToEditingElement("rotate");
    }}
                >${deg}&deg;</sp-action-button>
              `)}
            </sp-action-group>
          </div>
          <div class="flip-controls" style="padding: 8px; display: flex; align-items: center; gap: 8px;">
            <sp-field-label size="s">Flip</sp-field-label>
            <sp-action-group quiet>
              <sp-action-button
                quiet
                toggles
                .selected=${!!this.flipH}
                @click=${() => {
      this.flipH = !this.flipH;
      this.applyToEditingElement("flipH");
    }}
              >H</sp-action-button>
              <sp-action-button
                quiet
                toggles
                .selected=${!!this.flipV}
                @click=${() => {
      this.flipV = !this.flipV;
      this.applyToEditingElement("flipV");
    }}
              >V</sp-action-button>
            </sp-action-group>
          </div>
        </sp-popover>
      </overlay-trigger>
    `;
  }
  // Apply current palette values to the editor's selected element
  applyToEditingElement(what) {
    const store = this.store || (document.querySelector("experience-elements-editor")?.editorStore || null);
    const current = store?.editingElement || null;
    if (!current) return;
    const actions = store && (store.toolbarActions || store.toolbarActionsData) || null;
    const el = actions && actions.isSlotContent && actions.parentElement ? actions.parentElement : current;
    const setOrRemove = (attr, val) => {
      if (!attr) return;
      const v6 = (val ?? "").toString().trim();
      if (!v6) el.removeAttribute(attr);
      else el.setAttribute(attr, v6);
    };
    const setBool = (attr, flag) => {
      if (!attr) return;
      if (flag) el.setAttribute(attr, "");
      else el.removeAttribute(attr);
    };
    if (!what || what === "name") setOrRemove(this.nameAttr || "name", this.name || "");
    if (!what || what === "size") setOrRemove(this.sizeAttr || "size", (this.size || "").toLowerCase());
    if (!what || what === "rotate") {
      const rotateVal = Number(this.rotate);
      if (!rotateVal) el.removeAttribute(this.rotateAttr || "rotate");
      else el.setAttribute(this.rotateAttr || "rotate", String(rotateVal));
    }
    if (!what || what === "flipH") setBool(this.flipHAttr || "flip-h", !!this.flipH);
    if (!what || what === "flipV") setBool(this.flipVAttr || "flip-v", !!this.flipV);
    store?.scheduleSnapshot?.();
  }
};
customElements.define("spectrum-icon-palette", SpectrumIconPalette);

// src/custom-elements/core/spectrum-size-palette.js
init_lit();
init_sp_popover();

// node_modules/@spectrum-web-components/menu/src/Menu.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/menu/src/menu.css.js
init_src();
var t21 = i`
    :host{--spectrum-menu-item-background-color-hover:var(--system-menu-item-background-color-hover);--spectrum-menu-item-background-color-down:var(--system-menu-item-background-color-down);--spectrum-menu-item-background-color-key-focus:var(--system-menu-item-background-color-key-focus);--spectrum-menu-item-corner-radius:var(--system-menu-item-corner-radius);--spectrum-menu-item-focus-indicator-shadow:var(--system-menu-item-focus-indicator-shadow);--spectrum-menu-item-focus-indicator-offset:var(--system-menu-item-focus-indicator-offset);--spectrum-menu-item-spacing-multiplier:var(--system-menu-item-spacing-multiplier);--spectrum-menu-item-focus-indicator-outline-style:var(--system-menu-item-focus-indicator-outline-style)}@media (forced-colors:active){:host{--highcontrast-menu-item-background-color-default:ButtonFace;--highcontrast-menu-item-color-default:ButtonText;--highcontrast-menu-item-background-color-focus:Highlight;--highcontrast-menu-item-color-focus:HighlightText;--highcontrast-menu-checkmark-icon-color-default:Highlight;--highcontrast-menu-item-color-disabled:GrayText;--highcontrast-menu-item-focus-indicator-color:Highlight;--highcontrast-menu-item-selected-background-color:Highlight;--highcontrast-menu-item-selected-color:HighlightText}@supports (color:SelectedItem){:host{--highcontrast-menu-item-selected-background-color:SelectedItem;--highcontrast-menu-item-selected-color:SelectedItemText}}}:host{--spectrum-menu-item-top-to-action:var(--spectrum-spacing-50);--spectrum-menu-item-top-to-checkbox:var(--spectrum-spacing-50);--spectrum-menu-item-label-line-height:var(--spectrum-line-height-100);--spectrum-menu-item-label-line-height-cjk:var(--spectrum-cjk-line-height-100);--spectrum-menu-item-label-to-description-spacing:var(--spectrum-menu-item-label-to-description);--spectrum-menu-item-focus-indicator-width:var(--mod-menu-item-focus-indicator-width,var(--spectrum-border-width-200));--spectrum-menu-item-focus-indicator-color:var(--spectrum-blue-800);--spectrum-menu-item-label-to-value-area-min-spacing:var(--spectrum-spacing-100);--spectrum-menu-item-label-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-menu-item-label-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-menu-item-label-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-menu-item-label-content-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-menu-item-label-icon-color-default:var(--spectrum-neutral-content-color-default);--spectrum-menu-item-label-icon-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-menu-item-label-icon-color-down:var(--spectrum-neutral-content-color-down);--spectrum-menu-item-label-icon-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-menu-item-label-content-color-disabled:var(--spectrum-disabled-content-color);--spectrum-menu-item-label-icon-color-disabled:var(--spectrum-disabled-content-color);--spectrum-menu-item-description-line-height:var(--spectrum-line-height-100);--spectrum-menu-item-description-line-height-cjk:var(--spectrum-cjk-line-height-100);--spectrum-menu-item-description-color-default:var(--spectrum-neutral-subdued-content-color-default);--spectrum-menu-item-description-color-hover:var(--spectrum-neutral-subdued-content-color-hover);--spectrum-menu-item-description-color-down:var(--spectrum-neutral-subdued-content-color-down);--spectrum-menu-item-description-color-focus:var(--spectrum-neutral-subdued-content-color-key-focus);--spectrum-menu-item-description-color-disabled:var(--spectrum-disabled-content-color);--spectrum-menu-section-header-line-height:var(--spectrum-line-height-100);--spectrum-menu-section-header-line-height-cjk:var(--spectrum-cjk-line-height-100);--spectrum-menu-section-header-font-weight:var(--spectrum-bold-font-weight);--spectrum-menu-section-header-color:var(--spectrum-gray-900);--spectrum-menu-collapsible-icon-color:var(--spectrum-gray-900);--spectrum-menu-checkmark-icon-color-default:var(--spectrum-accent-color-900);--spectrum-menu-checkmark-icon-color-hover:var(--spectrum-accent-color-1000);--spectrum-menu-checkmark-icon-color-down:var(--spectrum-accent-color-1100);--spectrum-menu-checkmark-icon-color-focus:var(--spectrum-accent-color-1000);--spectrum-menu-drillin-icon-color-default:var(--spectrum-neutral-subdued-content-color-default);--spectrum-menu-drillin-icon-color-hover:var(--spectrum-neutral-subdued-content-color-hover);--spectrum-menu-drillin-icon-color-down:var(--spectrum-neutral-subdued-content-color-down);--spectrum-menu-drillin-icon-color-focus:var(--spectrum-neutral-subdued-content-color-key-focus);--spectrum-menu-item-value-color-default:var(--spectrum-neutral-subdued-content-color-default);--spectrum-menu-item-value-color-hover:var(--spectrum-neutral-subdued-content-color-hover);--spectrum-menu-item-value-color-down:var(--spectrum-neutral-subdued-content-color-down);--spectrum-menu-item-value-color-focus:var(--spectrum-neutral-subdued-content-color-key-focus);--spectrum-menu-checkmark-display-hidden:none;--spectrum-menu-checkmark-display-shown:block;--spectrum-menu-checkmark-display:var(--spectrum-menu-checkmark-display-shown);--spectrum-menu-item-min-height:var(--spectrum-component-height-100);--spectrum-menu-item-icon-height:var(--spectrum-workflow-icon-size-100);--spectrum-menu-item-icon-width:var(--spectrum-workflow-icon-size-100);--spectrum-menu-item-label-font-size:var(--spectrum-font-size-100);--spectrum-menu-item-label-text-to-visual:var(--spectrum-text-to-visual-100);--spectrum-menu-item-label-inline-edge-to-content:var(--spectrum-component-edge-to-text-100);--spectrum-menu-item-top-edge-to-text:var(--spectrum-component-top-to-text-100);--spectrum-menu-item-bottom-edge-to-text:var(--spectrum-component-bottom-to-text-100);--spectrum-menu-item-text-to-control:var(--spectrum-text-to-control-100);--spectrum-menu-item-description-font-size:var(--spectrum-font-size-75);--spectrum-menu-section-header-font-size:var(--spectrum-font-size-100);--spectrum-menu-section-header-min-width:var(--spectrum-component-height-100);--spectrum-menu-item-selectable-edge-to-text-not-selected:var(--spectrum-menu-item-selectable-edge-to-text-not-selected-medium);--spectrum-menu-item-checkmark-height:var(--spectrum-menu-item-checkmark-height-medium);--spectrum-menu-item-checkmark-width:var(--spectrum-menu-item-checkmark-width-medium);--spectrum-menu-item-top-to-checkmark:var(--spectrum-menu-item-top-to-selected-icon-medium);--spectrum-menu-back-icon-margin:var(--spectrum-navigational-indicator-top-to-back-icon-medium);--spectrum-menu-item-collapsible-no-icon-submenu-item-padding-x-start:calc(var(--spectrum-menu-item-label-inline-edge-to-content) + var(--spectrum-menu-item-checkmark-width) + var(--spectrum-menu-item-label-text-to-visual) + var(--spectrum-menu-item-focus-indicator-width));--spectrum-menu-item-focus-indicator-color-default:var(--highcontrast-menu-item-focus-indicator-color,var(--mod-menu-item-focus-indicator-color,var(--spectrum-menu-item-focus-indicator-color)));--spectrum-menu-item-focus-indicator-border-width:calc(var(--spectrum-menu-item-focus-indicator-width)*var(--spectrum-menu-item-focus-indicator-direction-scalar,1))}:host([size=s]){--spectrum-menu-item-min-height:var(--spectrum-component-height-75);--spectrum-menu-item-icon-height:var(--spectrum-workflow-icon-size-75);--spectrum-menu-item-icon-width:var(--spectrum-workflow-icon-size-75);--spectrum-menu-item-label-font-size:var(--spectrum-font-size-75);--spectrum-menu-item-label-text-to-visual:var(--spectrum-text-to-visual-75);--spectrum-menu-item-label-inline-edge-to-content:var(--spectrum-component-edge-to-text-75);--spectrum-menu-item-top-edge-to-text:var(--spectrum-component-top-to-text-75);--spectrum-menu-item-bottom-edge-to-text:var(--spectrum-component-bottom-to-text-75);--spectrum-menu-item-text-to-control:var(--spectrum-text-to-control-75);--spectrum-menu-item-description-font-size:var(--spectrum-font-size-50);--spectrum-menu-section-header-font-size:var(--spectrum-font-size-75);--spectrum-menu-section-header-min-width:var(--spectrum-component-height-75);--spectrum-menu-item-selectable-edge-to-text-not-selected:var(--spectrum-menu-item-selectable-edge-to-text-not-selected-small);--spectrum-menu-item-checkmark-height:var(--spectrum-menu-item-checkmark-height-small);--spectrum-menu-item-checkmark-width:var(--spectrum-menu-item-checkmark-width-small);--spectrum-menu-item-top-to-checkmark:var(--spectrum-menu-item-top-to-selected-icon-small);--spectrum-menu-back-icon-margin:var(--spectrum-navigational-indicator-top-to-back-icon-small)}:host([size=l]){--spectrum-menu-item-min-height:var(--spectrum-component-height-200);--spectrum-menu-item-icon-height:var(--spectrum-workflow-icon-size-200);--spectrum-menu-item-icon-width:var(--spectrum-workflow-icon-size-200);--spectrum-menu-item-label-font-size:var(--spectrum-font-size-200);--spectrum-menu-item-label-text-to-visual:var(--spectrum-text-to-visual-200);--spectrum-menu-item-label-inline-edge-to-content:var(--spectrum-component-edge-to-text-200);--spectrum-menu-item-top-edge-to-text:var(--spectrum-component-top-to-text-200);--spectrum-menu-item-bottom-edge-to-text:var(--spectrum-component-bottom-to-text-200);--spectrum-menu-item-text-to-control:var(--spectrum-text-to-control-200);--spectrum-menu-item-description-font-size:var(--spectrum-font-size-100);--spectrum-menu-section-header-font-size:var(--spectrum-font-size-200);--spectrum-menu-section-header-min-width:var(--spectrum-component-height-200);--spectrum-menu-item-selectable-edge-to-text-not-selected:var(--spectrum-menu-item-selectable-edge-to-text-not-selected-large);--spectrum-menu-item-checkmark-height:var(--spectrum-menu-item-checkmark-height-large);--spectrum-menu-item-checkmark-width:var(--spectrum-menu-item-checkmark-width-large);--spectrum-menu-item-top-to-checkmark:var(--spectrum-menu-item-top-to-selected-icon-large);--spectrum-menu-back-icon-margin:var(--spectrum-navigational-indicator-top-to-back-icon-large)}:host([size=xl]){--spectrum-menu-item-min-height:var(--spectrum-component-height-300);--spectrum-menu-item-icon-height:var(--spectrum-workflow-icon-size-300);--spectrum-menu-item-icon-width:var(--spectrum-workflow-icon-size-300);--spectrum-menu-item-label-font-size:var(--spectrum-font-size-300);--spectrum-menu-item-label-text-to-visual:var(--spectrum-text-to-visual-300);--spectrum-menu-item-label-inline-edge-to-content:var(--spectrum-component-edge-to-text-300);--spectrum-menu-item-top-edge-to-text:var(--spectrum-component-top-to-text-300);--spectrum-menu-item-bottom-edge-to-text:var(--spectrum-component-bottom-to-text-300);--spectrum-menu-item-text-to-control:var(--spectrum-text-to-control-300);--spectrum-menu-item-description-font-size:var(--spectrum-font-size-200);--spectrum-menu-section-header-font-size:var(--spectrum-font-size-300);--spectrum-menu-section-header-min-width:var(--spectrum-component-height-300);--spectrum-menu-item-selectable-edge-to-text-not-selected:var(--spectrum-menu-item-selectable-edge-to-text-not-selected-extra-large);--spectrum-menu-item-checkmark-height:var(--spectrum-menu-item-checkmark-height-extra-large);--spectrum-menu-item-checkmark-width:var(--spectrum-menu-item-checkmark-width-extra-large);--spectrum-menu-item-top-to-checkmark:var(--spectrum-menu-item-top-to-selected-icon-extra-large);--spectrum-menu-back-icon-margin:var(--spectrum-navigational-indicator-top-to-back-icon-extra-large)}:host:dir(rtl),:host([dir=rtl]){--spectrum-menu-item-focus-indicator-direction-scalar:-1}:host{inline-size:var(--mod-menu-inline-size,auto);box-sizing:border-box;margin:0;padding:0;list-style-type:none;display:inline-block;overflow:auto}:host:lang(ja),:host:lang(ko),:host:lang(zh){--spectrum-menu-item-label-line-height:var(--mod-menu-item-label-line-height-cjk,var(--spectrum-menu-item-label-line-height-cjk));--spectrum-menu-item-description-line-height:var(--mod-menu-item-description-line-height-cjk,var(--spectrum-menu-item-description-line-height-cjk));--spectrum-menu-section-header-line-height:var(--mod-menu-section-header-line-height-cjk,var(--spectrum-menu-section-header-line-height-cjk))}:host([selects]) ::slotted(sp-menu-item){--spectrum-menu-checkmark-display:var(--spectrum-menu-checkmark-display-hidden);padding-inline-start:var(--mod-menu-item-selectable-edge-to-text-not-selected,var(--spectrum-menu-item-selectable-edge-to-text-not-selected))}:host([selects]) ::slotted(sp-menu-item[selected]){--spectrum-menu-checkmark-display:var(--spectrum-menu-checkmark-display-shown);padding-inline-start:var(--mod-menu-item-label-inline-edge-to-content,var(--spectrum-menu-item-label-inline-edge-to-content))}.spectrum-Menu-backIcon{margin-block:var(--mod-menu-back-icon-margin-block,var(--spectrum-menu-back-icon-margin));margin-inline:var(--mod-menu-back-icon-margin-inline,var(--spectrum-menu-back-icon-margin));fill:var(--highcontrast-menu-item-color-default,var(--mod-menu-back-icon-color-default,var(--spectrum-menu-section-header-color)));color:var(--highcontrast-menu-item-color-default,var(--mod-menu-back-icon-color-default,var(--spectrum-menu-section-header-color)))}.spectrum-Menu-back:focus-visible{box-shadow:var(--spectrum-menu-item-focus-indicator-shadow)var(--spectrum-menu-item-focus-indicator-border-width)0 0 0 var(--spectrum-menu-item-focus-indicator-color-default);outline:var(--spectrum-menu-item-focus-indicator-width)var(--spectrum-menu-item-focus-indicator-outline-style)var(--spectrum-menu-item-focus-indicator-color-default);outline-offset:var(--spectrum-menu-item-focus-indicator-offset);border-radius:var(--spectrum-menu-item-corner-radius)}.spectrum-Menu-sectionHeading{color:var(--highcontrast-menu-item-color-default,var(--mod-menu-section-header-color,var(--spectrum-menu-section-header-color)));font-size:var(--mod-menu-section-header-font-size,var(--spectrum-menu-section-header-font-size));font-weight:var(--mod-menu-section-header-font-weight,var(--spectrum-menu-section-header-font-weight));line-height:var(--mod-menu-section-header-line-height,var(--spectrum-menu-section-header-line-height));min-inline-size:var(--mod-menu-section-header-min-width,var(--spectrum-menu-section-header-min-width));padding-block-start:var(--mod-menu-section-header-top-edge-to-text,var(--mod-menu-item-top-edge-to-text,var(--spectrum-menu-item-top-edge-to-text)));padding-block-end:var(--mod-menu-section-header-bottom-edge-to-text,var(--mod-menu-item-bottom-edge-to-text,var(--spectrum-menu-item-bottom-edge-to-text)));padding-inline:var(--mod-menu-item-label-inline-edge-to-content,var(--spectrum-menu-item-label-inline-edge-to-content));grid-area:sectionHeadingArea/1/sectionHeadingArea/-1;display:block}.spectrum-Menu-back{padding-inline:var(--mod-menu-back-padding-inline-start,0)var(--mod-menu-back-padding-inline-end,var(--spectrum-menu-item-label-inline-edge-to-content));padding-block:var(--mod-menu-back-padding-block-start,0)var(--mod-menu-back-padding-block-end,0);flex-flow:wrap;align-items:center;display:flex}.spectrum-Menu-back .spectrum-Menu-sectionHeading{padding:0}.spectrum-Menu-backButton{cursor:pointer;background:0 0;border:0;margin:0;padding:0;display:inline-flex}.spectrum-Menu-backButton:focus-visible{outline:var(--spectrum-focus-indicator-thickness)solid var(--spectrum-focus-indicator-color);outline-offset:calc((var(--spectrum-focus-indicator-thickness) + 1px)*-1)}.spectrum-Menu-backHeading{color:var(--highcontrast-menu-item-color-default,var(--mod-menu-back-heading-color,var(--spectrum-menu-section-header-color)));font-size:var(--mod-menu-section-header-font-size,var(--spectrum-menu-section-header-font-size));font-weight:var(--mod-menu-section-header-font-weight,var(--spectrum-menu-section-header-font-weight));line-height:var(--mod-menu-section-header-line-height,var(--spectrum-menu-section-header-line-height));display:block}:host{width:var(--swc-menu-width);flex-direction:column}:host(:focus){outline:none}::slotted(*){flex-shrink:0}
`;
var menu_css_default = t21;

// node_modules/@spectrum-web-components/menu/src/Menu.js
var v3 = Object.defineProperty;
var b7 = Object.getOwnPropertyDescriptor;
var o31 = (p30, c33, e36, s19) => {
  for (var t34 = s19 > 1 ? void 0 : s19 ? b7(c33, e36) : c33, i21 = p30.length - 1, n25; i21 >= 0; i21--) (n25 = p30[i21]) && (t34 = (s19 ? n25(c33, e36, t34) : n25(t34)) || t34);
  return s19 && t34 && v3(c33, e36, t34), t34;
};
var Menu = class extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {
  constructor() {
    super();
    this.touchStartY = void 0;
    this.touchStartTime = void 0;
    this.isCurrentlyScrolling = false;
    this.scrollThreshold = 10;
    this.scrollTimeThreshold = 300;
    this.label = "";
    this.ignore = false;
    this.value = "";
    this.valueSeparator = ",";
    this._selected = [];
    this.selectedItems = [];
    this.childItemSet = /* @__PURE__ */ new Set();
    this.focusedItemIndex = 0;
    this.focusInItemIndex = 0;
    this.shouldSupportDragAndSelect = false;
    this.selectedItemsMap = /* @__PURE__ */ new Map();
    this.pointerUpTarget = null;
    this.descendentOverlays = /* @__PURE__ */ new Map();
    this.handleSubmenuClosed = (e36) => {
      e36.stopPropagation(), e36.composedPath()[0].dispatchEvent(new Event("sp-menu-submenu-closed", { bubbles: true, composed: true }));
    };
    this.handleSubmenuOpened = (e36) => {
      e36.stopPropagation(), e36.composedPath()[0].dispatchEvent(new Event("sp-menu-submenu-opened", { bubbles: true, composed: true })), e36.composedPath().find((i21) => this.childItemSet.has(i21));
    };
    this._hasUpdatedSelectedItemIndex = false;
    this._willUpdateItems = false;
    this.cacheUpdated = Promise.resolve();
    this.resolveCacheUpdated = () => {
    };
    !this.rovingTabindexController && this.controlsRovingTabindex && (this.rovingTabindexController = new RovingTabindexController(this, { direction: "vertical", focusInIndex: (e36) => {
      let s19 = -1;
      const t34 = e36 == null ? void 0 : e36.findIndex((i21, n25) => (!e36[s19] && !i21.disabled && (s19 = n25), i21.selected && !i21.disabled));
      return e36 && t34 && e36[t34] ? t34 : s19;
    }, elements: () => this.childItems, isFocusableElement: this.isFocusableElement.bind(this), hostDelegatesFocus: true })), this.addEventListener("sp-menu-item-added-or-updated", this.onSelectableItemAddedOrUpdated), this.addEventListener("sp-menu-item-added-or-updated", this.onFocusableItemAddedOrUpdated, { capture: true }), this.addEventListener("click", this.handleClick), this.addEventListener("touchend", this.handlePointerup), this.addEventListener("focusout", this.handleFocusout), this.addEventListener("sp-menu-item-keydown", this.handleKeydown), this.addEventListener("pointerup", this.handlePointerup), this.addEventListener("sp-opened", this.handleSubmenuOpened), this.addEventListener("sp-closed", this.handleSubmenuClosed), this.addEventListener("touchstart", this.handleTouchStart, { passive: true }), this.addEventListener("touchmove", this.handleTouchMove, { passive: true });
  }
  static get styles() {
    return [menu_css_default];
  }
  get isSubmenu() {
    return this.slot === "submenu";
  }
  get isScrolling() {
    return this.isCurrentlyScrolling;
  }
  set isScrolling(e36) {
    this.isCurrentlyScrolling = e36;
  }
  get selected() {
    return this.selects ? this._selected : [];
  }
  set selected(e36) {
    if (e36 === this.selected) return;
    const s19 = this.selected;
    this._selected = e36, this.selectedItems = [], this.selectedItemsMap.clear(), this.childItems.forEach((t34) => {
      this === t34.menuData.selectionRoot && (t34.selected = this.selected.includes(t34.value), t34.selected && (this.selectedItems.push(t34), this.selectedItemsMap.set(t34, true)));
    }), this.requestUpdate("selected", s19);
  }
  get focusInItem() {
    var e36;
    return (e36 = this.rovingTabindexController) == null ? void 0 : e36.focusInElement;
  }
  get controlsRovingTabindex() {
    return true;
  }
  get childItems() {
    return this.cachedChildItems || (this.cachedChildItems = this.updateCachedMenuItems()), this.cachedChildItems;
  }
  updateCachedMenuItems() {
    var t34;
    if (!this.menuSlot) return [];
    const e36 = [], s19 = this.menuSlot.assignedElements({ flatten: true });
    for (const [i21, n25] of s19.entries()) {
      if (this.childItemSet.has(n25)) {
        e36.push(n25);
        continue;
      }
      const d22 = n25.localName === "slot" ? n25.assignedElements({ flatten: true }) : [...n25.querySelectorAll(":scope > *")];
      s19.splice(i21, 1, n25, ...d22);
    }
    return this.cachedChildItems = [...e36], (t34 = this.rovingTabindexController) == null || t34.clearElementCache(), this.cachedChildItems;
  }
  get childRole() {
    if (this.resolvedRole === "listbox") return "option";
    switch (this.resolvedSelects) {
      case "single":
        return "menuitemradio";
      case "multiple":
        return "menuitemcheckbox";
      default:
        return "menuitem";
    }
  }
  get ownRole() {
    return "menu";
  }
  onFocusableItemAddedOrUpdated(e36) {
    e36.menuCascade.set(this, { hadFocusRoot: !!e36.item.menuData.focusRoot, ancestorWithSelects: e36.currentAncestorWithSelects }), this.selects && (e36.currentAncestorWithSelects = this), e36.item.menuData.focusRoot = e36.item.menuData.focusRoot || this;
  }
  onSelectableItemAddedOrUpdated(e36) {
    var i21, n25;
    if (!e36.menuCascade.get(this)) return;
    if (e36.item.menuData.parentMenu = e36.item.menuData.parentMenu || this, this.addChildItem(e36.item), this.selects === "inherit") {
      this.resolvedSelects = "inherit";
      const l16 = (i21 = e36.currentAncestorWithSelects) == null ? void 0 : i21.ignore;
      this.resolvedRole = l16 ? "none" : ((n25 = e36.currentAncestorWithSelects) == null ? void 0 : n25.getAttribute("role")) || this.getAttribute("role") || void 0;
    } else this.selects ? (this.resolvedRole = this.ignore ? "none" : this.getAttribute("role") || void 0, this.resolvedSelects = this.selects) : (this.resolvedRole = this.ignore ? "none" : this.getAttribute("role") || void 0, this.resolvedSelects = this.resolvedRole === "none" ? "ignore" : "none");
    if (this.resolvedRole === "none") return;
    const t34 = this.resolvedSelects === "single" || this.resolvedSelects === "multiple";
    e36.item.menuData.cleanupSteps.push((l16) => this.removeChildItem(l16)), (t34 || !this.selects && this.resolvedSelects !== "ignore") && !e36.item.menuData.selectionRoot && (e36.item.setRole(this.childRole), e36.item.menuData.selectionRoot = e36.item.menuData.selectionRoot || this, e36.item.selected && (this.selectedItemsMap.set(e36.item, true), this.selectedItems = [...this.selectedItems, e36.item], this._selected = [...this.selected, e36.item.value], this.value = this.selected.join(this.valueSeparator)));
  }
  addChildItem(e36) {
    this.childItemSet.add(e36), this.handleItemsChanged();
  }
  async removeChildItem(e36) {
    (e36.focused || e36.hasAttribute("focused") || e36.active) && (this._updateFocus = this.getNeighboringFocusableElement(e36)), this.childItemSet.delete(e36), this.cachedChildItems = void 0;
  }
  focusOnFirstSelectedItem({ preventScroll: e36 } = {}) {
    var t34;
    if (!this.rovingTabindexController) return;
    const s19 = this.selectedItems.find((i21) => this.isFocusableElement(i21));
    if (!s19) {
      this.focus({ preventScroll: e36 });
      return;
    }
    s19 && !e36 && s19.scrollIntoView({ block: "nearest" }), (t34 = this.rovingTabindexController) == null || t34.focusOnItem(s19);
  }
  focus({ preventScroll: e36 } = {}) {
    if (this.rovingTabindexController) {
      if (!this.childItems.length || this.childItems.every((s19) => s19.disabled)) return;
      if (this.childItems.some((s19) => s19.menuData.focusRoot !== this)) {
        super.focus({ preventScroll: e36 });
        return;
      }
      this.rovingTabindexController.focus({ preventScroll: e36 });
    }
  }
  handleTouchStart(e36) {
    e36.touches.length === 1 && (this.touchStartY = e36.touches[0].clientY, this.touchStartTime = Date.now(), this.isCurrentlyScrolling = false);
  }
  handleTouchMove(e36) {
    if (e36.touches.length === 1 && this.touchStartY !== void 0 && this.touchStartTime !== void 0) {
      const s19 = e36.touches[0].clientY, t34 = Math.abs(s19 - this.touchStartY), i21 = Date.now() - this.touchStartTime;
      t34 > this.scrollThreshold && i21 < this.scrollTimeThreshold && (this.isCurrentlyScrolling = true);
    }
  }
  handleTouchEnd() {
    setTimeout(() => {
      this.isCurrentlyScrolling = false, this.touchStartY = void 0, this.touchStartTime = void 0;
    }, 100);
  }
  handleFocusout() {
    var e36;
    this.matches(":focus-within") || (e36 = this.rovingTabindexController) == null || e36.reset();
  }
  handleClick(e36) {
    if (this.pointerUpTarget === e36.target) {
      this.pointerUpTarget = null;
      return;
    }
    this.handlePointerBasedSelection(e36);
  }
  handlePointerup(e36) {
    this.handleTouchEnd(), this.shouldSupportDragAndSelect && (this.pointerUpTarget = e36.target, this.handlePointerBasedSelection(e36));
  }
  async handlePointerBasedSelection(e36) {
    var i21, n25;
    if (e36 instanceof MouseEvent && e36.button !== 0 || this.isScrolling) return;
    const t34 = e36.composedPath().find((l16) => l16 instanceof Element ? l16.getAttribute("role") === this.childRole : false);
    if (e36.defaultPrevented) {
      const l16 = this.childItems.indexOf(t34);
      ((i21 = t34 == null ? void 0 : t34.menuData) == null ? void 0 : i21.focusRoot) === this && l16 > -1 && (this.focusedItemIndex = l16);
      return;
    }
    if (t34 != null && t34.href && t34.href.length) {
      this.dispatchEvent(new Event("change", { bubbles: true, composed: true }));
      return;
    } else if (((n25 = t34 == null ? void 0 : t34.menuData) == null ? void 0 : n25.selectionRoot) === this && this.childItems.length) {
      if (e36.preventDefault(), t34.hasSubmenu || t34.open) return;
      this.selectOrToggleItem(t34);
    } else return;
    this.prepareToCleanUp();
  }
  handleDescendentOverlayOpened(e36) {
    const s19 = e36.composedPath()[0];
    s19.overlayElement && this.descendentOverlays.set(s19.overlayElement, s19.overlayElement);
  }
  handleDescendentOverlayClosed(e36) {
    const s19 = e36.composedPath()[0];
    s19.overlayElement && this.descendentOverlays.delete(s19.overlayElement);
  }
  getNeighboringFocusableElement(e36, s19 = false) {
    var d22;
    const t34 = s19 ? -1 : 1, i21 = ((d22 = this.rovingTabindexController) == null ? void 0 : d22.elements) || [], n25 = e36 ? i21.indexOf(e36) : -1;
    let l16 = Math.min(Math.max(0, n25 + t34), i21.length - 1);
    for (; !this.isFocusableElement(i21[l16]) && 0 < l16 && l16 < i21.length - 1; ) l16 += t34;
    return this.isFocusableElement(i21[l16]) ? i21[l16] : e36 || i21[0];
  }
  async selectOrToggleItem(e36) {
    var r25;
    const s19 = this.resolvedSelects, t34 = new Map(this.selectedItemsMap), i21 = this.selected.slice(), n25 = this.selectedItems.slice(), l16 = this.value;
    if (e36.menuData.selectionRoot !== this) return;
    if (s19 === "multiple") {
      this.selectedItemsMap.has(e36) ? this.selectedItemsMap.delete(e36) : this.selectedItemsMap.set(e36, true);
      const a23 = [], m18 = [];
      this.childItemSet.forEach((h16) => {
        h16.menuData.selectionRoot === this && this.selectedItemsMap.has(h16) && (a23.push(h16.value), m18.push(h16));
      }), this._selected = a23, this.selectedItems = m18, this.value = this.selected.join(this.valueSeparator);
    } else this.selectedItemsMap.clear(), this.selectedItemsMap.set(e36, true), this.value = e36.value, this._selected = [e36.value], this.selectedItems = [e36];
    if (!this.dispatchEvent(new Event("change", { cancelable: true, bubbles: true, composed: true }))) {
      this._selected = i21, this.selectedItems = n25, this.selectedItemsMap = t34, this.value = l16;
      return;
    }
    if (s19 === "single") {
      for (const a23 of t34.keys()) a23 !== e36 && (a23.selected = false);
      e36.selected = true;
    } else s19 === "multiple" ? e36.selected = !e36.selected : !e36.hasSubmenu && ((r25 = e36 == null ? void 0 : e36.menuData) == null ? void 0 : r25.focusRoot) === this && this.dispatchEvent(new Event("close", { bubbles: true }));
  }
  navigateBetweenRelatedMenus(e36) {
    const { key: s19, root: t34 } = e36, i21 = this.isLTR && s19 === "ArrowRight" || !this.isLTR && s19 === "ArrowLeft", n25 = this.isLTR && s19 === "ArrowLeft" || !this.isLTR && s19 === "ArrowRight" || s19 === "Escape", l16 = t34;
    i21 ? l16 != null && l16.hasSubmenu && (e36.stopPropagation(), l16.openOverlay(true)) : n25 && this.isSubmenu && (e36.stopPropagation(), this.dispatchEvent(new Event("close", { bubbles: true })), this.updateSelectedItemIndex());
  }
  handleKeydown(e36) {
    var d22;
    if (e36.defaultPrevented || !this.rovingTabindexController) return;
    const { key: s19, root: t34, shiftKey: i21, target: n25 } = e36, l16 = ["Enter", " "].includes(s19);
    if (i21 && n25 !== this && this.hasAttribute("tabindex")) {
      this.removeAttribute("tabindex");
      const r25 = (a23) => {
        !a23.shiftKey && !this.hasAttribute("tabindex") && (document.removeEventListener("keyup", r25), this.removeEventListener("focusout", r25));
      };
      document.addEventListener("keyup", r25), this.addEventListener("focusout", r25);
    }
    if (s19 === "Tab") {
      this.closeDescendentOverlays();
      return;
    }
    if (l16 && (t34 != null && t34.hasSubmenu) && !t34.open) {
      e36.preventDefault(), t34.openOverlay(true);
      return;
    }
    if (s19 === " " || s19 === "Enter") {
      e36.preventDefault(), (d22 = t34 == null ? void 0 : t34.focusElement) == null || d22.click(), t34 && this.selectOrToggleItem(t34);
      return;
    }
    this.navigateBetweenRelatedMenus(e36);
  }
  prepareToCleanUp() {
    document.addEventListener("focusout", () => {
      requestAnimationFrame(() => {
        const e36 = this.focusInItem;
        e36 && (e36.focused = false);
      });
    }, { once: true });
  }
  updateSelectedItemIndex() {
    let e36 = 0;
    const s19 = /* @__PURE__ */ new Map(), t34 = [], i21 = [];
    let n25 = this.childItems.length;
    for (; n25; ) {
      n25 -= 1;
      const l16 = this.childItems[n25];
      l16.menuData.selectionRoot === this && ((l16.selected || !this._hasUpdatedSelectedItemIndex && this.selected.includes(l16.value)) && (e36 = n25, s19.set(l16, true), t34.unshift(l16.value), i21.unshift(l16)), n25 !== e36 && (l16.focused = false));
    }
    this.selectedItemsMap = s19, this._selected = t34, this.selectedItems = i21, this.value = this.selected.join(this.valueSeparator), this.focusedItemIndex = e36, this.focusInItemIndex = e36;
  }
  handleItemsChanged() {
    this.cachedChildItems = void 0, this._willUpdateItems || (this._willUpdateItems = true, this.cacheUpdated = this.updateCache());
  }
  async updateCache() {
    this.hasUpdated ? await new Promise((e36) => requestAnimationFrame(() => e36(true))) : await Promise.all([new Promise((e36) => requestAnimationFrame(() => e36(true))), this.updateComplete]), this.cachedChildItems === void 0 && (this.updateSelectedItemIndex(), this.updateItemFocus()), this._willUpdateItems = false;
  }
  updateItemFocus() {
    var e36;
    (e36 = this.focusInItem) == null || e36.setAttribute("tabindex", "0"), this.childItems.length != 0;
  }
  closeDescendentOverlays() {
    this.descendentOverlays.forEach((e36) => {
      e36.open = false;
    }), this.descendentOverlays = /* @__PURE__ */ new Map();
  }
  handleSlotchange({ target: e36 }) {
    var t34;
    const s19 = e36.assignedElements({ flatten: true });
    this.childItems.length !== s19.length && s19.forEach((i21) => {
      typeof i21.triggerUpdate != "undefined" ? i21.triggerUpdate() : typeof i21.childItems != "undefined" && i21.childItems.forEach((n25) => {
        n25.triggerUpdate();
      });
    }), this._updateFocus && ((t34 = this.rovingTabindexController) == null || t34.focusOnItem(this._updateFocus), this._updateFocus = void 0);
  }
  renderMenuItemSlot() {
    return x`
            <slot
                @sp-menu-submenu-opened=${this.handleDescendentOverlayOpened}
                @sp-menu-submenu-closed=${this.handleDescendentOverlayClosed}
                @slotchange=${this.handleSlotchange}
            ></slot>
        `;
  }
  render() {
    return this.renderMenuItemSlot();
  }
  firstUpdated(e36) {
    super.firstUpdated(e36);
    const s19 = [new Promise((t34) => requestAnimationFrame(() => t34(true)))];
    [...this.children].forEach((t34) => {
      t34.localName === "sp-menu-item" && s19.push(t34.updateComplete);
    }), this.childItemsUpdated = Promise.all(s19);
  }
  updated(e36) {
    super.updated(e36), e36.has("selects") && this.hasUpdated && this.selectsChanged(), e36.has("label") && (this.label || typeof e36.get("label") != "undefined") && (this.label ? this.setAttribute("aria-label", this.label) : this.removeAttribute("aria-label"));
  }
  selectsChanged() {
    const e36 = [new Promise((s19) => requestAnimationFrame(() => s19(true)))];
    this.childItemSet.forEach((s19) => {
      e36.push(s19.triggerUpdate());
    }), this.childItemsUpdated = Promise.all(e36);
  }
  connectedCallback() {
    super.connectedCallback(), !this.hasAttribute("role") && !this.ignore && this.setAttribute("role", this.ownRole), this.updateComplete.then(() => this.updateItemFocus());
  }
  isFocusableElement(e36) {
    return e36 ? !e36.disabled : false;
  }
  disconnectedCallback() {
    this.cachedChildItems = void 0, this.selectedItems = [], this.selectedItemsMap.clear(), this.childItemSet.clear(), this.descendentOverlays = /* @__PURE__ */ new Map(), super.disconnectedCallback();
  }
  async getUpdateComplete() {
    const e36 = await super.getUpdateComplete();
    return await this.childItemsUpdated, await this.cacheUpdated, e36;
  }
};
Menu.shadowRootOptions = { ...SpectrumElement.shadowRootOptions, delegatesFocus: true }, o31([n4({ type: String, reflect: true })], Menu.prototype, "label", 2), o31([n4({ type: Boolean, reflect: true })], Menu.prototype, "ignore", 2), o31([n4({ type: String, reflect: true })], Menu.prototype, "selects", 2), o31([n4({ type: String })], Menu.prototype, "value", 2), o31([n4({ type: String, attribute: "value-separator" })], Menu.prototype, "valueSeparator", 2), o31([n4({ attribute: false })], Menu.prototype, "selected", 1), o31([n4({ attribute: false })], Menu.prototype, "selectedItems", 2), o31([e5("slot:not([name])")], Menu.prototype, "menuSlot", 2);

// node_modules/@spectrum-web-components/menu/sp-menu.js
init_define_element();
defineElement("sp-menu", Menu);

// node_modules/@spectrum-web-components/menu/src/MenuItem.js
init_src();
init_src2();
init_decorators2();
init_like_anchor();
init_focusable();

// node_modules/@spectrum-web-components/menu/src/menu-item.css.js
init_src();
var o32 = i`
    .checkmark{display:var(--mod-menu-checkmark-display,var(--spectrum-menu-checkmark-display));block-size:var(--mod-menu-item-checkmark-height,var(--spectrum-menu-item-checkmark-height));inline-size:var(--mod-menu-item-checkmark-width,var(--spectrum-menu-item-checkmark-width));fill:var(--highcontrast-menu-checkmark-icon-color-default,var(--mod-menu-checkmark-icon-color-default,var(--spectrum-menu-checkmark-icon-color-default)));color:var(--highcontrast-menu-checkmark-icon-color-default,var(--mod-menu-checkmark-icon-color-default,var(--spectrum-menu-checkmark-icon-color-default)));opacity:1;grid-area:checkmarkArea;align-self:start;margin-block-start:calc(var(--mod-menu-item-top-to-checkmark,var(--spectrum-menu-item-top-to-checkmark)) - var(--mod-menu-item-top-edge-to-text,var(--spectrum-menu-item-top-edge-to-text)));margin-inline-end:var(--mod-menu-item-text-to-control,var(--spectrum-menu-item-text-to-control))}.chevron{block-size:var(--spectrum-menu-item-checkmark-height);inline-size:var(--spectrum-menu-item-checkmark-width);grid-area:chevronArea;align-self:center;margin-inline-end:var(--mod-menu-item-text-to-control,var(--spectrum-menu-item-text-to-control))}.spectrum-Menu-back:focus-visible{box-shadow:var(--spectrum-menu-item-focus-indicator-shadow)var(--spectrum-menu-item-focus-indicator-border-width)0 0 0 var(--spectrum-menu-item-focus-indicator-color-default);outline:var(--spectrum-menu-item-focus-indicator-width)var(--spectrum-menu-item-focus-indicator-outline-style)var(--spectrum-menu-item-focus-indicator-color-default);outline-offset:var(--spectrum-menu-item-focus-indicator-offset);border-radius:var(--spectrum-menu-item-corner-radius)}.spectrum-Menu-backButton:focus-visible{outline:var(--spectrum-focus-indicator-thickness)solid var(--spectrum-focus-indicator-color);outline-offset:calc((var(--spectrum-focus-indicator-thickness) + 1px)*-1)}::slotted([slot=icon]){fill:var(--highcontrast-menu-item-color-default,var(--mod-menu-item-label-icon-color-default,var(--spectrum-menu-item-label-icon-color-default)));color:var(--highcontrast-menu-item-color-default,var(--mod-menu-item-label-icon-color-default,var(--spectrum-menu-item-label-icon-color-default)));grid-area:iconArea;align-self:start;margin-inline-end:var(--mod-menu-item-label-text-to-visual,var(--spectrum-menu-item-label-text-to-visual))}:host{cursor:pointer;border-radius:var(--spectrum-menu-item-corner-radius);box-sizing:border-box;background-color:var(--highcontrast-menu-item-background-color-default,var(--mod-menu-item-background-color-default,var(--spectrum-menu-item-background-color-default)));line-height:var(--mod-menu-item-label-line-height,var(--spectrum-menu-item-label-line-height));min-block-size:var(--mod-menu-item-min-height,var(--spectrum-menu-item-min-height));padding-block-start:var(--mod-menu-item-top-edge-to-text,var(--spectrum-menu-item-top-edge-to-text));padding-block-end:var(--mod-menu-item-bottom-edge-to-text,var(--spectrum-menu-item-bottom-edge-to-text));padding-inline:var(--mod-menu-item-label-inline-edge-to-content,var(--spectrum-menu-item-label-inline-edge-to-content));margin:calc((var(--spectrum-menu-item-focus-indicator-offset) + var(--spectrum-menu-item-focus-indicator-width))*var(--spectrum-menu-item-spacing-multiplier));grid-template:".chevronAreaCollapsible.headingIconArea sectionHeadingArea. . ."1fr"selectedArea chevronAreaCollapsible checkmarkArea iconArea labelArea valueArea actionsArea chevronAreaDrillIn"". . . .descriptionArea. . ."". . . .submenuArea. . ."/auto auto auto auto 1fr auto auto auto;align-items:center;-webkit-text-decoration:none;text-decoration:none;display:grid;position:relative}.spectrum-Menu-itemCheckbox{--mod-checkbox-top-to-text:0;--mod-checkbox-text-to-control:0;min-block-size:0}.spectrum-Menu-itemCheckbox .spectrum-Checkbox-box{margin-block-start:var(--mod-menu-item-top-to-checkbox,var(--spectrum-menu-item-top-to-checkbox));margin-block-end:0;margin-inline-end:var(--mod-menu-item-text-to-control,var(--spectrum-menu-item-text-to-control))}.spectrum-Menu-itemSwitch{min-block-size:0}.spectrum-Menu-itemSwitch .spectrum-Switch-switch{margin-block-start:var(--mod-menu-item-top-to-action,var(--spectrum-menu-item-top-to-action));margin-block-end:0}#label{grid-area:submenuItemLabelArea}::slotted([slot=value]){grid-area:submenuItemValueArea}:host([focused]),:host(:focus){background-color:var(--highcontrast-menu-item-background-color-focus,var(--mod-menu-item-background-color-key-focus,var(--spectrum-menu-item-background-color-key-focus)));outline:none}:host([focused])>#label,:host(:focus)>#label{color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-content-color-focus,var(--spectrum-menu-item-label-content-color-focus)))}:host([focused])>[name=description]::slotted(*),:host(:focus)>[name=description]::slotted(*){color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-description-color-focus,var(--spectrum-menu-item-description-color-focus)))}:host([focused])>::slotted([slot=value]),:host(:focus)>::slotted([slot=value]){color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-value-color-focus,var(--spectrum-menu-item-value-color-focus)))}:host([focused])>.icon:not(.chevron,.checkmark),:host(:focus)>.icon:not(.chevron,.checkmark){fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-icon-color-focus,var(--spectrum-menu-item-label-icon-color-focus)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-icon-color-focus,var(--spectrum-menu-item-label-icon-color-focus)))}:host([focused])>.chevron,:host(:focus)>.chevron{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-collapsible-icon-color,var(--spectrum-menu-collapsible-icon-color)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-collapsible-icon-color,var(--spectrum-menu-collapsible-icon-color)))}:host([focused])>.checkmark,:host(:focus)>.checkmark{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-checkmark-icon-color-focus,var(--spectrum-menu-checkmark-icon-color-focus)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-checkmark-icon-color-focus,var(--spectrum-menu-checkmark-icon-color-focus)))}:host(:is(:active,[active])){background-color:var(--highcontrast-menu-item-background-color-focus,var(--mod-menu-item-background-color-down,var(--spectrum-menu-item-background-color-down)))}:host(:is(:active,[active]))>#label{color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-content-color-down,var(--spectrum-menu-item-label-content-color-down)))}:host(:is(:active,[active]))>[name=description]::slotted(*){color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-description-color-down,var(--spectrum-menu-item-description-color-down)))}:host(:is(:active,[active]))>::slotted([slot=value]){color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-value-color-down,var(--spectrum-menu-item-value-color-down)))}:host(:is(:active,[active]))>.icon:not(.chevron,.checkmark){fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-icon-color-down,var(--spectrum-menu-item-label-icon-color-down)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-icon-color-down,var(--spectrum-menu-item-label-icon-color-down)))}:host(:is(:active,[active]))>.chevron{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-collapsible-icon-color,var(--spectrum-menu-collapsible-icon-color)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-collapsible-icon-color,var(--spectrum-menu-collapsible-icon-color)))}:host(:is(:active,[active]))>.checkmark{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-checkmark-icon-color-down,var(--spectrum-menu-checkmark-icon-color-down)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-checkmark-icon-color-down,var(--spectrum-menu-checkmark-icon-color-down)))}:host([disabled]),:host([aria-disabled=true]){background-color:initial}:host([disabled]) #label,:host([disabled]) ::slotted([slot=value]),:host([aria-disabled=true]) #label,:host([aria-disabled=true]) ::slotted([slot=value]){color:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-label-content-color-disabled,var(--spectrum-menu-item-label-content-color-disabled)))}:host([disabled]) [name=description]::slotted(*),:host([aria-disabled=true]) [name=description]::slotted(*){color:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-description-color-disabled,var(--spectrum-menu-item-description-color-disabled)))}:host([disabled]) ::slotted([slot=icon]),:host([aria-disabled=true]) ::slotted([slot=icon]){color:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-label-icon-color-disabled,var(--spectrum-menu-item-label-icon-color-disabled)));fill:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-label-icon-color-disabled,var(--spectrum-menu-item-label-icon-color-disabled)))}:host([focused]) .spectrum-Menu-back,:host([focused]){box-shadow:var(--spectrum-menu-item-focus-indicator-shadow)var(--spectrum-menu-item-focus-indicator-border-width)0 0 0 var(--spectrum-menu-item-focus-indicator-color-default);outline:var(--spectrum-menu-item-focus-indicator-width)var(--spectrum-menu-item-focus-indicator-outline-style)var(--spectrum-menu-item-focus-indicator-color-default);outline-offset:var(--spectrum-menu-item-focus-indicator-offset);border-radius:var(--spectrum-menu-item-corner-radius)}.spectrum-Menu-itemSelection{grid-area:selectedArea}#label{--mod-switch-control-label-spacing:0;--mod-switch-spacing-top-to-label:0;font-size:var(--mod-menu-item-label-font-size,var(--spectrum-menu-item-label-font-size));color:var(--highcontrast-menu-item-color-default,var(--mod-menu-item-label-content-color-default,var(--spectrum-menu-item-label-content-color-default)));hyphens:auto;overflow-wrap:break-word;grid-area:labelArea}::slotted([slot=value]){color:var(--highcontrast-menu-item-color-default,var(--mod-menu-item-value-color-default,var(--spectrum-menu-item-value-color-default)));font-size:var(--mod-menu-item-label-font-size,var(--spectrum-menu-item-label-font-size));grid-area:valueArea;justify-self:end}.spectrum-Menu-itemActions,::slotted([slot=value]){align-self:start;margin-inline-start:var(--mod-menu-item-label-to-value-area-min-spacing,var(--spectrum-menu-item-label-to-value-area-min-spacing))}.spectrum-Menu-itemActions{grid-area:actionsArea}[name=description]::slotted(*){color:var(--highcontrast-menu-item-color-default,var(--mod-menu-item-description-color-default,var(--spectrum-menu-item-description-color-default)));font-size:var(--mod-menu-item-description-font-size,var(--spectrum-menu-item-description-font-size));hyphens:auto;overflow-wrap:break-word;line-height:var(--mod-menu-item-description-line-height,var(--spectrum-menu-item-description-line-height));grid-area:descriptionArea;margin-block-start:var(--mod-menu-item-label-to-description-spacing,var(--spectrum-menu-item-label-to-description-spacing))}:host([no-wrap]) #label{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.spectrum-Menu-item--collapsible.is-open{padding-block-end:0}.spectrum-Menu-item--collapsible.is-open .chevron{transform:rotate(90deg)}:host([focused]) .spectrum-Menu-item--collapsible.is-open,:host(:is(:active,[active])) .spectrum-Menu-item--collapsible.is-open,.spectrum-Menu-item--collapsible.is-open:focus{background-color:var(--highcontrast-menu-item-background-color-default,var(--mod-menu-item-background-color-default,var(--spectrum-menu-item-background-color-default)))}.spectrum-Menu-item--collapsible ::slotted([slot=icon]){grid-area:headingIconArea}.spectrum-Menu-item--collapsible>::slotted([slot=icon]){padding-block-start:var(--mod-menu-section-header-top-edge-to-text,var(--mod-menu-item-top-edge-to-text,var(--spectrum-menu-item-top-edge-to-text)));padding-block-end:var(--mod-menu-section-header-bottom-edge-to-text,var(--mod-menu-item-bottom-edge-to-text,var(--spectrum-menu-item-bottom-edge-to-text)))}.spectrum-Menu-item--collapsible .chevron{grid-area:chevronAreaCollapsible}:host([has-submenu]) .chevron{fill:var(--highcontrast-menu-item-color-default,var(--mod-menu-drillin-icon-color-default,var(--spectrum-menu-drillin-icon-color-default)));color:var(--highcontrast-menu-item-color-default,var(--mod-menu-drillin-icon-color-default,var(--spectrum-menu-drillin-icon-color-default)));grid-area:chevronAreaDrillIn;margin-inline-start:var(--mod-menu-item-label-to-value-area-min-spacing,var(--spectrum-menu-item-label-to-value-area-min-spacing));margin-inline-end:0}:host([has-submenu]) .is-open{--spectrum-menu-item-background-color-default:var(--highcontrast-menu-item-selected-background-color,var(--mod-menu-item-background-color-hover,var(--spectrum-menu-item-background-color-hover)))}:host([has-submenu]) .is-open .icon:not(.chevron,.checkmark){fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-icon-color-hover,var(--spectrum-menu-item-label-icon-color-hover)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-icon-color-hover,var(--spectrum-menu-item-label-icon-color-hover)))}:host([has-submenu]) .is-open .chevron{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-drillin-icon-color-hover,var(--spectrum-menu-drillin-icon-color-hover)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-drillin-icon-color-hover,var(--spectrum-menu-drillin-icon-color-hover)))}:host([has-submenu]) .is-open .checkmark{fill:var(--highcontrast-menu-checkmark-icon-color-default,var(--mod-menu-checkmark-icon-color-hover,var(--spectrum-menu-checkmark-icon-color-hover)));color:var(--highcontrast-menu-checkmark-icon-color-default,var(--mod-menu-checkmark-icon-color-hover,var(--spectrum-menu-checkmark-icon-color-hover)))}@media (hover:hover){:host(:hover){background-color:var(--highcontrast-menu-item-background-color-focus,var(--mod-menu-item-background-color-hover,var(--spectrum-menu-item-background-color-hover)))}:host(:hover)>#label{color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-content-color-hover,var(--spectrum-menu-item-label-content-color-hover)))}:host(:hover)>[name=description]::slotted(*){color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-description-color-hover,var(--spectrum-menu-item-description-color-hover)))}:host(:hover)>::slotted([slot=value]){color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-value-color-hover,var(--spectrum-menu-item-value-color-hover)))}:host(:hover)>.icon:not(.chevron,.checkmark){fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-icon-color-hover,var(--spectrum-menu-item-label-icon-color-hover)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-item-label-icon-color-hover,var(--spectrum-menu-item-label-icon-color-hover)))}:host(:hover)>.chevron{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-collapsible-icon-color,var(--spectrum-menu-collapsible-icon-color)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-collapsible-icon-color,var(--spectrum-menu-collapsible-icon-color)))}:host(:hover)>.checkmark{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-checkmark-icon-color-hover,var(--spectrum-menu-checkmark-icon-color-hover)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-checkmark-icon-color-hover,var(--spectrum-menu-checkmark-icon-color-hover)))}:host([disabled]:hover),:host([aria-disabled=true]:hover){cursor:default;background-color:initial}:host([disabled]:hover) #label,:host([disabled]:hover) ::slotted([slot=value]),:host([aria-disabled=true]:hover) #label,:host([aria-disabled=true]:hover) ::slotted([slot=value]){color:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-label-content-color-disabled,var(--spectrum-menu-item-label-content-color-disabled)))}:host([disabled]:hover) [name=description]::slotted(*),:host([aria-disabled=true]:hover) [name=description]::slotted(*){color:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-description-color-disabled,var(--spectrum-menu-item-description-color-disabled)))}:host([disabled]:hover) ::slotted([slot=icon]),:host([aria-disabled=true]:hover) ::slotted([slot=icon]){color:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-label-icon-color-disabled,var(--spectrum-menu-item-label-icon-color-disabled)));fill:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-label-icon-color-disabled,var(--spectrum-menu-item-label-icon-color-disabled)))}.spectrum-Menu-item--collapsible.is-open:hover{background-color:var(--highcontrast-menu-item-background-color-default,var(--mod-menu-item-background-color-default,var(--spectrum-menu-item-background-color-default)))}:host([has-submenu]:hover) .chevron{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-drillin-icon-color-hover,var(--spectrum-menu-drillin-icon-color-hover)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-drillin-icon-color-hover,var(--spectrum-menu-drillin-icon-color-hover)))}}:host([has-submenu][focused]) .chevron,:host([has-submenu]:focus) .chevron{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-drillin-icon-color-focus,var(--spectrum-menu-drillin-icon-color-focus)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-drillin-icon-color-focus,var(--spectrum-menu-drillin-icon-color-focus)))}:host([has-submenu]:is(:active,[active])) .chevron{fill:var(--highcontrast-menu-item-color-focus,var(--mod-menu-drillin-icon-color-down,var(--spectrum-menu-drillin-icon-color-down)));color:var(--highcontrast-menu-item-color-focus,var(--mod-menu-drillin-icon-color-down,var(--spectrum-menu-drillin-icon-color-down)))}.spectrum-Menu-back{padding-inline:var(--mod-menu-back-padding-inline-start,0)var(--mod-menu-back-padding-inline-end,var(--spectrum-menu-item-label-inline-edge-to-content));padding-block:var(--mod-menu-back-padding-block-start,0)var(--mod-menu-back-padding-block-end,0);flex-flow:wrap;align-items:center;display:flex}.spectrum-Menu-backButton{cursor:pointer;background:0 0;border:0;margin:0;padding:0;display:inline-flex}:host([focused]) .spectrum-Menu-backButton{outline:var(--spectrum-focus-indicator-thickness)solid var(--spectrum-focus-indicator-color);outline-offset:calc((var(--spectrum-focus-indicator-thickness) + 1px)*-1)}.spectrum-Menu-backHeading{color:var(--highcontrast-menu-item-color-default,var(--mod-menu-back-heading-color,var(--spectrum-menu-section-header-color)));font-size:var(--mod-menu-section-header-font-size,var(--spectrum-menu-section-header-font-size));font-weight:var(--mod-menu-section-header-font-weight,var(--spectrum-menu-section-header-font-weight));line-height:var(--mod-menu-section-header-line-height,var(--spectrum-menu-section-header-line-height));display:block}:host{text-align:initial}:host([hidden]){display:none}:host([disabled]){pointer-events:none}:host([disabled]) [name=value]::slotted(*),:host([has-submenu][disabled]) .chevron{color:var(--highcontrast-menu-item-color-disabled,var(--mod-menu-item-label-icon-color-disabled,var(--spectrum-menu-item-label-icon-color-disabled)))}#button{position:absolute;inset:0}:host([dir=ltr]) [icon-only]::slotted(:last-of-type){margin-right:auto}:host([dir=rtl]) [icon-only]::slotted(:last-of-type){margin-left:auto}@media (forced-colors:active){:host{forced-color-adjust:none}}::slotted([slot=submenu]){width:max-content;max-width:100%;overflow-y:auto}:host([no-wrap]) #label{display:block}:host([focused]:not(:focus-visible)){box-shadow:none;outline:none}
`;
var menu_item_css_default = o32;

// node_modules/@spectrum-web-components/menu/src/MenuItem.js
init_mutation_controller();
init_slottable_request_event();
var h9 = Object.defineProperty;
var p11 = Object.getOwnPropertyDescriptor;
var r11 = (a23, n25, e36, t34) => {
  for (var i21 = t34 > 1 ? void 0 : t34 ? p11(n25, e36) : n25, o52 = a23.length - 1, d22; o52 >= 0; o52--) (d22 = a23[o52]) && (i21 = (t34 ? d22(n25, e36, i21) : d22(i21)) || i21);
  return t34 && i21 && h9(n25, e36, i21), i21;
};
var P2 = 100;
var MenuItemAddedOrUpdatedEvent = class extends Event {
  constructor(e36) {
    super("sp-menu-item-added-or-updated", { bubbles: true, composed: true });
    this.menuCascade = /* @__PURE__ */ new WeakMap();
    this.clear(e36);
  }
  clear(e36) {
    this._item = e36, this.currentAncestorWithSelects = void 0, e36.menuData = { cleanupSteps: [], focusRoot: void 0, selectionRoot: void 0, parentMenu: void 0 }, this.menuCascade = /* @__PURE__ */ new WeakMap();
  }
  get item() {
    return this._item;
  }
};
var MenuItemKeydownEvent = class extends KeyboardEvent {
  constructor({ root: n25, event: e36 }) {
    super("sp-menu-item-keydown", { bubbles: true, composed: true }), this.root = n25, this._event = e36;
  }
  get altKey() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.altKey) || false;
  }
  get code() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.code) || "";
  }
  get ctrlKey() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.ctrlKey) || false;
  }
  get isComposing() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.isComposing) || false;
  }
  get key() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.key) || "";
  }
  get location() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.location) || 0;
  }
  get metaKey() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.metaKey) || false;
  }
  get repeat() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.repeat) || false;
  }
  get shiftKey() {
    var n25;
    return ((n25 = this._event) == null ? void 0 : n25.shiftKey) || false;
  }
};
var MenuItem = class extends LikeAnchor(ObserveSlotText(ObserveSlotPresence(Focusable, '[slot="icon"]'))) {
  constructor() {
    super();
    this.active = false;
    this.dependencyManager = new DependencyManagerController(this);
    this.focused = false;
    this.selected = false;
    this._value = "";
    this.hasSubmenu = false;
    this.noWrap = false;
    this.open = false;
    this._openedViaKeyboard = false;
    this._closedViaPointer = false;
    this.handleSlottableRequest = (e36) => {
      var t34;
      (t34 = this.submenuElement) == null || t34.dispatchEvent(new SlottableRequestEvent(e36.name, e36.data));
    };
    this.proxyFocus = () => {
      this.focus();
    };
    this.handleKeydown = (e36) => {
      const { target: t34, key: i21 } = e36, o52 = this.hasSubmenu && !this.open && [" ", "Enter"].includes(i21);
      t34 === this && ((["ArrowLeft", "ArrowRight", "Escape"].includes(i21) || o52) && e36.preventDefault(), this.dispatchEvent(new MenuItemKeydownEvent({ root: this, event: e36 })));
    };
    this.handleBeforetoggle = (e36) => {
      e36.newState === "closed" && (this.open = true, this.overlayElement.manuallyKeepOpen(), this.overlayElement.removeEventListener("beforetoggle", this.handleBeforetoggle));
    };
    this.recentlyLeftChild = false;
    this.willDispatchUpdate = false;
    this.menuData = { focusRoot: void 0, parentMenu: void 0, selectionRoot: void 0, cleanupSteps: [] };
    this.addEventListener("click", this.handleClickCapture, { capture: true }), this.addEventListener("focus", this.handleFocus), this.addEventListener("blur", this.handleBlur), new t12(this, { config: { characterData: true, childList: true, subtree: true, attributeFilter: ["src"] }, callback: (e36) => {
      e36.every((i21) => i21.target.slot === "submenu") || this.breakItemChildrenCache();
    } });
  }
  static get styles() {
    return [menu_item_css_default, spectrum_icon_checkmark_css_default, spectrum_icon_chevron_css_default];
  }
  get value() {
    return this._value || this.itemText;
  }
  set value(e36) {
    e36 !== this._value && (this._value = e36 || "", this._value ? this.setAttribute("value", this._value) : this.removeAttribute("value"));
  }
  get itemText() {
    return this.itemChildren.content.reduce((e36, t34) => e36 + (t34.textContent || "").trim(), "");
  }
  get focusElement() {
    return this;
  }
  get hasIcon() {
    return this.slotContentIsPresent;
  }
  get itemChildren() {
    if (!this.iconSlot || !this.contentSlot) return { icon: [], content: [] };
    if (this._itemChildren) return this._itemChildren;
    const e36 = this.iconSlot.assignedElements().map((i21) => {
      const o52 = i21.cloneNode(true);
      return o52.removeAttribute("slot"), o52.classList.toggle("icon"), o52;
    }), t34 = this.contentSlot.assignedNodes().map((i21) => i21.cloneNode(true));
    return this._itemChildren = { icon: e36, content: t34 }, this._itemChildren;
  }
  handleClickCapture(e36) {
    if (this.disabled) return e36.preventDefault(), e36.stopImmediatePropagation(), e36.stopPropagation(), false;
    this.shouldProxyClick();
  }
  shouldProxyClick() {
    let e36 = false;
    return this.anchorElement && (this.anchorElement.click(), e36 = true), e36;
  }
  breakItemChildrenCache() {
    this._itemChildren = void 0, this.triggerUpdate();
  }
  renderSubmenu() {
    const e36 = x`
            <slot
                name="submenu"
                @slotchange=${this.manageSubmenu}
                @sp-menu-item-added-or-updated=${{ handleEvent: (t34) => {
      t34.clear(t34.item);
    }, capture: true }}
                @focusin=${(t34) => t34.stopPropagation()}
            ></slot>
        `;
    return this.hasSubmenu ? (this.dependencyManager.add("sp-overlay"), this.dependencyManager.add("sp-popover"), Promise.resolve().then(() => init_sp_overlay()), Promise.resolve().then(() => init_sp_popover()), x`
            <sp-overlay
                receives-focus="false"
                .triggerElement=${this}
                ?disabled=${!this.hasSubmenu}
                ?open=${this.hasSubmenu && this.open && this.dependencyManager.loaded}
                .placement=${this.isLTR ? "right-start" : "left-start"}
                receives-focus="false"
                .offset=${[-10, -5]}
                .type=${"auto"}
                @close=${(t34) => t34.stopPropagation()}
                @slottable-request=${this.handleSlottableRequest}
            >
                <sp-popover
                    @change=${(t34) => {
      this.handleSubmenuChange(t34), this.open = false;
    }}
                    @pointerenter=${this.handleSubmenuPointerenter}
                    @pointerleave=${this.handleSubmenuPointerleave}
                    @sp-menu-item-added-or-updated=${(t34) => t34.stopPropagation()}
                >
                    ${e36}
                </sp-popover>
            </sp-overlay>
            <sp-icon-chevron100
                class="spectrum-UIIcon-ChevronRight100 chevron icon"
            ></sp-icon-chevron100>
        `) : e36;
  }
  render() {
    return x`
            ${this.selected ? x`
                      <sp-icon-checkmark100
                          id="selected"
                          class="spectrum-UIIcon-Checkmark100
                            icon
                            checkmark
                            ${this.hasIcon ? "checkmark--withAdjacentIcon" : ""}"
                      ></sp-icon-checkmark100>
                  ` : E}
            <slot name="icon"></slot>
            <div id="label">
                <slot id="slot"></slot>
            </div>
            <slot name="description"></slot>
            <slot name="value"></slot>
            ${this.href && this.href.length > 0 ? super.renderAnchor({ id: "button", ariaHidden: true, className: "button anchor hidden" }) : E}
            ${this.renderSubmenu()}
        `;
  }
  manageSubmenu(e36) {
    this.submenuElement = e36.target.assignedElements({ flatten: true })[0], this.hasSubmenu = !!this.submenuElement, this.hasSubmenu && this.setAttribute("aria-haspopup", "true");
  }
  handlePointerdown(e36) {
    e36.target === this && this.hasSubmenu && this.open && (this.addEventListener("focus", this.handleSubmenuFocus, { once: true }), this.overlayElement.addEventListener("beforetoggle", this.handleBeforetoggle));
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.setAttribute("tabindex", "-1"), this.addEventListener("keydown", this.handleKeydown), this.addEventListener("mouseover", this.handleMouseover), this.addEventListener("pointerdown", this.handlePointerdown), this.addEventListener("pointerenter", this.closeOverlaysForRoot), this.hasAttribute("id") || (this.id = `sp-menu-item-${randomID()}`);
  }
  getActiveElementSafely() {
    let e36 = this.getRootNode(), t34 = e36.activeElement;
    if (!t34 && e36 !== document) for (; e36 && e36 !== document && "host" in e36 && (e36 = e36.host.getRootNode(), t34 = e36.activeElement, !t34); ) ;
    return t34;
  }
  handleMouseover(e36) {
    if (e36.target === this) {
      const i21 = this.getActiveElementSafely();
      (!i21 || !this.isInputElement(i21)) && this.focus(), this.focused = false;
    }
  }
  isInputElement(e36) {
    return !!(this.isNativeInputElement(e36) || e36.contentEditable === "true" || this.isSpectrumInputComponent(e36));
  }
  isNativeInputElement(e36) {
    return e36 instanceof HTMLInputElement || e36 instanceof HTMLTextAreaElement || e36 instanceof HTMLSelectElement;
  }
  isSpectrumInputComponent(e36) {
    if (!e36.tagName.startsWith("SP-")) return false;
    const t34 = e36.getAttribute("role");
    return !!(t34 && ["textbox", "searchbox", "combobox", "slider"].includes(t34) || INPUT_COMPONENT_PATTERN.test(e36.tagName));
  }
  closeOverlaysForRoot() {
    var e36;
    this.open || (e36 = this.menuData.parentMenu) == null || e36.closeDescendentOverlays();
  }
  handleFocus(e36) {
    const { target: t34 } = e36;
    t34 === this && (this.focused = true);
  }
  handleBlur(e36) {
    const { target: t34 } = e36;
    t34 === this && (this.focused = false);
  }
  handleSubmenuClick(e36) {
    e36.composedPath().includes(this.overlayElement) || this.openOverlay(true);
  }
  handleSubmenuFocus() {
    requestAnimationFrame(() => {
      this.overlayElement.open = this.open, this.focused = false;
    });
  }
  handlePointerenter() {
    if (this.leaveTimeout) {
      clearTimeout(this.leaveTimeout), delete this.leaveTimeout, this.recentlyLeftChild = false;
      return;
    }
    this.focus(), this.openOverlay();
  }
  handlePointerleave() {
    this._closedViaPointer = true, this.open && !this.recentlyLeftChild && (this.leaveTimeout = setTimeout(() => {
      delete this.leaveTimeout, this.open = false;
    }, P2));
  }
  handleSubmenuChange(e36) {
    var t34;
    e36.stopPropagation(), (t34 = this.menuData.selectionRoot) == null || t34.selectOrToggleItem(this);
  }
  handleSubmenuPointerenter() {
    this.recentlyLeftChild = true;
  }
  async handleSubmenuPointerleave() {
    this.recentlyLeftChild = false;
  }
  handleSubmenuOpen(e36) {
    var i21;
    const t34 = e36.composedPath().find((o52) => o52 !== this.overlayElement && o52.localName === "sp-overlay");
    this._openedViaKeyboard && ((i21 = this.submenuElement) == null || i21.focus()), this.overlayElement.parentOverlayToForceClose = t34;
  }
  cleanup() {
    this._closedViaPointer = false, this.setAttribute("aria-expanded", "false"), this.open = false, this.active = false;
  }
  async openOverlay(e36 = false) {
    !this.hasSubmenu || this.open || this.disabled || (this.open = true, this.active = true, this.setAttribute("aria-expanded", "true"), this._openedViaKeyboard = e36, this.addEventListener("sp-closed", this.cleanup, { once: true }));
  }
  updateAriaSelected() {
    const e36 = this.getAttribute("role");
    e36 === "option" ? this.setAttribute("aria-selected", this.selected ? "true" : "false") : (e36 === "menuitemcheckbox" || e36 === "menuitemradio") && this.setAttribute("aria-checked", this.selected ? "true" : "false");
  }
  setRole(e36) {
    this.setAttribute("role", e36), this.updateAriaSelected();
  }
  willUpdate(e36) {
    super.updated(e36), e36.has("open") && !this.open && this.hasSubmenu && !this._closedViaPointer && this.matches(":focus-within") && this.focus();
  }
  updated(e36) {
    var t34, i21;
    if (super.updated(e36), e36.has("label") && (this.label || typeof e36.get("label") != "undefined") && this.setAttribute("aria-label", this.label || ""), e36.has("active") && (this.active || typeof e36.get("active") != "undefined") && this.active && ((t34 = this.menuData.selectionRoot) == null || t34.closeDescendentOverlays()), this.anchorElement && (this.anchorElement.addEventListener("focus", this.proxyFocus), this.anchorElement.tabIndex = -1), e36.has("selected") && this.updateAriaSelected(), e36.has("hasSubmenu") && (this.hasSubmenu || typeof e36.get("hasSubmenu") != "undefined")) if (this.hasSubmenu) {
      this.abortControllerSubmenu = new AbortController();
      const o52 = { signal: this.abortControllerSubmenu.signal };
      this.addEventListener("click", this.handleSubmenuClick, o52), this.addEventListener("pointerenter", this.handlePointerenter, o52), this.addEventListener("pointerleave", this.handlePointerleave, o52), this.addEventListener("sp-opened", this.handleSubmenuOpen, o52);
    } else (i21 = this.abortControllerSubmenu) == null || i21.abort();
  }
  connectedCallback() {
    super.connectedCallback(), this.triggerUpdate();
  }
  disconnectedCallback() {
    this.menuData.cleanupSteps.forEach((e36) => e36(this)), this.menuData = { focusRoot: void 0, parentMenu: void 0, selectionRoot: void 0, cleanupSteps: [] }, super.disconnectedCallback();
  }
  async triggerUpdate() {
    this.willDispatchUpdate || (this.willDispatchUpdate = true, await new Promise((e36) => requestAnimationFrame(e36)), this.dispatchUpdate());
  }
  focus() {
    super.focus(), this.dispatchEvent(new FocusEvent("focus"));
  }
  blur() {
    this.dispatchEvent(new FocusEvent("blur")), super.blur();
  }
  dispatchUpdate() {
    this.isConnected && (this.dispatchEvent(new MenuItemAddedOrUpdatedEvent(this)), this.willDispatchUpdate = false);
  }
};
r11([n4({ type: Boolean, reflect: true })], MenuItem.prototype, "active", 2), r11([n4({ type: Boolean, reflect: true })], MenuItem.prototype, "focused", 2), r11([n4({ type: Boolean, reflect: true })], MenuItem.prototype, "selected", 2), r11([n4({ type: String })], MenuItem.prototype, "value", 1), r11([n4({ type: Boolean, reflect: true, attribute: "has-submenu" })], MenuItem.prototype, "hasSubmenu", 2), r11([e5("slot:not([name])")], MenuItem.prototype, "contentSlot", 2), r11([e5('slot[name="icon"]')], MenuItem.prototype, "iconSlot", 2), r11([n4({ type: Boolean, reflect: true, attribute: "no-wrap", hasChanged() {
  return false;
} })], MenuItem.prototype, "noWrap", 2), r11([e5(".anchor")], MenuItem.prototype, "anchorElement", 2), r11([e5("sp-overlay")], MenuItem.prototype, "overlayElement", 2), r11([n4({ type: Boolean, reflect: true })], MenuItem.prototype, "open", 2);

// node_modules/@spectrum-web-components/menu/sp-menu-item.js
init_define_element();
defineElement("sp-menu-item", MenuItem);

// src/custom-elements/core/spectrum-size-palette.js
var SIZES = ["xxs", "xs", "s", "m", "l", "xl", "xxl"];
var SpectrumSizePalette = class extends i4 {
  static properties = {
    size: { type: String, reflect: true },
    // Editor store for direct updates (optional; resolves from editor context if not provided)
    store: { type: Object, attribute: false },
    // Attribute name to update on the editing element
    attr: { type: String },
    // Optional allowed sizes override; pass as property (Array)
    sizes: { attribute: false }
  };
  static styles = i`
    :host {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      text-align: left;
      background-color: var(--spectrum-alias-component-background-color);
      box-sizing: border-box;
      padding: 2px 2px;
      border-radius: var(--spectrum-global-dimension-size-100);
    }
    sp-menu { min-width: 160px; }
  `;
  constructor() {
    super();
    this.size = "";
    this.attr = "size";
  }
  #pick(v6) {
    this.size = (v6 || "").toLowerCase();
    this.applyToEditingElement();
  }
  #renderRow(size3) {
    const isCurrent = (this.size || "") === (size3 || "");
    const label = (size3 || "").toUpperCase();
    return x`<sp-menu-item value="${size3}" ?selected=${isCurrent}
      >${label}</sp-menu-item
    >`;
  }
  render() {
    const selected = (this.size || "").trim().toLowerCase();
    const hasSelection2 = SIZES.includes(selected);
    const selectedLabel = hasSelection2 ? selected.toUpperCase() : "Size";
    const allowed = Array.isArray(this.sizes) && this.sizes.length ? this.sizes.filter((s19) => SIZES.includes(s19)) : SIZES;
    const onMenuChange = (e36) => {
      e36.stopPropagation();
      const v6 = e36.target?.value;
      if (v6) this.#pick(v6);
    };
    return x`
      <overlay-trigger triggered-by="click hover" placement="bottom-start" offset="6">
        <sp-action-button slot="trigger" size="l" quiet title="Choose size">
          ${selectedLabel}
        </sp-action-button>
        <sp-popover slot="click-content" open>
          <sp-menu selects="single" @change=${onMenuChange}>
            ${allowed.map((s19) => this.#renderRow(s19))}
          </sp-menu>
        </sp-popover>
      </overlay-trigger>
    `;
  }
  // Apply current size to the editor's selected element
  applyToEditingElement() {
    applyAttributeToSelection({
      store: this.store,
      attr: this.attr || "size",
      value: (this.size || "").trim()
    });
  }
};
customElements.define("spectrum-size-palette", SpectrumSizePalette);

// src/utils/author-schemas.js
function makeSWCIconNameSchema(options = {}, visibleCount = 4) {
  const {
    defaultValue = "sp-icon-add",
    label = "Icon Name",
    description = "Spectrum icon tag name",
    rotationAttr = "rotate",
    flipHAttr = "flip-h",
    flipVAttr = "flip-v"
  } = options;
  return {
    type: "popover",
    default: defaultValue,
    label,
    description,
    render: ({ html, value, onChange, updateAttribute, read }) => {
      const rotation = read ? read(rotationAttr) || 0 : 0;
      const size3 = read ? read("size") || "m" : "m";
      const color = read ? read("color") || "" : "";
      const rawFlipH = read ? read(flipHAttr) : null;
      const rawFlipV = read ? read(flipVAttr) : null;
      const flipH = !!(rawFlipH !== null && rawFlipH !== void 0 && String(rawFlipH).toLowerCase() !== "false");
      const flipV = !!(rawFlipV !== null && rawFlipV !== void 0 && String(rawFlipV).toLowerCase() !== "false");
      return html`<spectrum-icon-palette
        .name=${value}
        .size=${size3}
        .color=${color}
        .rotate=${Number(rotation) || 0}
        .flipH=${flipH}
        .flipV=${flipV}
        name-attr="name"
        size-attr="size"
        rotate-attr=${rotationAttr}
        flip-h-attr=${flipHAttr}
        flip-v-attr=${flipVAttr}
      ></spectrum-icon-palette>`;
    }
  };
}
function makeSWCIconSizeSchema(options = {}) {
  const {
    defaultValue = "m",
    label = "Icon Size",
    description = "Spectrum icon size"
  } = options;
  return {
    type: "popover",
    default: defaultValue,
    label,
    description,
    render: ({ html, value }) => {
      return html`<spectrum-size-palette .size=${value} attr="size"></spectrum-size-palette>`;
    }
  };
}
function makeSWCColorSchema(options = {}, visibleCount = 4) {
  const {
    defaultValue = "",
    label = "Icon Color",
    description = "Adobe Spectrum color (CSS var)",
    attr = "color",
    allowGradient = false
  } = options;
  return {
    type: "popover",
    default: defaultValue,
    label,
    description,
    render: ({ html, value }) => {
      return html`<spectrum-color-palette
        .color=${value}
        attr=${attr}
        ?allow-gradient=${allowGradient}
      ></spectrum-color-palette>`;
    }
  };
}
function makeToJson(el, schema2, serializeNode) {
  if (!el) return null;
  const attributes = {};
  const schemaAttrs = Object.keys(schema2?.attributes || {});
  for (const name of schemaAttrs) {
    if (el.hasAttribute(name)) {
      const value = el.getAttribute(name);
      if (schema2.attributes[name]?.type === "boolean") {
        attributes[name] = true;
      } else {
        attributes[name] = value;
      }
    }
  }
  const result = { tag: el.tagName.toLowerCase(), attributes };
  if (!schema2?.slots) {
    const text = (el.textContent || "").trim();
    if (text) result.slots = { default: [{ text }] };
    return result;
  }
  const slots = {};
  const slotOrder = Array.isArray(schema2.slots.order) ? schema2.slots.order : [];
  const slotConfigs = schema2.slots.configs || {};
  for (const slotName of slotOrder) {
    const config = slotConfigs[slotName];
    const selector = slotName === "default" ? ":scope > *:not([slot])" : `[slot="${slotName}"]`;
    let nodes2 = [];
    if (config?.maxLength === 1) {
      const node = el.querySelector(selector);
      nodes2 = node ? [node] : [];
    } else {
      nodes2 = Array.from(el.querySelectorAll(selector));
      if (slotName === "default" && nodes2.length === 0) {
        const text = (el.textContent || "").trim();
        if (text) {
          slots[slotName] = [{ text }];
        }
        continue;
      }
    }
    if (!nodes2.length) continue;
    const collected = [];
    for (const node of nodes2) {
      const tag3 = node.tagName?.toLowerCase?.();
      const Ctor4 = tag3 ? customElements.get(tag3) : null;
      if (Ctor4?.ee?.toJson) {
        collected.push(Ctor4.ee.toJson(node, serializeNode));
      } else if (serializeNode) {
        collected.push(serializeNode(node));
      }
    }
    if (collected.length) {
      slots[slotName] = collected;
    }
  }
  if (Object.keys(slots).length) {
    result.slots = slots;
  }
  return result;
}

// src/defaults/a.author.js
function getDefaultAnchorSchema() {
  const textStyles5 = ["bold", "italic", "underline", "strikethrough"];
  const alignFormats5 = ["align-left", "align-center", "align-right"];
  return {
    schemaVersion: 1,
    element: {
      label: "Link",
      description: "A hyperlink to another page or resource"
    },
    attributes: {
      href: {
        type: "text",
        default: "#",
        label: "Link URL",
        description: "Destination URL for the link",
        placeholder: "https://example.com or #"
      },
      title: {
        type: "text",
        default: "",
        label: "Title",
        description: "Link title"
      },
      "aria-label": {
        type: "text",
        default: "",
        label: "ARIA Label",
        description: "Accessible label for assistive technologies"
      },
      target: {
        type: "enum",
        options: ["_self", "_blank", "_parent", "_top"],
        default: "_self",
        label: "Open In",
        description: "Where to open the linked document"
      },
      rel: {
        type: "text",
        default: "",
        label: "Rel",
        description: 'Relationship tokens (e.g., "noopener noreferrer")',
        placeholder: "noopener noreferrer"
      },
      download: {
        type: "boolean",
        default: false,
        label: "Download",
        description: "Indicate that the target should be downloaded"
      }
    },
    slots: {
      order: ["default"],
      configs: {
        default: {
          label: "Link Text",
          description: "Visible link text",
          placeholder: "Link text",
          maxLength: 120,
          minLength: 1,
          inlineEditable: true,
          multiline: false,
          allowedStyles: [...textStyles5],
          allowedFormats: [...alignFormats5],
          allowLinks: false
        }
      }
    }
  };
}
function toJsonAnchor(el, serializeNode) {
  const schema2 = getDefaultAnchorSchema(el);
  return makeToJson(el, schema2, serializeNode);
}
if (typeof window !== "undefined") {
  window.eeDefaults = window.eeDefaults || {};
  window.eeDefaults["a"] = {
    getSchema: getDefaultAnchorSchema,
    toJson: toJsonAnchor
  };
}

// src/defaults/sp-button.author.js
function getDefaultSpButtonSchema() {
  return {
    schemaVersion: 1,
    element: {
      label: "Button",
      description: "Spectrum button with label and style options"
    },
    attributes: {
      variant: {
        type: "enum",
        options: ["accent", "primary", "secondary", "negative"],
        default: "secondary",
        label: "Variant",
        description: "Visual style variant"
      },
      size: {
        type: "popover",
        default: "m",
        label: "Size",
        description: "Button size",
        render: ({ html, value }) => html`<spectrum-size-palette
          .size=${value}
          .sizes=${["s", "m", "l", "xl"]}
          attr="size"
        ></spectrum-size-palette>`
      },
      treatment: {
        type: "enum",
        options: ["fill", "outline"],
        default: "fill",
        label: "Treatment",
        description: "Fill or outline treatment"
      },
      quiet: {
        type: "boolean",
        default: false,
        label: "Quiet",
        description: "Use quiet style"
      },
      disabled: {
        type: "boolean",
        default: false,
        label: "Disabled",
        description: "Disable the button"
      },
      "data-value": {
        type: "text",
        default: "",
        label: "Value",
        description: "Option value"
      }
    },
    slots: {
      order: ["default"],
      configs: {
        default: {
          label: "Button Label",
          placeholder: "Button",
          inlineEditable: true,
          allowedStyles: [],
          allowedFormats: [],
          multiline: false,
          plain: true,
          allowLinks: false
        }
      }
    }
  };
}
function toJsonSpButton(el, serializeNode) {
  const schema2 = getDefaultSpButtonSchema(el);
  return makeToJson(el, schema2, serializeNode);
}
if (typeof window !== "undefined") {
  window.eeDefaults = window.eeDefaults || {};
  window.eeDefaults["sp-button"] = {
    getSchema: getDefaultSpButtonSchema,
    toJson: toJsonSpButton
  };
}

// src/defaults/sp-link.author.js
function getDefaultSpLinkSchema() {
  return {
    schemaVersion: 1,
    element: {
      label: "Link",
      description: "Spectrum link component with styling and behavior options"
    },
    attributes: {
      variant: {
        type: "enum",
        options: ["secondary", "primary", "overBackground"],
        default: "secondary",
        label: "Variant",
        description: "Visual style variant for the link"
      },
      href: {
        type: "text",
        default: "",
        label: "Link URL",
        description: "Destination URL",
        placeholder: "https://example.com/"
      },
      target: {
        type: "enum",
        options: ["_self", "_blank", "_parent", "_top"],
        default: "_self",
        label: "Target",
        description: "Browser target for the destination"
      },
      quiet: {
        type: "boolean",
        default: false,
        label: "Quiet",
        description: "Render the link with quiet styling"
      },
      label: {
        type: "text",
        default: "",
        label: "ARIA Label",
        description: "Accessible name for assistive technologies",
        placeholder: "Descriptive link label"
      },
      download: {
        type: "text",
        default: "",
        label: "Download Filename",
        description: "Optional filename when using the download attribute",
        placeholder: "filename.ext"
      }
    },
    slots: {
      order: ["default", "href"],
      configs: {
        default: {
          label: "Link Text",
          placeholder: "Link",
          inlineEditable: true,
          allowedStyles: ["bold", "italic", "underline"],
          allowedFormats: [],
          multiline: false,
          plain: true,
          allowLinks: false
        }
      }
    }
  };
}
function toJsonSpLink(el, serializeNode) {
  const schema2 = getDefaultSpLinkSchema(el);
  return makeToJson(el, schema2, serializeNode);
}
if (typeof window !== "undefined") {
  window.eeDefaults = window.eeDefaults || {};
  window.eeDefaults["sp-link"] = {
    getSchema: getDefaultSpLinkSchema,
    toJson: toJsonSpLink
  };
}

// src/defaults/section.author.js
function getDefaultSectionSchema() {
  return {
    schemaVersion: 1,
    element: {
      label: "Section",
      description: "A semantic section container for content"
    },
    attributes: {},
    slots: {
      order: ["default"],
      configs: {
        default: {
          label: "Content",
          description: "Content within the section",
          allowPaste: true,
          maxLength: 1e3
        }
      }
    }
  };
}
if (typeof window !== "undefined") {
  window.eeDefaults = window.eeDefaults || {};
  window.eeDefaults["section"] = {
    getSchema: getDefaultSectionSchema
  };
}

// src/defaults/header.author.js
function getDefaultHeaderSchema() {
  return {
    schemaVersion: 1,
    element: {
      label: "Header",
      description: "Page header section",
      allowDuplicate: false,
      allowDelete: false
    },
    attributes: {
      title: {
        type: "text",
        default: "",
        label: "Page Title",
        description: "The title of the page (used for <title> tag and og:title)",
        placeholder: "Enter page title",
        maxLength: 200
      },
      description: {
        type: "text",
        default: "",
        label: "Meta Description",
        description: "Page description for SEO and social sharing (used for meta description and og:description)",
        placeholder: "Enter page description",
        maxLength: 500
      },
      "og-image": {
        type: "text",
        default: "",
        label: "Open Graph Image",
        description: "URL for the social sharing image (og:image)",
        placeholder: "https://example.com/image.png",
        maxLength: 500
      },
      canonical: {
        type: "text",
        default: "",
        label: "Canonical URL",
        description: 'Canonical URL for SEO (rel="canonical")',
        placeholder: "https://example.com/page",
        maxLength: 500
      },
      template: {
        type: "text",
        default: "default.html",
        label: "Template",
        description: "HTML template file to use for this page",
        placeholder: "default.html",
        maxLength: 200
      }
    },
    slots: {
      order: ["default"],
      configs: {
        default: {
          label: "Content",
          description: "Content within the header",
          allowPaste: true,
          minLength: 0,
          maxLength: null
        }
      }
    }
  };
}
if (typeof window !== "undefined") {
  window.eeDefaults = window.eeDefaults || {};
  window.eeDefaults["header"] = {
    getSchema: getDefaultHeaderSchema
  };
}

// src/defaults/main.author.js
function getDefaultMainSchema() {
  return {
    schemaVersion: 1,
    element: {
      label: "Main",
      description: "Main content area. Can only contain section elements.",
      allowDuplicate: false,
      allowDelete: false
    },
    attributes: {},
    slots: {
      order: ["default"],
      configs: {
        default: {
          label: "Sections",
          description: "Section elements for the main content area.",
          allowedTags: ["section"],
          minLength: 0,
          maxLength: null
        }
      }
    }
  };
}
function createMain() {
  const main = document.createElement("main");
  const section = document.createElement("section");
  main.appendChild(section);
  return main;
}
function sanitizeMain(element, helpers) {
  if (!element) return;
  const tagName = element.tagName?.toLowerCase?.();
  if (tagName !== "main") return;
  const children = Array.from(element.children);
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
  for (const child of children) {
    const childTag = child.tagName?.toLowerCase?.();
    if (childTag === "section") {
      element.appendChild(child);
    } else if (childTag === "script" && child.type === "application/ld+json") {
      element.appendChild(child);
    }
  }
  if (element.children.length === 0) {
    const section = document.createElement("section");
    element.appendChild(section);
  }
}
if (typeof window !== "undefined") {
  window.eeDefaults = window.eeDefaults || {};
  window.eeDefaults["main"] = {
    getSchema: getDefaultMainSchema,
    create: createMain,
    sanitize: sanitizeMain
  };
}

// src/defaults/footer.author.js
function getDefaultFooterSchema() {
  return {
    schemaVersion: 1,
    element: {
      label: "Footer",
      description: "Page footer section",
      allowDuplicate: false,
      allowDelete: false
    },
    attributes: {},
    slots: {
      order: ["default"],
      configs: {
        default: {
          label: "Content",
          description: "Content within the footer",
          allowPaste: true,
          minLength: 0,
          maxLength: null
        }
      }
    }
  };
}
if (typeof window !== "undefined") {
  window.eeDefaults = window.eeDefaults || {};
  window.eeDefaults["footer"] = {
    getSchema: getDefaultFooterSchema
  };
}

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconImage.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Image.js
var ImageIcon = ({ width: l16 = 24, height: e36 = 24, hidden: t34 = false, title: r25 = "Image" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m14.5,7.52114c0,.82843-.67157,1.5-1.5,1.5-.82843,0-1.5-.67157-1.5-1.5,0-.82843.67157-1.5,1.5-1.5s1.5.67157,1.5,1.5h0"
      fill="currentColor"
    />
    <path
      d="m16.75,3H3.25c-1.24023,0-2.25,1.00977-2.25,2.25v9.5c0,1.24023,1.00977,2.25,2.25,2.25h13.5c1.24023,0,2.25-1.00977,2.25-2.25V5.25c0-1.24023-1.00977-2.25-2.25-2.25Zm-13.5,1.5h13.5c.41309,0,.75.33691.75.75v8.21094l-1.90918-1.90918c-.87695-.87695-2.30469-.87695-3.18164,0l-1.23145,1.23145c-.09961.09766-.25684.09668-.35449.00098l-3.23242-3.23242c-.84961-.84961-2.33203-.84961-3.18164,0l-1.90918,1.90918v-6.21094c0-.41309.33691-.75.75-.75Zm0,11c-.41309,0-.75-.33691-.75-.75v-1.16797l2.96973-2.96973c.29297-.29297.76758-.29297,1.06055,0l3.2334,3.2334c.68164.67969,1.79199.68066,2.47363-.00098l1.23242-1.23242c.29297-.29297.76758-.29297,1.06055,0l2.70068,2.70068c-.1311.11206-.29565.18701-.48096.18701H3.25Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Image.js
var ImageIcon2 = ({ width: e36 = 24, height: a23 = 24, hidden: t34 = false, title: r25 = "Image" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${a23}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M33 6H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Zm-1 19.373L26.728 20.1a2 2 0 0 0-2.828 0l-3.072 3.072-7.556-7.557a2 2 0 0 0-2.828 0L4 22.059V8h28Z"
    />
    <circle cx="26.7" cy="13.3" r="2.7" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconImage.js
var IconImage = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ImageIcon({ hidden: !this.label, title: this.label }) : ImageIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-image.js
init_define_element();
defineElement("sp-icon-image", IconImage);

// src/defaults/picture.author.js
var DEFAULT_DESCRIPTION = "Responsive image wrapper that supports multiple sources and a fallback image.";
function getDefaultPictureSchema() {
  return {
    schemaVersion: 1,
    element: {
      label: "Responsive Picture",
      description: DEFAULT_DESCRIPTION
    },
    attributes: {},
    slots: {
      order: ["default"],
      configs: {
        default: {
          label: "Sources",
          description: "Add <source> elements for breakpoints followed by a final <img> fallback.",
          allowedTags: ["source", "img"],
          allowPaste: false,
          maxLength: 6,
          minLength: 1
        }
      }
    }
  };
}
function toJsonPicture(el, serializeNode) {
  const schema2 = getDefaultPictureSchema(el);
  return makeToJson(el, schema2, serializeNode);
}
if (typeof window !== "undefined") {
  window.eeDefaults = window.eeDefaults || {};
  window.eeDefaults["picture"] = {
    getSchema: getDefaultPictureSchema,
    toJson: toJsonPicture
  };
}

// src/defaults/index.js
function getDefaultSchemaForTag(tagName, element) {
  switch ((tagName || "").toLowerCase()) {
    case "a":
      return getDefaultAnchorSchema(element);
    case "sp-button":
      return getDefaultSpButtonSchema(element);
    case "sp-link":
      return getDefaultSpLinkSchema(element);
    case "section":
      return getDefaultSectionSchema(element);
    case "header":
      return getDefaultHeaderSchema(element);
    case "main":
      return getDefaultMainSchema(element);
    case "footer":
      return getDefaultFooterSchema(element);
    case "picture":
      return getDefaultPictureSchema(element);
    default:
      return null;
  }
}

// src/utils/schema-cache.js
var elementSchemaVersionKey = Symbol("eeSchemaVersion");
var providerCache = /* @__PURE__ */ new WeakMap();
var getProviderCache = (provider) => {
  let cache2 = providerCache.get(provider);
  if (!cache2) {
    cache2 = {
      byElement: /* @__PURE__ */ new WeakMap(),
      hasNullSchema: false,
      nullSchema: null
    };
    providerCache.set(provider, cache2);
  }
  return cache2;
};
function getElementSchema(provider, element = null) {
  if (!provider || typeof provider.getSchema !== "function") {
    return null;
  }
  const cache2 = getProviderCache(provider);
  if (element == null) {
    if (cache2.hasNullSchema) {
      return cache2.nullSchema;
    }
    const schema3 = provider.getSchema(null);
    cache2.nullSchema = schema3;
    cache2.hasNullSchema = true;
    return schema3;
  }
  const version2 = element[elementSchemaVersionKey] || 0;
  const entry = cache2.byElement.get(element);
  if (entry && entry.version === version2) {
    return entry.schema;
  }
  const schema2 = provider.getSchema(element);
  cache2.byElement.set(element, { schema: schema2, version: version2 });
  return schema2;
}
function markElementSchemaDirty(element) {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return;
  }
  const current = element[elementSchemaVersionKey] || 0;
  element[elementSchemaVersionKey] = current + 1;
}

// src/utils/viewport.js
function getValidBoundingRect(element) {
  if (!element) return { rect: null, element: null };
  let anchorEl = element;
  let rect = anchorEl.getBoundingClientRect?.() || null;
  while (rect && (rect.width === 0 || rect.height === 0) && anchorEl?.parentElement) {
    anchorEl = anchorEl.parentElement;
    rect = anchorEl.getBoundingClientRect?.() || null;
  }
  return { rect, element: anchorEl };
}
function isElementOutOfViewport(element, viewport) {
  const vr2 = viewport?.getBoundingClientRect?.() || null;
  const { rect: anchorRect } = getValidBoundingRect(element);
  if (!vr2 || !anchorRect) {
    return { outOfViewport: false, anchorRect, viewportRect: vr2 };
  }
  const hasValidRect = anchorRect.width > 0 && anchorRect.height > 0;
  const outOfViewport = hasValidRect && (anchorRect.right < vr2.left || anchorRect.left > vr2.right || anchorRect.bottom < vr2.top || anchorRect.top > vr2.bottom);
  return { outOfViewport, anchorRect, viewportRect: vr2 };
}
function getSlotOrElementRect(element, slotName) {
  if (slotName && element?.shadowRoot) {
    const selector = slotName === "default" ? "slot:not([name])" : `slot[name="${slotName}"]`;
    const slotEl = element.shadowRoot.querySelector(selector);
    if (slotEl) {
      const { rect: rect2 } = getValidBoundingRect(slotEl);
      if (rect2 && rect2.width > 0 && rect2.height > 0) {
        return rect2;
      }
    }
  }
  const { rect } = getValidBoundingRect(element);
  return rect;
}

// src/stores/editor/selection-store.js
var determineToolbarMode = (store, actions) => {
  if (!actions) return "element";
  const selectionType = actions.selection?.type;
  if (selectionType === "slot") return "slot";
  if (actions.isSlotContent) return "element";
  if (store?.slotOnlySelection && actions.slots?.current) return "slot";
  return actions.slots?.current ? "slot" : "element";
};
var EditorSelectionStore = class {
  static observableActions = [
    "setEditingElement",
    "setCurrentSlot",
    "selectElement",
    "selectSlot",
    "selectParent",
    "clearSelection",
    "handleEscape"
  ];
  static computedProperties = [];
  editingElement = null;
  currentSlot = null;
  slotOnlySelection = false;
  #slotsCacheByTag = /* @__PURE__ */ new Map();
  #lastOutlinedSlotEl = null;
  #recordSelectionAction = true;
  #lastSelectionInputType = "programmatic";
  #editor;
  #untrackEditor = null;
  #inlineActivationSuppressed = false;
  constructor(editor) {
    this.#editor = editor;
  }
  get editor() {
    return this.#editor;
  }
  get lastSelectionInputType() {
    return this.#lastSelectionInputType;
  }
  #normalizeInputType(value) {
    if (value === null || value === void 0) {
      return "programmatic";
    }
    const normalized = String(value).trim();
    return normalized ? normalized : "programmatic";
  }
  log() {
    this.#editor.log?.(...arguments);
  }
  getKnownSlots(el) {
    return this.#introspectAndRememberSlotsFor(el);
  }
  hasAuthoringSchema(element) {
    if (!element || !element.tagName) return false;
    const tag3 = element.tagName.toLowerCase();
    const ctor = customElements.get(tag3);
    const schema2 = getElementSchema(ctor?.ee, element) ?? getElementSchema(ctor?.ee, null);
    if (schema2) return true;
    return !!getDefaultSchemaForTag(tag3, element);
  }
  isAuthoringLocked(element) {
    return !!element?.hasAttribute?.("data-ee-locked");
  }
  get context() {
    if (!this.editingElement) return null;
    const actions = this.editor.toolbarActions;
    if (!actions) return null;
    const mode = determineToolbarMode(this.editor, actions);
    const hostElement = this.editingElement || null;
    const baseElement = actions.isSlotContent && hostElement ? hostElement : actions.element || hostElement || null;
    const slotName = actions.slots?.current || null;
    const selectionType = actions.selection?.type || (mode === "slot" ? "slot" : "element");
    let slotSelected = selectionType === "slot";
    if (!slotSelected && actions.textFormatting?.isSlotSelection) {
      slotSelected = true;
    }
    const element = slotSelected ? null : baseElement;
    const slotConfig = slotName ? actions.slots?.getConfig?.(slotName) ?? null : null;
    const slotInfo = slotName && actions.slots?.slotInfo ? actions.slots.slotInfo[slotName] || {} : null;
    const schemaTarget = slotSelected ? hostElement : element;
    const hasSchema = schemaTarget ? this.hasAuthoringSchema(schemaTarget) : false;
    const isLocked = hasSchema ? this.isAuthoringLocked(schemaTarget) : false;
    return {
      actions,
      mode,
      element,
      slotName,
      slotConfig,
      slotInfo,
      slotSelected,
      parentElement: actions.parentElement || (slotSelected ? hostElement : actions.isSlotContent ? actions.element : hostElement) || null,
      isLocked,
      elementLabel: actions.elementLabel || "Element",
      elementDescription: actions.elementDescription || "",
      showAttrs: !!actions.attributes?.enabled,
      showReorder: !!actions.reordering?.enabled,
      duplicationAllowed: actions.duplicationAllowed !== false,
      deletionAllowed: actions.deletionAllowed !== false
    };
  }
  get canSelectParent() {
    if (!this.editingElement) return false;
    const element = this.editingElement;
    const parent = element.parentElement;
    if (!parent) return false;
    const parentTag = parent.tagName?.toLowerCase?.() || "";
    if (parentTag === "experience-elements-editor") {
      return false;
    }
    if (parent.hasAttribute("data-ee-root")) return false;
    if (parent.tagName?.toLowerCase?.() === "template") return false;
    if (this.currentSlot && this.slotOnlySelection) {
      const host = element;
      if (!host || !host.shadowRoot) return false;
      const selector = this.currentSlot === "default" ? "slot:not([name])" : `slot[name="${this.currentSlot}"]`;
      const slot = host.shadowRoot.querySelector(selector);
      return !!slot;
    }
    return true;
  }
  selectParent() {
    const element = this.editingElement;
    if (!element) return;
    const parent = element.parentElement;
    if (!parent) return;
    if (parent.hasAttribute("data-ee-root")) return;
    if (parent.tagName?.toLowerCase?.() === "template") return;
    const slotName = element.getAttribute?.("slot")?.trim() || element.assignedSlot?.name?.trim() || null;
    if (slotName && slotName !== "default" && parent.tagName?.includes?.("-")) {
      this.selectSlot?.(parent, slotName);
      return;
    }
    this.selectElement(parent, null, { recordAction: false });
  }
  setEditingElement(element) {
    this.editor.toolbar.setToolbarActions(null);
    if (this.editingElement === element) {
      return;
    }
    this.editor.exitInlineEditing();
    document.querySelectorAll("ee-rte").forEach((rte) => rte.remove());
    if (this.editingElement) {
      delete this.editingElement._eeClickAction;
    }
    this.editingElement = element;
    if (this.#lastOutlinedSlotEl && this.#lastOutlinedSlotEl !== element) {
      this.#lastOutlinedSlotEl.classList.remove("slot-outline");
      this.#lastOutlinedSlotEl = null;
    }
  }
  setCurrentSlot(slotName) {
    if (this.currentSlot === slotName) return;
    this.currentSlot = slotName;
    if (!slotName && !this.editingElement) {
      this.slotOnlySelection = false;
    }
  }
  selectElement(element, slotName = null, options = {}) {
    this.editor?.clearRteContext?.();
    if (element && element.hasAttribute?.("data-ee-root")) {
      return this.clearSelection({
        inputType: options?.inputType
      });
    }
    const suppressFocus = options && options.suppressFocus === true;
    const recordAction = options && options.recordAction === false ? false : true;
    const slotOnly = options && options.slotOnly === true;
    const suppressInlineContext = options?.suppressInlineContext === true;
    const suppressInlineActivation = options?.suppressInlineActivation === true || suppressInlineContext;
    this.#lastSelectionInputType = this.#normalizeInputType(
      options?.inputType
    );
    this.editor.suppressFocus = suppressFocus;
    this.#inlineActivationSuppressed = suppressInlineActivation;
    if (!element) {
      this.editor.toolbar.setToolbarActions(null);
      this.setEditingElement(null);
      this.setCurrentSlot(null);
      this.slotOnlySelection = false;
      this.editor.toolbar.hideEEToolbar();
      return;
    }
    const slotNameExplicit = slotName !== null && slotName !== void 0;
    let resolvedSlot = slotNameExplicit ? slotName : this.#slotNameForElement(element);
    const shouldSelectSlotOnly = !!slotOnly && !!resolvedSlot;
    const shouldTrackSlotContext = slotNameExplicit && !!resolvedSlot;
    const isAuthorable = this.hasAuthoringSchema(element);
    const isNamedSlotSelection = !!resolvedSlot && resolvedSlot !== "default" && !isAuthorable;
    const hadSlotSelection = this.slotOnlySelection === true && typeof this.currentSlot === "string";
    const previousSlot = typeof this.currentSlot === "string" ? this.currentSlot : null;
    const isChildInSlot = element?.hasAttribute?.("slot") === true;
    const keepSlotSelection = hadSlotSelection && !!previousSlot && element && element === this.editingElement && !slotOnly && !slotNameExplicit && isChildInSlot;
    const lastActionType = String(this.editor?.lastAction?.type || "");
    const bypassInlineContext = suppressInlineContext || lastActionType.startsWith("tree:") || lastActionType.startsWith("comment:");
    this.slotOnlySelection = shouldSelectSlotOnly || keepSlotSelection || isNamedSlotSelection;
    if (bypassInlineContext && !slotNameExplicit && !shouldSelectSlotOnly && !shouldTrackSlotContext && !isNamedSlotSelection) {
      if (this.currentSlot !== null) {
        this.setCurrentSlot(null);
      }
      this.slotOnlySelection = false;
    }
    this.#recordSelectionAction = recordAction;
    const inlineContext = !bypassInlineContext && !slotNameExplicit && !shouldSelectSlotOnly && !shouldTrackSlotContext ? this.resolveInlineEditableSlotContext(element) : null;
    if (inlineContext && inlineContext.slotName) {
      resolvedSlot = inlineContext.slotName;
      this.setEditingElement(inlineContext.element);
    } else {
      this.setEditingElement(element);
    }
    this.#recordSelectionAction = true;
    const parentForSlot = element?.parentElement || null;
    const canUseResolvedSlot = !!resolvedSlot && parentForSlot && parentForSlot.tagName?.includes?.("-") && this.slotSupportsTextEditing(parentForSlot, resolvedSlot);
    if (shouldSelectSlotOnly || shouldTrackSlotContext) {
      this.setCurrentSlot(resolvedSlot);
    } else if (keepSlotSelection) {
      this.setCurrentSlot(previousSlot);
    } else if (inlineContext && inlineContext.slotName) {
      this.setCurrentSlot(inlineContext.slotName);
    } else if (canUseResolvedSlot) {
      this.setCurrentSlot(resolvedSlot);
    } else if (this.currentSlot !== null) {
      this.setCurrentSlot(null);
    }
    if (!slotNameExplicit && !shouldSelectSlotOnly && !shouldTrackSlotContext && !keepSlotSelection && !inlineContext && !canUseResolvedSlot && this.slotSupportsTextEditing(element, "default") && !bypassInlineContext) {
      if (this.currentSlot !== "default") {
        this.setCurrentSlot("default");
      }
      if (!this.hasAuthoringSchema(element) && this.slotOnlySelection) {
        this.slotOnlySelection = false;
      }
    }
    console.log("[EditorSelectionStore.selectElement] Final state before toolbar", {
      editingElement: this.editingElement ? {
        tagName: this.editingElement.tagName,
        id: this.editingElement.id
      } : null,
      currentSlot: this.currentSlot,
      slotOnlySelection: this.slotOnlySelection,
      resolvedSlot,
      slotNameExplicit,
      isNamedSlotSelection,
      shouldSelectSlotOnly,
      keepSlotSelection
    });
    this.editor.toolbar.showEEToolbar(element);
    const t34 = this.editor.lastAction?.type || "";
    if (t34.startsWith("tree:") || t34.startsWith("comment:")) {
      this.#maybeCenterSelection(element, t34, options);
    }
    if (this.editor.suppressFocus) {
      setTimeout(() => {
        this.editor.suppressFocus = false;
      }, 0);
    }
    if (this.editor.editorElement && this.editor.history.undoStack.length === 0) {
      this.editor.captureSnapshot();
    }
    if (suppressFocus && element?.scrollIntoView) {
      element.scrollIntoView({ block: "center", inline: "center" });
    }
  }
  selectSlot(parentElement, slotName, options = {}) {
    const wasAlreadySelected = this.currentSlot === slotName && this.slotOnlySelection === true && this.editingElement === parentElement;
    this.editor?.clearRteContext?.();
    const inputType = this.#normalizeInputType(options?.inputType);
    this.#lastSelectionInputType = inputType;
    const suppressInlineContext = options?.suppressInlineContext === true;
    const slotConfig = this.getNormalizedSlotConfig(parentElement, slotName);
    const isInlineEditableSlot = slotConfig?.inlineEditable === true;
    const isTreeAction = this.editor?.lastAction?.type?.startsWith?.("tree:") || options?.fromTree === true;
    const suppressInlineActivation = options?.suppressInlineActivation === true || isTreeAction || !wasAlreadySelected;
    this.#inlineActivationSuppressed = suppressInlineActivation;
    console.log("[EditorSelectionStore.selectSlot] Inline activation check", {
      slotName,
      wasAlreadySelected,
      isInlineEditableSlot,
      suppressInlineActivation,
      slotConfig: slotConfig ? { inlineEditable: slotConfig.inlineEditable } : null
    });
    if (!parentElement || !slotName) return;
    const sr2 = parentElement.shadowRoot;
    if (!sr2)
      return this.selectElement(parentElement, null, {
        inputType,
        suppressInlineContext,
        suppressInlineActivation
      });
    const selector = slotName === "default" ? "slot:not([name])" : `slot[name="${slotName}"]`;
    const slot = sr2.querySelector(selector);
    if (!slot)
      return this.selectElement(parentElement, null, {
        inputType,
        suppressInlineContext,
        suppressInlineActivation
      });
    this.setCurrentSlot(slotName);
    this.slotOnlySelection = true;
    this.setEditingElement(parentElement);
    const isDefaultSlot = slotName === "default";
    if (this.#lastOutlinedSlotEl && this.#lastOutlinedSlotEl !== slot) {
      this.#lastOutlinedSlotEl.classList.remove("slot-outline");
      this.#lastOutlinedSlotEl = null;
    }
    if (!isDefaultSlot) {
      slot.classList.add("slot-outline");
      this.#lastOutlinedSlotEl = slot;
    } else {
      slot.classList.remove("slot-outline");
      this.#lastOutlinedSlotEl = null;
    }
    this.editor.toolbar.showEEToolbar(parentElement);
  }
  clearSelection({ dismissToolbar = false, inputType } = {}) {
    this.editor.toolbar.setToolbarActions(null);
    this.setEditingElement(null);
    this.setCurrentSlot(null);
    this.slotOnlySelection = false;
    this.#inlineActivationSuppressed = false;
    this.#lastSelectionInputType = this.#normalizeInputType(inputType);
    this.editor?.clearRteContext?.();
    if (this.#lastOutlinedSlotEl) {
      this.#lastOutlinedSlotEl.classList.remove("slot-outline");
      this.#lastOutlinedSlotEl = null;
    }
    if (!dismissToolbar) {
      this.editor.toolbar.hideEEToolbar();
    }
  }
  handleEscape() {
    const last = this.editor.lastAction?.type || "";
    if (this.editor.isEEToolbarVisible && last.startsWith("toolbar:")) {
      this.editor.toolbar.hideEEToolbar();
      return;
    }
    if (this.canSelectParent) {
      this.selectParent();
      return;
    }
    this.clearSelection({ dismissToolbar: true });
  }
  #maybeCenterSelection(element, actionType, options) {
    const host = this.editor.editorElement;
    const viewport = host?.shadowRoot?.querySelector?.("#surface-wrapper");
    const anchorRect = getSlotOrElementRect(element, this.currentSlot);
    const { outOfViewport, viewportRect: vr2 } = isElementOutOfViewport(element, viewport);
    this.editor.setLastAction?.(
      actionType.startsWith("tree:") ? "tree:center-on-check" : "comment:center-on-check",
      {
        outOfViewport,
        viewport: vr2 ? {
          x: Math.round(vr2.left),
          y: Math.round(vr2.top),
          w: Math.round(vr2.width),
          h: Math.round(vr2.height)
        } : null,
        anchor: anchorRect ? {
          x: Math.round(anchorRect.left),
          y: Math.round(anchorRect.top),
          w: Math.round(anchorRect.width),
          h: Math.round(anchorRect.height)
        } : null,
        tag: element?.tagName?.toLowerCase?.() || null,
        id: element?.id || null
      }
    );
    if (outOfViewport && host?.centerOnElement) {
      this.editor.setLastAction?.(
        actionType.startsWith("tree:") ? "tree:center-on-exec" : "comment:center-on-exec",
        {
          tag: element?.tagName?.toLowerCase?.() || null,
          id: element?.id || null
        }
      );
      host.centerOnElement(element);
    } else {
      this.editor.setLastAction?.(
        actionType.startsWith("tree:") ? "tree:center-on-skip" : "comment:center-on-skip",
        {
          reason: outOfViewport ? "no-host-center" : "visible"
        }
      );
    }
  }
  #introspectAndRememberSlotsFor(el) {
    if (!el || !el.tagName) return [];
    const tag3 = el.tagName.toLowerCase();
    const sr2 = el.shadowRoot;
    if (!sr2) {
      const cached = this.#slotsCacheByTag.get(tag3);
      return cached ? Array.from(cached) : [];
    }
    const slotEls = Array.from(sr2.querySelectorAll("slot"));
    if (!slotEls.length) {
      const cached = this.#slotsCacheByTag.get(tag3);
      return cached ? Array.from(cached) : [];
    }
    const names = [];
    for (const s19 of slotEls) {
      const n25 = s19.getAttribute("name");
      names.push(n25 && n25.trim() ? n25.trim() : "default");
    }
    const ordered = [];
    const seen = /* @__PURE__ */ new Set();
    for (const n25 of names) {
      if (!seen.has(n25)) {
        seen.add(n25);
        ordered.push(n25);
      }
    }
    const existing = this.#slotsCacheByTag.get(tag3) || /* @__PURE__ */ new Set();
    for (const n25 of ordered) existing.add(n25);
    this.#slotsCacheByTag.set(tag3, existing);
    return Array.from(existing);
  }
  #rememberSlotsForTag(tag3, slots) {
    if (!tag3 || !Array.isArray(slots) || !slots.length) return;
    const key = String(tag3).toLowerCase();
    const set = this.#slotsCacheByTag.get(key) || /* @__PURE__ */ new Set();
    for (const s19 of slots) {
      if (!s19) continue;
      set.add(String(s19));
    }
    this.#slotsCacheByTag.set(key, set);
  }
  #getSchemaForElement(element) {
    if (!element || !element.tagName) return null;
    const tag3 = element.tagName.toLowerCase();
    const ctor = customElements.get(tag3);
    const eeApi = ctor?.ee || null;
    if (!eeApi) return null;
    const schemaWithElement = getElementSchema(eeApi, element);
    if (schemaWithElement) {
      return schemaWithElement;
    }
    const schemaFromGetter = getElementSchema(eeApi, null);
    if (schemaFromGetter) {
      return schemaFromGetter;
    }
    const schemaValue = eeApi.schema;
    if (schemaValue?.call) {
      return schemaValue.call(eeApi);
    }
    return schemaValue || null;
  }
  #getSlotConfigForElement(element, slotName) {
    if (!element || !slotName) return null;
    const schema2 = this.#getSchemaForElement(element);
    const eeConfig = typeof slotName === "string" && schema2?.slots?.configs ? schema2.slots.configs[slotName] : null;
    const tag3 = element.tagName?.toLowerCase?.() || null;
    const ctor = tag3 ? customElements.get(tag3) : null;
    const eeApi = ctor?.ee || null;
    if (eeApi?.getSlotConfig) {
      const direct = eeApi.getSlotConfig(slotName, element);
      if (direct) return direct;
      const fallback2 = eeApi.getSlotConfig(slotName);
      if (fallback2) return fallback2;
    }
    if (eeConfig) return eeConfig;
    const fallback = getDefaultSchemaForTag(tag3, element);
    if (fallback?.getSlotConfig) {
      const result = fallback.getSlotConfig(slotName, element);
      if (result) return result;
    }
    if (fallback?.slots?.configs?.[slotName]) {
      return fallback.slots.configs[slotName];
    }
    const parent = element.parentElement;
    if (parent) {
      const parentTag = parent.tagName?.toLowerCase?.() || null;
      const parentCtor = parentTag ? customElements.get(parentTag) : null;
      const parentApi = parentCtor?.ee || null;
      if (parentApi?.getSlotConfig) {
        const parentDirect = parentApi.getSlotConfig(slotName, parent);
        if (parentDirect) return parentDirect;
        const parentFallback = parentApi.getSlotConfig(slotName);
        if (parentFallback) return parentFallback;
      }
      const parentSchema = this.#getSchemaForElement(parent);
      if (parentSchema?.slots?.configs?.[slotName]) {
        return parentSchema.slots.configs[slotName];
      }
    }
    return null;
  }
  getNormalizedSlotConfig(element, slotName) {
    if (!element || !slotName) return null;
    const cfg = this.#getSlotConfigForElement(element, slotName);
    return cfg;
  }
  #isInlineEditableConfig(config) {
    if (!config || typeof config !== "object") return false;
    if (config.inlineEditable === true) return true;
    if (Array.isArray(config.allowedFormats) && config.allowedFormats.length > 0) {
      return true;
    }
    if (config.supportsTextFormatting === true) return true;
    if (typeof config.richTextPreset === "string" && config.richTextPreset) {
      return true;
    }
    return false;
  }
  slotSupportsTextEditing(element, slotName) {
    if (!element) return false;
    const normalizedSlot = typeof slotName === "string" && slotName.trim() ? slotName.trim() : "default";
    const slotConfig = this.getNormalizedSlotConfig(element, normalizedSlot) || null;
    return this.#isInlineEditableConfig(slotConfig);
  }
  consumeInlineActivationSuppressed() {
    if (!this.#inlineActivationSuppressed) {
      return false;
    }
    this.#inlineActivationSuppressed = false;
    return true;
  }
  resolveInlineEditableSlotContext(element) {
    const editorRoot = this.editor?.editorElement || null;
    let current = element;
    let firstPass = true;
    let encounteredReference = false;
    while (current && current.nodeType === Node.ELEMENT_NODE) {
      if (current === editorRoot) break;
      const parent = current.parentElement;
      const tagUpper = current.tagName?.toUpperCase?.() || "";
      if (tagUpper === "EE-RTE") {
        current = parent;
        firstPass = false;
        continue;
      }
      const tagLowerCurrent = current.tagName?.toLowerCase?.() || "";
      if (tagLowerCurrent === "ee-reference") {
        encounteredReference = true;
      }
      const assignedSlot = current.getAttribute?.("slot")?.trim();
      if (assignedSlot && parent && parent.tagName?.includes?.("-") && this.slotSupportsTextEditing(parent, assignedSlot)) {
        if (tagLowerCurrent === "ee-reference" || encounteredReference) {
          current = parent;
          firstPass = false;
          continue;
        }
        if (firstPass && this.hasAuthoringSchema(current)) {
          return null;
        }
        return { element: parent, slotName: assignedSlot };
      }
      const tagName = current.tagName?.toLowerCase?.() || "";
      const isCustom = tagName.includes("-");
      if (firstPass && this.hasAuthoringSchema(current)) {
        return null;
      }
      if (isCustom && firstPass && this.slotSupportsTextEditing(current, "default")) {
        return { element: current, slotName: "default" };
      }
      if (isCustom && parent && parent.tagName?.includes?.("-")) {
        if (this.slotSupportsTextEditing(parent, "default")) {
          return { element: parent, slotName: "default" };
        }
      }
      current = parent;
      firstPass = false;
    }
    return null;
  }
  #slotNameForElement(element) {
    if (!element) return null;
    const attrSlot = element.getAttribute?.("slot");
    if (attrSlot && attrSlot.trim()) {
      return attrSlot.trim();
    }
    const assigned = element.assignedSlot?.name;
    if (assigned && assigned.trim()) {
      return assigned.trim();
    }
    return null;
  }
  #normalizeSchemaFromEE(ee2, element) {
    const schemaFromProvider = getElementSchema(ee2, element);
    if (typeof ee2?.getSchema === "function") {
      const order = Array.isArray(schemaFromProvider?.slots?.order) ? schemaFromProvider.slots.order : [];
      const configs = schemaFromProvider?.slots?.configs || {};
      const getSlotConfig2 = (name) => configs && name in configs ? configs[name] : void 0;
      const getSlotLabel = (name) => {
        const cfg = getSlotConfig2(name);
        return cfg && cfg.label ? cfg.label : name;
      };
      return {
        attributes: schemaFromProvider?.attributes || {},
        slots: order,
        element: schemaFromProvider?.element || {},
        elementLabel: schemaFromProvider?.element?.label || "",
        elementDescription: schemaFromProvider?.element?.description || "",
        tools: schemaFromProvider?.tools || [],
        getSlotConfig: getSlotConfig2,
        getSlotLabel
      };
    }
    return {
      attributes: ee2?.getAttributeSchema?.() || {},
      slots: ee2?.getSlots?.() || [],
      element: {},
      elementLabel: ee2?.getElementLabel?.() || "",
      elementDescription: ee2?.getElementDescription?.() || "",
      getSlotConfig: ee2?.getSlotConfig,
      getSlotLabel: ee2?.getSlotLabel
    };
  }
  buildElementSchema(element) {
    if (!element) return null;
    const tagName = element.tagName?.toLowerCase?.();
    if (!tagName) return null;
    const slotName = element.getAttribute("slot");
    if (slotName) {
      const elementConstructor = customElements.get(tagName);
      if (elementConstructor?.ee) {
        const normalized2 = this.#normalizeSchemaFromEE(elementConstructor.ee, element);
        this.#rememberSlotsForTag(tagName, normalized2?.slots || []);
        return {
          ...normalized2,
          isSlotContent: true,
          slotName,
          slotConfig: normalized2.getSlotConfig?.("default") || null
        };
      }
      const parent = element.parentElement;
      if (parent && parent.tagName?.includes?.("-")) {
        const parentTag = parent.tagName.toLowerCase();
        const parentCtor = customElements.get(parentTag);
        if (parentCtor?.ee) {
          const parentNorm = this.#normalizeSchemaFromEE(parentCtor.ee, parent);
          this.#rememberSlotsForTag(parentTag, parentNorm?.slots || []);
          const parentConfig = parentNorm.getSlotConfig?.(slotName);
          const slotLabel = parentNorm.getSlotLabel?.(slotName) || slotName;
          const vanilla = getDefaultSchemaForTag(tagName, element) || {};
          return {
            attributes: vanilla.attributes || {},
            slots: vanilla.slots || [],
            elementLabel: vanilla.elementLabel || slotLabel,
            elementDescription: vanilla.elementDescription || "",
            getSlotConfig: vanilla.getSlotConfig || ((name) => parentNorm.getSlotConfig?.(name)),
            getSlotLabel: vanilla.getSlotLabel || ((name) => parentNorm.getSlotLabel?.(name)),
            isSlotContent: true,
            parentElement: parent,
            slotName,
            slotConfig: vanilla.getSlotConfig && vanilla.getSlotConfig("default") || parentConfig
          };
        }
      }
    }
    {
      const selfCtor = tagName ? customElements.get(tagName) : null;
      const hasOwnEE = !!selfCtor?.ee;
      if (!hasOwnEE) {
        let ancestor = element.parentElement;
        let ancestorWithSlot = null;
        while (ancestor && ancestor !== document.body && !ancestorWithSlot) {
          if (ancestor.hasAttribute && ancestor.hasAttribute("slot")) {
            ancestorWithSlot = ancestor;
            break;
          }
          ancestor = ancestor.parentElement;
        }
        if (ancestorWithSlot) {
          const parent = ancestorWithSlot.parentElement;
          const parentTagName = parent?.tagName?.toLowerCase?.();
          const parentCtor = parentTagName ? customElements.get(parentTagName) : null;
          const ancestorSlot = ancestorWithSlot.getAttribute("slot");
          if (parentCtor?.ee && ancestorSlot) {
            const parentNorm = this.#normalizeSchemaFromEE(parentCtor.ee, parent);
            const parentConfig = parentNorm.getSlotConfig?.(ancestorSlot);
            const slotLabel = parentNorm.getSlotLabel?.(ancestorSlot) || ancestorSlot;
            const vanilla = getDefaultSchemaForTag(tagName, element) || {};
            return {
              attributes: vanilla.attributes || {},
              slots: vanilla.slots || [],
              elementLabel: vanilla.elementLabel || slotLabel,
              elementDescription: vanilla.elementDescription || "",
              getSlotConfig: vanilla.getSlotConfig || ((name) => parentNorm.getSlotConfig?.(name)),
              getSlotLabel: vanilla.getSlotLabel || ((name) => parentNorm.getSlotLabel?.(name)),
              isSlotContent: true,
              parentElement: parent,
              slotName: ancestorSlot,
              slotConfig: vanilla.getSlotConfig && vanilla.getSlotConfig("default") || parentConfig
            };
          }
        }
      }
    }
    const ctor = customElements.get(tagName);
    if (!ctor?.ee) {
      const vanilla = getDefaultSchemaForTag(tagName, element);
      if (vanilla) {
        const order = Array.isArray(vanilla?.slots?.order) ? vanilla.slots.order : [];
        const configs = vanilla?.slots?.configs || {};
        const getSlotConfig2 = (name) => configs && name in configs ? configs[name] : void 0;
        const getSlotLabel = (name) => {
          const cfg = getSlotConfig2(name);
          return cfg && cfg.label ? cfg.label : name;
        };
        return {
          attributes: vanilla.attributes || {},
          slots: order,
          // Normalize to array instead of object
          element: vanilla.element || {},
          elementLabel: vanilla.element?.label || tagName,
          elementDescription: vanilla.element?.description || "",
          getSlotConfig: getSlotConfig2,
          getSlotLabel,
          isSlotContent: false
        };
      }
      const slots = this.#introspectAndRememberSlotsFor(element);
      if (Array.isArray(slots) && slots.length > 0) {
        return {
          attributes: {},
          slots,
          elementLabel: tagName,
          elementDescription: "",
          getSlotConfig: () => ({}),
          getSlotLabel: (name) => name,
          isSlotContent: false
        };
      }
      return null;
    }
    const normalized = this.#normalizeSchemaFromEE(ctor.ee, element);
    this.#rememberSlotsForTag(tagName, normalized?.slots || []);
    return {
      ...normalized,
      isSlotContent: false
    };
  }
};
makeObservable(EditorSelectionStore);

// src/libraries/library-manager.js
var LibraryLevel = Object.freeze({
  SYSTEM: "system",
  ORG: "org",
  INDIVIDUAL: "individual"
});
var LEVEL_ORDER = {
  [LibraryLevel.SYSTEM]: 0,
  [LibraryLevel.ORG]: 1,
  [LibraryLevel.INDIVIDUAL]: 2
};
var normalizeLibrary = (config = {}) => {
  const id = String(config.id || "").trim();
  if (!id) throw new Error("Library id is required");
  const level = Object.values(LibraryLevel).includes(config.level) ? config.level : LibraryLevel.SYSTEM;
  return {
    id,
    level,
    name: config.name || id,
    description: config.description || "",
    keywords: Array.isArray(config.keywords) ? config.keywords.slice() : []
  };
};
var normalizeElement = (libraryId, config = {}) => {
  const base2 = typeof config === "string" ? { tag: config } : { ...config };
  const tag3 = String(base2.tag || "").trim().toLowerCase();
  if (!tag3) throw new Error("Element tag is required");
  const ctor = customElements.get(tag3);
  let schema2 = null;
  let schemaApi = null;
  if (base2.schema) {
    if (typeof base2.schema.getSchema === "function") {
      schemaApi = base2.schema;
      schema2 = getElementSchema(schemaApi, null);
    } else {
      schema2 = base2.schema;
    }
  } else if (ctor?.ee && typeof ctor.ee.getSchema === "function") {
    schemaApi = ctor.ee;
    schema2 = getElementSchema(schemaApi, null);
  }
  const elementMeta = schema2?.element || {};
  const displayName = base2.displayName || elementMeta.label || tag3;
  const description = base2.description || elementMeta.description || "";
  const allowBlank = base2.allowBlank !== void 0 ? !!base2.allowBlank : elementMeta.allowBlank !== void 0 ? !!elementMeta.allowBlank : true;
  const create = typeof base2.create === "function" ? base2.create : schemaApi?.create ? () => schemaApi.create() : ctor?.ee && typeof ctor.ee.create === "function" ? () => ctor.ee.create() : () => document.createElement(tag3);
  const getIcon = typeof base2.getIcon === "function" ? base2.getIcon : schemaApi?.getElementIcon ? schemaApi.getElementIcon.bind(schemaApi) : ctor?.ee && typeof ctor.ee.getElementIcon === "function" ? ctor.ee.getElementIcon.bind(ctor.ee) : null;
  const keywords = Array.isArray(base2.keywords) ? base2.keywords.slice() : Array.isArray(elementMeta.keywords) ? elementMeta.keywords.slice() : [];
  return {
    libraryId,
    tag: tag3,
    displayName,
    description,
    create,
    getIcon,
    keywords,
    schema: schema2 || null,
    ee: schemaApi || null,
    // Store full API object for sanitize, etc.
    allowBlank
  };
};
var LibraryManagerStore = class {
  static observableActions = ["registerLibrary", "registerElement", "includeLibrary"];
  static computedProperties = [
    "libraries",
    "allElements"
  ];
  librariesById = {};
  elementsByLibrary = {};
  elementsByTag = {};
  dependencies = /* @__PURE__ */ new Map();
  registerLibrary(config) {
    const normalized = normalizeLibrary(config);
    const existing = this.librariesById[normalized.id] || {};
    this.librariesById = {
      ...this.librariesById,
      [normalized.id]: {
        ...existing,
        ...normalized
      }
    };
    if (!this.dependencies.has(normalized.id)) {
      const next = new Map(this.dependencies);
      next.set(normalized.id, /* @__PURE__ */ new Set());
      this.dependencies = next;
    }
  }
  registerElement(libraryId, config) {
    if (!libraryId) throw new Error("libraryId is required to register an element");
    if (!this.librariesById[libraryId]) {
      this.registerLibrary({ id: libraryId, level: LibraryLevel.SYSTEM });
    }
    const normalized = normalizeElement(libraryId, config);
    const existingList = this.elementsByLibrary[libraryId] || [];
    const filtered = existingList.filter((entry) => entry.tag !== normalized.tag);
    this.elementsByLibrary = {
      ...this.elementsByLibrary,
      [libraryId]: [...filtered, normalized]
    };
    const key = normalized.tag.toLowerCase();
    this.elementsByTag = {
      ...this.elementsByTag,
      [key]: normalized
    };
  }
  get libraries() {
    const libs = Object.values(this.librariesById);
    return libs.sort((a23, b12) => {
      const levelCompare = (LEVEL_ORDER[a23.level] || 0) - (LEVEL_ORDER[b12.level] || 0);
      if (levelCompare !== 0) return levelCompare;
      return a23.name.localeCompare(b12.name, void 0, { sensitivity: "base" });
    });
  }
  get allElements() {
    const list = [];
    for (const library of this.libraries) {
      const elements = this.elementsByLibrary[library.id] || [];
      for (const entry of elements) {
        list.push(entry);
      }
    }
    return list;
  }
  getElementsForLibrary(libraryId) {
    const direct = (this.elementsByLibrary[libraryId] || []).filter((entry) => entry.allowBlank !== false).slice().sort(
      (a23, b12) => a23.displayName.localeCompare(b12.displayName, void 0, { sensitivity: "base" })
    );
    const inheritedMap = this.#collectIncludedElements(libraryId);
    const directTags = new Set(direct.map((entry) => entry.tag));
    const inherited = [];
    inheritedMap.forEach((entry, tag3) => {
      if (!directTags.has(tag3)) inherited.push(entry);
    });
    inherited.sort(
      (a23, b12) => a23.displayName.localeCompare(b12.displayName, void 0, { sensitivity: "base" })
    );
    return [...direct, ...inherited];
  }
  getElementByTag(tagName) {
    if (!tagName) return null;
    return this.elementsByTag[String(tagName).toLowerCase()] || null;
  }
  includeLibrary(libraryId, dependencyId) {
    const parent = this.librariesById[libraryId];
    const dependency = this.librariesById[dependencyId];
    if (!parent) {
      throw new Error(`Library '${libraryId}' must be registered before including others.`);
    }
    if (!dependency) {
      throw new Error(`Cannot include unknown library '${dependencyId}'.`);
    }
    if (!this.#canInclude(parent.level, dependency.level)) {
      throw new Error(`Library '${libraryId}' (${parent.level}) cannot include '${dependencyId}' (${dependency.level}).`);
    }
    const existing = this.dependencies.get(libraryId) || /* @__PURE__ */ new Set();
    if (existing.has(dependencyId)) return;
    const next = new Map(this.dependencies);
    const updated = new Set(existing);
    updated.add(dependencyId);
    next.set(libraryId, updated);
    this.dependencies = next;
  }
  #collectIncludedElements(libraryId) {
    const result = /* @__PURE__ */ new Map();
    const includeIds = this.#getResolvedDependencies(libraryId, /* @__PURE__ */ new Set());
    includeIds.forEach((includeId) => {
      const entries = this.elementsByLibrary[includeId] || [];
      entries.forEach((entry) => {
        if (entry.allowBlank === false) return;
        if (!result.has(entry.tag)) result.set(entry.tag, entry);
      });
    });
    return result;
  }
  #getResolvedDependencies(libraryId, visited) {
    const resolved = [];
    if (visited.has(libraryId)) return resolved;
    visited.add(libraryId);
    const direct = Array.from(this.dependencies.get(libraryId) || []);
    direct.forEach((depId) => {
      if (!resolved.includes(depId)) resolved.push(depId);
      const nested = this.#getResolvedDependencies(depId, visited);
      nested.forEach((nestedId) => {
        if (!resolved.includes(nestedId)) resolved.push(nestedId);
      });
    });
    return resolved;
  }
  #canInclude(level, includeLevel) {
    const base2 = LEVEL_ORDER[level];
    const includeBase = LEVEL_ORDER[includeLevel];
    if (base2 === void 0 || includeBase === void 0) return false;
    return includeBase < base2;
  }
};
makeObservable(LibraryManagerStore);
var libraryManager = new LibraryManagerStore();
var registerLibrary = (config) => libraryManager.registerLibrary(config);
var registerElement = (libraryId, config) => libraryManager.registerElement(libraryId, config);

// src/features/shared/sanitize.js
function stripAuthoringArtifacts(root, helpers = {}) {
  const walk = (node) => {
    if (node.nodeType === Node.ELEMENT_NODE) {
      const el = node;
      const toRemove = [];
      for (const { name } of Array.from(el.attributes || [])) {
        const lower = typeof name === "string" ? name.toLowerCase() : "";
        if (lower.startsWith("data-ee-")) {
          if (lower === "data-ee-comment-id") continue;
          if (lower === "data-ee-locked") continue;
          if (lower === "data-ee-agent-id") continue;
          if (lower.startsWith("data-ee-agent-") && lower.endsWith("-id")) continue;
          toRemove.push(name);
        } else if (lower === "role" || lower.startsWith("aria-") || lower === "tabindex") {
          if (helpers.isComparison) toRemove.push(name);
        }
      }
      toRemove.forEach((name) => el.removeAttribute(name));
      if (el.style) {
        el.style.removeProperty("user-select");
        el.style.removeProperty("-webkit-user-select");
      }
      if (el.hasAttribute && el.hasAttribute("style")) {
        const css = (el.getAttribute("style") || "").trim().replace(/;+$/g, "");
        if (helpers.isComparison || !css) el.removeAttribute("style");
      }
      if (el.hasAttribute && el.hasAttribute("theme")) {
        el.removeAttribute("theme");
      }
      if (el.hasAttribute && el.hasAttribute("class")) {
        if (helpers.beforeSave !== false) el.removeAttribute("class");
      }
    }
    if (node.childNodes && node.childNodes.length) {
      const children = Array.from(node.childNodes);
      for (const child of children) {
        if (child.nodeType === Node.TEXT_NODE) {
          const t34 = child.textContent || "";
          if (child === node.lastChild && /^\s*\|\s*$/.test(t34)) {
            child.remove();
            continue;
          }
        } else if (child.nodeType === Node.ELEMENT_NODE) {
          walk(child);
        }
      }
    }
  };
  walk(root);
}
function applyElementSanitizers(root, helpers) {
  const visit = (el) => {
    const tag3 = el.tagName?.toLowerCase?.();
    const ctor = tag3 ? customElements.get(tag3) : null;
    let sanitize = ctor?.ee?.sanitize;
    if (!sanitize) {
      const elementEntry = libraryManager.getElementByTag(tag3);
      if (elementEntry?.ee?.sanitize) {
        sanitize = elementEntry.ee.sanitize;
      }
    }
    if (!sanitize && typeof window !== "undefined" && window.eeDefaults) {
      const defaults = window.eeDefaults[tag3];
      if (defaults?.sanitize) {
        sanitize = defaults.sanitize;
      }
    }
    Array.from(el.children || []).forEach((c33) => visit(c33));
    if (sanitize) sanitize(el, helpers);
  };
  visit(root);
}
function removeNodeIds(root) {
  function visit(node) {
    if (!node) return;
    if (node.nodeType === Node.ELEMENT_NODE) {
      const el = node;
      if (el.hasAttribute?.("data-ee-node-id")) {
        el.removeAttribute("data-ee-node-id");
      }
      if (el.id && /-[0-9]+(-|$)/.test(el.id)) {
        el.removeAttribute("id");
      }
    }
    const children = Array.from(node.childNodes || []);
    children.forEach((child) => visit(child));
  }
  visit(root);
}
function sanitizeTree(root, helpers = {}) {
  (function removeAllComments(node) {
    const children = Array.from(node.childNodes || []);
    for (const child of children) {
      if (!child) continue;
      if (child.nodeType === Node.COMMENT_NODE) {
        child.remove();
        continue;
      }
      if (child.childNodes && child.childNodes.length) removeAllComments(child);
    }
  })(root);
  const normalizedHelpers = normalizeHelpers(helpers);
  stripAuthoringArtifacts(root, normalizedHelpers);
  applyElementSanitizers(root, normalizedHelpers);
  removeNodeIds(root);
  return root;
}
function normalizeHelpers(helpers) {
  const editor = document.querySelector("experience-elements-editor");
  const showToast2 = helpers.showToast || ((msg) => {
    if (editor && editor.showToast) editor.showToast(msg);
    else console.warn(msg);
  });
  return {
    currentDocumentId: helpers.currentDocumentId || editor?.getAttribute?.("data-ee-current-id") || null,
    showToast: showToast2,
    beforeSave: !!helpers.beforeSave,
    isComparison: !!helpers.isComparison
  };
}

// src/features/editor/save-helpers.js
function stripRteWrappers(root) {
  if (!root) return;
  const doc3 = root.ownerDocument || document;
  function unwrap(rte) {
    console.log("[save-helpers] stripRteWrappers: unwrapping ee-rte");
    const surface = rte.querySelector?.('[part~="surface"]') || rte.querySelector?.(".ee-rte__surface") || rte.querySelector?.(".ProseMirror") || rte;
    const fragment = doc3.createDocumentFragment();
    Array.from(surface.childNodes || []).forEach((child) => {
      fragment.appendChild(child.cloneNode(true));
    });
    rte.replaceWith(fragment);
  }
  const rteNodes = Array.from(root.querySelectorAll("ee-rte"));
  rteNodes.forEach((rte) => unwrap(rte));
}
function getSanitizedHtml(input, urn, options = {}) {
  if (!input) return "";
  const parts = [];
  const doc3 = (input instanceof Node ? input.ownerDocument : null) || document;
  const container = doc3.createElement("div");
  let children = [];
  if (input instanceof NodeList || Array.isArray(input)) {
    children = Array.from(input);
  } else if (input.nodeType === Node.DOCUMENT_FRAGMENT_NODE || input.childNodes) {
    children = Array.from(input.childNodes);
  } else if (input.children) {
    children = Array.from(input.children);
  }
  for (const node of children) {
    if (!node) continue;
    if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE) {
      container.appendChild(node.cloneNode(true));
    }
  }
  sanitizeTree(container, {
    currentDocumentId: urn,
    showToast: () => {
    },
    // Isolated, no UI feedback
    beforeSave: true,
    isComparison: !!options.isComparison
  });
  stripRteWrappers(container);
  Array.from(container.childNodes).forEach((node) => {
    if (node.nodeType === Node.ELEMENT_NODE) {
      parts.push(node.outerHTML);
    } else if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent ?? "";
      if (text.length > 0) {
        parts.push(text);
      }
    }
  });
  return parts.join("\n");
}
function buildSanitizedHtmlFromHost(host, urn) {
  return getSanitizedHtml(host, urn);
}
function getJsonSnapshot(editorElement) {
  const host = editorElement;
  if (!host) return [];
  function serializeElement(el) {
    return { content: el.outerHTML };
  }
  function serializeNode(node) {
    if (!node) return null;
    if (node.nodeType === Node.TEXT_NODE) {
      const t34 = node.textContent?.trim();
      return t34 ? { text: t34 } : null;
    }
    if (node.nodeType === Node.ELEMENT_NODE) {
      const tag3 = node.tagName?.toLowerCase?.();
      if (tag3 === "ee-rte") {
        console.log("[save-helpers] getJsonSnapshot: transparently passing through ee-rte container");
        const children = Array.from(node.children || []);
        const serialized = children.map((c33) => serializeNode(c33)).filter(Boolean);
        if (serialized.length === 1) return serialized[0];
        return serialized;
      }
      const Ctor4 = customElements.get(tag3);
      if (Ctor4?.ee?.toJson) {
        return Ctor4.ee.toJson(node, serializeNode);
      }
      const def = typeof window !== "undefined" && window.eeDefaults ? window.eeDefaults[tag3] : null;
      if (def?.toJson) {
        return def.toJson(node, serializeNode);
      }
      return serializeElement(node);
    }
    return null;
  }
  const out = [];
  for (const el of Array.from(host.children)) {
    if (!(el && el.nodeType === Node.ELEMENT_NODE)) continue;
    const tag3 = el.tagName?.toLowerCase?.();
    const Ctor4 = tag3 ? customElements.get(tag3) : null;
    if (Ctor4?.ee?.toJson) {
      out.push(Ctor4.ee.toJson(el, serializeNode));
    } else {
      const def = typeof window !== "undefined" && window.eeDefaults ? window.eeDefaults[tag3] : null;
      if (def?.toJson) out.push(def.toJson(el, serializeNode));
      else out.push(serializeElement(el));
    }
  }
  return out;
}

// src/stores/editor/history-store.js
var EditorHistoryStore = class {
  undoStack = [];
  redoStack = [];
  maxHistorySize = 50;
  isUndoRedoInProgress = false;
  editorElement = null;
  snapshotTimeout = null;
  snapshotDelay = 250;
  autoSaveTimeout = null;
  autoSaveDelay = 1500;
  lastSavedAt = 0;
  saveIndicatorVisible = false;
  saveIndicatorHideTimeout = null;
  baselineHtmlNormalized = null;
  #editor;
  constructor(editor) {
    this.#editor = editor;
  }
  get editor() {
    return this.#editor;
  }
  setEditorElement(element) {
    this.editorElement = element;
  }
  scheduleSnapshot() {
    console.log("[EditorHistoryStore] scheduleSnapshot called");
    if (this.isUndoRedoInProgress) {
      return;
    }
    if (this.snapshotTimeout) {
      clearTimeout(this.snapshotTimeout);
    }
    this.snapshotTimeout = setTimeout(() => {
      this.editor.captureSnapshot();
    }, this.snapshotDelay);
    this.scheduleAutoSave();
  }
  captureSnapshot() {
    if (!this.editorElement) return;
    const urn = this.editor.currentElementId;
    const htmlContent = buildSanitizedHtmlFromHost(this.editorElement, urn);
    if (this.undoStack.length === 0) {
      this.undoStack.push(htmlContent);
      return;
    }
    this.pushUndoState(htmlContent);
  }
  getJsonSnapshot() {
    return getJsonSnapshot(this.editorElement);
  }
  getSanitizedHtml() {
    if (!this.editorElement) return "";
    const urn = this.editor.currentElementId;
    return buildSanitizedHtmlFromHost(this.editorElement, urn);
  }
  scheduleAutoSave() {
    if (this.autoSaveTimeout) {
      clearTimeout(this.autoSaveTimeout);
    }
    this.autoSaveTimeout = setTimeout(() => {
      this.autoSaveTimeout = null;
      this.editor.performAutoSave();
    }, this.autoSaveDelay);
  }
  async performAutoSave() {
    const host = this.editorElement;
    if (!host) return;
    if (this.editor.richText?.activeRte) {
      console.log("[EditorHistoryStore] Skipping auto-save: inline editing is active");
      return;
    }
    const appStore = host?.store;
    const doc3 = appStore?.currentElement;
    const urn = this.editor.currentElementId || appStore?.editorStore?.currentElementId;
    if (!doc3 || !urn) return;
    if (!host.firstElementChild) return;
    const nextHtml = buildSanitizedHtmlFromHost(host, urn);
    const normalizeComments = (list) => Array.isArray(list) ? list.map((c33) => ({
      id: String(c33.id || ""),
      targetId: String(c33.targetId || ""),
      text: String(c33.text || ""),
      status: c33.status === "resolved" ? "resolved" : "open",
      createdAt: c33.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: c33.updatedAt || c33.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
      ...c33.author ? { author: String(c33.author) } : {},
      ...c33.authorEmail ? { authorEmail: String(c33.authorEmail) } : {}
    })) : [];
    const nextComments = normalizeComments(
      appStore?.collaboration?.comment?.comments || []
    );
    const prevComments = normalizeComments(doc3.comments || []);
    const sameHtml = String(doc3.html || "") === String(nextHtml || "");
    const sameComments = (() => {
      if (prevComments.length !== nextComments.length) return false;
      for (let i21 = 0; i21 < nextComments.length; i21++) {
        const a23 = nextComments[i21];
        const b12 = prevComments[i21];
        if (!b12) return false;
        if (a23.id !== b12.id || a23.targetId !== b12.targetId || a23.text !== b12.text || a23.status !== b12.status || a23.author !== b12.author || a23.authorEmail !== b12.authorEmail) {
          return false;
        }
      }
      return true;
    })();
    if (sameHtml && sameComments) return;
    doc3.html = nextHtml;
    doc3.comments = nextComments;
    doc3.editorStore = this.editor;
    await appStore.documentStore.saveDocument(doc3);
    this.markSaved();
  }
  markSaved() {
    this.lastSavedAt = Date.now();
    this.saveIndicatorVisible = true;
    notify(this.editor);
    if (this.saveIndicatorHideTimeout) {
      clearTimeout(this.saveIndicatorHideTimeout);
    }
    this.saveIndicatorHideTimeout = setTimeout(() => {
      this.saveIndicatorVisible = false;
      notify(this.editor);
    }, 1500);
    this.setBaselineFromCurrent();
  }
  hasUnsavedChanges() {
    const host = this.editorElement;
    if (!host) return false;
    const appStore = host?.store;
    const doc3 = appStore?.currentElement;
    const urn = this.editor.currentElementId || appStore?.editorStore?.currentElementId;
    if (!doc3 || !urn) return false;
    if (!host.firstElementChild) return false;
    const currentSanitized = getSanitizedHtml(host, urn, { isComparison: true });
    if (this.baselineHtmlNormalized != null) {
      const b13 = String(this.baselineHtmlNormalized);
      const c34 = String(currentSanitized || "");
      const hasChanges2 = b13 !== c34;
      if (hasChanges2) {
        console.groupCollapsed("Editor: Unsaved changes detected (baseline mismatch)");
        console.log("URN:", urn);
        console.log("Baseline:", b13);
        console.log("Current: ", c34);
        for (let i21 = 0; i21 < Math.max(b13.length, c34.length); i21++) {
          if (b13[i21] !== c34[i21]) {
            console.log(`First difference at index ${i21}:`);
            console.log(`  Baseline: "...${b13.substring(Math.max(0, i21 - 10), i21)}[${b13[i21] || ""}]${b13.substring(i21 + 1, i21 + 20)}..."`);
            console.log(`  Current:  "...${c34.substring(Math.max(0, i21 - 10), i21)}[${c34[i21] || ""}]${c34.substring(i21 + 1, i21 + 20)}..."`);
            break;
          }
        }
        console.groupEnd();
      }
      return hasChanges2;
    }
    const last = String(doc3.html || "");
    const parser = new DOMParser();
    const docParsed = parser.parseFromString(last, "text/html");
    const lastSanitized = getSanitizedHtml(docParsed.body.childNodes, urn, { isComparison: true });
    const b12 = String(lastSanitized || "");
    const c33 = String(currentSanitized || "");
    const hasChanges = b12 !== c33;
    if (hasChanges) {
      console.groupCollapsed("Editor: Unsaved changes detected (fallback mismatch)");
      console.log("URN:", urn);
      console.log("Last Sanitized:", b12);
      console.log("Current Sanitized:", c33);
      console.groupEnd();
    }
    return hasChanges;
  }
  setBaselineFromCurrent(input) {
    const host = this.editorElement;
    if (!host && !input) return;
    const appStore = host?.store;
    const urn = this.editor.currentElementId || appStore?.editorStore?.currentElementId;
    const source = input || host;
    if (!source) return;
    this.baselineHtmlNormalized = getSanitizedHtml(source, urn, { isComparison: true });
  }
  async saveCurrentElement() {
    const host = this.editorElement;
    if (!host) return;
    const appStore = host?.store;
    const doc3 = appStore?.currentElement;
    const urn = this.editor.currentElementId || appStore?.editorStore?.currentElementId;
    if (!doc3 || !urn) return;
    if (!host.firstElementChild) return;
    const html = buildSanitizedHtmlFromHost(host, urn);
    const comments = appStore?.collaboration?.comment?.comments || [];
    doc3.comments = Array.isArray(comments) ? comments.map((c33) => ({
      id: String(c33.id || ""),
      targetId: String(c33.targetId || ""),
      text: String(c33.text || ""),
      status: c33.status === "resolved" ? "resolved" : "open",
      createdAt: c33.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: c33.updatedAt || c33.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
      ...c33.author ? { author: String(c33.author) } : {},
      ...c33.authorEmail ? { authorEmail: String(c33.authorEmail) } : {}
    })) : [];
    doc3.html = html;
    await appStore.documentStore.saveDocument(doc3);
  }
  pushUndoState(htmlContent) {
    if (this.isUndoRedoInProgress) {
      return;
    }
    const lastUndoState = this.undoStack.length > 0 ? this.undoStack[this.undoStack.length - 1] : null;
    if (htmlContent === lastUndoState) return;
    this.undoStack.push(htmlContent);
    this.redoStack = [];
    if (this.undoStack.length > this.maxHistorySize) {
      this.undoStack.shift();
    }
  }
  undo() {
    if (!this.canUndo || !this.editorElement) {
      return false;
    }
    if (this.undoStack.length <= 1) return false;
    const currentState = this.undoStack.pop();
    this.redoStack.push(currentState);
    const previousState = this.undoStack[this.undoStack.length - 1];
    this.isUndoRedoInProgress = true;
    this.editorElement.innerHTML = previousState;
    this.editor.setEditingElement(null);
    this.editor.toolbar.hideEEToolbar();
    setTimeout(() => {
      this.isUndoRedoInProgress = false;
    }, 100);
    return true;
  }
  redo() {
    if (!this.canRedo || !this.editorElement) {
      return false;
    }
    const nextState = this.redoStack.pop();
    this.undoStack.push(nextState);
    this.isUndoRedoInProgress = true;
    this.editorElement.innerHTML = nextState;
    this.editor.setEditingElement(null);
    this.editor.toolbar.hideEEToolbar();
    setTimeout(() => {
      this.isUndoRedoInProgress = false;
    }, 100);
    return true;
  }
  clearUndoRedo() {
    this.undoStack = [];
    this.redoStack = [];
  }
  get canUndo() {
    return this.undoStack.length > 1;
  }
  get canRedo() {
    return this.redoStack.length > 0;
  }
  static computedProperties = ["canUndo", "canRedo"];
};

// src/features/toolbar/toolbar-actions.js
var getSlotConfig = (parent, slotName, domStore) => {
  if (!parent) {
    return null;
  }
  const tag3 = parent.tagName?.toLowerCase?.();
  if (!tag3) {
    return null;
  }
  const ctor = customElements.get(tag3);
  if (!ctor) return null;
  const normalized = domStore?.normalizeSlotName(slotName) ?? "default";
  let cfg = null;
  if (ctor?.ee) {
    const schema2 = getElementSchema(ctor.ee, parent);
    if (schema2) {
      cfg = schema2.slots?.configs?.[normalized] ?? null;
    }
  }
  if (!cfg && ctor?.ee?.getSlotConfig) {
    cfg = ctor.ee.getSlotConfig(normalized) ?? null;
  }
  return cfg;
};
function handleDuplicateElement(context) {
  const { editorStore, domStore, element } = context;
  if (!element) {
    return false;
  }
  if (!domStore) {
    console.error("Dom store required for duplication");
    return false;
  }
  const parent = element.parentElement || null;
  const resolvedSlotName = domStore.normalizeSlotName(
    element.getAttribute?.("slot")
  );
  if (parent) {
    const cfg = getSlotConfig(parent, resolvedSlotName, domStore);
    if (cfg) {
      const maxLen = cfg.maxLength === null || cfg.maxLength === void 0 ? Infinity : Number(cfg.maxLength);
      if (Number.isFinite(maxLen)) {
        const currentCount = domStore.countSlotChildren(
          parent,
          resolvedSlotName
        );
        if (currentCount >= maxLen) {
          console.warn("Cannot duplicate: slot cardinality limit reached");
          return false;
        }
      }
    }
  }
  const duplicate = domStore.duplicateElement(element, { insertAfter: true });
  if (!duplicate || !duplicate.element) {
    console.warn("Failed to duplicate element via dom store");
    return false;
  }
  const clone = duplicate.element;
  if (clone.tagName?.toLowerCase?.() === "a" && !clone.textContent?.trim()) {
    clone.textContent = "Link";
    clone.eePlaceholder = true;
  }
  editorStore.setEditingElement?.(clone);
  editorStore.toolbar?.showEEToolbar?.(clone);
  editorStore.history.scheduleSnapshot();
  editorStore.history.scheduleAutoSave?.();
  editorStore.setLastAction?.("editor:duplicate", {
    tag: clone.tagName?.toLowerCase?.() || null
  });
  return {
    element: clone
  };
}
function handleDeleteElement(context) {
  const { editorStore, domStore, element } = context;
  if (!element) {
    return false;
  }
  if (!domStore) {
    console.error("Dom store required for deletion");
    return false;
  }
  editorStore?.richText?.disposeInlineEditing?.();
  let targetElement = element;
  const elementParent = element.parentElement;
  if (elementParent?.tagName?.toLowerCase?.() === "ee-content") {
    targetElement = elementParent;
  }
  const parent = targetElement.parentElement || null;
  const slotName = domStore.normalizeSlotName(
    targetElement.getAttribute?.("slot")
  );
  const previous = domStore.getPreviousAuthorableSibling(targetElement);
  const next = domStore.getNextAuthorableSibling(targetElement);
  const siblings = parent ? domStore.getAuthorableChildren(parent) : [];
  const sameSlotSiblings = siblings.filter(
    (child) => domStore.normalizeSlotName(child.getAttribute?.("slot")) === slotName
  );
  const sameSlotIndex = sameSlotSiblings.indexOf(targetElement);
  const resolveElement = (el) => {
    if (!el) return null;
    if (el.tagName?.toLowerCase?.() === "ee-content" && el.firstElementChild) {
      return el.firstElementChild;
    }
    return el;
  };
  let selectionPlan = { type: "none" };
  const elementSelectionOptions = {
    suppressInlineContext: true,
    inputType: "delete",
    suppressInlineActivation: true
  };
  if (sameSlotIndex >= 0 && sameSlotIndex < sameSlotSiblings.length - 1) {
    selectionPlan = {
      type: "element",
      element: resolveElement(sameSlotSiblings[sameSlotIndex + 1]),
      options: elementSelectionOptions
    };
  } else if (sameSlotIndex > 0) {
    selectionPlan = {
      type: "element",
      element: resolveElement(sameSlotSiblings[sameSlotIndex - 1]),
      options: elementSelectionOptions
    };
  } else if (parent) {
    selectionPlan = {
      type: "slot",
      parent,
      slotName,
      options: {
        inputType: "delete",
        suppressInlineContext: true,
        suppressInlineActivation: true
      }
    };
  }
  const removed = domStore.deleteElement(targetElement);
  if (!removed) {
    console.warn("Failed to delete node via dom store");
    return false;
  }
  const wasSelected = editorStore.editingElement === element || editorStore.editingElement === targetElement;
  if (wasSelected) {
    requestAnimationFrame(() => {
      if (selectionPlan.type === "element" && selectionPlan.element?.isConnected) {
        editorStore.selection.selectElement(
          selectionPlan.element,
          null,
          selectionPlan.options || {}
        );
        return;
      }
      if (selectionPlan.type === "slot" && selectionPlan.parent?.isConnected) {
        editorStore.selection.selectSlot(
          selectionPlan.parent,
          selectionPlan.slotName || domStore.defaultSlotName,
          selectionPlan.options || {}
        );
        return;
      }
      if (previous?.isConnected) {
        editorStore.selection.selectElement(
          previous,
          null,
          elementSelectionOptions
        );
        return;
      }
      if (next?.isConnected) {
        editorStore.selection.selectElement(
          next,
          null,
          elementSelectionOptions
        );
        return;
      }
      editorStore.selection.clearSelection?.();
    });
  }
  editorStore.history.scheduleSnapshot();
  return true;
}

// src/editor-constants.js
var ZOOM = {
  MIN: 1,
  MAX: 4,
  STEP: 0.1
};
var DRAG = {
  START_THRESHOLD_PX: 2,
  DELTA_IS_SCREEN_SPACE: true,
  ZOOM_GAIN_EXP: 0.8,
  MIN_GAIN: 1
};

// src/zoom.js
var resolveEl = (ref, fallbackSelector) => {
  if (!ref) return document.querySelector(fallbackSelector);
  if (typeof ref === "string") return document.querySelector(ref);
  return ref;
};
var ZoomStore = class {
  static observableActions = [
    "setZoom",
    "zoomIn",
    "zoomOut",
    "zoomBy",
    "setPan",
    "panBy",
    "reset",
    "setEnabled"
  ];
  static computedProperties = ["transform", "canZoomIn", "canZoomOut"];
  constructor(opts = {}) {
    this.minZoom = Number.isFinite(opts.minZoom) ? opts.minZoom : ZOOM?.MIN ?? 1;
    this.maxZoom = Number.isFinite(opts.maxZoom) ? opts.maxZoom : ZOOM?.MAX ?? 4;
    this.step = Number.isFinite(opts.step) ? opts.step : ZOOM?.STEP ?? 0.1;
  }
  // View state
  x = 0;
  y = 0;
  z = 1;
  enabled = true;
  get transform() {
    return `translate(${this.x}px, ${this.y}px) scale(${this.z})`;
  }
  get canZoomIn() {
    return (this.z || 1) < (this.maxZoom ?? 4) - 1e-6;
  }
  get canZoomOut() {
    return (this.z || 1) > (this.minZoom ?? 1) + 1e-6;
  }
  setEnabled(v6) {
    this.enabled = !!v6;
  }
  setZoom(z3, anchor) {
    const zOld = this.z;
    const zNew = Math.min(this.maxZoom, Math.max(this.minZoom, z3));
    if (zNew === zOld) return;
    if (anchor && Number.isFinite(anchor.x) && Number.isFinite(anchor.y)) {
      const r25 = zNew / zOld;
      const { x: px, y: py } = anchor;
      this.x = px - (px - this.x) * r25;
      this.y = py - (py - this.y) * r25;
    }
    this.z = zNew;
  }
  zoomBy(delta, anchor) {
    this.setZoom(this.z * (1 + delta), anchor);
  }
  zoomIn(amount = this.step, anchor) {
    this.setZoom(this.z * (1 + amount), anchor);
  }
  zoomOut(amount = this.step, anchor) {
    this.setZoom(this.z / (1 + amount), anchor);
  }
  setPan(x5, y5) {
    this.x = x5;
    this.y = y5;
  }
  panBy(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
  reset() {
    this.x = 0;
    this.y = 0;
    this.z = 1;
  }
};
makeObservable(ZoomStore);
function attachZoomPan(options = {}) {
  const container = resolveEl(options.container, "#canvas-container");
  const surface = resolveEl(options.surface, "#surface-wrapper");
  const target = resolveEl(options.target, "#surface-content") || surface;
  const debug = (type, meta = {}) => {
  };
  if (!container || !surface) {
    throw new Error("attachZoomPan: container or surface not found");
  }
  const store = new ZoomStore({
    minZoom: options.minZoom,
    maxZoom: options.maxZoom,
    step: options.step
  });
  let dragging = false;
  let pointerDown = false;
  let last = { x: 0, y: 0, id: null };
  const startThreshold = DRAG && Number.isFinite(DRAG.START_THRESHOLD_PX) ? DRAG.START_THRESHOLD_PX : 2;
  let selectionDisabled = false;
  let selectListenerAttached = false;
  const disableSelection = () => {
    if (selectionDisabled) return;
    target.style.userSelect = "none";
    target.style.webkitUserSelect = "none";
    selectionDisabled = true;
    if (!selectListenerAttached) {
      document.addEventListener("selectstart", preventSelect, true);
      selectListenerAttached = true;
    }
  };
  const enableSelection = () => {
    if (!selectionDisabled) return;
    target.style.userSelect = "";
    target.style.webkitUserSelect = "";
    selectionDisabled = false;
    if (selectListenerAttached) {
      document.removeEventListener("selectstart", preventSelect, true);
      selectListenerAttached = false;
    }
  };
  const preventSelect = (e36) => {
    e36.preventDefault();
  };
  const disposeTransform = reaction(
    store,
    (s19) => [s19.x, s19.y, s19.z],
    () => {
      target.style.transform = store.transform;
    }
  );
  target.style.transformOrigin = "0 0";
  target.style.transform = store.transform;
  const onWheel = (e36) => {
    if (!store.enabled) return;
    const rect = container.getBoundingClientRect();
    if (e36.ctrlKey || e36.metaKey) {
      e36.preventDefault();
      e36.stopPropagation();
      const anchor = {
        x: e36.clientX - rect.left + container.scrollLeft,
        y: e36.clientY - rect.top + container.scrollTop
      };
      const gain = 1e-3;
      const factor = Math.exp(-e36.deltaY * gain);
      const zFrom = store.z;
      store.setZoom(store.z * factor, anchor);
      const zTo = store.z;
      debug("zoom:wheel", { zFrom, zTo, anchorX: anchor.x, anchorY: anchor.y, deltaY: e36.deltaY });
      return;
    }
    if ((store.z || 1) <= 1) {
      return;
    }
    const dx = -e36.deltaX;
    const dy = -e36.deltaY;
    const z3 = store.z || 1;
    const next = clampPan(store.x + dx / z3, store.y + dy / z3);
    if (next.x !== store.x || next.y !== store.y) {
      e36.preventDefault();
      e36.stopPropagation();
      store.setPan(next.x, next.y);
      debug("zoom:wheel-pan", { dx, dy, x: next.x, y: next.y, z: z3 });
    } else {
      return;
    }
  };
  const onPointerDown = (e36) => {
    if (!store.enabled) return;
    if (e36.pointerType === "mouse" && e36.button !== 0) return;
    if (typeof options.shouldCapture === "function" && !options.shouldCapture(e36)) return;
    pointerDown = true;
    last.x = e36.clientX;
    last.y = e36.clientY;
    last.id = e36.pointerId;
    if ((store.z || 1) > 1) disableSelection();
    debug("zoom:pointerdown", { clientX: e36.clientX, clientY: e36.clientY, z: store.z });
  };
  const onPointerMove = (e36) => {
    if (!store.enabled || !pointerDown) return;
    if ((store.z || 1) <= 1) return;
    if (last.id != null && e36.pointerId !== last.id) return;
    const dx = e36.clientX - last.x;
    const dy = e36.clientY - last.y;
    if (!dragging) {
      const dist = Math.hypot(dx, dy);
      if (dist < startThreshold) return;
      dragging = true;
      if (typeof surface.setPointerCapture === "function") {
        surface.setPointerCapture(last.id);
      }
      debug("zoom:pan-start", { startX: store.x, startY: store.y, z: store.z });
    }
    const next = clampPan(store.x + dx, store.y + dy);
    store.setPan(next.x, next.y);
    last.x = e36.clientX;
    last.y = e36.clientY;
    e36.preventDefault();
  };
  const endDrag = (e36) => {
    if (!pointerDown) return;
    if (last.id != null && e36 && e36.pointerId !== last.id) return;
    if (dragging) {
      e36.preventDefault();
    }
    dragging = false;
    pointerDown = false;
    if (typeof surface.hasPointerCapture === "function" && surface.hasPointerCapture(last.id)) {
      surface.releasePointerCapture(last.id);
    }
    last.id = null;
    enableSelection();
    debug("zoom:pan-end", { x: store.x, y: store.y, z: store.z });
  };
  const wheelOpts = { passive: false, capture: true };
  container.addEventListener("wheel", onWheel, wheelOpts);
  surface.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove, { passive: false });
  window.addEventListener("pointerup", endDrag);
  window.addEventListener("pointercancel", endDrag);
  const destroy = () => {
    disposeTransform();
    container.removeEventListener("wheel", onWheel, wheelOpts);
    surface.removeEventListener("pointerdown", onPointerDown);
    window.removeEventListener("pointermove", onPointerMove, { passive: false });
    window.removeEventListener("pointerup", endDrag);
    window.removeEventListener("pointercancel", endDrag);
    enableSelection();
  };
  const getViewportRect2 = () => container.getBoundingClientRect();
  const getSurfacePadding = /* @__PURE__ */ (() => {
    let cache2 = null;
    return () => {
      if (cache2) return cache2;
      const cs2 = getComputedStyle(surface);
      const pl = parseFloat(cs2.paddingLeft) || 0;
      const pr2 = parseFloat(cs2.paddingRight) || 0;
      const pt2 = parseFloat(cs2.paddingTop) || 0;
      const pb = parseFloat(cs2.paddingBottom) || 0;
      cache2 = { pl, pr: pr2, pt: pt2, pb };
      return cache2;
    };
  })();
  const getContentSize = () => ({ w: target.offsetWidth || 0, h: target.offsetHeight || 0 });
  const getScaledSize = () => {
    const z3 = store.z || 1;
    const base2 = getContentSize();
    return { w: base2.w * z3, h: base2.h * z3 };
  };
  const clampPan = (x5, y5) => {
    const vp = surface.getBoundingClientRect();
    const pad = getSurfacePadding();
    const innerW = Math.max(0, vp.width - pad.pl - pad.pr);
    const innerH = Math.max(0, vp.height - pad.pt - pad.pb);
    const scaled = getScaledSize();
    const centerX = innerW / 2;
    const edgeSlop = 12;
    let minX;
    let maxX;
    if (scaled.w <= innerW) {
      minX = centerX - scaled.w - edgeSlop;
      maxX = centerX + edgeSlop;
    } else {
      minX = innerW - scaled.w - edgeSlop;
      maxX = 0 + edgeSlop;
    }
    const minY = Math.min(0, innerH - scaled.h);
    const maxY = 0;
    return {
      x: Math.max(minX, Math.min(maxX, x5)),
      y: Math.max(minY, Math.min(maxY, y5))
    };
  };
  const ensureRectVisible = (el, margin = 24) => {
    if (!el || !el.getBoundingClientRect) return false;
    const vp = getViewportRect2();
    const pad = getSurfacePadding();
    const leftBound = vp.left + pad.pl;
    const rightBound = vp.right - pad.pr;
    const topBound = vp.top + pad.pt;
    const bottomBound = vp.bottom - pad.pb;
    let changed = false;
    let adjustments = 0;
    for (let i21 = 0; i21 < 5; i21++) {
      const rect = el.getBoundingClientRect();
      const fullyInside = rect.left >= leftBound + margin && rect.top >= topBound + margin && rect.right <= rightBound - margin && rect.bottom <= bottomBound - margin;
      if (fullyInside) break;
      let dx = 0;
      let dy = 0;
      const rectW = rect.width;
      const vpW = rightBound - leftBound - margin * 2;
      if (rectW > vpW) {
        dx = leftBound + margin - rect.left;
      } else {
        if (rect.left < leftBound + margin) dx = leftBound + margin - rect.left;
        else if (rect.right > rightBound - margin) dx = rightBound - margin - rect.right;
      }
      const rectH = rect.height;
      const vpH = bottomBound - topBound - margin * 2;
      if (rectH > vpH) {
        dy = topBound + margin - rect.top;
      } else {
        if (rect.top < topBound + margin) dy = topBound + margin - rect.top;
        else if (rect.bottom > bottomBound - margin) dy = bottomBound - margin - rect.bottom;
      }
      if (dx || dy) {
        const z3 = store.z || 1;
        const panDx = dx / z3;
        const panDy = dy / z3;
        const next = clampPan(store.x + panDx, store.y + panDy);
        store.setPan(next.x, next.y);
        changed = true;
        adjustments++;
      } else {
        break;
      }
    }
    if (changed) {
      const r25 = el.getBoundingClientRect();
      debug("zoom:ensure-visible", {
        adjustments,
        elementTag: el.tagName?.toLowerCase?.() || null,
        elementId: el.id || null,
        rectX: Math.round(r25.left),
        rectY: Math.round(r25.top),
        rectW: Math.round(r25.width),
        rectH: Math.round(r25.height),
        x: store.x,
        y: store.y,
        z: store.z
      });
    }
    return changed;
  };
  const focusElement = (el, { margin = 24 } = {}) => {
    if (!el || !el.getBoundingClientRect) return false;
    debug("zoom:focus-element", { elementTag: el.tagName?.toLowerCase?.() || null, elementId: el.id || null, margin });
    let changed = ensureRectVisible(el, margin);
    requestAnimationFrame(() => {
      changed = ensureRectVisible(el, margin) || changed;
      requestAnimationFrame(() => {
        ensureRectVisible(el, margin);
      });
    });
    return changed;
  };
  return {
    store,
    focusElement,
    ensureRectVisible,
    destroy
  };
}
var zoom_default = attachZoomPan;

// src/stores/editor/toolbar-store.js
var EditorToolbarStore = class {
  static observableActions = [
    "setEEToolbarPosition",
    "setToolbarOverlayOpen",
    "setOpenTool",
    "moveElementBefore",
    "moveElementAfter",
    "duplicateElement",
    "deleteElement",
    "elementMoved",
    "setToolbarActions",
    "setToolbarActionsData"
  ];
  static computedProperties = [
    "isEEToolbarVisible",
    "toolbarConfig"
  ];
  eeToolbarVisible = false;
  eeToolbarElement = null;
  eeToolbarPosition = { x: 0, y: 0 };
  toolbarOverlayOpen = false;
  toolbarActionsData = null;
  openTool = null;
  #editor;
  #selection;
  #history;
  #positionFrozen = false;
  #frozenPosition = null;
  #dragging = false;
  #dragOffsetX = 0;
  #dragOffsetY = 0;
  #lastAnchorElement = null;
  #lastReactionEditingElement = null;
  constructor(editor, selection, history3) {
    this.#editor = editor;
    this.#selection = selection;
    this.#history = history3;
  }
  #resolveConfigTag(config) {
    if (!config) return null;
    if (typeof config.tag !== "string") return null;
    const trimmed = config.tag.trim();
    return trimmed ? trimmed.toLowerCase() : null;
  }
  get editor() {
    return this.#editor;
  }
  get selection() {
    return this.#selection;
  }
  get history() {
    return this.#history;
  }
  setToolbarActions(actionsData) {
    this.toolbarActionsData = actionsData;
  }
  setToolbarActionsData(actionsData) {
    this.toolbarActionsData = actionsData;
  }
  get isEEToolbarVisible() {
    return this.eeToolbarVisible;
  }
  get elementSchema() {
    const element = this.selection.editingElement;
    if (!element) return null;
    return this.selection.buildElementSchema(element);
  }
  get canReorder() {
    const element = this.selection.editingElement;
    if (!element) return false;
    const state = this.#computeReorderingState(element);
    return state.enabled;
  }
  get toolbarConfig() {
    const schema2 = this.elementSchema;
    const hasSchema = !!schema2;
    return {
      visible: this.eeToolbarVisible,
      position: this.eeToolbarPosition,
      element: this.selection.editingElement,
      schema: schema2,
      hasSchema,
      showAttributeControls: hasSchema && schema2?.attributes && Object.keys(schema2.attributes).length > 0,
      showSlots: hasSchema && schema2?.slots && schema2.slots.length > 0,
      showReordering: this.canReorder,
      currentSlot: this.selection.currentSlot
    };
  }
  get toolbarActions() {
    const element = this.selection.editingElement;
    if (!element) return null;
    const schema2 = this.elementSchema;
    const currentSlot = this.selection.currentSlot;
    const slotOnly = !!this.selection.slotOnlySelection && !!currentSlot;
    const getConfig = (name) => {
      if (!name) {
        return this.selection.getNormalizedSlotConfig(element, "default") || {};
      }
      const normalized = this.selection.getNormalizedSlotConfig(element, name);
      if (normalized) {
        return normalized;
      }
      const configs = (schema2?.slots && typeof schema2.slots.configs === "object" ? schema2.slots.configs : null) || null;
      if (configs && name in configs) {
        return configs[name] || {};
      }
      return {};
    };
    const schemaSlotOrder = Array.isArray(schema2?.slots) && schema2.slots.length > 0 ? schema2.slots : this.selection.getKnownSlots(element);
    const slotInfo = {};
    if (schemaSlotOrder.length) {
      for (const slotName of schemaSlotOrder) {
        let nodes2 = [];
        if (element.shadowRoot) {
          const slot = element.shadowRoot.querySelector(
            slotName === "default" ? "slot:not([name])" : `slot[name="${slotName}"]`
          );
          nodes2 = slot ? slot.assignedNodes() : [];
        } else {
          nodes2 = Array.from(element.children).filter(
            (c33) => slotName === "default" ? !c33.hasAttribute("slot") : c33.getAttribute("slot") === slotName
          );
        }
        const cfg = getConfig(slotName);
        slotInfo[slotName] = {
          hasContent: nodes2.some((n25) => n25.nodeType === Node.ELEMENT_NODE),
          count: nodes2.filter((n25) => n25.nodeType === Node.ELEMENT_NODE).length,
          label: schema2.getSlotLabel?.(slotName) || slotName,
          minLength: cfg.minLength || 0,
          maxLength: cfg.maxLength == null ? Infinity : cfg.maxLength
        };
      }
    }
    const duplicationAllowed = (() => {
      if (slotOnly) return false;
      const elementMeta = schema2?.element || {};
      if (elementMeta.allowDuplicate === false) {
        return false;
      }
      const parent = element.parentElement;
      if (!parent) return false;
      const parentTag = parent.tagName?.toLowerCase?.() || "";
      if (!parent.tagName?.includes?.("-")) return true;
      const parentCtor = customElements.get(parentTag);
      const slotName = element.getAttribute("slot") || "default";
      const schemaDef = parentCtor?.ee?.getSchema?.();
      const cfg = schemaDef?.slots?.configs?.[slotName] || parentCtor?.ee?.getSlotConfig?.(slotName);
      if (!cfg) return true;
      const maxLen = cfg.maxLength == null ? Infinity : cfg.maxLength;
      const count = Array.from(parent.children).filter(
        (c33) => slotName === "default" ? !c33.hasAttribute("slot") : c33.getAttribute("slot") === slotName
      ).length;
      return count < maxLen;
    })();
    const deletionAllowed = (() => {
      if (slotOnly) return true;
      const elementMeta = schema2?.element || {};
      if (elementMeta.allowDelete === false) {
        return false;
      }
      return true;
    })();
    let attributesSchema = schema2?.attributes || {};
    let attributeNodeConfig = null;
    if (slotOnly) {
      attributesSchema = {};
    }
    let customActions = [];
    const ctor = customElements.get(element.tagName.toLowerCase());
    const getActions = ctor?.ee?.getToolbarActions;
    const helpers = {
      showToast: (msg) => this.editor.editorElement?.showToast?.(msg),
      openInEditor: (id) => {
        const url = new URL(window.location.href);
        url.searchParams.set("id", String(id || ""));
        url.searchParams.delete("new");
        url.searchParams.delete("category");
        window.location.href = url.toString();
      }
    };
    const res = getActions?.(element, helpers);
    if (Array.isArray(res)) customActions = res;
    if (slotOnly) {
      customActions = [];
    }
    const parentElementRef = schema2?.parentElement || (slotOnly ? element : null);
    const activeElement = slotOnly ? null : element;
    const reorderingState = slotOnly ? this.#getDisabledReorderingState() : this.#computeReorderingState(element);
    const textFormatting = this.buildTextFormattingConfig({
      element,
      slotOnly,
      getConfig,
      preferredSlot: schema2?.slotName || null
    });
    const linkNode = textFormatting?.node;
    if (linkNode?.type === "link" && !slotOnly && (!attributesSchema || Object.keys(attributesSchema).length === 0)) {
      attributesSchema = linkNode.attributes || {};
      attributeNodeConfig = linkNode;
    }
    const attributeCount = Object.keys(attributesSchema || {}).length;
    const attributesEnabled = attributeNodeConfig ? attributeCount > 0 : !slotOnly && attributeCount > 0;
    const tools = Array.isArray(schema2?.tools) ? schema2.tools : [];
    return {
      element: activeElement,
      elementLabel: schema2?.elementLabel || "",
      elementDescription: schema2?.elementDescription || "",
      isSlotContent: !!schema2?.isSlotContent,
      slotName: schema2?.slotName || null,
      parentElement: parentElementRef,
      selection: {
        type: slotOnly ? "slot" : "element",
        host: element,
        slotName: this.selection.currentSlot || null
      },
      textFormatting,
      attributes: {
        enabled: attributesEnabled,
        schema: attributesSchema || {},
        node: attributeNodeConfig
      },
      slots: {
        enabled: !!(schema2?.slots && schema2.slots.length > 0),
        available: schema2?.slots || [],
        current: this.selection.currentSlot,
        getConfig,
        getLabel: schema2?.getSlotLabel,
        slotInfo
      },
      tools: {
        enabled: !slotOnly && tools.length > 0,
        available: tools
      },
      reordering: reorderingState,
      duplicationAllowed,
      deletionAllowed,
      customActions
    };
  }
  moveElementBefore(element) {
    if (!element) return;
    this.editor?.richText?.disposeInlineEditing?.();
    const domStore = this.editor?.domStore;
    if (!domStore) return;
    const moved = domStore.moveElementBefore(element);
    if (!moved) return;
    this.elementMoved(element);
    this.history.scheduleSnapshot();
  }
  moveElementAfter(element) {
    if (!element) return;
    this.editor?.richText?.disposeInlineEditing?.();
    const domStore = this.editor?.domStore;
    if (!domStore) return;
    const moved = domStore.moveElementAfter(element);
    if (!moved) return;
    this.elementMoved(element);
    this.history.scheduleSnapshot();
  }
  duplicateElement(element) {
    if (!element) return;
    this.editor?.richText?.disposeInlineEditing?.();
    const domStore = this.editor.domStore;
    if (!domStore) return;
    const duplicate = handleDuplicateElement({
      editorStore: this.editor,
      domStore,
      element
    });
    if (duplicate && duplicate.element) {
      this.selection.selectElement(duplicate.element, null, {
        suppressInlineContext: true,
        inputType: "duplicate"
      });
      this.history.scheduleSnapshot();
      this.history.scheduleAutoSave();
    }
  }
  #getDisabledReorderingState() {
    return {
      enabled: false,
      canMoveUp: false,
      canMoveDown: false,
      canMoveFirst: false,
      canMoveLast: false
    };
  }
  #computeReorderingState(element) {
    if (!element) {
      return this.#getDisabledReorderingState();
    }
    const domStore = this.editor?.domStore || null;
    if (!domStore) {
      return this.#getDisabledReorderingState();
    }
    const canMoveUp = domStore.canMoveElementUp(element) === true;
    const canMoveDown = domStore.canMoveElementDown(element) === true;
    const enabled = canMoveUp || canMoveDown;
    if (!enabled) {
      return this.#getDisabledReorderingState();
    }
    return {
      enabled,
      canMoveUp,
      canMoveDown,
      canMoveFirst: canMoveUp,
      canMoveLast: canMoveDown
    };
  }
  buildTextFormattingConfig({
    element,
    slotOnly,
    getConfig,
    preferredSlot
  }) {
    console.log("[ToolbarStore.buildTextFormattingConfig] Called", {
      element: element ? { tagName: element.tagName, id: element.id } : null,
      slotOnly,
      currentSlot: this.selection.currentSlot,
      preferredSlot
    });
    if (!element || !getConfig) {
      console.log("[ToolbarStore.buildTextFormattingConfig] Early return - no element or getConfig");
      return null;
    }
    const editorStore = this.editor || null;
    const richText = editorStore?.richText || null;
    const activeRte = richText?.activeRte || null;
    let slotName = this.selection.currentSlot || preferredSlot || (element.getAttribute?.("slot") ?? null);
    if (!slotName) {
      slotName = "default";
    }
    if (!slotName) {
      console.log("[ToolbarStore.buildTextFormattingConfig] Early return - no slotName");
      return null;
    }
    const config = getConfig(slotName);
    console.log("[ToolbarStore.buildTextFormattingConfig] Config check", {
      slotName,
      hasConfig: !!config,
      inlineEditable: config?.inlineEditable
    });
    if (!config || config.inlineEditable !== true) {
      console.log("[ToolbarStore.buildTextFormattingConfig] Early return - not inlineEditable");
      return null;
    }
    if (!this.selection.currentSlot && slotName && slotName !== "default") {
      this.selection.setCurrentSlot?.(slotName);
    }
    const normalizeList2 = (value) => Array.isArray(value) ? value.map(
      (item) => typeof item === "string" ? item.trim().toLowerCase() : ""
    ).filter(Boolean) : [];
    const allowedMarks = normalizeList2(config.allowedStyles);
    const allowedFormats = normalizeList2(config.allowedFormats);
    const allowedAlignments = allowedFormats.filter(
      (format) => format.startsWith("align-")
    );
    const allowedLists = allowedFormats.filter(
      (format) => format === "unordered-list" || format === "ordered-list"
    );
    const allowLink = config.allowLinks === true;
    const placeholder = typeof config.placeholder === "string" ? config.placeholder : "";
    const tag3 = this.#resolveConfigTag(config);
    const cloneData2 = (value) => {
      if (value == null) return null;
      if (Array.isArray(value)) {
        return value.map((item) => cloneData2(item));
      }
      if (typeof value === "object") {
        const output = {};
        for (const [key, entry] of Object.entries(value)) {
          output[key] = cloneData2(entry);
        }
        return output;
      }
      return value;
    };
    const rteContext = editorStore?.richText?.context || null;
    return {
      inlineEditable: true,
      slotName,
      isSlotSelection: !!slotOnly,
      allowedMarks,
      allowedAlignments,
      allowedLists,
      allowLink,
      placeholder,
      tag: tag3,
      commands: cloneData2(rteContext?.commands),
      selection: cloneData2(rteContext?.selection),
      activeRte,
      multiline: config.multiline !== false,
      node: this.buildRteNodeConfig({
        selectionDetail: rteContext?.selection,
        commands: rteContext?.commands,
        activeRte
      })
    };
  }
  buildRteNodeConfig({ selectionDetail, commands, activeRte }) {
    if (!selectionDetail) return null;
    const buildLinkNode = (detail) => {
      if (!detail) return null;
      const linkState = commands?.link || {};
      const schemaProvider = typeof window !== "undefined" ? window.eeDefaults?.a : null;
      const schemaGetter = schemaProvider?.getSchema;
      if (!schemaGetter) return null;
      const tempTag = detail?.tag === "sp-link" ? "sp-link" : "a";
      const temp = document.createElement(tempTag);
      const attrsSource = detail && typeof detail === "object" ? detail : {};
      const attrs = detail?.attrs && typeof detail.attrs === "object" ? detail.attrs : attrsSource;
      Object.entries(attrs).forEach(([key, value]) => {
        if (value === null || value === void 0) {
          temp.removeAttribute(key);
        } else {
          temp.setAttribute(key, String(value));
        }
      });
      const schema2 = schemaGetter(temp) || null;
      if (!schema2) return null;
      const attributes = schema2.attributes || {};
      const values = Object.keys(attributes).reduce((acc, key) => {
        const def = attributes[key];
        if (def?.type === "boolean") {
          acc[key] = attrs[key] === "" || attrs[key] === true;
        } else {
          acc[key] = attrs[key] ?? (def?.default !== void 0 ? def.default : "");
        }
        return acc;
      }, {});
      const apply2 = (updates = {}) => {
        const next = { ...attrs };
        for (const [key, value] of Object.entries(updates)) {
          const def = attributes[key];
          if (def?.type === "boolean") {
            if (value) {
              next[key] = "";
            } else {
              delete next[key];
            }
          } else if (value === null || value === void 0 || value === "") {
            delete next[key];
          } else {
            next[key] = value;
          }
        }
        if (detail.tag === "sp-link") {
          next.tag = "sp-link";
        }
        activeRte?.applyLink?.(next);
      };
      const removeEnabled = linkState.removeEnabled === true;
      const remove = removeEnabled ? () => activeRte?.removeLink?.() : null;
      return {
        type: "link",
        label: "",
        description: schema2.element?.description || "",
        attributes,
        values,
        toolbarActions: [],
        apply: apply2,
        remove,
        removeEnabled
      };
    };
    if (selectionDetail.link) {
      return buildLinkNode(selectionDetail.link);
    }
    return null;
  }
  deleteElement(element) {
    if (!element) return;
    const domStore = this.editor.domStore;
    handleDeleteElement({
      editorStore: this.editor,
      domStore,
      element
    });
  }
  elementMoved(element) {
    if (!element) return;
    const editingMatches = this.selection.editingElement === element;
    if (editingMatches) {
      this.setToolbarActions(null);
    }
    if (this.eeToolbarElement === element) {
      this.updateEEToolbarPosition();
      this.editor.setLastAction("editor:toolbar:move", {
        tag: element.tagName?.toLowerCase?.() || null,
        id: element.id || null
      });
    }
  }
  updateEEToolbarPosition() {
    if (!this.eeToolbarElement) {
      return;
    }
    const pos = this.calculateEEToolbarPosition(this.eeToolbarElement);
    this.setEEToolbarPosition(pos.x, pos.y);
    this.#lastAnchorElement = this.eeToolbarElement;
  }
  calculateEEToolbarPosition(element) {
    if (!element) {
      return { x: 0, y: 0 };
    }
    const selection = window.getSelection?.();
    if (selection && selection.rangeCount > 0 && !selection.isCollapsed) {
      return this.#calculatePositionFromRect(
        selection.getRangeAt(0).getBoundingClientRect()
      );
    }
    const slotName = this.selection.currentSlot;
    const shadowRoot = element.shadowRoot;
    if (slotName && shadowRoot) {
      const selector = slotName === "default" ? "slot:not([name])" : `slot[name="${slotName}"]`;
      const slotElement = shadowRoot.querySelector(selector);
      const rect = slotElement?.getBoundingClientRect?.();
      if (rect && rect.width >= 1 && rect.height >= 1) {
        return this.#calculatePositionFromRect(rect);
      }
    }
    return this.#calculatePositionFromRect(element.getBoundingClientRect());
  }
  #calculatePositionFromRect(rect) {
    if (!rect) {
      return { x: 0, y: 0 };
    }
    const bounds = this.getSurfaceBounds();
    const surfaceRect = bounds?.surface;
    const minX = surfaceRect?.left ?? 0;
    const maxRight = surfaceRect?.right ?? (window.innerWidth || 1024);
    const minY = surfaceRect?.top ?? 0;
    const maxBottom = surfaceRect?.bottom ?? (window.innerHeight || 768);
    const margin = 8;
    const gap = 62;
    const { width: toolbarWidth, height: toolbarHeight } = this.#getToolbarDims();
    let x5 = rect.left + rect.width / 2 - toolbarWidth / 2;
    const nearBottom = rect.bottom >= maxBottom * 0.8;
    const yBelow = rect.bottom + gap;
    const yAbove = rect.top - toolbarHeight - gap;
    let y5 = nearBottom ? yAbove : yBelow;
    const maxX = Math.max(minX + margin, maxRight - toolbarWidth - margin);
    const maxY = Math.max(minY + margin, maxBottom - toolbarHeight - margin);
    if (y5 < minY + margin) {
      y5 = nearBottom ? yBelow : yAbove;
    }
    if (y5 > maxY) {
      y5 = nearBottom ? yAbove : yBelow;
    }
    x5 = Math.min(Math.max(minX + margin, x5), maxX);
    y5 = Math.min(Math.max(minY + margin, y5), maxY);
    return { x: x5, y: y5 };
  }
  #getToolbarDims() {
    const toolbarHost = this.editor.editorElement?.shadowRoot?.querySelector("ee-toolbar")?.shadowRoot?.getElementById("ee-toolbar");
    if (toolbarHost) {
      const rect = toolbarHost.getBoundingClientRect();
      return {
        width: Math.max(1, Math.round(rect.width || 520)),
        height: Math.max(1, Math.round(rect.height || 40))
      };
    }
    return { width: 520, height: 40 };
  }
  showEEToolbar(element, position) {
    this.eeToolbarElement = element;
    if (position) {
      this.setEEToolbarPosition(position.x, position.y);
    } else {
      this.updateEEToolbarPosition();
    }
    this.eeToolbarVisible = true;
    this.#lastAnchorElement = element || null;
    const tag3 = element && element.tagName ? element.tagName.toLowerCase() : null;
    const id = element && element.id ? element.id : null;
    this.editor.setLastAction("editor:toolbar:show", { tag: tag3, id });
  }
  hideEEToolbar() {
    this.eeToolbarVisible = false;
    this.eeToolbarElement = null;
    this.toolbarOverlayOpen = false;
    this.#lastAnchorElement = null;
    this.editor.setLastAction("editor:toolbar:hide");
  }
  setEEToolbarPosition(x5, y5) {
    console.log("[ToolbarStore] setEEToolbarPosition", {
      oldPosition: this.eeToolbarPosition,
      newPosition: { x: x5, y: y5 },
      positionFrozen: this.#positionFrozen
    });
    this.eeToolbarPosition = { x: x5, y: y5 };
    const toolbarElement = this.editor.editorElement?.shadowRoot?.querySelector("ee-toolbar")?.shadowRoot?.getElementById("ee-toolbar");
    if (toolbarElement) {
      const xRounded = Math.round(x5);
      const yRounded = Math.round(y5);
      toolbarElement.style.transform = `translate(${xRounded}px, ${yRounded}px)`;
    }
  }
  setToolbarOverlayOpen(open) {
    this.toolbarOverlayOpen = !!open;
  }
  setOpenTool(tool) {
    this.openTool = tool || null;
  }
  getToolbarDims() {
    return this.#getToolbarDims();
  }
  calculateToolbarPosition(element) {
    return this.calculateEEToolbarPosition(element);
  }
  updateToolbarPosition(options = {}) {
    if (this.#positionFrozen) {
      console.log("[ToolbarStore] updateToolbarPosition blocked - position frozen");
      return;
    }
    const editingElement = this.editor.editingElement;
    if (!editingElement) {
      console.log("[ToolbarStore] updateToolbarPosition - no editing element");
      this.#lastAnchorElement = null;
      return;
    }
    const force = options?.force === true;
    if (!force && editingElement === this.#lastAnchorElement) {
      console.log("[ToolbarStore] updateToolbarPosition - skipped (same anchor, not forced)");
      return;
    }
    console.log("[ToolbarStore] updateToolbarPosition - calculating new position", {
      force,
      editingElement: editingElement.tagName
    });
    const position = this.calculateEEToolbarPosition(editingElement);
    this.setEEToolbarPosition(position.x, position.y);
    this.#lastAnchorElement = editingElement;
  }
  checkAndAdjustOverflow() {
    if (this.#positionFrozen) {
      return;
    }
    const toolbarElement = this.editor.editorElement?.shadowRoot?.querySelector("ee-toolbar")?.shadowRoot?.getElementById("ee-toolbar");
    if (!toolbarElement) {
      return;
    }
    const toolbarRect = toolbarElement.getBoundingClientRect();
    const bounds = this.getSurfaceBounds();
    const surfaceRect = bounds?.surface;
    if (!surfaceRect) {
      return;
    }
    const margin = 8;
    let { x: x5, y: y5 } = this.eeToolbarPosition || { x: 0, y: 0 };
    let adjusted = false;
    if (toolbarRect.right > surfaceRect.right - margin) {
      x5 = surfaceRect.right - toolbarRect.width - margin;
      adjusted = true;
    }
    if (toolbarRect.left < surfaceRect.left + margin) {
      x5 = surfaceRect.left + margin;
      adjusted = true;
    }
    if (toolbarRect.bottom > surfaceRect.bottom - margin) {
      y5 = surfaceRect.bottom - toolbarRect.height - margin;
      adjusted = true;
    }
    if (toolbarRect.top < surfaceRect.top + margin) {
      y5 = surfaceRect.top + margin;
      adjusted = true;
    }
    if (adjusted) {
      this.setEEToolbarPosition(x5, y5);
    }
  }
  freezePositionDuring(fn2) {
    if (!fn2) {
      return;
    }
    if (this.#positionFrozen) {
      fn2();
      return;
    }
    this.#frozenPosition = this.eeToolbarPosition ? {
      x: this.eeToolbarPosition.x,
      y: this.eeToolbarPosition.y
    } : null;
    this.#positionFrozen = true;
    fn2();
    setTimeout(() => {
      if (this.#frozenPosition) {
        this.setEEToolbarPosition(
          this.#frozenPosition.x,
          this.#frozenPosition.y
        );
        this.#lastAnchorElement = this.editor.editingElement || this.#lastAnchorElement;
      }
      this.#positionFrozen = false;
      this.#frozenPosition = null;
    }, 0);
  }
  createDragHandlers(toolbarElement) {
    console.log("[DragHandlers] Creating drag handlers", {
      toolbarElement,
      hasToolbarElement: !!toolbarElement
    });
    if (!toolbarElement) {
      console.warn("[DragHandlers] No toolbar element provided");
      return null;
    }
    let dragMoved = false;
    const onDragMove = (event) => {
      if (!this.#dragging) {
        console.log("[DragHandlers] onDragMove called but not dragging");
        return;
      }
      dragMoved = true;
      const viewportW = window.innerWidth || 1024;
      const viewportH = window.innerHeight || 768;
      const dims = this.getToolbarDims();
      const margin = 4;
      let x5 = event.clientX - this.#dragOffsetX;
      let y5 = event.clientY - this.#dragOffsetY;
      x5 = Math.min(
        Math.max(margin, x5),
        Math.max(margin, viewportW - dims.width - margin)
      );
      y5 = Math.min(
        Math.max(margin, y5),
        Math.max(margin, viewportH - dims.height - margin)
      );
      console.log("[DragHandlers] onDragMove", {
        clientX: event.clientX,
        clientY: event.clientY,
        dragOffsetX: this.#dragOffsetX,
        dragOffsetY: this.#dragOffsetY,
        calculatedX: x5,
        calculatedY: y5,
        dims
      });
      this.setEEToolbarPosition(x5, y5);
      this.#lastAnchorElement = this.editor.editingElement || this.#lastAnchorElement;
    };
    const onDragEnd = () => {
      console.log("[DragHandlers] onDragEnd", {
        wasDragging: this.#dragging,
        dragMoved,
        positionFrozen: this.#positionFrozen
      });
      this.#dragging = false;
      this.#positionFrozen = false;
      dragMoved = false;
      document.removeEventListener("mousemove", onDragMove);
    };
    const onDragStart = (event) => {
      console.log("[DragHandlers] onDragStart called", {
        button: event.button,
        clientX: event.clientX,
        clientY: event.clientY
      });
      dragMoved = false;
      if (event.button !== 0) {
        console.warn("[DragHandlers] Not left click, ignoring", {
          button: event.button
        });
        return;
      }
      const shadowRoot = toolbarElement.shadowRoot;
      const toolbarInner = shadowRoot?.getElementById("ee-toolbar");
      console.log("[DragHandlers] Getting toolbar rect", {
        hasShadowRoot: !!shadowRoot,
        hasToolbarInner: !!toolbarInner
      });
      const toolbarRect = toolbarInner?.getBoundingClientRect();
      if (!toolbarRect) {
        console.error("[DragHandlers] Could not get toolbar rect", {
          toolbarElement,
          shadowRoot,
          toolbarInner
        });
        return;
      }
      console.log("[DragHandlers] Toolbar rect", {
        left: toolbarRect.left,
        top: toolbarRect.top,
        width: toolbarRect.width,
        height: toolbarRect.height
      });
      this.#dragging = true;
      this.#positionFrozen = true;
      this.#dragOffsetX = event.clientX - toolbarRect.left;
      this.#dragOffsetY = event.clientY - toolbarRect.top;
      console.log("[DragHandlers] Drag started", {
        dragOffsetX: this.#dragOffsetX,
        dragOffsetY: this.#dragOffsetY,
        positionFrozen: this.#positionFrozen
      });
      document.addEventListener("mousemove", onDragMove);
      document.addEventListener("mouseup", onDragEnd, { once: true });
      console.log("[DragHandlers] Event listeners attached");
    };
    return { onDragStart, onDragMove, onDragEnd };
  }
  initZoomPan() {
    const host = this.editor.editorElement;
    if (!host) {
      return;
    }
    const shadowRoot = host.shadowRoot;
    if (!shadowRoot) {
      return;
    }
    const container = shadowRoot.querySelector("#canvas-container");
    const surface = shadowRoot.querySelector("#surface-wrapper");
    const target = shadowRoot.querySelector("#surface-content");
    if (!container || !surface || !target) {
      return;
    }
    const existingController = host.getZoomController?.();
    if (existingController && host.zoomTargetElement === target) {
      return;
    }
    if (existingController) {
      existingController.destroy?.();
      host.setZoomController(null);
      host.zoomStore = null;
    }
    const zoomController = zoom_default({
      container,
      surface,
      target,
      shouldCapture: () => {
        return !this.editor.richText?.activeRte;
      }
    });
    host.setZoomController(zoomController);
    host.zoomStore = zoomController.store;
    host.zoomTargetElement = target;
    const existingCleanup = host.cleanupZoomReaction;
    existingCleanup?.();
    const reactionCleanup = reaction(
      zoomController.store,
      (state) => [state.x, state.y, state.z],
      () => {
        if (this.editor.isEEToolbarVisible) {
          this.updateToolbarPosition({ force: true });
        }
        host.requestUpdate();
      }
    );
    const cleanup = () => {
      reactionCleanup();
      if (host.cleanupZoomReaction === cleanup) {
        host.cleanupZoomReaction = null;
      }
    };
    host.cleanupZoomReaction = cleanup;
  }
  setupToolbarSync() {
    const host = this.editor.editorElement;
    if (!host || !this.editor) {
      return;
    }
    const existingCleanup = host.cleanupToolbarReaction;
    existingCleanup?.();
    const cleanupReaction = reaction(
      this.editor,
      (state) => [state.eeToolbarVisible, state.editingElement, state.currentSlot],
      () => {
        const visible = this.editor.isEEToolbarVisible;
        const currentEditing = this.editor.editingElement || null;
        const editingChanged = currentEditing !== this.#lastReactionEditingElement;
        this.#lastReactionEditingElement = currentEditing;
        if (!visible) {
          if (!currentEditing) {
            this.#lastAnchorElement = null;
          }
          return;
        }
        this.updateToolbarPosition({ force: editingChanged });
      }
    );
    const container = host.shadowRoot?.querySelector("#canvas-container");
    const onScroll = () => {
      if (this.editor.isEEToolbarVisible) {
        this.updateToolbarPosition({ force: true });
      }
    };
    if (container) {
      container.addEventListener("scroll", onScroll, { passive: true });
    }
    const cleanup = () => {
      cleanupReaction();
      if (container) {
        container.removeEventListener("scroll", onScroll);
      }
      if (host.cleanupToolbarReaction === cleanup) {
        host.cleanupToolbarReaction = null;
      }
    };
    host.cleanupToolbarReaction = cleanup;
  }
  getSurfaceBounds() {
    const host = this.editor.editorElement;
    if (!host) return null;
    const surface = host.shadowRoot?.querySelector("#surface-wrapper");
    const container = host.shadowRoot?.querySelector("#canvas-container");
    if (!surface || !container) return null;
    return {
      surface: surface.getBoundingClientRect(),
      container: container.getBoundingClientRect()
    };
  }
};
makeObservable(EditorToolbarStore);

// src/features/rte/commands.js
init_dist4();
init_dist5();

// src/features/rte/link-utils.js
var SAFE_PROTOCOLS = /* @__PURE__ */ new Set(["http", "https", "mailto", "tel", "ftp", "sms"]);
var DISALLOWED_SCHEME_PREFIXES = ["javascript:", "data:", "vbscript:"];
var ALLOWED_TARGETS = /* @__PURE__ */ new Set(["_blank", "_self", "_parent", "_top"]);
var sanitizeText = (value) => {
  if (value === null || value === void 0) return null;
  const text = String(value).trim();
  return text ? text : null;
};
var normalizeHref = (value) => {
  if (value === null || value === void 0) return "#";
  const trimmed = String(value).trim();
  if (!trimmed) return "#";
  const lower = trimmed.toLowerCase();
  if (DISALLOWED_SCHEME_PREFIXES.some((prefix) => lower.startsWith(prefix))) {
    return "#";
  }
  if (lower.startsWith("#") || lower.startsWith("/") || lower.startsWith("./") || lower.startsWith("../") || lower.startsWith("//")) {
    return trimmed;
  }
  const colonIndex = trimmed.indexOf(":");
  const slashIndex = trimmed.indexOf("/");
  if (colonIndex > -1 && (slashIndex === -1 || colonIndex < slashIndex)) {
    const scheme = lower.slice(0, colonIndex);
    if (SAFE_PROTOCOLS.has(scheme)) {
      return trimmed;
    }
    return "#";
  }
  return trimmed;
};
var normalizeTarget = (value) => {
  const text = sanitizeText(value);
  if (!text) return null;
  const lower = text.toLowerCase();
  return ALLOWED_TARGETS.has(lower) ? lower : null;
};
var normalizeRel = (value, target) => {
  const relText = sanitizeText(value);
  const tokens = /* @__PURE__ */ new Set();
  if (relText) {
    relText.split(/\s+/).filter(Boolean).forEach((token) => tokens.add(token));
  }
  if (target === "_blank") {
    tokens.add("noopener");
    tokens.add("noreferrer");
  }
  if (tokens.size === 0) {
    return null;
  }
  return Array.from(tokens).join(" ");
};
var normalizeDownloadAttr = (value) => {
  if (value === null || value === void 0 || value === false) return null;
  if (value === true) return "";
  const text = String(value).trim();
  return text;
};
var sanitizeLinkAttrs = (attrs = {}) => {
  const href = normalizeHref(attrs.href);
  const title = sanitizeText(attrs.title);
  const target = normalizeTarget(attrs.target);
  const rel = normalizeRel(attrs.rel, target);
  const ariaLabel = sanitizeText(attrs["aria-label"]);
  const download = normalizeDownloadAttr(attrs.download);
  return {
    href,
    title,
    target,
    rel,
    "aria-label": ariaLabel,
    download
  };
};

// src/features/rte/commands.js
var MARK_TO_FORMAT = {
  strong: "bold",
  em: "italic",
  underline: "underline",
  strikethrough: "strikethrough"
};
var WHITESPACE = /\s/;
var isWhitespace = (char) => WHITESPACE.test(char);
var forwardInText = (text, start) => {
  const length = text.length;
  if (start >= length) return length;
  let pos = start;
  if (isWhitespace(text.charAt(pos))) {
    while (pos < length && isWhitespace(text.charAt(pos))) pos += 1;
    if (pos < length) {
      while (pos < length && !isWhitespace(text.charAt(pos))) pos += 1;
      while (pos < length && isWhitespace(text.charAt(pos))) pos += 1;
    }
    return pos;
  }
  while (pos < length && !isWhitespace(text.charAt(pos))) pos += 1;
  while (pos < length && isWhitespace(text.charAt(pos))) pos += 1;
  return pos;
};
var backwardInText = (text, end) => {
  if (end <= 0) return 0;
  let pos = end;
  if (isWhitespace(text.charAt(pos - 1))) {
    while (pos > 0 && isWhitespace(text.charAt(pos - 1))) pos -= 1;
    if (pos > 0) {
      while (pos > 0 && !isWhitespace(text.charAt(pos - 1))) pos -= 1;
    }
    return pos;
  }
  while (pos > 0 && !isWhitespace(text.charAt(pos - 1))) pos -= 1;
  while (pos > 0 && isWhitespace(text.charAt(pos - 1))) pos -= 1;
  return pos;
};
var moveToWordBoundary = (doc3, position, direction) => {
  const size3 = doc3.content.size;
  if (direction > 0) {
    let current2 = position;
    while (current2 < size3) {
      const $pos = doc3.resolve(current2);
      const parent = $pos.parent;
      const parentOffset = $pos.parentOffset;
      const base2 = current2 - parentOffset;
      if (!parent.isTextblock) {
        const next2 = current2 + 1;
        return next2 > size3 ? size3 : next2;
      }
      const { node, offset: offset4 } = parent.childAfter(parentOffset);
      if (!node) {
        const parentEnd = base2 + parent.content.size;
        return parentEnd > size3 ? size3 : parentEnd;
      }
      if (node.isText) {
        const text = node.text || "";
        const startInNode = parentOffset - offset4;
        let offsetInNode = forwardInText(text, startInNode);
        let next2 = base2 + offset4 + offsetInNode;
        if (next2 === current2) {
          next2 = base2 + offset4 + node.nodeSize;
        }
        if (next2 === current2) {
          break;
        }
        return next2 > size3 ? size3 : next2;
      }
      const next = base2 + offset4 + node.nodeSize;
      if (next === current2) {
        break;
      }
      return next > size3 ? size3 : next;
    }
    return size3;
  }
  let current = position;
  while (current > 0) {
    const $pos = doc3.resolve(current);
    const parent = $pos.parent;
    const parentOffset = $pos.parentOffset;
    const base2 = current - parentOffset;
    if (!parent.isTextblock) {
      const prev2 = current - 1;
      return prev2 < 0 ? 0 : prev2;
    }
    const { node, offset: offset4 } = parent.childBefore(parentOffset);
    if (!node) {
      const parentStart = base2;
      return parentStart < 0 ? 0 : parentStart;
    }
    if (node.isText) {
      const text = node.text || "";
      const endInNode = parentOffset - offset4;
      let offsetInNode = backwardInText(text, endInNode);
      let prev2 = base2 + offset4 + offsetInNode;
      if (prev2 === current) {
        prev2 = base2 + offset4;
      }
      if (prev2 === current) {
        break;
      }
      return prev2 < 0 ? 0 : prev2;
    }
    const prev = base2 + offset4;
    if (prev === current) {
      break;
    }
    return prev < 0 ? 0 : prev;
  }
  return 0;
};
var FORMAT_TO_MARK = Object.entries(MARK_TO_FORMAT).reduce((acc, [mark, format]) => {
  acc[format] = mark;
  return acc;
}, {});
var ALIGN_KEYS = [
  "align-left",
  "align-center",
  "align-right",
  "align-justify"
];
var checkIsInList = (schema2, $from, $to) => {
  const bulletType = schema2.nodes.bullet_list;
  const orderedType = schema2.nodes.ordered_list;
  const checkPos = ($pos) => {
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node = $pos.node(depth);
      if (node.type === bulletType || node.type === orderedType) return true;
    }
    return false;
  };
  return checkPos($from) || checkPos($to);
};
var deriveSelectionDetail = (view) => {
  if (!view) return null;
  const { state } = view;
  const { selection } = state;
  const anchor = selection?.anchor ?? 0;
  const head = selection?.head ?? anchor;
  const from2 = selection?.from ?? anchor;
  const to2 = selection?.to ?? head;
  const markAttrs = /* @__PURE__ */ new Map();
  let activeMarks = [];
  if (selection?.empty) {
    const storedMarks = state.storedMarks || selection.$from?.marks?.() || [];
    storedMarks.forEach((mark) => {
      markAttrs.set(mark.type.name, mark.attrs);
    });
    activeMarks = storedMarks.map((mark) => mark.type.name);
  } else {
    let intersection = null;
    let textNodesEncountered = 0;
    state.doc.nodesBetween(from2, to2, (node) => {
      if (!node.isText) return true;
      const textLength = node.text?.length ?? 0;
      if (textLength === 0) return true;
      textNodesEncountered += 1;
      const nodeMarks = node.marks.map((mark) => {
        if (!markAttrs.has(mark.type.name)) {
          markAttrs.set(mark.type.name, mark.attrs);
        }
        return mark.type.name;
      });
      if (intersection === null) {
        intersection = new Set(nodeMarks);
      } else {
        for (const markName of Array.from(intersection)) {
          if (!nodeMarks.includes(markName)) {
            intersection.delete(markName);
          }
        }
      }
      return true;
    });
    if (textNodesEncountered > 0 && intersection) {
      activeMarks = Array.from(intersection);
    }
  }
  const activeLink = activeMarks.includes("link") ? { ...markAttrs.get("link") || {} } : null;
  const parent = selection?.$from?.parent || null;
  const block = parent?.isTextblock ? {
    type: parent.type.name,
    attrs: { ...parent.attrs }
  } : null;
  let reference = null;
  state.doc.nodesBetween(from2, Math.max(from2, to2 || from2), (node) => {
    if (node.type?.name === "ee_reference") {
      reference = { ...node.attrs };
      return false;
    }
    return true;
  });
  if (!reference && selection?.empty) {
    const after = selection.$from?.nodeAfter;
    if (after?.type?.name === "ee_reference") {
      reference = { ...after.attrs };
    }
    const before = selection.$from?.nodeBefore;
    if (!reference && before?.type?.name === "ee_reference") {
      reference = { ...before.attrs };
    }
  }
  return {
    anchor,
    head,
    empty: selection?.empty ?? true,
    marks: activeMarks,
    block,
    link: activeLink,
    reference
  };
};
var formatStatesFromSelection = (schema2, selectionDetail) => {
  if (!schema2) return {};
  const formats = {};
  Object.entries(MARK_TO_FORMAT).forEach(([markName, formatName]) => {
    const hasMark = !!schema2.marks[markName];
    if (!hasMark) return;
    const active = selectionDetail?.marks?.includes(markName) ?? false;
    formats[formatName] = {
      enabled: true,
      active
    };
  });
  return formats;
};
var linkStateFromSelection = (schema2, selectionDetail) => {
  const hasLink = !!schema2?.marks?.link;
  const removeEnabled = hasLink && !selectionDetail?.reference;
  return {
    enabled: hasLink,
    active: hasLink && !!selectionDetail?.link,
    ...selectionDetail?.link ? { attrs: { ...selectionDetail.link } } : {},
    removeEnabled
  };
};
var blockStatesFromSelection = (selectionDetail, schemaConfig, isInList) => {
  const align = selectionDetail?.block?.attrs?.align || "left";
  const mode = schemaConfig?.mode || "rich";
  const alignmentEnabled = mode === "rich" && !isInList;
  const blocks = {};
  ALIGN_KEYS.forEach((key) => {
    const target = key.replace("align-", "");
    blocks[key] = {
      enabled: alignmentEnabled,
      active: alignmentEnabled && align === target
    };
  });
  return blocks;
};
var historyStates = (pm, view) => {
  if (!pm || !view) {
    return {
      undo: { enabled: false },
      redo: { enabled: false }
    };
  }
  const undoEnabled = pm.undoDepth(view.state) > 0;
  const redoEnabled = pm.redoDepth(view.state) > 0;
  return {
    undo: { enabled: undoEnabled },
    redo: { enabled: redoEnabled }
  };
};
var listStates = (schema2, view, selectionDetail) => {
  const hasBullet = !!schema2?.nodes?.bullet_list;
  const hasOrdered = !!schema2?.nodes?.ordered_list;
  if (!view) {
    return {
      "unordered-list": { enabled: hasBullet, active: false },
      "ordered-list": { enabled: hasOrdered, active: false }
    };
  }
  const { selection } = view.state;
  const { $from, $to } = selection;
  const isInList = (type) => {
    const nodeType = schema2.nodes[type];
    if (!nodeType) return false;
    const checkPos = ($pos) => {
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === nodeType) return true;
      }
      return false;
    };
    return checkPos($from) || checkPos($to);
  };
  const align = selectionDetail?.block?.attrs?.align || "left";
  const hasNonDefaultAlignment = align !== "left";
  const listsEnabled = !hasNonDefaultAlignment;
  return {
    "unordered-list": {
      enabled: hasBullet && listsEnabled,
      active: hasBullet && isInList("bullet_list")
    },
    "ordered-list": {
      enabled: hasOrdered && listsEnabled,
      active: hasOrdered && isInList("ordered_list")
    }
  };
};
var getCommandState = ({ view, pm, schemaConfig = {}, selectionDetail }) => {
  if (!view) return null;
  const detail = selectionDetail || deriveSelectionDetail(view);
  const schema2 = view.state.schema;
  const { selection } = view.state;
  const { $from, $to } = selection;
  const isInList = checkIsInList(schema2, $from, $to);
  const formats = formatStatesFromSelection(schema2, detail);
  const link = linkStateFromSelection(schema2, detail);
  const blocks = blockStatesFromSelection(detail, schemaConfig, isInList);
  const history3 = historyStates(pm, view);
  const lists = listStates(schema2, view, detail);
  return {
    formats,
    blocks,
    link,
    undo: history3.undo,
    redo: history3.redo,
    lists
  };
};
var toggleMarkCommand = (pm, view, markName) => {
  if (!markName || !view || !pm) return false;
  const { schema: schema2 } = view.state;
  const markType = schema2.marks[markName];
  if (!markType || typeof pm.toggleMark !== "function") return false;
  const command = pm.toggleMark(markType);
  return command(view.state, view.dispatch.bind(view), view) || false;
};
var setAlignmentCommand = (view, align) => {
  if (!view) return false;
  const { state } = view;
  const { schema: schema2, selection } = state;
  if (!schema2 || !selection) return false;
  const { $from, $to } = selection;
  const isInList = checkIsInList(schema2, $from, $to);
  if (isInList) return false;
  const alignValue = align === "center" || align === "right" ? align : align === "justify" ? "justify" : "left";
  const defaultAlign = "left";
  const fromPos = selection.empty ? selection.$from.start(selection.$from.depth) : selection.from;
  const toPos = selection.empty ? selection.$from.end(selection.$from.depth) : selection.to;
  let tr2 = state.tr;
  let updated = false;
  const usedAligns = /* @__PURE__ */ new Set();
  state.doc.nodesBetween(fromPos, toPos, (node, pos) => {
    if (!node.isTextblock) return true;
    const current = node.attrs?.align || defaultAlign;
    usedAligns.add(current);
    if (current === alignValue) {
      return true;
    }
    const nextAttrs = { ...node.attrs || {} };
    if (alignValue === defaultAlign) {
      delete nextAttrs.align;
    } else {
      nextAttrs.align = alignValue;
    }
    tr2 = tr2.setNodeMarkup(pos, node.type, nextAttrs, node.marks);
    updated = true;
    return true;
  });
  if (!updated) {
    if (usedAligns.size === 1 && usedAligns.has(alignValue)) {
      return true;
    }
    return false;
  }
  view.dispatch(tr2);
  return true;
};
var setBlockTypeCommand = (pm, view, type) => {
  if (!type || !pm || !view) return false;
  const { state } = view;
  const { schema: schema2 } = state;
  const command = pm.commands?.setBlockType && schema2.nodes[type] ? pm.commands.setBlockType(schema2.nodes[type]) : null;
  if (!command) return false;
  return command(state, view.dispatch.bind(view), view) || false;
};
var findLinkRange = (state, linkMark) => {
  if (!state || !linkMark) return null;
  const { selection, doc: doc3 } = state;
  if (!selection) return null;
  let { from: from2, to: to2 } = selection;
  const expandBackward = (pos) => {
    let current = pos;
    while (current > 0 && doc3.rangeHasMark(current - 1, current, linkMark)) {
      current -= 1;
    }
    return current;
  };
  const expandForward = (pos) => {
    let current = pos;
    const size3 = doc3.content.size;
    while (current < size3 && doc3.rangeHasMark(current, current + 1, linkMark)) {
      current += 1;
    }
    return current;
  };
  if (selection.empty) {
    const pos = selection.from;
    const hasMarkBefore = pos > 0 && doc3.rangeHasMark(pos - 1, pos, linkMark);
    const hasMarkAfter = doc3.rangeHasMark(pos, pos + 1, linkMark);
    if (!hasMarkBefore && !hasMarkAfter) {
      return null;
    }
    from2 = hasMarkBefore ? expandBackward(pos) : pos;
    to2 = hasMarkAfter ? expandForward(pos) : pos;
    if (from2 === to2) {
      to2 = expandForward(pos + 1);
    }
    return { from: from2, to: to2 };
  }
  const start = expandBackward(from2);
  const end = expandForward(to2);
  return { from: start, to: end };
};
var setLinkCommand = (pm, view, attrs = {}) => {
  if (!pm || !view) return false;
  const { schema: schema2 } = view.state;
  const linkMark = schema2.marks.link;
  if (!linkMark) return false;
  const tag3 = attrs && typeof attrs.tag === "string" && attrs.tag.toLowerCase() === "sp-link" ? "sp-link" : "a";
  const normalized = sanitizeLinkAttrs(attrs);
  normalized.tag = tag3;
  const { state } = view;
  let tr2 = state.tr;
  const range = findLinkRange(state, linkMark);
  if (range && range.from < range.to) {
    tr2 = tr2.removeMark(range.from, range.to, linkMark);
    tr2 = tr2.addMark(range.from, range.to, linkMark.create(normalized));
    view.dispatch(tr2);
    return true;
  }
  tr2 = tr2.addStoredMark(linkMark.create(normalized));
  view.dispatch(tr2);
  return true;
};
var removeLinkCommand = (pm, view) => {
  if (!pm || !view) return false;
  const selectionDetail = deriveSelectionDetail(view);
  if (selectionDetail?.reference) return false;
  const { schema: schema2 } = view.state;
  const linkMark = schema2.marks.link;
  if (!linkMark) return false;
  const { state } = view;
  const range = findLinkRange(state, linkMark);
  if (!range || range.from === range.to) {
    return false;
  }
  const tr2 = state.tr.removeMark(range.from, range.to, linkMark);
  view.dispatch(tr2);
  return true;
};
var findReferencePos = (state, referenceType) => {
  if (!state || !referenceType) return null;
  const { selection, doc: doc3 } = state;
  if (!selection || !doc3) return null;
  let found2 = null;
  doc3.nodesBetween(selection.from, selection.to, (node, pos) => {
    if (node.type === referenceType) {
      found2 = pos;
      return false;
    }
    return true;
  });
  if (found2 !== null) {
    return found2;
  }
  const $from = selection.$from;
  if (!$from) return null;
  const before = $from.nodeBefore;
  if (before && before.type === referenceType) {
    return $from.pos - before.nodeSize;
  }
  const after = $from.nodeAfter;
  if (after && after.type === referenceType) {
    return $from.pos;
  }
  return null;
};
var updateReferenceCommand = (pm, view, attrs = {}) => {
  if (!pm || !view) return false;
  const { state } = view;
  if (!state) return false;
  const referenceType = state.schema.nodes.ee_reference;
  if (!referenceType) return false;
  const pos = findReferencePos(state, referenceType);
  if (pos === null || pos === void 0) {
    return false;
  }
  const node = state.doc.nodeAt(pos);
  if (!node || node.type !== referenceType) {
    return false;
  }
  const nextAttrs = { ...node.attrs, ...attrs };
  const tr2 = state.tr.setNodeMarkup(pos, referenceType, nextAttrs, node.marks);
  view.dispatch(tr2);
  return true;
};
var toggleListCommand = (pm, view, listType) => {
  if (!pm || !view) return false;
  const dispatch = view.dispatch.bind(view);
  const resetAlignmentForSelection = () => {
    const { state } = view;
    const { selection, doc: doc3 } = state;
    if (!selection || !doc3) return;
    const maxPos = doc3.content.size;
    const from2 = Math.max(0, selection.from);
    const to2 = Math.min(maxPos, selection.to + (selection.empty ? 1 : 0));
    let tr2 = state.tr;
    let updated = false;
    doc3.nodesBetween(from2, to2, (node, pos) => {
      if (!node.isTextblock) return true;
      if (!Object.prototype.hasOwnProperty.call(node.attrs || {}, "align")) {
        return true;
      }
      const defaultAlign = node.type.spec?.attrs?.align?.default ?? "left";
      const currentAlign = node.attrs.align ?? defaultAlign;
      if (currentAlign === defaultAlign) {
        return true;
      }
      const nextAttrs = { ...node.attrs };
      if (defaultAlign === void 0) {
        delete nextAttrs.align;
      } else {
        nextAttrs.align = defaultAlign;
      }
      tr2 = tr2.setNodeMarkup(pos, node.type, nextAttrs, node.marks);
      updated = true;
      return true;
    });
    if (updated) {
      dispatch(tr2);
    }
  };
  resetAlignmentForSelection();
  const { schema: schema2 } = view.state;
  const listItemType = schema2.nodes.list_item;
  if (!listItemType) return false;
  const targetType = listType === "bullet" ? schema2.nodes.bullet_list : schema2.nodes.ordered_list;
  if (!targetType) return false;
  const otherType = listType === "bullet" ? schema2.nodes.ordered_list : schema2.nodes.bullet_list;
  const isInList = (type) => {
    if (!type) return false;
    const { $from, $to } = view.state.selection;
    const checkPos = ($pos) => {
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === type) return true;
      }
      return false;
    };
    return checkPos($from) || checkPos($to);
  };
  if (isInList(targetType)) {
    return liftListItem(listItemType)(view.state, dispatch, view) || false;
  }
  if (isInList(otherType)) {
    const lifted = liftListItem(listItemType)(view.state, dispatch, view);
    if (!lifted) {
      return false;
    }
    return wrapInList(targetType)(view.state, dispatch, view) || false;
  }
  return wrapInList(targetType)(view.state, dispatch, view) || false;
};
var extendSelection = (state, dispatch, direction) => {
  const { selection, doc: doc3 } = state;
  if (!selection) return false;
  const head = selection.head;
  const target = moveToWordBoundary(doc3, head, direction);
  if (target === head) {
    return false;
  }
  const nextSelection = TextSelection.create(doc3, selection.anchor, target);
  const tr2 = state.tr.setSelection(nextSelection);
  if (dispatch) {
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var extendSelectionWordCommand = (direction) => (state, dispatch) => extendSelection(state, dispatch, direction);
var undoCommand = (pm, view) => {
  if (!pm || !view || typeof pm.undo !== "function") return false;
  return pm.undo(view.state, view.dispatch.bind(view), view) || false;
};
var redoCommand = (pm, view) => {
  if (!pm || !view || typeof pm.redo !== "function") return false;
  return pm.redo(view.state, view.dispatch.bind(view), view) || false;
};

// src/features/rte/ee-rte.js
init_lit();

// src/constants.js
var TREE_DEBUG = false;
var EDITOR_DEBUG = false;
var TOOLBAR_DEBUG = true;

// src/features/rte/schema/factory.js
init_dist2();
init_dist6();
init_dist5();

// src/features/rte/reference-utils.js
var DOM_AVAILABLE = typeof window !== "undefined" && !!window.document;
var booleanFrom = (value) => {
  if (value === true || value === false) {
    return value;
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (normalized === "true" || normalized === "") {
      return true;
    }
    if (normalized === "false") {
      return false;
    }
  }
  return Boolean(value);
};
var sanitizeInlineArtifactsMarkup = (markup = "", options = {}) => {
  if (!DOM_AVAILABLE) {
    return String(markup ?? "");
  }
  const input = typeof markup === "string" ? markup : String(markup ?? "");
  if (!input) return "";
  const template = document.createElement("template");
  template.innerHTML = input;
  template.content.querySelectorAll?.("ee-rte").forEach((rte) => {
    const placeholder = typeof rte.getAttribute === "function" ? rte.getAttribute("placeholder") || "" : "";
    const fallback = (rte.textContent || "").trim();
    const text = (placeholder || fallback || "").trim();
    if (text) {
      rte.replaceWith(document.createTextNode(text));
    } else {
      rte.remove();
    }
  });
  const pmHelpers = template.content.querySelectorAll?.(".ProseMirror-trailingBreak, .ProseMirror-separator") || [];
  Array.from(pmHelpers).forEach((node) => node.remove());
  const stripSlot = options.stripSlot === true;
  template.content.querySelectorAll?.("*").forEach((node) => {
    if (!node || !node.hasAttribute) return;
    const attrs = Array.from(node.attributes || []);
    for (const attr of attrs) {
      const name = attr.name?.toLowerCase?.() || "";
      if (!name) continue;
      if (name === "contenteditable") {
        node.removeAttribute(attr.name);
        continue;
      }
      if (name === "tabindex") {
        node.removeAttribute(attr.name);
        continue;
      }
      if (name.startsWith("data-ee-")) {
        node.removeAttribute(attr.name);
        continue;
      }
      if (stripSlot && name === "slot") {
        node.removeAttribute(attr.name);
        continue;
      }
    }
  });
  return template.innerHTML;
};
var sanitizeReferenceAttributes = (attrs = {}) => {
  const { urn: rawUrn, inline: rawInline, modal: rawModal, trigger: rawTrigger, ...rest } = attrs;
  const urn = typeof rawUrn === "string" ? rawUrn : String(rawUrn ?? "");
  const inline2 = booleanFrom(rawInline);
  const modal = booleanFrom(rawModal);
  const triggerMarkup = typeof rawTrigger === "string" ? rawTrigger : rawTrigger?.outerHTML ? rawTrigger.outerHTML : "";
  if (!DOM_AVAILABLE) {
    return { ...rest, urn, inline: inline2, modal, trigger: triggerMarkup };
  }
  let trigger = triggerMarkup;
  if (trigger && typeof trigger === "string") {
    const template = document.createElement("template");
    template.innerHTML = sanitizeInlineArtifactsMarkup(trigger);
    template.content.querySelectorAll?.("[contenteditable]").forEach((node) => {
      node.removeAttribute("contenteditable");
    });
    template.content.querySelectorAll?.("[tabindex]").forEach((node) => {
      if (node.getAttribute("tabindex") === "-1") return;
      node.removeAttribute("tabindex");
    });
    template.content.querySelectorAll?.("*").forEach((node) => {
      if (!node || !node.hasAttribute) return;
      const attributes = Array.from(node.attributes);
      for (const attr of attributes) {
        const name = attr.name?.toLowerCase?.() || "";
        if (!name) continue;
        if (name.startsWith("data-") && name !== "data-slot") {
          node.removeAttribute(attr.name);
        }
      }
    });
    template.content.querySelectorAll?.("a").forEach((anchor) => {
      if (!anchor || !anchor.setAttribute) return;
      anchor.setAttribute("href", "#");
      anchor.removeAttribute("contenteditable");
    });
    trigger = template.innerHTML;
  }
  return {
    ...rest,
    urn,
    inline: inline2,
    modal,
    trigger
  };
};
var referenceAttrsEqual = (left = {}, right = {}) => {
  const keys2 = /* @__PURE__ */ new Set([...Object.keys(left), ...Object.keys(right)]);
  for (const key of keys2) {
    if (key === "trigger") {
      if ((left[key] || "") !== (right[key] || "")) return false;
      continue;
    }
    if (key === "inline" || key === "modal" || key === "full-width" || key === "stretch") {
      if (booleanFrom(left[key]) !== booleanFrom(right[key])) return false;
      continue;
    }
    if (left[key] !== right[key]) return false;
  }
  return true;
};
var sanitizeReferenceFragment = (pm, fragment) => {
  if (!pm || !fragment) {
    return { fragment, changed: false };
  }
  let changed = false;
  const nodes2 = [];
  fragment.forEach((child) => {
    if (child.type?.name === "ee_reference") {
      const sanitized = sanitizeReferenceAttributes(child.attrs);
      if (!referenceAttrsEqual(child.attrs, sanitized)) {
        nodes2.push(child.type.create(sanitized, null, child.marks));
        changed = true;
      } else {
        nodes2.push(child);
      }
      return;
    }
    if (child.type?.name === "ee_inline_content_inline") {
      const html = typeof child.attrs?.html === "string" ? child.attrs.html : String(child.attrs?.html ?? "");
      const sanitizedHtml = sanitizeInlineArtifactsMarkup(html, { stripSlot: true });
      if (sanitizedHtml !== html) {
        nodes2.push(
          child.type.create(
            {
              ...child.attrs || {},
              html: sanitizedHtml
            },
            null,
            child.marks
          )
        );
        changed = true;
      } else {
        nodes2.push(child);
      }
      return;
    }
    if (child.content && child.content.size) {
      const inner = sanitizeReferenceFragment(pm, child.content);
      if (inner.changed) {
        nodes2.push(child.copy(inner.fragment));
        changed = true;
      } else {
        nodes2.push(child);
      }
      return;
    }
    nodes2.push(child);
  });
  if (!changed) {
    return { fragment, changed: false };
  }
  const FragmentClass = pm.Fragment || fragment.constructor;
  const nextFragment = FragmentClass.from(nodes2);
  return { fragment: nextFragment, changed: true };
};
var sanitizeReferenceSlice = (pm, slice2) => {
  if (!pm || !slice2) {
    return { slice: slice2, changed: false };
  }
  const { fragment, changed } = sanitizeReferenceFragment(pm, slice2.content);
  if (!changed) {
    return { slice: slice2, changed: false };
  }
  const SliceClass = pm.Slice || slice2.constructor;
  const nextSlice = new SliceClass(fragment, slice2.openStart, slice2.openEnd);
  return { slice: nextSlice, changed: true };
};
var fragmentToArray = (fragment) => {
  const nodes2 = [];
  fragment?.forEach?.((child) => nodes2.push(child));
  return nodes2;
};
var isTrimmableEmptyParagraph = (node) => {
  if (!node || node.type?.name !== "paragraph") return false;
  if (!node.content || node.content.size === 0) return true;
  let onlyBreaksOrWhitespace = true;
  node.content.forEach((child) => {
    if (!onlyBreaksOrWhitespace) return;
    if (child.type?.name === "hard_break") return;
    if (child.isText) {
      if ((child.text || "").trim() === "") return;
    }
    onlyBreaksOrWhitespace = false;
  });
  return onlyBreaksOrWhitespace;
};
var isInlineAtomNode = (node) => {
  if (!node) return false;
  const t34 = node.type?.name || "";
  return t34 === "ee_inline_content_inline" || t34 === "ee_reference";
};
var canUnwrapSingleInlineParagraph = (paragraph) => {
  if (!paragraph || paragraph.type?.name !== "paragraph") return false;
  const children = fragmentToArray(paragraph.content);
  if (children.length !== 1) return false;
  const only = children[0];
  return isInlineAtomNode(only);
};
var normalizePastedSlice = (pm, slice2) => {
  if (!pm || !slice2) return slice2;
  const FragmentClass = pm.Fragment || slice2.content?.constructor;
  const SliceClass = pm.Slice || slice2.constructor;
  if (!FragmentClass || !SliceClass) return slice2;
  const nodes2 = fragmentToArray(slice2.content);
  if (!nodes2.length) return slice2;
  let start = 0;
  let end = nodes2.length;
  while (start < end && isTrimmableEmptyParagraph(nodes2[start])) start += 1;
  while (end > start && isTrimmableEmptyParagraph(nodes2[end - 1])) end -= 1;
  const trimmed = start !== 0 || end !== nodes2.length;
  const kept = trimmed ? nodes2.slice(start, end) : nodes2;
  if (!kept.length) {
    return new SliceClass(FragmentClass.from([]), slice2.openStart, slice2.openEnd);
  }
  if (kept.length === 1 && canUnwrapSingleInlineParagraph(kept[0])) {
    return new SliceClass(kept[0].content, 1, 1);
  }
  if (!trimmed) return slice2;
  return new SliceClass(FragmentClass.from(kept), slice2.openStart, slice2.openEnd);
};

// src/features/rte/schema/factory.js
var normalizeMode = (value) => {
  if (typeof value !== "string") {
    return "rich";
  }
  const normalized = value.trim().toLowerCase();
  if (normalized === "plain") {
    return "plain";
  }
  return "rich";
};
var LINK_EXTRA_ATTRS = {
  target: { default: null },
  rel: { default: null },
  "aria-label": { default: null },
  download: { default: null },
  tag: { default: "a" }
};
var createLinkMarkSpec = (baseSpec) => {
  if (!baseSpec) return baseSpec;
  const baseAttrs = baseSpec.attrs || {};
  const attrs = { ...baseAttrs, ...LINK_EXTRA_ATTRS };
  const readAttrsFromDom = (dom, base2 = {}) => {
    const fromDom = {
      ...base2,
      href: base2.href !== void 0 ? base2.href : dom.getAttribute?.("href") || "",
      title: base2.title !== void 0 ? base2.title : dom.getAttribute?.("title") || null,
      target: dom.getAttribute?.("target"),
      rel: dom.getAttribute?.("rel"),
      "aria-label": dom.getAttribute?.("aria-label"),
      download: dom.hasAttribute?.("download") ? dom.getAttribute("download") ?? "" : null
    };
    const sanitized = sanitizeLinkAttrs(fromDom);
    const tagName = dom.tagName?.toLowerCase?.() || "";
    sanitized.tag = tagName === "sp-link" ? "sp-link" : "a";
    return sanitized;
  };
  const parseDOM = (baseSpec.parseDOM || []).map((rule) => {
    const originalGetAttrs = rule.getAttrs;
    return {
      ...rule,
      getAttrs(dom) {
        const base2 = originalGetAttrs ? originalGetAttrs(dom) : {};
        if (base2 === false) return false;
        return readAttrsFromDom(dom, base2 || {});
      }
    };
  });
  parseDOM.push({
    tag: "sp-link",
    getAttrs(dom) {
      return readAttrsFromDom(dom);
    }
  });
  const toDOM = (node) => {
    const result = baseSpec.toDOM ? baseSpec.toDOM(node) : ["a", {}, 0];
    if (!Array.isArray(result)) {
      return result;
    }
    const [, attrsObj, ...rest] = result;
    const nextAttrs = { ...attrsObj || {} };
    const sanitized = sanitizeLinkAttrs(node.attrs || {});
    const tag3 = node.attrs?.tag === "sp-link" ? "sp-link" : "a";
    sanitized.tag = tag3;
    nextAttrs.href = sanitized.href;
    if (sanitized.title) {
      nextAttrs.title = sanitized.title;
    } else {
      delete nextAttrs.title;
    }
    if (sanitized.target) {
      nextAttrs.target = sanitized.target;
    } else {
      delete nextAttrs.target;
    }
    if (sanitized.rel) {
      nextAttrs.rel = sanitized.rel;
    } else {
      delete nextAttrs.rel;
    }
    if (sanitized["aria-label"]) {
      nextAttrs["aria-label"] = sanitized["aria-label"];
    } else {
      delete nextAttrs["aria-label"];
    }
    if (sanitized.download !== null && sanitized.download !== void 0) {
      const downloadValue = normalizeDownloadAttr(sanitized.download);
      if (downloadValue === null) {
        delete nextAttrs.download;
      } else {
        nextAttrs.download = downloadValue;
      }
    } else {
      delete nextAttrs.download;
    }
    return [tag3, nextAttrs, ...rest];
  };
  return {
    ...baseSpec,
    attrs,
    parseDOM,
    toDOM
  };
};
var ALIGN_VALUES = /* @__PURE__ */ new Set(["left", "center", "right", "justify"]);
var normalizeAlign = (value) => {
  if (!value && value !== 0) return "left";
  const normalized = String(value).trim().toLowerCase();
  return ALIGN_VALUES.has(normalized) ? normalized : "left";
};
var extractAlignFromStyle = (style) => {
  if (typeof style !== "string") return null;
  const match = style.match(/text-align\s*:\s*(left|center|right)/i);
  if (!match) return null;
  return normalizeAlign(match[1]);
};
var readAlignment = (dom) => {
  if (!dom) return "left";
  const explicit = dom.getAttribute?.("data-align") || dom.getAttribute?.("align");
  if (explicit) {
    return normalizeAlign(explicit);
  }
  const styleAlign = extractAlignFromStyle(dom.getAttribute?.("style"));
  if (styleAlign) {
    return styleAlign;
  }
  const inlineStyle = dom.style?.textAlign;
  if (inlineStyle) {
    return normalizeAlign(inlineStyle);
  }
  return "left";
};
var plainParagraphSpec = {
  group: "block",
  content: "text*",
  attrs: {
    align: { default: "left" }
  },
  parseDOM: [
    {
      tag: "p",
      getAttrs: (dom) => ({ align: readAlignment(dom) })
    },
    {
      tag: "div",
      getAttrs: (dom) => ({ align: readAlignment(dom) })
    }
  ],
  toDOM(node) {
    const align = normalizeAlign(node.attrs.align);
    const attrs = {};
    if (align !== "left") {
      attrs.style = `text-align: ${align};`;
    }
    return ["p", attrs, 0];
  }
};
var underlineMarkSpec = {
  inclusive: true,
  parseDOM: [
    { tag: "u" },
    { tag: "ins" },
    {
      style: "text-decoration",
      getAttrs: (value) => typeof value === "string" && value.includes("underline") ? null : false
    }
  ],
  toDOM() {
    return ["u", 0];
  }
};
var strikethroughMarkSpec = {
  inclusive: true,
  parseDOM: [
    { tag: "s" },
    { tag: "del" },
    { tag: "strike" },
    {
      style: "text-decoration",
      getAttrs: (value) => typeof value === "string" && value.includes("line-through") ? null : false
    }
  ],
  toDOM() {
    return ["s", 0];
  }
};
var referenceNodeSpec = {
  inline: true,
  group: "inline",
  atom: true,
  selectable: true,
  isolating: true,
  attrs: {
    urn: { default: "" },
    inline: { default: false },
    modal: { default: false },
    display: { default: "block" },
    "full-width": { default: false },
    stretch: { default: false },
    trigger: { default: "" }
  },
  parseDOM: [
    {
      tag: "ee-reference",
      getAttrs: (dom) => {
        const attrs = {};
        if (dom.getAttributeNames) {
          for (const name of dom.getAttributeNames()) {
            attrs[name] = dom.getAttribute(name);
          }
        }
        attrs.trigger = dom.innerHTML || "";
        return sanitizeReferenceAttributes(attrs);
      }
    }
  ],
  toDOM(node) {
    const el = document.createElement("ee-reference");
    for (const [name, value] of Object.entries(node.attrs)) {
      if (name === "trigger") continue;
      if (value === true) {
        el.setAttribute(name, "");
      } else if (value !== false && value != null) {
        el.setAttribute(name, value);
      }
    }
    const markup = node.attrs.trigger;
    if (markup) {
      const template = document.createElement("template");
      template.innerHTML = markup;
      el.appendChild(template.content.cloneNode(true));
    }
    return el;
  }
};
var inlineContentInlineNodeSpec = {
  inline: true,
  group: "inline",
  atom: true,
  selectable: true,
  attrs: {
    html: { default: "" }
  },
  parseDOM: [
    {
      tag: "ee-content",
      getAttrs: (dom) => {
        const html = dom.innerHTML || "";
        return { html };
      }
    }
  ],
  toDOM(node) {
    const html = node.attrs.html || "";
    if (!html) {
      return ["ee-content", { "inline": "" }];
    }
    const template = document.createElement("template");
    template.innerHTML = html;
    const children = Array.from(template.content.childNodes);
    return ["ee-content", { "inline": "" }, ...children];
  }
};
var createPlainSchema = ({ inline: inline2 = false, multiline = true, wrapperTag = "div", tag: tag3 } = {}) => {
  const textSpec = schema.spec.nodes.get("text") || { group: "inline" };
  const normalizedWrapper = typeof wrapperTag === "string" && wrapperTag ? wrapperTag.toLowerCase() : "div";
  const normalizedTag = typeof tag3 === "string" && tag3 ? tag3.toLowerCase() : "p";
  const nodes2 = inline2 ? {
    doc: { content: "inline*" },
    text: textSpec
  } : {
    doc: { content: "paragraph" },
    paragraph: {
      ...plainParagraphSpec,
      parseDOM: [
        {
          tag: normalizedTag,
          getAttrs: (dom) => ({ align: readAlignment(dom) })
        },
        {
          tag: "p",
          getAttrs: (dom) => ({ align: readAlignment(dom) })
        },
        {
          tag: "div",
          getAttrs: (dom) => ({ align: readAlignment(dom) })
        }
      ],
      toDOM(node) {
        const align = normalizeAlign(node.attrs.align);
        const attrs = {};
        if (align !== "left") {
          attrs.style = `text-align: ${align};`;
        }
        const paragraphTag = multiline ? normalizedWrapper : normalizedTag;
        return [paragraphTag, attrs, 0];
      }
    },
    text: textSpec
  };
  return new Schema({ nodes: nodes2, marks: {} });
};
var createRichSchema = ({
  multiline = true,
  wrapperTag = "div",
  tag: tag3 = "span"
} = {}) => {
  const basicNodes = schema.spec.nodes;
  const basicMarks = schema.spec.marks;
  const baseParagraphSpec = basicNodes.get("paragraph");
  const paragraphTag = multiline ? "p" : (typeof wrapperTag === "string" && wrapperTag || typeof tag3 === "string" && tag3 || "span").toLowerCase();
  const paragraphWithAlign = {
    ...baseParagraphSpec,
    attrs: {
      ...baseParagraphSpec.attrs || {},
      align: { default: "left" }
    },
    parseDOM: (() => {
      const baseRules = Array.isArray(baseParagraphSpec.parseDOM) ? baseParagraphSpec.parseDOM : [];
      const enhancedRules = baseRules.map((rule) => {
        const originalGetAttrs = rule.getAttrs;
        return {
          ...rule,
          getAttrs(dom) {
            const baseAttrs = originalGetAttrs ? originalGetAttrs(dom) : {};
            if (baseAttrs === false) {
              return false;
            }
            return {
              ...baseAttrs || {},
              align: readAlignment(dom)
            };
          }
        };
      });
      const ensureRuleForTag = (tag4) => {
        if (!tag4) return;
        const normalizedTag = tag4.toLowerCase();
        const hasRule = enhancedRules.some(
          (rule) => typeof rule.tag === "string" && rule.tag.toLowerCase() === normalizedTag
        );
        if (!hasRule) {
          enhancedRules.unshift({
            tag: normalizedTag,
            getAttrs: (dom) => ({
              align: readAlignment(dom)
            })
          });
        }
      };
      ensureRuleForTag(paragraphTag);
      ensureRuleForTag("p");
      return enhancedRules;
    })(),
    toDOM(node) {
      const align = normalizeAlign(node.attrs.align);
      const attrs = {};
      if (align !== "left") {
        attrs.style = `text-align: ${align};`;
      }
      return [paragraphTag, attrs, 0];
    }
  };
  const docSpec = multiline ? basicNodes.get("doc") : {
    ...basicNodes.get("doc") || {},
    content: "inline*"
  };
  const nodes2 = {
    doc: docSpec,
    paragraph: paragraphWithAlign,
    text: basicNodes.get("text")
  };
  const hardBreakSpec = basicNodes.get("hard_break");
  if (hardBreakSpec) {
    nodes2.hard_break = hardBreakSpec;
  }
  const headingSpec = basicNodes.get("heading");
  if (headingSpec) {
    nodes2.heading = headingSpec;
  }
  const listItem2 = listItem ? {
    ...listItem,
    content: listItem.content || "paragraph block*",
    attrs: {
      ...listItem.attrs || {},
      align: { default: "left" }
    }
  } : {
    content: "paragraph block*",
    attrs: { align: { default: "left" } },
    parseDOM: [{ tag: "li" }],
    toDOM() {
      return ["li", 0];
    },
    defining: true
  };
  const bulletList2 = bulletList ? {
    ...bulletList,
    content: bulletList.content || "list_item+",
    group: bulletList.group || "block"
  } : {
    content: "list_item+",
    group: "block",
    parseDOM: [{ tag: "ul" }],
    toDOM() {
      return ["ul", 0];
    }
  };
  const orderedList2 = orderedList ? {
    ...orderedList,
    content: orderedList.content || "list_item+",
    group: orderedList.group || "block"
  } : {
    content: "list_item+",
    group: "block",
    attrs: { order: { default: 1, validate: "number" } },
    parseDOM: [
      {
        tag: "ol",
        getAttrs(dom) {
          return {
            order: dom.hasAttribute("start") ? Number(dom.getAttribute("start")) || 1 : 1
          };
        }
      }
    ],
    toDOM(node) {
      return node.attrs.order === 1 ? ["ol", 0] : ["ol", { start: node.attrs.order }, 0];
    }
  };
  if (listItem2) {
    nodes2.list_item = listItem2;
  }
  if (bulletList2) {
    nodes2.bullet_list = bulletList2;
  }
  if (orderedList2) {
    nodes2.ordered_list = orderedList2;
  }
  nodes2.ee_reference = referenceNodeSpec;
  nodes2.ee_inline_content_inline = inlineContentInlineNodeSpec;
  const marks2 = {};
  const strongSpec = basicMarks.get("strong");
  if (strongSpec) marks2.strong = strongSpec;
  const emSpec = basicMarks.get("em");
  if (emSpec) marks2.em = emSpec;
  const linkSpec = basicMarks.get("link");
  if (linkSpec) marks2.link = createLinkMarkSpec(linkSpec);
  marks2.underline = underlineMarkSpec;
  marks2.strikethrough = strikethroughMarkSpec;
  return new Schema({
    nodes: nodes2,
    marks: marks2
  });
};
var createSchemaFromConfig = (config = {}) => {
  const mode = normalizeMode(config.mode);
  const multiline = config.multiline === false ? false : true;
  const tag3 = typeof config.tag === "string" && config.tag ? config.tag.toLowerCase() : "span";
  const wrapperTag = multiline ? "div" : tag3;
  const schema2 = mode === "rich" ? createRichSchema({
    multiline,
    wrapperTag,
    tag: tag3
  }) : createPlainSchema({
    inline: !multiline,
    multiline,
    wrapperTag,
    tag: tag3
  });
  return {
    schema: schema2,
    config: {
      mode,
      multiline,
      wrapperTag,
      tag: tag3,
      inlineTag: tag3
    }
  };
};

// src/features/rte/prosemirror-loader.js
var baseImports = {
  state: () => Promise.resolve().then(() => (init_dist4(), dist_exports2)),
  view: () => Promise.resolve().then(() => (init_dist7(), dist_exports5)),
  model: () => Promise.resolve().then(() => (init_dist2(), dist_exports)),
  history: () => Promise.resolve().then(() => (init_dist9(), dist_exports6)),
  keymap: () => Promise.resolve().then(() => (init_dist10(), dist_exports7)),
  commands: () => Promise.resolve().then(() => (init_dist11(), dist_exports8)),
  schemaBasic: () => Promise.resolve().then(() => (init_dist6(), dist_exports4)),
  schemaList: () => Promise.resolve().then(() => (init_dist5(), dist_exports3)),
  dropcursor: () => Promise.resolve().then(() => (init_dist12(), dist_exports9)),
  gapcursor: () => Promise.resolve().then(() => (init_dist13(), dist_exports10)),
  inputrules: () => Promise.resolve().then(() => (init_dist14(), dist_exports11))
};
var cache = /* @__PURE__ */ new Map();
var loadProseMirror = async (options = {}) => {
  const targets = Array.isArray(options.modules) && options.modules.length ? options.modules : Object.keys(baseImports);
  const entries = await Promise.all(
    targets.map(async (key) => {
      if (cache.has(key)) {
        return [key, cache.get(key)];
      }
      const loader = baseImports[key];
      if (!loader) {
        return [key, null];
      }
      const mod = await loader();
      cache.set(key, mod);
      return [key, mod];
    })
  );
  return Object.fromEntries(entries);
};

// src/features/rte/plugins/reference.js
init_dist4();
var REFERENCE_PLUGIN_KEY = "ee-reference-guard";
var createReferencePlugin = (pm, options = {}) => {
  if (!Plugin || !PluginKey || !TextSelection) return null;
  const key = new PluginKey(REFERENCE_PLUGIN_KEY);
  const isAtomicNode = (node) => node?.type?.name === "ee_reference" || node?.type?.name === "ee_inline_content_inline";
  const sanitizeState = (state) => {
    if (!state) return null;
    let tr2 = null;
    state.doc.descendants((node, pos) => {
      if (node?.type?.name === "ee_reference") {
        const sanitized = sanitizeReferenceAttributes(node.attrs);
        if (!referenceAttrsEqual(node.attrs, sanitized)) {
          if (!tr2) {
            tr2 = state.tr;
          }
          tr2.setNodeMarkup(pos, node.type, sanitized, node.marks);
        }
        return true;
      }
      if (node?.type?.name === "ee_inline_content_inline") {
        const html = typeof node.attrs?.html === "string" ? node.attrs.html : String(node.attrs?.html ?? "");
        const sanitizedHtml = sanitizeInlineArtifactsMarkup(html, { stripSlot: true });
        if (sanitizedHtml !== html) {
          if (!tr2) {
            tr2 = state.tr;
          }
          tr2.setNodeMarkup(
            pos,
            node.type,
            {
              ...node.attrs || {},
              html: sanitizedHtml
            },
            node.marks
          );
        }
        return true;
      }
      return true;
    });
    return tr2 && tr2.steps.length ? tr2 : null;
  };
  const handleNavigation = (view, event, direction) => {
    const { state, dispatch } = view;
    const { selection, doc: doc3 } = state;
    const isRight = direction === "right";
    if (selection instanceof NodeSelection && isAtomicNode(selection.node)) {
      if (isRight) {
        const nextPos = selection.to;
        dispatch(state.tr.setSelection(TextSelection.create(doc3, nextPos)));
        return true;
      } else {
        const prevPos = selection.from;
        dispatch(state.tr.setSelection(TextSelection.create(doc3, prevPos)));
        return true;
      }
    }
    if (selection instanceof TextSelection) {
      const { $head } = selection;
      if (isRight) {
        const nodeAfter = $head.nodeAfter;
        if (isAtomicNode(nodeAfter)) {
          const nodePos = $head.pos;
          const tr2 = state.tr.setSelection(NodeSelection.create(doc3, nodePos));
          dispatch(tr2);
          return true;
        }
      } else {
        const nodeBefore = $head.nodeBefore;
        if (isAtomicNode(nodeBefore)) {
          const nodePos = $head.pos - nodeBefore.nodeSize;
          const tr2 = state.tr.setSelection(NodeSelection.create(doc3, nodePos));
          dispatch(tr2);
          return true;
        }
      }
    }
    return false;
  };
  return new Plugin({
    key,
    props: {
      handleKeyDown(view, event) {
        if (event.defaultPrevented) return false;
        if (event.shiftKey) return false;
        if (event.key === "ArrowRight") {
          if (handleNavigation(view, event, "right")) {
            event.preventDefault();
            return true;
          }
        } else if (event.key === "ArrowLeft") {
          if (handleNavigation(view, event, "left")) {
            event.preventDefault();
            return true;
          }
        }
        return false;
      },
      handleClickOn(view, pos, node, nodePos, event, direct) {
        if (isAtomicNode(node)) {
          const selection = NodeSelection.create(view.state.doc, nodePos);
          view.dispatch(view.state.tr.setSelection(selection));
          return true;
        }
        return false;
      },
      transformPasted(slice2) {
        const result = sanitizeReferenceSlice(pm, slice2);
        const sanitized = result.changed ? result.slice : slice2;
        return normalizePastedSlice(pm, sanitized);
      }
    },
    view(editorView) {
      const tr2 = sanitizeState(editorView.state);
      if (tr2) {
        editorView.dispatch(tr2);
      }
      return {};
    },
    appendTransaction(transactions, _oldState, newState) {
      if (!transactions.some((tr2) => tr2.docChanged)) {
        return null;
      }
      const sanitized = sanitizeState(newState);
      return sanitized;
    }
  });
};

// src/features/rte/plugins/index.js
var createArrowHandler = (pm, direction) => (state, dispatch, view) => {
  if (!view) return false;
  const { selection, doc: doc3 } = state;
  const { head } = selection;
  const startCoords = view.coordsAtPos(head);
  const step = 20;
  const targetY = direction === "up" ? startCoords.top - step : startCoords.bottom + step;
  const targetPos = view.posAtCoords({ left: startCoords.left, top: targetY });
  if (!targetPos) return false;
  let resolvedPos = doc3.resolve(targetPos.pos);
  if (resolvedPos.pos === head) {
    const largeStep = 60;
    const targetY2 = direction === "up" ? startCoords.top - largeStep : startCoords.bottom + largeStep;
    const targetPos2 = view.posAtCoords({ left: startCoords.left, top: targetY2 });
    if (targetPos2) resolvedPos = doc3.resolve(targetPos2.pos);
  }
  if (resolvedPos.pos === head) return false;
  if (dispatch) {
    const newSelection = state.selection.constructor.name === "NodeSelection" ? pm.TextSelection.create(doc3, resolvedPos.pos) : pm.TextSelection.create(doc3, resolvedPos.pos);
    dispatch(state.tr.setSelection(newSelection).scrollIntoView());
  }
  return true;
};
var createBasePlugins = (pm, config = {}) => {
  if (!pm) return [];
  const plugins = [];
  plugins.push(pm.history());
  plugins.push(
    pm.keymap({
      "Mod-z": pm.undo,
      "Mod-y": pm.redo,
      "Shift-Mod-z": pm.redo,
      "ArrowUp": createArrowHandler(pm, "up"),
      "ArrowDown": createArrowHandler(pm, "down")
    })
  );
  const wordSelectionKeymap = pm.keymap({
    "Shift-Mod-ArrowRight": extendSelectionWordCommand(1),
    "Shift-Mod-ArrowLeft": extendSelectionWordCommand(-1)
  });
  plugins.push(wordSelectionKeymap);
  if (config.multiline === false) {
    plugins.push(
      pm.keymap({
        Enter: () => true
      })
    );
  }
  plugins.push(pm.keymap(pm.baseKeymap));
  const dropCursorOptions = config.mode === "plain" ? { color: "var(--spectrum-alias-border-color-default, currentColor)" } : void 0;
  plugins.push(pm.dropCursor(dropCursorOptions));
  if (pm.gapCursor) {
    plugins.push(pm.gapCursor());
  }
  const ir2 = pm.inputRules;
  if (ir2?.inputRules) {
    const rules = [];
    if (Array.isArray(ir2.smartQuotes)) {
      rules.push(...ir2.smartQuotes);
    }
    if (ir2.emDash) {
      rules.push(ir2.emDash);
    }
    if (ir2.ellipsis) {
      rules.push(ir2.ellipsis);
    }
    const schema2 = config.schemaPackage?.schema;
    if (config.mode === "rich" && schema2) {
      const { wrappingInputRule: wrappingInputRule2, textblockTypeInputRule: textblockTypeInputRule2 } = ir2;
      if (schema2.nodes.heading && textblockTypeInputRule2) {
        rules.push(
          textblockTypeInputRule2(
            new RegExp("^(#{1,6})\\s$"),
            schema2.nodes.heading,
            (match) => ({ level: match[1].length })
          )
        );
      }
      if (schema2.nodes.bullet_list && wrappingInputRule2) {
        rules.push(
          wrappingInputRule2(/^\s*([-+*])\s$/, schema2.nodes.bullet_list)
        );
      }
      if (schema2.nodes.ordered_list && wrappingInputRule2) {
        rules.push(
          wrappingInputRule2(
            /^\s*(\d+)\.\s$/,
            schema2.nodes.ordered_list,
            (match) => ({ order: +match[1] }),
            (match, node) => node.childCount + node.attrs.order === +match[1]
          )
        );
      }
      if (schema2.nodes.blockquote && wrappingInputRule2) {
        rules.push(wrappingInputRule2(/^\s*>\s$/, schema2.nodes.blockquote));
      }
    }
    if (rules.length) {
      plugins.push(ir2.inputRules({ rules }));
    }
  }
  if (config.mode === "rich") {
    plugins.push(
      pm.keymap({
        "Shift-Enter": (state, dispatch) => {
          const { hard_break } = state.schema.nodes;
          if (!hard_break) return false;
          if (dispatch) {
            dispatch(
              state.tr.replaceSelectionWith(hard_break.create()).scrollIntoView()
            );
          }
          return true;
        }
      })
    );
  }
  if (config.mode === "rich") {
    const referencePlugin = createReferencePlugin(pm, config);
    if (referencePlugin) plugins.push(referencePlugin);
  }
  return plugins;
};

// src/features/rte/prosemirror.css.js
var prosemirrorStyles = `
    .ProseMirror {
        position: relative;
    }

    .ProseMirror {
        word-wrap: break-word;
        white-space: pre-wrap;
        white-space: break-spaces;
        -webkit-font-variant-ligatures: none;
        font-variant-ligatures: none;
        font-feature-settings: 'liga' 0; /* the above doesn't seem to work in Edge */
    }

    .ProseMirror pre {
        white-space: pre-wrap;
    }

    .ProseMirror li {
        position: relative;
    }

    .ProseMirror-hideselection *::selection {
        background: transparent;
    }
    .ProseMirror-hideselection *::-moz-selection {
        background: transparent;
    }
    .ProseMirror-hideselection {
        caret-color: transparent;
    }

    /* See https://github.com/ProseMirror/prosemirror/issues/1421#issuecomment-1759320191 */
    .ProseMirror [draggable][contenteditable='false'] {
        user-select: text;
    }

    /* Make sure li selections wrap around markers */

    li.ProseMirror-selectednode {
        outline: none;
    }

    li.ProseMirror-selectednode:after {
        content: '';
        position: absolute;
        left: -32px;
        right: -2px;
        top: -2px;
        bottom: -2px;
        border: 2px solid #8cf;
        pointer-events: none;
    }

    /* Protect against generic img rules */

    img.ProseMirror-separator {
        display: inline !important;
        border: none !important;
        margin: 0 !important;
    }
    .ProseMirror-textblock-dropdown {
        min-width: 3em;
    }

    .ProseMirror-menu {
        margin: 0 -4px;
        line-height: 1;
    }

    .ProseMirror-tooltip .ProseMirror-menu {
        width: -webkit-fit-content;
        width: fit-content;
        white-space: pre;
    }

    .ProseMirror-menuitem {
        margin-right: 3px;
        display: inline-block;
    }

    .ProseMirror-menuseparator {
        border-right: 1px solid #ddd;
        margin-right: 3px;
    }

    .ProseMirror-menu-dropdown,
    .ProseMirror-menu-dropdown-menu {
        font-size: 90%;
        white-space: nowrap;
    }

    .ProseMirror-menu-dropdown {
        vertical-align: 1px;
        cursor: pointer;
        position: relative;
        padding-right: 15px;
    }

    .ProseMirror-menu-dropdown-wrap {
        padding: 1px 0 1px 4px;
        display: inline-block;
        position: relative;
    }

    .ProseMirror-menu-dropdown:after {
        content: '';
        border-left: 4px solid transparent;
        border-right: 4px solid transparent;
        border-top: 4px solid currentColor;
        opacity: 0.6;
        position: absolute;
        right: 4px;
        top: calc(50% - 2px);
    }

    .ProseMirror-menu-dropdown-menu,
    .ProseMirror-menu-submenu {
        position: absolute;
        background: white;
        color: #666;
        border: 1px solid #aaa;
        padding: 2px;
    }

    .ProseMirror-menu-dropdown-menu {
        z-index: 15;
        min-width: 6em;
    }

    .ProseMirror-menu-dropdown-item {
        cursor: pointer;
        padding: 2px 8px 2px 4px;
    }

    .ProseMirror-menu-dropdown-item:hover {
        background: #f2f2f2;
    }

    .ProseMirror-menu-submenu-wrap {
        position: relative;
        margin-right: -4px;
    }

    .ProseMirror-menu-submenu-label:after {
        content: '';
        border-top: 4px solid transparent;
        border-bottom: 4px solid transparent;
        border-left: 4px solid currentColor;
        opacity: 0.6;
        position: absolute;
        right: 4px;
        top: calc(50% - 4px);
    }

    .ProseMirror-menu-submenu {
        display: none;
        min-width: 4em;
        left: 100%;
        top: -3px;
    }

    .ProseMirror-menu-active {
        background: #eee;
        border-radius: 4px;
    }

    .ProseMirror-menu-disabled {
        opacity: 0.3;
    }

    .ProseMirror-menu-submenu-wrap:hover .ProseMirror-menu-submenu,
    .ProseMirror-menu-submenu-wrap-active .ProseMirror-menu-submenu {
        display: block;
    }

    .ProseMirror-menubar {
        border-top-left-radius: inherit;
        border-top-right-radius: inherit;
        position: relative;
        min-height: 1em;
        color: #666;
        padding: 1px 6px;
        top: 0;
        left: 0;
        right: 0;
        border-bottom: 1px solid silver;
        background: white;
        z-index: 10;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
        overflow: visible;
    }

    .ProseMirror-icon {
        display: inline-block;
        line-height: 0.8;
        vertical-align: -2px; /* Compensate for padding */
        padding: 2px 8px;
        cursor: pointer;
    }

    .ProseMirror-menu-disabled.ProseMirror-icon {
        cursor: default;
    }

    .ProseMirror-icon svg {
        fill: currentColor;
        height: 1em;
    }

    .ProseMirror-icon span {
        vertical-align: text-top;
    }
    .ProseMirror-gapcursor {
        display: none;
        pointer-events: none;
        position: absolute;
    }

    .ProseMirror-gapcursor:after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        height: 1em;
        width: 1px;
        border-left: 1px solid black;
        animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
    }

    @keyframes ProseMirror-cursor-blink {
        to {
            visibility: hidden;
        }
    }

    .ProseMirror-focused .ProseMirror-gapcursor {
        display: block;
    }
    /* Add space around the hr to make clicking it easier */

    .ProseMirror-example-setup-style hr {
        padding: 2px 10px;
        border: none;
        margin: 1em 0;
    }

    .ProseMirror-example-setup-style hr:after {
        content: '';
        display: block;
        height: 1px;
        background-color: silver;
        line-height: 2px;
    }

    .ProseMirror ul,
    .ProseMirror ol {
        padding-left: 30px;
    }

    .ProseMirror blockquote {
        padding-left: 1em;
        border-left: 3px solid #eee;
        margin-left: 0;
        margin-right: 0;
    }

    .ProseMirror-example-setup-style img {
        cursor: default;
    }

    .ProseMirror-prompt {
        background: white;
        padding: 5px 10px 5px 15px;
        border: 1px solid silver;
        position: fixed;
        border-radius: 3px;
        z-index: 11;
        box-shadow: -0.5px 2px 5px rgba(0, 0, 0, 0.2);
    }

    .ProseMirror-prompt h5 {
        margin: 0;
        font-weight: normal;
        font-size: 100%;
        color: #444;
    }

    .ProseMirror-prompt input[type='text'],
    .ProseMirror-prompt textarea {
        background: #eee;
        border: none;
        outline: none;
    }

    .ProseMirror-prompt input[type='text'] {
        padding: 0 4px;
    }

    .ProseMirror-prompt-close {
        position: absolute;
        left: 2px;
        top: 1px;
        color: #666;
        border: none;
        background: transparent;
        padding: 0;
    }

    .ProseMirror-prompt-close:after {
        content: '\u2715';
        font-size: 12px;
    }

    .ProseMirror-invalid {
        background: #ffc;
        border: 1px solid #cc7;
        border-radius: 4px;
        padding: 5px 10px;
        position: absolute;
        min-width: 10em;
    }

    .ProseMirror-prompt-buttons {
        margin-top: 5px;
        display: none;
    }

    .ProseMirror {
        outline: none;
    }

    .ProseMirror-selectednode {
        outline: 2px solid;
        outline-color: var(--spectrum-indigo-800);
        border-radius: 4px;
        outline-offset: 1px;
    }
`;
var prosemirrorStyleSheet = new CSSStyleSheet();
prosemirrorStyleSheet.replaceSync(prosemirrorStyles);
document.adoptedStyleSheets = [...document.adoptedStyleSheets, prosemirrorStyleSheet];

// src/features/rte/ee-rte.js
var nextRteDebugId = 0;
var EeRte = class extends i4 {
  static preload(modules) {
    return loadProseMirror({ modules });
  }
  static properties = {
    readonly: { type: Boolean, reflect: true, converter: booleanConverter },
    formats: { type: String, reflect: true },
    links: { type: String, reflect: true },
    blocks: { type: String, reflect: true },
    plain: { type: Boolean, reflect: true, converter: booleanConverter },
    placeholder: { type: String, reflect: true },
    multiline: { type: Boolean, reflect: true, converter: booleanConverter },
    inlineConfig: { attribute: false },
    inlineOptions: { attribute: false }
  };
  #logEnabled = EDITOR_DEBUG === true;
  #debugId = ++nextRteDebugId;
  #logSequence = 0;
  #plainFlag = false;
  #view = null;
  #editorElement = null;
  #schemaPackage = null;
  #parser = null;
  #serializer = null;
  #initialMarkup = "";
  #lastSerialized = "";
  #pm = null;
  #pmPromise = null;
  #isLoadingModules = false;
  #resolvedInlineOptions = null;
  #pendingSchemaRefresh = false;
  #readyPromise = null;
  #readyResolver = null;
  #linkMode() {
    const raw = typeof this.links === "string" ? this.links.trim().toLowerCase() : "";
    return raw === "disabled" ? "disabled" : "enabled";
  }
  #linksEnabled() {
    return this.#linkMode() === "enabled";
  }
  constructor() {
    super();
    this.readonly = false;
    this.formats = null;
    this.links = "enabled";
    this.blocks = "paragraph";
    this.plain = false;
    this.placeholder = "";
    this.multiline = true;
    this.inlineConfig = null;
    this.inlineOptions = null;
    this.#readyPromise = new Promise((resolve) => {
      this.#readyResolver = resolve;
    });
  }
  whenReady() {
    return this.#readyPromise;
  }
  get value() {
    if (this.#view) {
      return this.#serializeDoc(this.#view.state.doc);
    }
    if (typeof this.#lastSerialized === "string") {
      return this.#lastSerialized;
    }
    return "";
  }
  getValue() {
    return this.value;
  }
  get plain() {
    return this.#plainFlag;
  }
  set plain(value) {
    const next = value === true || value === "" || value === 1 || value === "1" || typeof value === "string" && value.toLowerCase() === "true";
    const previous = this.#plainFlag;
    if (next === previous) {
      return;
    }
    this.#plainFlag = next;
    this.requestUpdate("plain", previous);
  }
  #setModuleLoading(flag) {
    const next = flag === true;
    if (this.#isLoadingModules === next) return;
    this.#isLoadingModules = next;
  }
  async #ensureProseMirror() {
    this.#debugLog("#ensureProseMirror()");
    if (this.#pm) {
      return this.#pm;
    }
    if (this.#pmPromise) {
      return this.#pmPromise;
    }
    this.#setModuleLoading(true);
    this.#pmPromise = loadProseMirror({
      modules: [
        "state",
        "view",
        "model",
        "history",
        "keymap",
        "commands",
        "dropcursor",
        "gapcursor",
        "inputrules"
      ]
    }).then((modules) => {
      const pm = {
        EditorState: modules.state.EditorState,
        TextSelection: modules.state.TextSelection,
        NodeSelection: modules.state.NodeSelection,
        EditorView: modules.view.EditorView,
        DOMParser: modules.model.DOMParser,
        DOMSerializer: modules.model.DOMSerializer,
        Fragment: modules.model.Fragment,
        Slice: modules.model.Slice,
        history: modules.history.history,
        undo: modules.history.undo,
        redo: modules.history.redo,
        undoDepth: modules.history.undoDepth,
        redoDepth: modules.history.redoDepth,
        keymap: modules.keymap.keymap,
        baseKeymap: modules.commands.baseKeymap,
        toggleMark: modules.commands.toggleMark,
        dropCursor: modules.dropcursor?.dropCursor,
        gapCursor: modules.gapcursor?.gapCursor,
        inputRules: modules.inputrules,
        Plugin: modules.state.Plugin,
        PluginKey: modules.state.PluginKey
      };
      this.#pm = pm;
      this.#setModuleLoading(false);
      return pm;
    }).catch((err) => {
      this.#setModuleLoading(false);
      this.#pmPromise = null;
      throw err;
    });
    return this.#pmPromise;
  }
  createRenderRoot() {
    return this;
  }
  connectedCallback() {
    super.connectedCallback();
  }
  #debugLog(label, detail = null) {
    if (!this.#logEnabled) {
      return;
    }
    this.#logSequence += 1;
    let payload;
    if (detail && typeof detail === "object" && !Array.isArray(detail)) {
      payload = { rteId: this.#debugId, callId: this.#logSequence, ...detail };
    } else if (detail !== null && detail !== void 0) {
      payload = {
        rteId: this.#debugId,
        callId: this.#logSequence,
        value: detail
      };
    } else {
      payload = { rteId: this.#debugId, callId: this.#logSequence };
    }
    console.log(`[ee-rte] ${label}`, payload);
  }
  disconnectedCallback() {
    this.dispose();
    super.disconnectedCallback();
  }
  render() {
    return x`<div id="ee-rte-surface" part="surface-container"></div>`;
  }
  get loading() {
    return this.#isLoadingModules;
  }
  async getUpdateComplete() {
    await super.getUpdateComplete();
    if (this.#pmPromise) {
      await this.#pmPromise;
    }
    return true;
  }
  async firstUpdated() {
    this.#debugLog("firstUpdated()");
    this.#editorElement = this.renderRoot?.querySelector?.("#ee-rte-surface") || this;
    this.#applyInlineOptions();
    await this.#ensureProseMirror();
    this.#adoptTargetContent();
    this.#captureInitialValue();
    this.#prepareSchema();
    this.#applyExternalValue();
    this.#initEditor();
    await this.updateComplete;
    if (this.#readyResolver) {
      this.#readyResolver();
    }
    if (this.#pendingSchemaRefresh) {
      this.#pendingSchemaRefresh = false;
      this.#prepareSchema();
      this.#recreateEditor();
    }
  }
  /**
   * Programmatically focus the editor surface.
   */
  focusEditor(options) {
    const focusOptions = options && typeof options === "object" ? options : void 0;
    const view = this.#view;
    if (!view) return;
    const dom = view.dom;
    if (dom?.focus) {
      dom.focus(focusOptions);
      if (view.hasFocus?.() === false && view.focus) {
        view.focus();
      }
      return;
    }
    if (view.focus) {
      view.focus();
    }
  }
  focus(options) {
    this.focusEditor(options);
  }
  blur() {
    if (this.#view?.dom) {
      this.#view.dom.blur();
      return;
    }
    this.#editorElement?.blur?.();
  }
  toggleMark(mark) {
    const normalized = typeof mark === "string" && mark.trim() ? FORMAT_TO_MARK[mark.trim()] || mark.trim() : "";
    if (!normalized) return false;
    return this.#execToggleMark(normalized);
  }
  toggleBold() {
    return this.toggleMark("bold");
  }
  toggleItalic() {
    return this.toggleMark("italic");
  }
  toggleUnderline() {
    return this.toggleMark("underline");
  }
  toggleStrikethrough() {
    return this.toggleMark("strikethrough");
  }
  toggleList(listType = "bullet") {
    const normalized = listType === "ordered" || listType === "numbered" ? "ordered" : "bullet";
    return this.#execToggleList(normalized);
  }
  toggleBulletList() {
    return this.toggleList("bullet");
  }
  toggleOrderedList() {
    return this.toggleList("ordered");
  }
  setAlignment(align = "left") {
    const normalized = align === "center" || align === "right" ? align : "left";
    return this.#execSetAlignment(normalized);
  }
  setBlock(type) {
    if (!type || typeof type !== "string") return false;
    return this.#execSetBlockType(type);
  }
  applyLink(attrs = {}) {
    if (!attrs || typeof attrs !== "object") {
      return false;
    }
    return this.#execSetLink(attrs);
  }
  removeLink() {
    return this.#execRemoveLink();
  }
  updateReference(attrs = {}) {
    if (!attrs || typeof attrs !== "object") {
      return false;
    }
    return this.#execUpdateReference(attrs);
  }
  undo() {
    return this.#execUndo();
  }
  redo() {
    return this.#execRedo();
  }
  insertText(text = "") {
    return this.#execInsertText(String(text ?? ""));
  }
  insertHtml(html = "") {
    return this.#execInsertHTML(String(html ?? ""));
  }
  setSelection(range = {}) {
    return this.#execSetSelection(range);
  }
  isEditorFocused() {
    const view = this.#view;
    if (view?.hasFocus) {
      return view.hasFocus();
    }
    const dom = view?.dom;
    const active = dom?.ownerDocument?.activeElement || document.activeElement;
    if (dom && active) {
      return active === dom || dom.contains(active);
    }
    return false;
  }
  setSelectionFromPoint(point = {}) {
    const view = this.#view;
    const pm = this.#pm;
    if (!view || !pm) {
      return false;
    }
    const coords = this.#normalizeSelectionPoint(point);
    if (!coords) {
      return false;
    }
    if (typeof view.posAtCoords !== "function") {
      return false;
    }
    const position = view.posAtCoords(coords);
    if (!position || !Number.isInteger(position.pos)) {
      return false;
    }
    return this.#execSetSelection({ anchor: position.pos, head: position.pos });
  }
  dispose() {
    if (this.#view) {
      this.#debugLog("dispose()", {
        hasDoc: !!this.#view.state?.doc
      });
      const doc3 = this.#view.state?.doc || null;
      if (doc3) {
        this.#lastSerialized = this.#serializeDoc(doc3);
      }
      this.#view.destroy();
      this.#view = null;
    }
  }
  getEditorView() {
    return this.#view;
  }
  getProseMirrorToolkit() {
    return this.#pm;
  }
  /**
   * @returns {RteSchemaConfig}
   */
  #currentMode() {
    return this.plain ? "plain" : "rich";
  }
  /**
   * @returns {RteSchemaConfig}
   */
  #computeSchemaConfig() {
    const resolved = this.#resolvedInlineOptions || {
      mode: this.#currentMode(),
      multiline: this.multiline !== false,
      tag: "span",
      inlineTag: "span",
      wrapperTag: this.multiline !== false ? "div" : "span"
    };
    const mode = resolved.mode === "plain" ? "plain" : "rich";
    const placeholderValue = typeof this.placeholder === "string" ? this.placeholder.trim() : "";
    const multiline = resolved.multiline !== false;
    const tag3 = typeof resolved.tag === "string" && resolved.tag || typeof resolved.inlineTag === "string" && resolved.inlineTag || "span";
    const wrapperTag = typeof resolved.wrapperTag === "string" && resolved.wrapperTag || (multiline ? "div" : tag3);
    return {
      mode,
      placeholder: placeholderValue,
      multiline,
      tag: tag3,
      wrapperTag,
      inlineTag: tag3
    };
  }
  #execInsertText(text) {
    if (!text) return false;
    const view = this.#view;
    if (!view) return false;
    const tr2 = view.state.tr.insertText(text);
    if (!tr2) return false;
    view.dispatch(tr2);
    return true;
  }
  #execToggleMark(markName) {
    return toggleMarkCommand(this.#pm, this.#view, markName);
  }
  #execSetAlignment(align) {
    return setAlignmentCommand(this.#view, align);
  }
  #execSetBlockType(type) {
    return setBlockTypeCommand(this.#pm, this.#view, type);
  }
  #execSetLink(payload) {
    return setLinkCommand(this.#pm, this.#view, payload);
  }
  #execRemoveLink() {
    return removeLinkCommand(this.#pm, this.#view);
  }
  #execUpdateReference(payload) {
    return updateReferenceCommand(this.#pm, this.#view, payload);
  }
  #execUndo() {
    return undoCommand(this.#pm, this.#view);
  }
  #execRedo() {
    return redoCommand(this.#pm, this.#view);
  }
  #execInsertHTML(html) {
    if (!html) return false;
    const view = this.#view;
    const pm = this.#pm;
    if (!view || !pm || !this.#parser) return false;
    const config = this.getSchemaConfig();
    const mode = config?.mode || "rich";
    const container = document.createElement("div");
    container.innerHTML = html;
    if (mode === "plain") {
      const text = container.textContent || "";
      return this.#execInsertText(text);
    }
    if (mode === "rich") {
      this.#wrapUnrecognizedElements(container);
    }
    const parsedDoc = this.#parser.parse(container);
    if (!parsedDoc) return false;
    const fragment = parsedDoc.content;
    if (!fragment || fragment.size === 0) {
      return false;
    }
    let slice2;
    const firstChild = fragment.firstChild;
    const isSingleParagraph = fragment.childCount === 1 && firstChild?.type?.name === "paragraph";
    if (isSingleParagraph && firstChild.content) {
      slice2 = new pm.Slice(firstChild.content, 0, 0);
    } else {
      const isInlineContent = fragment.childCount === 1 && firstChild?.type?.name === "ee_inline_content_inline";
      if (isInlineContent) {
        slice2 = new pm.Slice(fragment, 1, 1);
      } else {
        slice2 = new pm.Slice(fragment, 0, 0);
      }
    }
    const tr2 = view.state.tr.replaceSelection(slice2).scrollIntoView();
    view.dispatch(tr2);
    return true;
  }
  #wrapUnrecognizedElements(container) {
    const metaTags = container.querySelectorAll("meta");
    metaTags.forEach((meta) => meta.remove());
    const eeContentElements = container.querySelectorAll("ee-content:not([inline])");
    eeContentElements.forEach((el) => el.setAttribute("inline", ""));
    const elements = Array.from(container.querySelectorAll("*"));
    for (const el of elements) {
      const tagName = el.tagName.toLowerCase();
      if (el.closest("ee-content")) continue;
      if (el.closest("ee-reference")) continue;
      if (!tagName.includes("-")) continue;
      if (tagName === "ee-content" || tagName === "ee-reference") continue;
      if (!customElements.get(tagName)) continue;
      const wrapper = document.createElement("ee-content");
      wrapper.setAttribute("inline", "");
      const clone = el.cloneNode(true);
      wrapper.appendChild(clone);
      el.parentNode?.replaceChild(wrapper, el);
    }
  }
  #transformPastedHTML(html) {
    if (!html) return html;
    const container = document.createElement("div");
    container.innerHTML = html;
    const eeContentElements = container.querySelectorAll("ee-content:not([inline])");
    eeContentElements.forEach((el) => el.setAttribute("inline", ""));
    return container.innerHTML;
  }
  #execToggleList(listType) {
    return toggleListCommand(this.#pm, this.#view, listType);
  }
  #execSetSelection(payload) {
    const view = this.#view;
    const pm = this.#pm;
    if (!view || !pm) return false;
    const doc3 = view.state.doc;
    const size3 = doc3.content.size;
    const anchorRaw = Number.isInteger(payload?.anchor) ? payload.anchor : Number.isInteger(payload?.from) ? payload.from : size3;
    const headRaw = Number.isInteger(payload?.head) ? payload.head : Number.isInteger(payload?.to) ? payload.to : anchorRaw;
    const clamp2 = (pos) => Math.max(0, Math.min(size3, pos));
    const $anchor = doc3.resolve(clamp2(anchorRaw));
    const $head = doc3.resolve(clamp2(headRaw));
    const selection = pm.TextSelection.between($anchor, $head);
    const tr2 = view.state.tr.setSelection(selection);
    view.dispatch(tr2);
    return true;
  }
  #normalizeSelectionPoint(input) {
    if (!input || typeof input !== "object") {
      return null;
    }
    const resolve = (candidates) => {
      for (const value of candidates) {
        if (Number.isFinite(value)) {
          return value;
        }
      }
      return null;
    };
    const left = resolve([input.left, input.clientX, input.x]);
    const top = resolve([input.top, input.clientY, input.y]);
    if (left == null || top == null) {
      return null;
    }
    return { left, top };
  }
  #cloneSelectionDetail(detail) {
    if (!detail || typeof detail !== "object") return null;
    return {
      anchor: detail.anchor ?? 0,
      head: detail.head ?? detail.anchor ?? 0,
      empty: Boolean(detail.empty),
      marks: Array.isArray(detail.marks) ? [...detail.marks] : [],
      block: detail.block && typeof detail.block === "object" ? {
        type: String(detail.block.type || ""),
        attrs: { ...detail.block.attrs || {} }
      } : null,
      link: detail.link && typeof detail.link === "object" ? { ...detail.link || {} } : null,
      reference: detail.reference && typeof detail.reference === "object" ? { ...detail.reference || {} } : null
    };
  }
  #cloneCommandState(state) {
    if (!state || typeof state !== "object") return null;
    const cloneGroup = (group) => {
      if (!group || typeof group !== "object") return {};
      return Object.keys(group).reduce((acc, key) => {
        const entry = group[key];
        acc[key] = {
          enabled: entry?.enabled === true,
          ...entry?.active !== void 0 ? { active: Boolean(entry.active) } : {},
          ...entry?.attrs ? { attrs: { ...entry.attrs } } : {}
        };
        return acc;
      }, {});
    };
    return {
      formats: cloneGroup(state.formats),
      blocks: cloneGroup(state.blocks),
      lists: cloneGroup(state.lists),
      link: {
        enabled: state.link?.enabled === true,
        ...state.link?.attrs ? { attrs: { ...state.link.attrs } } : {},
        ...state.link?.active !== void 0 ? { active: Boolean(state.link.active) } : {},
        ...state.link?.removeEnabled !== void 0 ? { removeEnabled: state.link.removeEnabled === true } : {}
      },
      undo: { enabled: state.undo?.enabled === true },
      redo: { enabled: state.redo?.enabled === true }
    };
  }
  #dispatchContext(selectionDetail, commandState) {
    if (!selectionDetail && !commandState) return;
    this.dispatchEvent(
      new CustomEvent("rte-contextchange", {
        detail: {
          selection: selectionDetail ? this.#cloneSelectionDetail(selectionDetail) : null,
          commands: commandState ? this.#cloneCommandState(commandState) : null
        },
        bubbles: true,
        composed: true
      })
    );
  }
  #decorateSurface() {
    const surface = this.#view?.dom;
    if (!surface) return;
    surface.classList.add("ee-rte__surface");
    const existingPart = surface.getAttribute("part") || "";
    if (!existingPart.split(/\s+/).includes("surface")) {
      surface.setAttribute("part", existingPart ? `${existingPart} surface` : "surface");
    }
    const inlineMode = this.multiline === false;
    surface.classList.toggle("ee-rte__surface--inline", inlineMode);
    surface.style.whiteSpace = "pre-wrap";
    this.#clearInlinePlaceholder(surface);
  }
  #clearInlinePlaceholder(surface = null) {
    const target = surface || this.#view?.dom;
    if (!target) return;
    if (this.multiline !== false) return;
    if (target.hasAttribute("data-placeholder")) {
      target.removeAttribute("data-placeholder");
    }
  }
  #applyInlineOptions(sourceOptions = null) {
    this.#debugLog("#applyInlineOptions()");
    const options = sourceOptions && typeof sourceOptions === "object" ? sourceOptions : this.inlineOptions && typeof this.inlineOptions === "object" ? this.inlineOptions : null;
    if (!options) {
      const fallbackMode = this.#currentMode();
      const fallbackMultiline = this.multiline !== false;
      this.#resolvedInlineOptions = {
        mode: fallbackMode,
        multiline: fallbackMultiline,
        tag: "span",
        inlineTag: "span",
        wrapperTag: fallbackMultiline ? "div" : "span"
      };
      this.blocks = fallbackMultiline ? "paragraph" : "inline";
      return;
    }
    const requestedMode = typeof options.mode === "string" ? options.mode.trim().toLowerCase() : null;
    const preferPlain = options.plain === true || requestedMode === "plain";
    const mode = preferPlain ? "plain" : "rich";
    const multiline = options.multiline !== false;
    if (options.plain !== void 0) {
      if (this.plain !== preferPlain) {
        this.plain = preferPlain;
      }
    } else if (requestedMode) {
      const plainRequested = requestedMode === "plain";
      if (this.plain !== plainRequested) {
        this.plain = plainRequested;
      }
    }
    if (this.multiline !== multiline) {
      this.multiline = multiline;
    }
    this.blocks = multiline ? "paragraph" : "inline";
    if (options.placeholder !== void 0) {
      if (this.placeholder !== options.placeholder) {
        this.placeholder = options.placeholder;
      }
    }
    if (options.inlineConfig) {
      if (this.inlineConfig !== options.inlineConfig) {
        this.inlineConfig = options.inlineConfig;
      }
    }
    const normalizedTag = typeof options.tag === "string" && options.tag.trim() ? options.tag.trim() : typeof options.inlineTag === "string" && options.inlineTag.trim() ? options.inlineTag.trim() : "";
    const inlineTagCandidate = normalizedTag || "span";
    const optionWrapper = typeof options.wrapperTag === "string" && options.wrapperTag.trim() ? options.wrapperTag.trim() : "";
    const wrapperTagCandidate = multiline ? optionWrapper || "div" : optionWrapper || inlineTagCandidate;
    this.#resolvedInlineOptions = {
      mode,
      multiline,
      tag: inlineTagCandidate,
      wrapperTag: wrapperTagCandidate,
      inlineTag: inlineTagCandidate
    };
  }
  configureInline(options) {
    const next = options && typeof options === "object" ? { ...options } : null;
    if (next) {
      this.inlineOptions = next;
    } else {
      this.inlineOptions = null;
    }
    this.#applyInlineOptions(next);
  }
  #prepareSchema() {
    this.#debugLog("#prepareSchema()");
    if (!this.#pm) return;
    const config = this.#computeSchemaConfig();
    this.#schemaPackage = createSchemaFromConfig(config);
    const schema2 = this.#schemaPackage?.schema;
    if (!schema2) {
      this.#parser = null;
      this.#serializer = null;
      return;
    }
    this.#schemaPackage.config = {
      ...config || {},
      ...this.#schemaPackage.config || {}
    };
    const { DOMParser: DOMParser3, DOMSerializer: DOMSerializer2 } = this.#pm;
    this.#parser = DOMParser3.fromSchema(schema2);
    this.#serializer = DOMSerializer2.fromSchema(schema2);
  }
  /**
   * Creates a custom NodeView for atomic nodes (ee-reference, ee-content).
   * This enables reliable click-to-select behavior for contenteditable=false elements.
   */
  #createAtomicNodeView(node, view, getPos) {
    const { NodeSelection: NodeSelection2 } = this.#pm;
    const spec = node.type.spec.toDOM(node);
    let dom;
    if (spec instanceof HTMLElement) {
      dom = spec;
    } else if (Array.isArray(spec)) {
      const [tagName, attrs, ...children] = spec;
      dom = document.createElement(tagName);
      if (attrs && typeof attrs === "object" && !Array.isArray(attrs) && !(attrs instanceof Node)) {
        for (const [key, value] of Object.entries(attrs)) {
          if (value != null) {
            dom.setAttribute(key, String(value));
          }
        }
      }
      const appendChildren = (parent, childSpec) => {
        if (childSpec instanceof Node) {
          parent.appendChild(childSpec);
        } else if (typeof childSpec === "string") {
          parent.appendChild(document.createTextNode(childSpec));
        } else if (Array.isArray(childSpec)) {
          const [tag3, childAttrs, ...grandChildren] = childSpec;
          const child = document.createElement(tag3);
          if (childAttrs && typeof childAttrs === "object" && !Array.isArray(childAttrs) && !(childAttrs instanceof Node)) {
            for (const [k2, v6] of Object.entries(childAttrs)) {
              if (v6 != null) child.setAttribute(k2, String(v6));
            }
          }
          grandChildren.forEach((gc) => appendChildren(child, gc));
          parent.appendChild(child);
        }
      };
      children.forEach((c33) => appendChildren(dom, c33));
    } else {
      const tagName = node.type.name === "ee_reference" ? "ee-reference" : "ee-content";
      dom = document.createElement(tagName);
    }
    dom.contentEditable = "false";
    dom.addEventListener("mousedown", (e36) => {
      const rect = dom.getBoundingClientRect();
      const edgeThreshold = 4;
      const clickX = e36.clientX;
      const isNearLeftEdge = clickX - rect.left < edgeThreshold;
      const isNearRightEdge = rect.right - clickX < edgeThreshold;
      if (isNearLeftEdge || isNearRightEdge) {
        return;
      }
      e36.preventDefault();
      e36.stopPropagation();
      const pos = getPos();
      if (typeof pos !== "number") return;
      try {
        const selection = NodeSelection2.create(view.state.doc, pos);
        view.dispatch(view.state.tr.setSelection(selection));
        view.focus();
      } catch {
      }
    });
    return { dom };
  }
  #initEditor() {
    this.#debugLog("#initEditor()");
    if (!this.#editorElement || this.#view || !this.#pm) return;
    const state = this.#createStateFromValue(this.#lastSerialized);
    if (!state) return;
    const { EditorView: EditorView2 } = this.#pm;
    this.#editorElement.innerHTML = "";
    this.#view = new EditorView2(this.#editorElement, {
      state,
      editable: () => !this.readonly,
      dispatchTransaction: (tr2) => {
        const view = this.#view;
        if (!view) return;
        const newState = view.state.apply(tr2);
        view.updateState(newState);
        this.#handleTransaction(tr2, newState);
      },
      transformPastedHTML: (html) => this.#transformPastedHTML(html),
      handleDOMEvents: this.#getHandleDOMEvents(),
      nodeViews: {
        ee_reference: (node, view, getPos) => this.#createAtomicNodeView(node, view, getPos),
        ee_inline_content_inline: (node, view, getPos) => this.#createAtomicNodeView(node, view, getPos)
      }
    });
    this.#decorateSurface();
    if (this.#view && this.#pm) {
      const initialSelection = this.#createSelectionDetail(this.#view.state);
      const initialCommands = getCommandState({
        view: this.#view,
        pm: this.#pm,
        schemaConfig: this.getSchemaConfig(),
        selectionDetail: initialSelection
      });
      this.#dispatchContext(initialSelection, initialCommands);
    }
  }
  #recreateEditor() {
    this.#debugLog("#recreateEditor()");
    if (!this.#editorElement || !this.#pm) return;
    const prevSelection = this.#view?.state?.selection || null;
    this.destroy();
    const state = this.#createStateFromValue(this.#lastSerialized, prevSelection);
    if (!state) return;
    const { EditorView: EditorView2 } = this.#pm;
    this.#editorElement.innerHTML = "";
    this.#view = new EditorView2(this.#editorElement, {
      state,
      editable: () => !this.readonly,
      dispatchTransaction: (tr2) => {
        const view = this.#view;
        if (!view) return;
        const newState = view.state.apply(tr2);
        view.updateState(newState);
        this.#handleTransaction(tr2, newState);
      },
      transformPastedHTML: (html) => this.#transformPastedHTML(html),
      handleDOMEvents: this.#getHandleDOMEvents(),
      nodeViews: {
        ee_reference: (node, view, getPos) => this.#createAtomicNodeView(node, view, getPos),
        ee_inline_content_inline: (node, view, getPos) => this.#createAtomicNodeView(node, view, getPos)
      }
    });
    this.#decorateSurface();
    if (this.#view && this.#pm) {
      const selectionDetail = this.#createSelectionDetail(this.#view.state);
      const commandState = getCommandState({
        view: this.#view,
        pm: this.#pm,
        schemaConfig: this.getSchemaConfig(),
        selectionDetail
      });
      this.#dispatchContext(selectionDetail, commandState);
    }
  }
  #getHandleDOMEvents() {
    return {
      keydown: (view, event) => {
        if (event.key === " ") {
          event.stopPropagation();
          return false;
        }
      },
      paste: (view, event) => {
        event.preventDefault();
        event.stopPropagation();
        const clipboardData = event.clipboardData;
        if (!clipboardData) return true;
        const html = clipboardData.getData("text/html");
        const text = clipboardData.getData("text/plain");
        if (html) {
          this.#execInsertHTML(html);
        } else if (text) {
          this.#execInsertText(text);
        }
        return true;
      }
    };
  }
  #createStateFromValue(initialValue = "", prevSelection = null) {
    this.#debugLog("#createStateFromValue()", {
      hasParser: !!this.#parser,
      hasSchema: !!this.#schemaPackage?.schema,
      initialValue
    });
    const pm = this.#pm;
    if (!pm) return null;
    const schema2 = this.#schemaPackage?.schema;
    if (!schema2) {
      return null;
    }
    const schemaConfig = this.#schemaPackage?.config || {};
    const plugins = createBasePlugins(pm, {
      ...schemaConfig,
      schemaPackage: this.#schemaPackage
    });
    const doc3 = this.#parseDoc(initialValue, schema2);
    const stateConfig = {
      schema: schema2,
      doc: doc3,
      plugins
    };
    if (prevSelection) {
      stateConfig.selection = prevSelection;
    }
    return pm.EditorState.create(stateConfig);
  }
  #parseDoc(html = "", schema2) {
    if (!schema2) return null;
    if (!html || !this.#parser) {
      return schema2.topNodeType.createAndFill();
    }
    const container = document.createElement("div");
    container.innerHTML = html;
    const schemaConfig = this.#schemaPackage?.config || {};
    if (schemaConfig.multiline === false) {
      const inlineTag = schemaConfig.tag || schemaConfig.inlineTag || "span";
      const wrapper = container.firstElementChild;
      if (wrapper && wrapper === container.lastElementChild && wrapper.tagName?.toLowerCase?.() === inlineTag) {
        container.innerHTML = wrapper.innerHTML;
      }
    }
    const parsed = this.#parser.parse(container);
    return parsed || schema2.topNodeType.createAndFill();
  }
  #serializeDoc(doc3) {
    if (!doc3 || !this.#serializer) {
      return this.#editorElement?.innerHTML || this.#lastSerialized || this.#initialMarkup || "";
    }
    const fragment = this.#serializer.serializeFragment(doc3.content, {
      document
    });
    const container = document.createElement("div");
    container.appendChild(fragment);
    const schemaConfig = this.#schemaPackage?.config || {};
    if (schemaConfig.multiline === false) {
      const inlineTag = schemaConfig.tag || schemaConfig.inlineTag || "span";
      const wrapper = document.createElement(inlineTag);
      while (container.firstChild) {
        wrapper.appendChild(container.firstChild);
      }
      container.appendChild(wrapper);
    }
    if (schemaConfig.multiline === false) {
      const nodes2 = Array.from(container.childNodes || []);
      nodes2.forEach((node) => {
        if (node?.nodeType === Node.ELEMENT_NODE && typeof node.tagName === "string" && node.tagName.toLowerCase() === "p") {
          const paragraph = node;
          while (paragraph.firstChild) {
            container.insertBefore(paragraph.firstChild, paragraph);
          }
          container.removeChild(paragraph);
        }
      });
    }
    container.querySelectorAll(".ee-rte-caret, .ee-rte-selection").forEach((el) => {
      if (el.classList.contains("ee-rte-selection")) {
        while (el.firstChild) {
          el.parentNode.insertBefore(el.firstChild, el);
        }
      }
      el.remove();
    });
    return container.innerHTML;
  }
  #applyExternalValue() {
    this.#debugLog("#applyExternalValue()", {
      hasView: !!this.#view,
      lastSerialized: this.#lastSerialized,
      initialMarkup: this.#initialMarkup
    });
    const html = (typeof this.#lastSerialized === "string" ? this.#lastSerialized : null) ?? this.#initialMarkup ?? "";
    if (!this.#view) {
      if (this.#editorElement) {
        this.#editorElement.innerHTML = html;
      }
      this.#lastSerialized = html;
      return;
    }
    const schema2 = this.#schemaPackage?.schema;
    if (!schema2) return;
    const nextDoc = this.#parseDoc(html, schema2);
    if (!nextDoc) return;
    const plugins = this.#view.state.plugins;
    const pm = this.#pm;
    if (!pm) return;
    const nextState = pm.EditorState.create({
      schema: schema2,
      doc: nextDoc,
      plugins
    });
    this.#view.updateState(nextState);
    this.#lastSerialized = html;
    this.#clearInlinePlaceholder();
  }
  #captureInitialValue() {
    this.#debugLog("#captureInitialValue()");
    const fromLightDom = this.#initialMarkup || "";
    this.#lastSerialized = fromLightDom;
  }
  #adoptTargetContent() {
    this.#debugLog("#adoptTargetContent()");
    const target = this.parentElement;
    if (!target || !this.#isEligibleAdoptionTarget(target)) return;
    const nodes2 = Array.from(target.childNodes || []).filter((node) => node !== this);
    if (!nodes2.length) return;
    const doc3 = this.ownerDocument || document;
    const container = doc3.createElement("div");
    nodes2.forEach((node) => container.appendChild(node));
    const markup = container.innerHTML;
    this.#initialMarkup = markup;
    this.#lastSerialized = markup;
  }
  #isEligibleAdoptionTarget(target) {
    if (!target) return false;
    if (target.hasAttribute("data-ee-rte-target")) return true;
    if (target.classList?.contains?.("ee-rte-target")) return true;
    if (target.hasAttribute?.("data-ee-node-id")) return true;
    return false;
  }
  #handleTransaction(tr2, state) {
    const selectionDetail = this.#createSelectionDetail(state);
    if (tr2.docChanged) {
      const html = this.#serializeDoc(state.doc);
      this.#lastSerialized = html;
      this.dispatchEvent(
        new CustomEvent("rte-change", {
          detail: {
            selection: selectionDetail
          },
          bubbles: true,
          composed: true
        })
      );
    }
    this.#clearInlinePlaceholder();
    const commandState = this.#pm ? getCommandState({
      view: this.#view,
      pm: this.#pm,
      schemaConfig: this.getSchemaConfig(),
      selectionDetail
    }) : null;
    this.#dispatchContext(selectionDetail, commandState);
  }
  /**
   * @param {import("prosemirror-state").EditorState} state
   * @returns {RteSelectionPayload | null}
   */
  #createSelectionDetail(state) {
    if (!state) return null;
    const { selection } = state;
    const anchor = selection?.anchor ?? 0;
    const head = selection?.head ?? anchor;
    const from2 = selection?.from ?? anchor;
    const to2 = selection?.to ?? head;
    const markMap = /* @__PURE__ */ new Map();
    if (selection?.empty) {
      const stored = state.storedMarks || selection.$from?.marks?.() || [];
      stored.forEach((mark) => {
        markMap.set(mark.type.name, mark.attrs);
      });
    } else {
      state.doc.nodesBetween(from2, to2, (node) => {
        if (!node.isText) return true;
        node.marks.forEach((mark) => {
          if (!markMap.has(mark.type.name)) {
            markMap.set(mark.type.name, mark.attrs);
          }
        });
        return true;
      });
    }
    const activeMarks = Array.from(markMap.keys());
    const activeLink = markMap.has("link") ? { ...markMap.get("link") } : null;
    const parent = selection?.$from?.parent || null;
    const block = parent ? {
      type: parent.type.name,
      attrs: { ...parent.attrs }
    } : null;
    let reference = null;
    state.doc.nodesBetween(from2, Math.max(from2, to2 || from2), (node) => {
      if (node.type?.name === "ee_reference") {
        reference = { ...node.attrs };
        return false;
      }
      if (node.type?.name === "ee_inline_content_inline") {
        reference = { ...node.attrs, type: "content" };
        return false;
      }
      return true;
    });
    if (!reference && selection?.empty) {
      const after = selection.$from?.nodeAfter;
      if (after?.type?.name === "ee_reference") {
        reference = { ...after.attrs };
      } else if (after?.type?.name === "ee_inline_content_inline") {
        reference = { ...after.attrs, type: "content" };
      }
      const before = selection.$from?.nodeBefore;
      if (!reference && before?.type?.name === "ee_reference") {
        reference = { ...before.attrs };
      } else if (!reference && before?.type?.name === "ee_inline_content_inline") {
        reference = { ...before.attrs, type: "content" };
      }
    }
    return {
      anchor,
      head,
      empty: selection?.empty ?? true,
      marks: activeMarks,
      block,
      link: activeLink,
      reference
    };
  }
  /**
   * @returns {RteSchemaConfig}
   */
  getSchemaConfig() {
    return this.#computeSchemaConfig();
  }
};
customElements.define("ee-rte", EeRte);

// src/stores/editor/richtext-store.js
var cloneData = (value) => {
  if (value == null) return null;
  if (Array.isArray(value)) {
    return value.map((item) => cloneData(item));
  }
  if (typeof value === "object") {
    const output = {};
    for (const [key, entry] of Object.entries(value)) {
      output[key] = cloneData(entry);
    }
    return output;
  }
  return value;
};
var INLINE_EDITOR_SELECTOR = "ee-rte[data-ee-inline-editor]";
var INLINE_MARKER_ATTR = "data-ee-inline-editor";
var RTE_TARGET_ATTR = "data-ee-rte-target";
var AUTO_CONTAINER_ATTR = "data-ee-inline-container";
var INLINE_CONFIG_SIGNATURE = Symbol("inline-config-signature");
var normalizeSlotName = (value) => {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed ? trimmed : null;
};
var InlineRteController = class {
  #host;
  #editorStore;
  #activeRte = null;
  #activeTarget = null;
  #activeElement = null;
  #initialNodeSnapshots = /* @__PURE__ */ new WeakMap();
  #newlyCreatedContainers = /* @__PURE__ */ new WeakSet();
  #activeSlotName = null;
  #pointerFocusHandlers = /* @__PURE__ */ new WeakMap();
  #pointerClickBlockers = /* @__PURE__ */ new WeakMap();
  #logEnabled = EDITOR_DEBUG === true;
  #syncInvocation = 0;
  #activeSyncCallId = 0;
  #onRteKeyDown = (event) => {
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      this.#cancelActiveEdit();
    }
  };
  #onRteChange = (event) => {
    const rte = event?.currentTarget || event?.target || null;
    const target = this.#activeTarget;
    if (!rte || !target) {
      return;
    }
    void this.serializeRteValue(rte, target);
  };
  #onRteClick = (event) => {
    const isModifierClick = event.metaKey || event.ctrlKey;
    if (!isModifierClick) {
      event.stopPropagation();
    }
  };
  constructor(host, editorStore) {
    this.#host = host;
    this.#editorStore = editorStore;
  }
  #log(level, message, data = {}) {
    if (!this.#logEnabled) return;
    const logger = console[level] || console.log;
    logger.call(console, `[InlineRteController] ${message}`, data);
  }
  get activeTarget() {
    return this.#activeTarget;
  }
  get activeElement() {
    return this.#activeElement;
  }
  get activeRte() {
    return this.#activeRte;
  }
  setup() {
    if (!this.#editorStore) return () => {
    };
    return () => {
      this.dispose();
    };
  }
  /**
   * Called from canvas-interactions on each click.
   * First click: stores action reference, no activation
   * Same click (multi-call): sees same action, no activation  
   * Second click: different action, activates inline editor
   * @param {HTMLElement} element - The clicked/selected element
   * @param {Object} action - The lastAction object from editorStore
   */
  async tryActivateInlineEdit(element, action) {
    if (!element) return;
    const store = this.#editorStore;
    const currentSlot = store?.currentSlot || "default";
    const formatting = store?.toolbarActions?.textFormatting || null;
    const isInlineEditable = formatting?.inlineEditable === true;
    if (!isInlineEditable) {
      if (this.#activeRte) this.dispose();
      return;
    }
    const storedAction = element._eeClickAction;
    if (!storedAction) {
      element._eeClickAction = action;
      console.log("[InlineRteController.tryActivateInlineEdit] First click - stored action");
      return;
    }
    if (storedAction === action) {
      console.log("[InlineRteController.tryActivateInlineEdit] Same click - ignoring");
      return;
    }
    console.log("[InlineRteController.tryActivateInlineEdit] Second click - activating");
    delete element._eeClickAction;
    const meta = action?.meta || {};
    const coords = Number.isFinite(meta.x) && Number.isFinite(meta.y) ? { left: meta.x, top: meta.y, clientX: meta.x, clientY: meta.y } : null;
    const resolvedTarget = this.#resolveTarget(currentSlot);
    const targetElement = resolvedTarget?.element;
    if (!targetElement) return;
    const slotConfig = this.#getSlotConfig(currentSlot);
    const config = this.#buildRteConfig(formatting, slotConfig);
    await this.#ensureInlineEditor(targetElement, config, currentSlot, 0, {
      shouldActivate: true,
      shouldFocus: true,
      coords
    });
  }
  dispose() {
    const target = this.#activeTarget;
    const activeElement = this.#activeElement || target;
    const slotName = this.#editorStore?.currentSlot || null;
    const slotConfig = this.#getSlotConfig(slotName) || {};
    let finalHtml = target?.innerHTML || "";
    if (this.#activeRte) {
      if (activeElement) {
        finalHtml = this.serializeRteValue(this.#activeRte, activeElement);
      }
      this.#activeRte.removeEventListener("rte-change", this.#onRteChange);
      this.#activeRte.removeEventListener("keydown", this.#onRteKeyDown);
      this.#activeRte.destroy?.();
      this.#activeRte.remove();
      this.#activeRte = null;
    } else if (finalHtml) {
      finalHtml = this.#normalizeSerializedMarkup(finalHtml, slotConfig);
    }
    if (target && target.isConnected) {
      target.removeAttribute(RTE_TARGET_ATTR);
    }
    if (target && activeElement) {
      console.log("[InlineRteController] dispose final content:", finalHtml);
      const normalizedHtml = typeof finalHtml === "string" ? finalHtml : "";
      this.#applyFinalMarkup(activeElement, normalizedHtml);
    }
    this.#activeTarget = null;
    this.#activeElement = null;
    this.#activeSlotName = null;
    if (activeElement) {
      delete activeElement._eeClickAction;
    }
    if (activeElement) {
      this.#clearPointerFocus(activeElement);
    }
    if (activeElement) {
      this.#initialNodeSnapshots.delete(activeElement);
      this.#newlyCreatedContainers.delete(activeElement);
    }
    this.#editorStore?.clearRteContext();
    this.#editorStore.history?.scheduleSnapshot?.();
  }
  #normalizeSerializedMarkup(html, schemaConfig) {
    if (!html || !schemaConfig) {
      return html;
    }
    const multiline = schemaConfig.multiline !== false;
    const requiresWrapper = multiline === false;
    if (requiresWrapper) {
      return html;
    }
    const template = document.createElement("template");
    template.innerHTML = html;
    const { content } = template;
    let elementCount = 0;
    for (const node of Array.from(content.childNodes)) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        elementCount += 1;
      } else if (node.nodeType === Node.TEXT_NODE && node.textContent?.trim()) {
        return html;
      }
    }
    if (elementCount !== 1) {
      return html;
    }
    const wrapper = content.firstElementChild;
    if (!wrapper) {
      return html;
    }
    const expectedTag = this.#resolveConfigTag(schemaConfig) || "div";
    if (wrapper.tagName?.toLowerCase() !== expectedTag) {
      return html;
    }
    const hasMeaningfulAttributes = Array.from(wrapper.attributes || []).some(
      (attr) => {
        const name = attr.name?.toLowerCase?.() || "";
        if (name.startsWith("data-ee-node-id")) return false;
        if (name.startsWith("data-ee-node")) return false;
        if (name === "slot" && !attr.value) return false;
        return true;
      }
    );
    if (hasMeaningfulAttributes) {
      return html;
    }
    return wrapper.innerHTML;
  }
  #activateInlineEditor(rte, shouldFocus, selectionOptions = null) {
    if (!rte || !shouldFocus) return;
    rte.focusEditor?.();
    let selectionApplied = false;
    const options = selectionOptions && typeof selectionOptions === "object" ? selectionOptions : null;
    if (options) {
      if (options.coords) {
        selectionApplied = rte.setSelectionFromPoint?.(options.coords) === true;
      }
      if (!selectionApplied) {
        const anchor = Number.isInteger(options.anchor) ? options.anchor : Number.isInteger(options.position) ? options.position : null;
        if (anchor != null) {
          const head = Number.isInteger(options.head) ? options.head : anchor;
          selectionApplied = rte.setSelection?.({ anchor, head }) === true;
        }
      }
    }
    if (!selectionApplied) {
      rte.setSelection?.({ anchor: 0, head: 0 });
    }
  }
  #clearPointerFocus(target) {
    if (!target) return;
    const pointerHandler = this.#pointerFocusHandlers.get(target);
    if (pointerHandler) {
      target.removeEventListener("pointerdown", pointerHandler, true);
      this.#pointerFocusHandlers.delete(target);
    }
    const clickBlocker = this.#pointerClickBlockers.get(target);
    if (clickBlocker) {
      target.removeEventListener("click", clickBlocker, true);
      this.#pointerClickBlockers.delete(target);
    }
  }
  #preparePointerFocus(target, rte, shouldFocus) {
    if (!target || !rte) return;
    this.#clearPointerFocus(target);
    if (shouldFocus) return;
    const pointerHandler = (event) => {
      if (!this.#activeRte || this.#activeRte !== rte) {
        this.#clearPointerFocus(target);
        return;
      }
      target.removeEventListener("pointerdown", pointerHandler, true);
      if (typeof event.stopPropagation === "function") {
        event.stopPropagation();
      }
      if (typeof event.preventDefault === "function") {
        event.preventDefault();
      }
      const hasPointerCoords = Number.isFinite(event.clientX) && Number.isFinite(event.clientY);
      const coords = hasPointerCoords ? {
        left: event.clientX,
        top: event.clientY,
        clientX: event.clientX,
        clientY: event.clientY,
        x: Number.isFinite(event.x) ? event.x : event.clientX,
        y: Number.isFinite(event.y) ? event.y : event.clientY
      } : null;
      requestAnimationFrame(() => {
        if (this.#activeRte === rte) {
          if (coords) {
            this.#activateInlineEditor(rte, true, { coords });
          } else {
            this.#activateInlineEditor(rte, true);
          }
        }
      });
      const suppressClick = (clickEvent) => {
        clickEvent.stopPropagation();
        clickEvent.preventDefault();
        target.removeEventListener("click", suppressClick, true);
        this.#pointerClickBlockers.delete(target);
      };
      target.addEventListener("click", suppressClick, true);
      this.#pointerClickBlockers.set(target, suppressClick);
      this.#pointerFocusHandlers.delete(target);
    };
    target.addEventListener("pointerdown", pointerHandler, true);
    this.#pointerFocusHandlers.set(target, pointerHandler);
  }
  #resolveTarget(slotName) {
    const editingElement = this.#editorStore?.editingElement || null;
    if (!editingElement) {
      return null;
    }
    if (!editingElement.isConnected) {
      const snapshot = this.#initialNodeSnapshots.get(editingElement);
      const parent = snapshot?.parent || editingElement.parentElement || null;
      if (!parent || !parent.isConnected) {
        this.#editorStore?.selection?.clearSelection?.();
      }
      return null;
    }
    if (slotName && slotName !== "default") {
      return this.#ensureSlotContainerTarget(editingElement, slotName);
    }
    return { element: editingElement };
  }
  #findAssignedSlotElement(host, slotName) {
    const children = Array.from(host.children || []);
    for (const child of children) {
      const childSlot = child.getAttribute?.("slot");
      if (childSlot === slotName) {
        return child;
      }
    }
    return null;
  }
  #getDomStore() {
    return this.#editorStore?.domStore || this.#host?.store?.domStore || null;
  }
  #resolveConfigTag(config) {
    if (!config) return null;
    if (typeof config.tag !== "string") return null;
    const trimmed = config.tag.trim();
    return trimmed ? trimmed.toLowerCase() : null;
  }
  #ensureSlotContainerTarget(host, slotName) {
    if (!host) return null;
    const store = this.#getDomStore();
    const fallbackElement = this.#findAssignedSlotElement(host, slotName);
    if (!store) {
      return fallbackElement ? { element: fallbackElement } : null;
    }
    const desiredSlot = normalizeSlotName(slotName);
    let element = fallbackElement;
    if (!element) {
      const slotConfig = this.#getSlotConfig(slotName);
      const preferredTag = this.#resolveConfigTag(slotConfig);
      element = store.ensureSlotContainer(host, slotName, {
        tag: preferredTag || void 0,
        multiline: slotConfig?.multiline !== false
      });
      if (element) {
        this.#newlyCreatedContainers.add(element);
      }
    }
    if (!element) {
      return null;
    }
    if (normalizeSlotName(element.getAttribute("slot")) !== desiredSlot) {
      store.setElementSlot(element, desiredSlot);
    }
    return { element };
  }
  #applyFinalMarkup(element, html) {
    const store = this.#getDomStore();
    if (!element) return;
    const inputValue = typeof html === "string" ? html : "";
    let nextValue = this.#unwrapMatchingWrapper(element, inputValue);
    const slotName = normalizeSlotName(element.getAttribute("slot"));
    const slotConfig = this.#getSlotConfig(slotName, element) || null;
    if (slotConfig?.multiline === false) {
      nextValue = this.#normalizeSingleLineMarkup(element, slotConfig, nextValue);
    }
    const isAutoContainer = element.hasAttribute?.(AUTO_CONTAINER_ATTR);
    if (isAutoContainer && !this.#markupHasMeaningfulContent(nextValue)) {
      const snapshot = this.#initialNodeSnapshots.get(element);
      if (snapshot && snapshot.existed && snapshot.html) {
        element.innerHTML = snapshot.html;
        this.#editorStore.history?.scheduleSnapshot?.();
        return;
      }
      store?.deleteElement?.(element);
      this.#editorStore.history?.scheduleSnapshot?.();
      return;
    }
    element.innerHTML = nextValue;
    this.#editorStore.history?.scheduleSnapshot?.();
  }
  #unwrapMatchingWrapper(element, markup) {
    if (!element) return markup;
    const text = typeof markup === "string" ? markup : "";
    const trimmed = text.trim();
    if (!trimmed.startsWith("<") || !trimmed.endsWith(">")) {
      return text;
    }
    const template = document.createElement("template");
    template.innerHTML = trimmed;
    const { content } = template;
    if (!content || content.childElementCount !== 1) {
      return text;
    }
    const wrapper = content.firstElementChild;
    if (!wrapper || wrapper.tagName !== element.tagName) {
      return text;
    }
    if (!this.#attributesComparable(wrapper, element)) {
      return text;
    }
    const siblings = Array.from(content.childNodes || []).filter(
      (node) => node !== wrapper && !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
    );
    if (siblings.length > 0) {
      return text;
    }
    return wrapper.innerHTML;
  }
  #attributesComparable(source, target) {
    if (!source || !target) return false;
    const sourceAttrs = Array.from(source.attributes || []);
    for (const attr of sourceAttrs) {
      const name = attr.name;
      const value = attr.value;
      if (target.getAttribute(name) !== value) {
        return false;
      }
    }
    return true;
  }
  #normalizeSingleLineMarkup(element, slotConfig, markup) {
    if (!markup) {
      return markup;
    }
    const text = typeof markup === "string" ? markup : "";
    if (!text.trim()) {
      return text;
    }
    const container = document.createElement("div");
    container.innerHTML = text;
    const hostTag = element.tagName?.toLowerCase?.() || "";
    const configTag = this.#resolveConfigTag(slotConfig);
    const flattenable = /* @__PURE__ */ new Set(["p", "span"]);
    if (hostTag) flattenable.add(hostTag);
    if (configTag) flattenable.add(configTag);
    const prune = (node) => {
      if (!node) return;
      const childNodes = Array.from(node.childNodes || []);
      childNodes.forEach((child) => {
        if (child.nodeType === Node.TEXT_NODE) {
          return;
        }
        if (child.nodeType === Node.ELEMENT_NODE) {
          prune(child);
        }
      });
      if (node !== container && node.nodeType === Node.ELEMENT_NODE) {
        const el = (
          /** @type {Element} */
          node
        );
        if (!el.childNodes.length) {
          el.remove();
          return;
        }
        const tag3 = el.tagName?.toLowerCase?.() || "";
        const canFlatten = flattenable.has(tag3) && el.attributes?.length === 0 && el.childNodes.length > 0;
        if (canFlatten) {
          const parent = el.parentNode;
          if (!parent) return;
          while (el.firstChild) {
            parent.insertBefore(el.firstChild, el);
          }
          parent.removeChild(el);
        }
      }
    };
    prune(container);
    return container.innerHTML;
  }
  #stripRedundantWrappers(html, schemaConfig) {
    const text = typeof html === "string" ? html : "";
    const trimmed = text.trim();
    if (!trimmed) {
      return "";
    }
    const allowedTags = /* @__PURE__ */ new Set();
    const preferred = this.#resolveConfigTag(schemaConfig);
    if (preferred) allowedTags.add(preferred);
    const legacyWrapper = schemaConfig?.wrapperTag?.toLowerCase?.() || null;
    const legacyInline = schemaConfig?.inlineTag?.toLowerCase?.() || null;
    if (legacyWrapper) allowedTags.add(legacyWrapper);
    if (legacyInline) allowedTags.add(legacyInline);
    if (!allowedTags.size) {
      return text;
    }
    const template = document.createElement("template");
    template.innerHTML = trimmed;
    const { content } = template;
    this.#pruneEmptyWrappers(content, allowedTags);
    while (this.#unwrapSingleWrapper(content, allowedTags)) {
      this.#pruneEmptyWrappers(content, allowedTags);
    }
    const container = document.createElement("div");
    container.appendChild(content.cloneNode(true));
    return container.innerHTML;
  }
  #pruneEmptyWrappers(root, allowedTags) {
    const nodes2 = Array.from(root.childNodes || []);
    nodes2.forEach((node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        return;
      }
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = (
          /** @type {Element} */
          node
        );
        this.#pruneEmptyWrappers(element, allowedTags);
        const tag3 = element.tagName?.toLowerCase?.() || "";
        if (allowedTags.has(tag3) && !this.#fragmentHasMeaningfulContent(element)) {
          if (element.parentNode === root) {
            root.removeChild(element);
          } else {
            element.remove();
          }
        }
      }
    });
  }
  #unwrapSingleWrapper(fragment, allowedTags) {
    const childNodes = Array.from(fragment.childNodes || []).filter((node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        return !!node.textContent?.trim();
      }
      return true;
    });
    if (childNodes.length !== 1) {
      return false;
    }
    const wrapper = childNodes[0];
    if (wrapper.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    const element = (
      /** @type {Element} */
      wrapper
    );
    const tag3 = element.tagName?.toLowerCase?.() || "";
    if (!allowedTags.has(tag3)) {
      return false;
    }
    if (!this.#canUnwrapWrapper(element)) {
      return false;
    }
    while (element.firstChild) {
      fragment.insertBefore(element.firstChild, element);
    }
    element.remove();
    return true;
  }
  #canUnwrapWrapper(element) {
    if (!element) return false;
    const attrs = Array.from(element.attributes || []);
    if (!attrs.length) {
      return true;
    }
    return attrs.every((attr) => {
      const name = attr.name?.toLowerCase?.() || "";
      if (!name) return false;
      if (name.startsWith("data-ee-node")) return true;
      if (name === "contenteditable") return true;
      if (name === "spellcheck") return true;
      return false;
    });
  }
  serializeRteValue(rte, targetElement = null) {
    if (!rte) return "";
    const value = rte.getValue?.() ?? rte.value ?? "";
    const config = rte.getSchemaConfig?.() ?? null;
    const slotName = targetElement ? normalizeSlotName(targetElement.getAttribute("slot")) : this.#editorStore?.currentSlot || null;
    this.#log("debug", "serializeRteValue", {
      callId: this.#activeSyncCallId,
      slotName,
      rawValue: value,
      schemaConfig: config
    });
    if (!config) {
      return value;
    }
    const multiline = config.multiline !== false;
    const configTag = this.#resolveConfigTag(config);
    const wrapperTag = configTag || (multiline ? "div" : "span");
    const needsWrapper = multiline === false;
    const sanitizedValue = this.#stripRedundantWrappers(value, config);
    this.#log("debug", "serializeRteValue sanitized", {
      callId: this.#activeSyncCallId,
      slotName,
      sanitizedValue
    });
    const wrappedValue = needsWrapper ? `<${wrapperTag}>${sanitizedValue}</${wrapperTag}>` : sanitizedValue;
    const normalized = this.#normalizeSerializedMarkup(wrappedValue, config);
    const slotConfig = this.#getSlotConfig(slotName, targetElement) || null;
    const effectiveSlotConfig = slotConfig || {
      multiline,
      tag: configTag
    };
    this.#log("debug", "serializeRteValue slotConfig", {
      callId: this.#activeSyncCallId,
      slotName,
      slotConfig: effectiveSlotConfig
    });
    if (effectiveSlotConfig?.multiline === false) {
      const effectiveTag = this.#resolveConfigTag(effectiveSlotConfig);
      const host = targetElement || (effectiveTag ? document.createElement(effectiveTag) : document.createElement("div"));
      return this.#normalizeSingleLineMarkup(
        host,
        effectiveSlotConfig,
        normalized
      );
    }
    return normalized;
  }
  #getSlotConfig(slotName, element = null) {
    const actions = this.#editorStore?.toolbarActions;
    const slotsApi = actions?.slots;
    if (!slotsApi || typeof slotsApi.getConfig !== "function") return null;
    const config = slotsApi.getConfig(slotName);
    if (config) {
      return config;
    }
    const host = element?.parentElement || this.#editorStore?.editingElement || null;
    if (host && this.#editorStore?.selection) {
      const normalized = this.#editorStore.selection.getNormalizedSlotConfig(
        host,
        slotName
      );
      if (normalized) {
        return normalized;
      }
    }
    return null;
  }
  #buildRteConfig(formatting, slotConfig) {
    const hasMarks = Array.isArray(formatting.allowedMarks) ? formatting.allowedMarks.length > 0 : false;
    const hasAlignments = Array.isArray(formatting.allowedAlignments) ? formatting.allowedAlignments.length > 0 : false;
    const hasLists = Array.isArray(formatting.allowedLists) ? formatting.allowedLists.length > 0 : false;
    const hasLinks = formatting.allowLink === true;
    const multiline = formatting.multiline !== false;
    const mode = hasMarks || hasAlignments || hasLists || hasLinks ? "rich" : "plain";
    const placeholder = typeof slotConfig?.placeholder === "string" ? slotConfig.placeholder : "";
    const tag3 = this.#resolveConfigTag(slotConfig);
    return {
      multiline,
      mode,
      placeholder,
      tag: tag3
    };
  }
  async #ensureInlineEditor(target, config, slotName = null, callId = null, activation = {}) {
    this.#log("debug", "ensureInlineEditor", {
      callId: callId ?? this.#activeSyncCallId,
      targetTag: target?.tagName?.toLowerCase?.() || null,
      connected: target?.isConnected ?? false,
      slotName
    });
    if (!target) return;
    const shouldAutoFocus = activation?.shouldFocus === true;
    const clickCoords = activation?.coords || null;
    target.setAttribute(RTE_TARGET_ATTR, "inline");
    if (!this.#initialNodeSnapshots.has(target)) {
      const createdForEdit = this.#newlyCreatedContainers.has(target);
      if (createdForEdit) {
        this.#newlyCreatedContainers.delete(target);
      }
      const originalHtml = target?.innerHTML ?? "";
      const parent = target?.parentElement ?? null;
      const domIndex2 = parent ? Array.from(parent.children || []).indexOf(target) : -1;
      this.#initialNodeSnapshots.set(target, {
        html: createdForEdit ? "" : originalHtml,
        existed: !createdForEdit,
        parent,
        domIndex: domIndex2,
        tag: target?.tagName?.toLowerCase?.() || null,
        slot: normalizeSlotName(target?.getAttribute?.("slot"))
      });
    }
    const existing = target.querySelector(INLINE_EDITOR_SELECTOR);
    if (existing) {
      this.#log("debug", "reuse existing inline editor", {
        callId: callId ?? this.#activeSyncCallId
      });
      this.#activeTarget = target;
      this.#activeElement = target;
      this.#activeRte = existing;
      this.#activeSlotName = slotName != null ? normalizeSlotName(slotName) : normalizeSlotName(target.getAttribute("slot")) || "default";
      existing.removeEventListener("rte-change", this.#onRteChange);
      existing.addEventListener("rte-change", this.#onRteChange);
      existing.removeEventListener("click", this.#onRteClick);
      existing.addEventListener("click", this.#onRteClick);
      this.#applyConfig(existing, config);
      this.#primeStoreActiveRte(existing);
      this.#syncRteContext(existing);
      this.#activateInlineEditor(existing, shouldAutoFocus, clickCoords ? { coords: clickCoords } : null);
      this.#preparePointerFocus(target, existing, shouldAutoFocus);
      return;
    }
    const rte = document.createElement("ee-rte");
    rte.setAttribute(INLINE_MARKER_ATTR, "");
    this.#applyConfig(rte, config);
    target.appendChild(rte);
    await customElements.whenDefined("ee-rte");
    const updateReady = rte.getUpdateComplete?.() ?? rte.updateComplete;
    if (updateReady?.then) {
      await updateReady;
    }
    if (typeof rte.whenReady === "function") {
      await rte.whenReady();
    }
    this.#activeTarget = target;
    this.#activeElement = target;
    this.#activeRte = rte;
    rte.addEventListener("rte-change", this.#onRteChange);
    rte.addEventListener("keydown", this.#onRteKeyDown);
    rte.addEventListener("click", this.#onRteClick);
    this.#log("debug", "created inline editor", {
      callId: callId ?? this.#activeSyncCallId
    });
    this.#primeStoreActiveRte(rte);
    this.#syncRteContext(rte);
    this.#activeSlotName = slotName != null ? normalizeSlotName(slotName) : normalizeSlotName(target.getAttribute("slot")) || "default";
    this.#activateInlineEditor(rte, shouldAutoFocus, clickCoords ? { coords: clickCoords } : null);
    this.#preparePointerFocus(target, rte, shouldAutoFocus);
  }
  #applyConfig(rte, config) {
    if (!rte) return;
    const multiline = config.multiline !== false;
    const tag3 = typeof config.tag === "string" && config.tag ? config.tag : null;
    const inlineOptions = {
      mode: config.mode,
      multiline,
      tag: tag3,
      placeholder: config.placeholder || "",
      inlineConfig: config.inlineConfig
    };
    if (!multiline && tag3) {
      inlineOptions.wrapperTag = tag3;
    }
    const signature = this.#computeInlineSignature(inlineOptions);
    if (rte[INLINE_CONFIG_SIGNATURE] === signature) {
      return;
    }
    if (typeof rte.configureInline === "function") {
      rte.configureInline(inlineOptions);
    } else {
      rte.multiline = multiline;
      rte.plain = config.mode === "plain";
      rte.placeholder = config.placeholder || "";
      rte.inlineOptions = inlineOptions;
    }
    rte[INLINE_CONFIG_SIGNATURE] = signature;
  }
  #computeInlineSignature(options) {
    if (!options || typeof options !== "object") {
      return "null";
    }
    const serialize = (value) => {
      if (value == null) return "";
      if (typeof value === "function") {
        return `fn:${value.name || "anonymous"}`;
      }
      if (Array.isArray(value)) {
        return `[${value.map((entry) => serialize(entry)).join(",")}]`;
      }
      if (typeof value === "object") {
        const entries = Object.entries(value).map(([key, entry]) => [key, serialize(entry)]).sort(([a23], [b12]) => a23.localeCompare(b12));
        return `{${entries.map(([key, entry]) => `${key}:${entry}`).join(",")}}`;
      }
      return String(value);
    };
    return [
      String(options.mode || ""),
      options.multiline !== false ? "1" : "0",
      String(options.tag || ""),
      String(options.wrapperTag || ""),
      String(options.placeholder || ""),
      serialize(options.inlineConfig)
    ].join("|");
  }
  #markupHasMeaningfulContent(markup) {
    if (!markup || !markup.trim()) {
      return false;
    }
    const template = document.createElement("template");
    template.innerHTML = markup;
    return this.#fragmentHasMeaningfulContent(template.content);
  }
  #fragmentHasMeaningfulContent(fragment) {
    const nodes2 = Array.from(fragment?.childNodes ?? []);
    for (const node of nodes2) {
      if (this.#nodeHasMeaningfulContent(node)) {
        return true;
      }
    }
    return false;
  }
  #nodeHasMeaningfulContent(node) {
    if (!node) return false;
    if (node.nodeType === Node.TEXT_NODE) {
      return !!node.textContent && !!node.textContent.trim();
    }
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    const element = node;
    const tag3 = element.tagName?.toLowerCase?.() || "";
    if (tag3 === "ee-rte") {
      return false;
    }
    if (element.hasAttribute?.(AUTO_CONTAINER_ATTR)) {
      return Array.from(element.childNodes || []).some(
        (child) => this.#nodeHasMeaningfulContent(child)
      );
    }
    if (!element.childNodes || element.childNodes.length === 0) {
      return true;
    }
    return Array.from(element.childNodes || []).some(
      (child) => this.#nodeHasMeaningfulContent(child)
    );
  }
  #cancelActiveEdit() {
    const element = this.#activeElement || this.#activeTarget || null;
    const store = this.#getDomStore();
    const snapshot = element ? this.#initialNodeSnapshots.get(element) : null;
    if (this.#activeRte) {
      this.#activeRte.removeEventListener("rte-change", this.#onRteChange);
      this.#activeRte.removeEventListener("keydown", this.#onRteKeyDown);
      this.#activeRte.destroy?.();
      this.#activeRte.remove();
      this.#activeRte = null;
    }
    if (element && store && snapshot) {
      if (snapshot.existed) {
        element.innerHTML = snapshot.html;
      } else {
        store.deleteElement?.(element);
      }
    }
    this.dispose();
  }
  #syncRteContext(rte) {
    if (!rte) return;
    const richText = this.#editorStore?.richText;
    if (!richText) {
      queueMicrotask(() => this.#syncRteContext(rte));
      return;
    }
    const view = rte.getEditorView?.() ?? null;
    const pm = rte.getProseMirrorToolkit?.() ?? null;
    if (!view || !pm) {
      return;
    }
    const schemaConfig = rte.getSchemaConfig?.() ?? {};
    const selectionDetail = deriveSelectionDetail(view);
    const commandState = getCommandState({
      view,
      pm,
      schemaConfig,
      selectionDetail
    });
    this.#editorStore.setRteContext(rte, {
      selection: selectionDetail,
      commands: commandState
    });
  }
  #primeStoreActiveRte(rte) {
    if (!rte) return;
    const richText = this.#editorStore?.richText;
    if (!richText) {
      queueMicrotask(() => this.#primeStoreActiveRte(rte));
      return;
    }
    if (richText.activeRte === rte) {
      return;
    }
    this.#editorStore.setRteContext(rte, {
      selection: richText.context?.selection || null,
      commands: richText.context?.commands || null
    });
  }
};
var EditorRichTextStore = class {
  static observableActions = ["setRteContext", "clearRteContext"];
  #editorStore;
  #controller = null;
  #cleanup = null;
  #hostElement = null;
  #context = { selection: null, commands: null };
  constructor(editorStore) {
    this.#editorStore = editorStore;
    this.activeRte = null;
  }
  get context() {
    return this.#context;
  }
  setRteContext(rte, detail = {}) {
    this.activeRte = rte || null;
    this.#context = {
      selection: cloneData(detail?.selection),
      commands: cloneData(detail?.commands)
    };
  }
  clearRteContext() {
    this.setRteContext(null, null);
  }
  bindInlineEditing(host) {
    if (host === this.#hostElement) {
      return;
    }
    if (this.#cleanup) {
      this.#cleanup();
      this.#cleanup = null;
    }
    this.#hostElement = host ?? null;
    if (!this.#hostElement || !this.#editorStore) {
      this.#controller = null;
      return;
    }
    this.#controller = new InlineRteController(this.#hostElement, this.#editorStore);
    this.#cleanup = this.#controller.setup();
  }
  disposeInlineEditing() {
    if (this.#cleanup) {
      this.#cleanup();
      this.#cleanup = null;
    }
    this.#hostElement = null;
    this.#controller = null;
  }
  exitInlineEditing() {
    this.#controller?.dispose?.();
  }
  tryActivateInlineEdit(element, action) {
    this.#controller?.tryActivateInlineEdit?.(element, action);
  }
  get inlineTarget() {
    return this.#controller?.activeTarget ?? null;
  }
  get inlineEditor() {
    return this.#controller?.activeRte ?? null;
  }
};
makeObservable(EditorRichTextStore);

// src/stores/editor-store.js
var EditorStore = class {
  static observableActions = [
    "setCurrentElementId",
    "setEditingElement",
    "setEEToolbarPosition",
    "setToolbarOverlayOpen",
    "setOpenTool",
    "elementMoved",
    "pushUndoState",
    "undo",
    "redo",
    "clearUndoRedo",
    "setEditorElement",
    "scheduleSnapshot",
    "captureSnapshot",
    "scheduleAutoSave",
    "performAutoSave",
    "markSaved",
    "setSidebarOpen",
    "handleEscape",
    "clearSelection",
    "setLastAction",
    "clearRteContext",
    "attachDomStore"
  ];
  static computedProperties = [
    "isEEToolbarVisible",
    "canUndo",
    "canRedo",
    "elementSchema",
    "canReorder",
    "toolbarConfig",
    "toolbarActions",
    "canSelectParent",
    "context"
  ];
  currentElementId = null;
  isLoadingContent = false;
  debugLogs = [];
  lastUserAction = null;
  lastAction = null;
  sidebarOpen = true;
  suppressFocus = false;
  themeColor = "light";
  domStore = null;
  #domStoreCleanup = null;
  #selection = new EditorSelectionStore(this);
  #history = new EditorHistoryStore(this);
  #toolbar = new EditorToolbarStore(this, this.#selection, this.#history);
  #richText = new EditorRichTextStore(this);
  constructor() {
    track(this.#selection, this);
    track(this.#toolbar, this);
  }
  log() {
  }
  get selection() {
    return this.#selection;
  }
  get history() {
    return this.#history;
  }
  get toolbar() {
    return this.#toolbar;
  }
  get richText() {
    return this.#richText;
  }
  get context() {
    return this.selection.context;
  }
  get canSelectParent() {
    return this.selection.canSelectParent;
  }
  get lastSelectionInputType() {
    return this.selection.lastSelectionInputType;
  }
  get isEditorOpen() {
    return !!this.currentElementId;
  }
  get editingElement() {
    return this.selection.editingElement;
  }
  set editingElement(element) {
    this.selection.setEditingElement(element);
  }
  get currentSlot() {
    return this.selection.currentSlot;
  }
  set currentSlot(slotName) {
    this.selection.setCurrentSlot(slotName);
  }
  get slotOnlySelection() {
    return this.selection.slotOnlySelection;
  }
  set slotOnlySelection(on2) {
    this.selection.slotOnlySelection = !!on2;
  }
  setRteContext(rte, detail = {}) {
    this.#richText.setRteContext(rte, detail);
    this.toolbar.setToolbarActions(null);
  }
  clearRteContext() {
    this.#richText.clearRteContext();
    this.toolbar.setToolbarActions(null);
  }
  exitInlineEditing() {
    this.#richText.exitInlineEditing();
  }
  get eeToolbarVisible() {
    return this.toolbar.isEEToolbarVisible;
  }
  get eeToolbarElement() {
    return this.toolbar.eeToolbarElement;
  }
  get toolbarOverlayOpen() {
    return this.toolbar.toolbarOverlayOpen;
  }
  get toolbarActionsData() {
    return this.toolbar.toolbarActionsData;
  }
  get saveIndicatorVisible() {
    return this.history.saveIndicatorVisible;
  }
  get canUndo() {
    return this.history.canUndo;
  }
  get canRedo() {
    return this.history.canRedo;
  }
  get elementSchema() {
    return this.toolbar.elementSchema;
  }
  get canReorder() {
    return this.toolbar.canReorder;
  }
  get toolbarConfig() {
    return this.toolbar.toolbarConfig;
  }
  get toolbarActions() {
    return this.toolbar.toolbarActions;
  }
  get undoStack() {
    return this.history.undoStack;
  }
  get redoStack() {
    return this.history.redoStack;
  }
  get editorElement() {
    return this.history.editorElement;
  }
  get maxHistorySize() {
    return this.history.maxHistorySize;
  }
  set maxHistorySize(value) {
    this.history.maxHistorySize = value;
  }
  get snapshotDelay() {
    return this.history.snapshotDelay;
  }
  set snapshotDelay(value) {
    this.history.snapshotDelay = value;
  }
  get isUndoRedoInProgress() {
    return this.history.isUndoRedoInProgress;
  }
  set isUndoRedoInProgress(value) {
    this.history.isUndoRedoInProgress = value;
  }
  get debugState() {
    if (!EDITOR_DEBUG) return null;
    return this.context;
  }
  getKnownSlots(element) {
    return this.selection.getKnownSlots(element);
  }
  hasAuthoringSchema(element) {
    return this.selection.hasAuthoringSchema(element);
  }
  isAuthoringLocked(element) {
    return this.selection.isAuthoringLocked(element);
  }
  getNormalizedSlotConfig(element, slotName) {
    return this.selection.getNormalizedSlotConfig(element, slotName);
  }
  slotSupportsTextEditing(element, slotName) {
    return this.selection.slotSupportsTextEditing(element, slotName);
  }
  resolveInlineEditableSlotContext(element) {
    return this.selection.resolveInlineEditableSlotContext(element);
  }
  setCurrentElementId(id) {
    if (this.history.autoSaveTimeout) {
      clearTimeout(this.history.autoSaveTimeout);
      this.history.autoSaveTimeout = null;
    }
    this.currentElementId = id || null;
  }
  setEditingElement(element) {
    this.selection.setEditingElement(element);
  }
  setEEToolbarPosition(x5, y5) {
    this.toolbar.setEEToolbarPosition(x5, y5);
  }
  setToolbarOverlayOpen(open) {
    this.toolbar.setToolbarOverlayOpen(open);
  }
  setOpenTool(tool) {
    this.toolbar.setOpenTool(tool);
  }
  elementMoved(element) {
    this.toolbar.elementMoved(element);
  }
  getSurfaceBounds() {
    return this.toolbar.getSurfaceBounds();
  }
  setEditorElement(element) {
    this.history.setEditorElement(element);
  }
  attachDomStore(store) {
    if (this.#domStoreCleanup) {
      this.#domStoreCleanup();
      this.#domStoreCleanup = null;
    }
    this.domStore = store;
    if (this.domStore) {
      const untrack = track(this.domStore, this);
      const unMutation = this.domStore.onMutation(() => {
        if (!this.richText.activeRte) {
          console.log("[EditorStore] Mutation detected, scheduling snapshot");
          this.history.scheduleSnapshot();
        }
      });
      this.#domStoreCleanup = () => {
        untrack();
        unMutation();
      };
    }
  }
  scheduleSnapshot() {
    this.history.scheduleSnapshot();
  }
  captureSnapshot() {
    this.history.captureSnapshot();
  }
  getJsonSnapshot() {
    return this.history.getJsonSnapshot();
  }
  getSanitizedHtml() {
    return this.history.getSanitizedHtml();
  }
  scheduleAutoSave() {
    this.history.scheduleAutoSave();
  }
  performAutoSave() {
    return this.history.performAutoSave();
  }
  markSaved() {
    this.history.markSaved();
  }
  hasUnsavedChanges() {
    return this.history.hasUnsavedChanges();
  }
  setBaselineFromCurrent(input) {
    this.history.setBaselineFromCurrent(input);
  }
  saveCurrentElement() {
    return this.history.saveCurrentElement();
  }
  pushUndoState(htmlContent) {
    this.history.pushUndoState(htmlContent);
  }
  undo() {
    return this.history.undo();
  }
  redo() {
    return this.history.redo();
  }
  clearUndoRedo() {
    this.history.clearUndoRedo();
  }
  setSidebarOpen(open) {
    this.sidebarOpen = !!open;
    if (!this.sidebarOpen) {
      this.toolbar.hideEEToolbar();
    }
  }
  clearSelection() {
    this.selection.clearSelection();
  }
  handleEscape() {
    this.selection.handleEscape();
  }
  setPan() {
    return;
  }
  updatePan() {
    return;
  }
  animatePanTo() {
    return;
  }
  setLastAction(type, meta = {}, opts = {}) {
    const user = !!(opts && opts.user);
    const entry = { type: String(type || ""), at: Date.now(), meta, user };
    this.lastAction = entry;
    if (user) this.lastUserAction = entry;
    this.debugLogs.push(entry);
    if (this.debugLogs.length > 500) {
      this.debugLogs.splice(0, this.debugLogs.length - 500);
    }
  }
  setUserAction(type, meta = {}) {
    return this.setLastAction(type, meta, { user: true });
  }
  getDebugLogs() {
    return this.debugLogs.slice();
  }
  getMcpState() {
    return {
      urn: this.currentElementId,
      html: this.getSanitizedHtml()
    };
  }
  applyThemeColor() {
    const themeEl = document.querySelector("sp-theme");
    if (themeEl) {
      themeEl.setAttribute(
        "color",
        this.themeColor === "dark" ? "dark" : "light"
      );
    }
  }
};
makeObservable(EditorStore);

// node_modules/@spectrum-web-components/checkbox/src/Checkbox.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/checkbox/src/CheckboxMixin.js
init_src();
init_decorators2();
init_directives();
var a8 = Object.defineProperty;
var p12 = Object.getOwnPropertyDescriptor;
var c19 = (i21, e36, r25, n25) => {
  for (var t34 = n25 > 1 ? void 0 : n25 ? p12(e36, r25) : e36, o52 = i21.length - 1, l16; o52 >= 0; o52--) (l16 = i21[o52]) && (t34 = (n25 ? l16(e36, r25, t34) : l16(t34)) || t34);
  return n25 && t34 && a8(e36, r25, t34), t34;
};
function CheckboxMixin(i21) {
  class e36 extends i21 {
    constructor() {
      super(...arguments);
      this.checked = false;
      this.readonly = false;
    }
    handleChange() {
      if (this.readonly) {
        this.inputElement.checked = this.checked;
        return;
      }
      this.checked = this.inputElement.checked;
      const t34 = new CustomEvent("change", { bubbles: true, cancelable: true, composed: true });
      this.dispatchEvent(t34) || (this.checked = !this.inputElement.checked, this.inputElement.checked = this.checked);
    }
    render() {
      return x`
                <input
                    id="input"
                    name=${o9(this.name || void 0)}
                    type="checkbox"
                    .checked=${this.checked}
                    ?disabled=${this.readonly}
                    @change=${this.handleChange}
                />
            `;
    }
  }
  return c19([n4({ type: Boolean, reflect: true })], e36.prototype, "checked", 2), c19([n4({ type: String, reflect: true })], e36.prototype, "name", 2), c19([n4({ type: Boolean, reflect: true })], e36.prototype, "readonly", 2), c19([e5("#input")], e36.prototype, "inputElement", 2), e36;
}

// node_modules/@spectrum-web-components/checkbox/src/checkbox.css.js
init_src();
var c20 = i`
    :host{--spectrum-checkbox-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-checkbox-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-checkbox-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-checkbox-content-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-checkbox-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-checkbox-content-color-disabled:var(--spectrum-disabled-content-color);--spectrum-checkbox-control-color-disabled:var(--spectrum-disabled-content-color);--spectrum-checkbox-invalid-color-default:var(--spectrum-negative-color-900);--spectrum-checkbox-invalid-color-hover:var(--spectrum-negative-color-1000);--spectrum-checkbox-invalid-color-down:var(--spectrum-negative-color-1100);--spectrum-checkbox-invalid-color-focus:var(--spectrum-negative-color-1000);--spectrum-checkbox-emphasized-color-default:var(--spectrum-accent-color-900);--spectrum-checkbox-emphasized-color-hover:var(--spectrum-accent-color-1000);--spectrum-checkbox-emphasized-color-down:var(--spectrum-accent-color-1100);--spectrum-checkbox-emphasized-color-focus:var(--spectrum-accent-color-1000);--spectrum-checkbox-control-selected-color-default:var(--spectrum-neutral-background-color-selected-default);--spectrum-checkbox-control-selected-color-hover:var(--spectrum-neutral-background-color-selected-hover);--spectrum-checkbox-control-selected-color-down:var(--spectrum-neutral-background-color-selected-down);--spectrum-checkbox-control-selected-color-focus:var(--spectrum-neutral-background-color-selected-key-focus);--spectrum-checkbox-line-height:var(--spectrum-line-height-100);--spectrum-checkbox-line-height-cjk:var(--spectrum-cjk-line-height-100);--spectrum-checkbox-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--spectrum-checkbox-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-checkbox-border-width:var(--spectrum-border-width-200);--spectrum-checkbox-selected-border-width:calc(var(--spectrum-checkbox-control-size)/2);--spectrum-checkbox-animation-duration:var(--spectrum-animation-duration-100)}:host,:host{--spectrum-checkbox-font-size:var(--spectrum-font-size-100);--spectrum-checkbox-height:var(--spectrum-component-height-100);--spectrum-checkbox-control-size:var(--spectrum-checkbox-control-size-medium);--spectrum-checkbox-top-to-text:var(--spectrum-component-top-to-text-100);--spectrum-checkbox-text-to-control:var(--spectrum-text-to-control-100)}:host([size=s]){--spectrum-checkbox-font-size:var(--spectrum-font-size-75);--spectrum-checkbox-height:var(--spectrum-component-height-75);--spectrum-checkbox-control-size:var(--spectrum-checkbox-control-size-small);--spectrum-checkbox-top-to-text:var(--spectrum-component-top-to-text-75);--spectrum-checkbox-text-to-control:var(--spectrum-text-to-control-75)}:host([size=l]){--spectrum-checkbox-font-size:var(--spectrum-font-size-200);--spectrum-checkbox-height:var(--spectrum-component-height-200);--spectrum-checkbox-control-size:var(--spectrum-checkbox-control-size-large);--spectrum-checkbox-top-to-text:var(--spectrum-component-top-to-text-200);--spectrum-checkbox-text-to-control:var(--spectrum-text-to-control-200)}:host([size=xl]){--spectrum-checkbox-font-size:var(--spectrum-font-size-300);--spectrum-checkbox-height:var(--spectrum-component-height-300);--spectrum-checkbox-control-size:var(--spectrum-checkbox-control-size-extra-large);--spectrum-checkbox-top-to-text:var(--spectrum-component-top-to-text-300);--spectrum-checkbox-text-to-control:var(--spectrum-text-to-control-300)}:host{color:var(--highcontrast-checkbox-content-color-default,var(--mod-checkbox-content-color-default,var(--spectrum-checkbox-content-color-default)));min-block-size:var(--mod-checkbox-height,var(--spectrum-checkbox-height));vertical-align:top;align-items:flex-start;max-inline-size:100%;display:inline-flex;position:relative}:host(:is(:active,[active])) #box:before{border-color:var(--highcontrast-checkbox-highlight-color-down,var(--mod-checkbox-control-color-down,var(--spectrum-checkbox-control-color-down)))}:host(:is(:active,[active])) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-down,var(--mod-checkbox-control-selected-color-down,var(--spectrum-checkbox-control-selected-color-down)))}:host(:is(:active,[active])) #label{color:var(--highcontrast-checkbox-content-color-down,var(--mod-checkbox-content-color-down,var(--spectrum-checkbox-content-color-down)))}:host([invalid][invalid]) #box:before,:host([invalid][invalid]) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-color-default,var(--mod-checkbox-invalid-color-default,var(--spectrum-checkbox-invalid-color-default)))}:host([invalid][invalid]) #input:focus-visible+#box:before,:host([invalid][invalid][indeterminate]) #input:focus-visible+#box:before{border-color:var(--highcontrast-checkbox-color-hover,var(--mod-checkbox-invalid-color-hover,var(--spectrum-checkbox-invalid-color-hover)))}:host([readonly]) #input{cursor:default}:host([readonly]) #input:checked:disabled+#box:before,:host([readonly]) #input:disabled+#box:before{border-color:var(--highcontrast-checkbox-color-default,var(--mod-checkbox-control-selected-color-default,var(--spectrum-checkbox-control-selected-color-default)));background-color:var(--highcontrast-checkbox-background-color-default,var(--mod-checkbox-checkmark-color,var(--spectrum-checkbox-checkmark-color)))}:host([readonly]) #input:checked:disabled~#label,:host([readonly]) #input:disabled~#label{color:var(--highcontrast-checkbox-color-default,var(--mod-checkbox-content-color-default,var(--spectrum-checkbox-content-color-default)))}:host([indeterminate]) #box:before,:host([indeterminate]) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-default,var(--mod-checkbox-control-selected-color-default,var(--spectrum-checkbox-control-selected-color-default)));border-width:var(--mod-checkbox-selected-border-width,var(--spectrum-checkbox-selected-border-width))}:host([indeterminate]) #box #checkmark,:host([indeterminate]) #input:checked+#box #checkmark{display:none}:host([indeterminate]) #box #partialCheckmark,:host([indeterminate]) #input:checked+#box #partialCheckmark{opacity:1;display:block;transform:scale(1)}:host([indeterminate]) #input:focus-visible+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-focus,var(--mod-checkbox-control-selected-color-focus,var(--spectrum-checkbox-control-selected-color-focus)))}:host([invalid][invalid][indeterminate]) #box:before,:host([invalid][invalid][indeterminate]) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-color-default,var(--mod-checkbox-invalid-color-default,var(--spectrum-checkbox-invalid-color-default)));border-width:var(--mod-checkbox-selected-border-width,var(--spectrum-checkbox-selected-border-width))}:host([emphasized]) #input:checked+#box:before,:host([emphasized][indeterminate]) #box:before,:host([emphasized][indeterminate]) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-default,var(--mod-checkbox-emphasized-color-default,var(--spectrum-checkbox-emphasized-color-default)))}:host([emphasized]) #input:focus-visible:checked+#box:before,:host([emphasized][indeterminate]) #input:focus-visible+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-focus,var(--mod-checkbox-emphasized-color-focus,var(--spectrum-checkbox-emphasized-color-focus)))}:host([emphasized][invalid][invalid]) #input:focus-visible:checked+#box:before{border-color:var(--highcontrast-checkbox-color-default,var(--mod-checkbox-invalid-color-focus,var(--spectrum-checkbox-invalid-color-focus)))}@media (hover:hover){:host(:hover) #box:before{border-color:var(--highcontrast-checkbox-highlight-color-hover,var(--mod-checkbox-control-color-hover,var(--spectrum-checkbox-control-color-hover)))}:host(:hover) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-hover,var(--mod-checkbox-control-selected-color-hover,var(--spectrum-checkbox-control-selected-color-hover)))}:host(:hover) #label{color:var(--highcontrast-checkbox-content-color-hover,var(--mod-checkbox-content-color-hover,var(--spectrum-checkbox-content-color-hover)))}:host([invalid][invalid]:hover) #box:before,:host([invalid][invalid]:hover) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-color-hover,var(--mod-checkbox-invalid-color-hover,var(--spectrum-checkbox-invalid-color-hover)))}:host([indeterminate]:hover) #box:before,:host([indeterminate]:hover) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-hover,var(--mod-checkbox-control-selected-color-hover,var(--spectrum-checkbox-control-selected-color-hover)))}:host([invalid][invalid][indeterminate]:hover) #box:before,:host([invalid][invalid][indeterminate]:hover) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-color-default,var(--mod-checkbox-invalid-color-hover,var(--spectrum-checkbox-invalid-color-hover)))}:host([invalid][invalid][indeterminate]:hover) #label{color:var(--highcontrast-checkbox-content-color-hover,var(--mod-checkbox-content-color-hover,var(--spectrum-checkbox-content-color-hover)))}:host([emphasized][invalid][invalid][indeterminate]:hover) #box:before,:host([emphasized][invalid][invalid][indeterminate]:hover) #input:checked+#box:before,:host([emphasized][invalid][invalid]:hover) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-color-hover,var(--mod-checkbox-invalid-color-hover,var(--spectrum-checkbox-invalid-color-hover)))}:host([emphasized][indeterminate]:hover) #box:before,:host([emphasized][indeterminate]:hover) #input:checked+#box:before,:host([emphasized]:hover) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-hover,var(--mod-checkbox-emphasized-color-hover,var(--spectrum-checkbox-emphasized-color-hover)))}}:host([emphasized][indeterminate]:is(:active,[active])) #box:before,:host([emphasized][indeterminate]:is(:active,[active])) #input:checked+#box:before,:host([emphasized]:is(:active,[active])) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-default,var(--mod-checkbox-emphasized-color-down,var(--spectrum-checkbox-emphasized-color-down)))}:host([emphasized][invalid][invalid]:is(:active,[active])) #box:before,:host([emphasized][invalid][invalid]:is(:active,[active])) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-default,var(--mod-checkbox-control-invalid-color-down,var(--spectrum-checkbox-invalid-color-down)))}:host([emphasized]:focus-visible) #box:before,:host([emphasized]:focus-visible) #input:checked+#box:before{border-color:var(--highcontrast-checkbox-color-focus,var(--mod-checkbox-control-color-focus,var(--spectrum-checkbox-control-color-focus)))}#label{text-align:start;font-size:var(--mod-checkbox-font-size,var(--spectrum-checkbox-font-size));transition:color var(--mod-checkbox-animation-duration,var(--spectrum-checkbox-animation-duration))ease-in-out;line-height:var(--mod-checkbox-line-height,var(--spectrum-checkbox-line-height));margin-block-start:var(--mod-checkbox-top-to-text,var(--spectrum-checkbox-top-to-text));margin-inline-start:var(--mod-checkbox-text-to-control,var(--spectrum-checkbox-text-to-control))}#label:lang(ja),#label:lang(ko),#label:lang(zh){line-height:var(--mod-checkbox-line-height-cjk,var(--spectrum-checkbox-line-height-cjk))}#input{color:var(--mod-checkbox-control-color-default,var(--spectrum-checkbox-control-color-default));box-sizing:border-box;opacity:0;z-index:1;cursor:pointer;block-size:100%;inline-size:100%;margin:0;padding:0;font-family:inherit;font-size:100%;line-height:1.15;position:absolute;overflow:visible}#input:disabled{cursor:default}#input:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-default,var(--mod-checkbox-control-selected-color-default,var(--spectrum-checkbox-control-selected-color-default)));background-color:var(--mod-checkbox-checkmark-color,var(--spectrum-checkbox-checkmark-color));border-width:var(--mod-checkbox-selected-border-width,var(--spectrum-checkbox-selected-border-width))}#input:checked+#box #checkmark{opacity:1;transform:scale(1)}#input:focus-visible+#box:before{border-color:var(--highcontrast-checkbox-color-focus,var(--mod-checkbox-control-color-focus,var(--spectrum-checkbox-control-color-focus)))}#input:focus-visible+#box:after{forced-color-adjust:none;box-shadow:0 0 0 var(--mod-checkbox-focus-indicator-thinkness,var(--spectrum-checkbox-focus-indicator-thickness))var(--highcontrast-checkbox-focus-indicator-color,var(--mod-checkbox-focus-indicator-color,var(--spectrum-checkbox-focus-indicator-color)));margin:calc(var(--mod-checkbox-focus-indicator-gap,var(--spectrum-checkbox-focus-indicator-gap))*-1)}#input:focus-visible+#label{color:var(--highcontrast-checkbox-content-color-focus,var(--mod-checkbox-content-color-focus,var(--spectrum-checkbox-content-color-focus)))}#input:focus-visible:checked+#box:before{border-color:var(--highcontrast-checkbox-highlight-color-focus,var(--mod-checkbox-control-selected-color-focus,var(--spectrum-checkbox-control-selected-color-focus)))}#box{--spectrum-checkbox-spacing:calc(var(--mod-checkbox-height,var(--spectrum-checkbox-height)) - var(--mod-checkbox-control-size,var(--spectrum-checkbox-control-size)));margin:calc(var(--mod-checkbox-spacing,var(--spectrum-checkbox-spacing))/2)0;flex-grow:0;flex-shrink:0;justify-content:center;align-items:center;display:flex;position:relative}#box,#box:before{box-sizing:border-box;inline-size:var(--mod-checkbox-control-size,var(--spectrum-checkbox-control-size));block-size:var(--mod-checkbox-control-size,var(--spectrum-checkbox-control-size))}#box:before{forced-color-adjust:none;border-color:var(--highcontrast-checkbox-color-default,var(--mod-checkbox-control-color-default,var(--spectrum-checkbox-control-color-default)));z-index:0;content:"";border-radius:var(--mod-checkbox-control-corner-radius,var(--spectrum-checkbox-control-corner-radius));border-width:var(--mod-checkbox-border-width,var(--spectrum-checkbox-border-width));transition:border var(--mod-checkbox-animation-duration,var(--spectrum-checkbox-animation-duration))ease-in-out,box-shadow var(--mod-checkbox-animation-duration,var(--spectrum-checkbox-animation-duration))ease-in-out;border-style:solid;display:block;position:absolute}#box:after{border-radius:calc(var(--mod-checkbox-control-corner-radius,var(--spectrum-checkbox-control-corner-radius)) + var(--mod-checkbox-focus-indicator-gap,var(--spectrum-checkbox-focus-indicator-gap)));content:"";margin:var(--mod-checkbox-focus-indicator-gap,var(--spectrum-checkbox-focus-indicator-gap));transition:box-shadow var(--mod-checkbox-animation-duration,var(--spectrum-checkbox-animation-duration))ease-out,margin var(--mod-checkbox-animation-duration,var(--spectrum-checkbox-animation-duration))ease-out;display:block;position:absolute;inset-block:0;inset-inline:0;transform:translate(0)}#checkmark,#partialCheckmark{color:var(--highcontrast-checkbox-background-color-default,var(--mod-checkbox-checkmark-color,var(--spectrum-checkbox-checkmark-color)));opacity:0;transition:opacity var(--mod-checkbox-animation-duration,var(--spectrum-checkbox-animation-duration))ease-in-out,transform var(--mod-checkbox-animation-duration,var(--spectrum-checkbox-animation-duration))ease-in-out;transform:scale(0)}#partialCheckmark{display:none}#input:checked:disabled+#box:before,#input:disabled+#box:before{border-color:var(--highcontrast-checkbox-disabled-color-default,var(--mod-checkbox-control-color-disabled,var(--spectrum-checkbox-control-color-disabled)));background-color:var(--highcontrast-checkbox-background-color-default,var(--mod-checkbox-checkmark-color,var(--spectrum-checkbox-checkmark-color)))}#input:checked:disabled~#label,#input:disabled~#label{forced-color-adjust:none;color:var(--highcontrast-checkbox-disabled-color-default,var(--mod-checkbox-content-color-disabled,var(--spectrum-checkbox-content-color-disabled)))}@media (forced-colors:active){#input:focus-visible+#box{forced-color-adjust:none;outline-color:var(--highcontrast-checkbox-focus-indicator-color,var(--mod-checkbox-focus-indicator-color,var(--spectrum-checkbox-focus-indicator-color)));outline-offset:var(--mod-checkbox-focus-indicator-gap,var(--spectrum-checkbox-focus-indicator-gap));outline-style:auto;outline-width:var(--mod-focus-indicator-thickness,var(--spectrum-focus-indicator-thickness))}#input:focus-visible+#box:after{box-shadow:0 0 0 0 var(--highcontrast-checkbox-focus-indicator-color,var(--mod-checkbox-focus-indicator-color,var(--spectrum-checkbox-focus-indicator-color)))}:host{--highcontrast-checkbox-content-color-default:CanvasText;--highcontrast-checkbox-content-color-hover:CanvasText;--highcontrast-checkbox-content-color-down:CanvasText;--highcontrast-checkbox-content-color-focus:CanvasText;--highcontrast-checkbox-background-color-default:Canvas;--highcontrast-checkbox-color-default:ButtonText;--highcontrast-checkbox-color-hover:ButtonText;--highcontrast-checkbox-color-focus:Highlight;--highcontrast-checkbox-highlight-color-default:Highlight;--highcontrast-checkbox-highlight-color-hover:Highlight;--highcontrast-checkbox-highlight-color-down:Highlight;--highcontrast-checkbox-highlight-color-focus:Highlight;--highcontrast-checkbox-disabled-color-default:GrayText;--highcontrast-checkbox-focus-indicator-color:CanvasText}}:host{--spectrum-checkbox-control-color-default:var(--system-checkbox-control-color-default);--spectrum-checkbox-control-color-hover:var(--system-checkbox-control-color-hover);--spectrum-checkbox-control-color-down:var(--system-checkbox-control-color-down);--spectrum-checkbox-control-color-focus:var(--system-checkbox-control-color-focus);--spectrum-checkbox-checkmark-color:var(--system-checkbox-checkmark-color);--spectrum-checkbox-control-corner-radius:var(--system-checkbox-control-corner-radius)}:host{vertical-align:top;display:inline-flex}:host(:focus){outline:none}:host([disabled]){pointer-events:none}:host(:empty) label{display:none}
`;
var checkbox_css_default = c20;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCheckmark75.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Checkmark75.js
var Checkmark75Icon = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Checkmark75" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M3.667 9.07a.96.96 0 0 1-.737-.344L.753 6.114a.96.96 0 1 1 1.474-1.23l1.418 1.701 4.112-5.233a.96.96 0 0 1 1.51 1.186L4.422 8.704a.96.96 0 0 1-.741.367z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Checkmark75.js
var Checkmark75Icon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Checkmark75" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M3.667 9.07a.96.96 0 0 1-.737-.344L.753 6.114a.96.96 0 1 1 1.474-1.23l1.418 1.701 4.112-5.233a.96.96 0 0 1 1.51 1.186L4.422 8.704a.96.96 0 0 1-.741.367z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCheckmark75.js
var IconCheckmark75 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Checkmark75Icon({ hidden: !this.label, title: this.label }) : Checkmark75Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-checkmark75.js
init_define_element();
defineElement("sp-icon-checkmark75", IconCheckmark75);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCheckmark200.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Checkmark200.js
var Checkmark200Icon = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Checkmark200" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M4.313 10.98a1.04 1.04 0 0 1-.8-.375L.647 7.165a1.042 1.042 0 0 1 1.6-1.333l2.042 2.45 5.443-6.928a1.042 1.042 0 0 1 1.64 1.287l-6.24 7.94a1.04 1.04 0 0 1-.804.399z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Checkmark200.js
var Checkmark200Icon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Checkmark200" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M4.313 10.98a1.04 1.04 0 0 1-.8-.375L.647 7.165a1.042 1.042 0 0 1 1.6-1.333l2.042 2.45 5.443-6.928a1.042 1.042 0 0 1 1.64 1.287l-6.24 7.94a1.04 1.04 0 0 1-.804.399z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCheckmark200.js
var IconCheckmark200 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Checkmark200Icon({ hidden: !this.label, title: this.label }) : Checkmark200Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-checkmark200.js
init_define_element();
defineElement("sp-icon-checkmark200", IconCheckmark200);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCheckmark300.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Checkmark300.js
var Checkmark300Icon = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Checkmark300" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 14 14"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M5.102 12.514a1.09 1.09 0 0 1-.834-.39L.988 8.19A1.085 1.085 0 0 1 2.656 6.8l2.421 2.906 6.243-7.947a1.085 1.085 0 0 1 1.707 1.34L5.955 12.1a1.09 1.09 0 0 1-.838.415z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Checkmark300.js
var Checkmark300Icon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Checkmark300" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 14 14"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${e36}"
    height="${t34}"
  >
    <path
      d="M5.102 12.514a1.09 1.09 0 0 1-.834-.39L.988 8.19A1.085 1.085 0 0 1 2.656 6.8l2.421 2.906 6.243-7.947a1.085 1.085 0 0 1 1.707 1.34L5.955 12.1a1.09 1.09 0 0 1-.838.415z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconCheckmark300.js
var IconCheckmark300 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Checkmark300Icon({ hidden: !this.label, title: this.label }) : Checkmark300Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-checkmark300.js
init_define_element();
defineElement("sp-icon-checkmark300", IconCheckmark300);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconDash75.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Dash75.js
var Dash75Icon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Dash75" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 8 8"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path d="M6.99 4.96H1.01a.96.96 0 0 1 0-1.92h5.98a.96.96 0 0 1 0 1.92" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Dash75.js
var Dash75Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Dash75" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 8 8"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path d="M6.99 4.96H1.01a.96.96 0 0 1 0-1.92h5.98a.96.96 0 0 1 0 1.92" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconDash75.js
var IconDash75 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Dash75Icon({ hidden: !this.label, title: this.label }) : Dash75Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-dash75.js
init_define_element();
defineElement("sp-icon-dash75", IconDash75);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconDash100.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Dash100.js
var Dash100Icon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Dash100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path d="M8.5 6h-7a1 1 0 0 1 0-2h7a1 1 0 0 1 0 2" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Dash100.js
var Dash100Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Dash100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path d="M8.5 6h-7a1 1 0 0 1 0-2h7a1 1 0 0 1 0 2" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconDash100.js
var IconDash100 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Dash100Icon({ hidden: !this.label, title: this.label }) : Dash100Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-dash100.js
init_define_element();
defineElement("sp-icon-dash100", IconDash100);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconDash200.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Dash200.js
var Dash200Icon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Dash200" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path d="M10.021 7.042H1.98a1.042 1.042 0 1 1 0-2.083h8.043a1.042 1.042 0 0 1 0 2.083z" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Dash200.js
var Dash200Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Dash200" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path d="M10.021 7.042H1.98a1.042 1.042 0 1 1 0-2.083h8.043a1.042 1.042 0 0 1 0 2.083z" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconDash200.js
var IconDash200 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Dash200Icon({ hidden: !this.label, title: this.label }) : Dash200Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-dash200.js
init_define_element();
defineElement("sp-icon-dash200", IconDash200);

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconDash300.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Dash300.js
var Dash300Icon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Dash300" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path d="M10.61 7.085H1.39a1.085 1.085 0 0 1 0-2.17h9.22a1.085 1.085 0 0 1 0 2.17" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Dash300.js
var Dash300Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Dash300" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 12 12"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
    width="${t34}"
    height="${e36}"
  >
    <path d="M10.61 7.085H1.39a1.085 1.085 0 0 1 0-2.17h9.22a1.085 1.085 0 0 1 0 2.17" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconDash300.js
var IconDash300 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Dash300Icon({ hidden: !this.label, title: this.label }) : Dash300Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-dash300.js
init_define_element();
defineElement("sp-icon-dash300", IconDash300);

// node_modules/@spectrum-web-components/icon/src/spectrum-icon-dash.css.js
init_src();
var c21 = i`
    .spectrum-UIIcon-Dash50{--spectrum-icon-size:var(--spectrum-dash-icon-size-50)}.spectrum-UIIcon-Dash75{--spectrum-icon-size:var(--spectrum-dash-icon-size-75)}.spectrum-UIIcon-Dash100{--spectrum-icon-size:var(--spectrum-dash-icon-size-100)}.spectrum-UIIcon-Dash200{--spectrum-icon-size:var(--spectrum-dash-icon-size-200)}.spectrum-UIIcon-Dash300{--spectrum-icon-size:var(--spectrum-dash-icon-size-300)}.spectrum-UIIcon-Dash400{--spectrum-icon-size:var(--spectrum-dash-icon-size-400)}.spectrum-UIIcon-Dash500{--spectrum-icon-size:var(--spectrum-dash-icon-size-500)}.spectrum-UIIcon-Dash600{--spectrum-icon-size:var(--spectrum-dash-icon-size-600)}
`;
var spectrum_icon_dash_css_default = c21;

// node_modules/@spectrum-web-components/checkbox/src/Checkbox.js
var d9 = Object.defineProperty;
var m14 = Object.getOwnPropertyDescriptor;
var r12 = (n25, s19, e36, c33) => {
  for (var i21 = c33 > 1 ? void 0 : c33 ? m14(s19, e36) : s19, l16 = n25.length - 1, o52; l16 >= 0; l16--) (o52 = n25[l16]) && (i21 = (c33 ? o52(s19, e36, i21) : o52(i21)) || i21);
  return c33 && i21 && d9(s19, e36, i21), i21;
};
var I2 = { s: () => x`
            <sp-icon-checkmark75
                id="checkmark"
                class="spectrum-Icon spectrum-UIIcon-Checkmark75"
            ></sp-icon-checkmark75>
        `, m: () => x`
            <sp-icon-checkmark100
                id="checkmark"
                class="spectrum-Icon spectrum-UIIcon-Checkmark100"
            ></sp-icon-checkmark100>
        `, l: () => x`
            <sp-icon-checkmark200
                id="checkmark"
                class="spectrum-Icon spectrum-UIIcon-Checkmark200"
            ></sp-icon-checkmark200>
        `, xl: () => x`
            <sp-icon-checkmark300
                id="checkmark"
                class="spectrum-Icon spectrum-UIIcon-Checkmark300"
            ></sp-icon-checkmark300>
        ` };
var v4 = { s: () => x`
            <sp-icon-dash75
                id="partialCheckmark"
                class="spectrum-Icon spectrum-UIIcon-Dash75"
            ></sp-icon-dash75>
        `, m: () => x`
            <sp-icon-dash100
                id="partialCheckmark"
                class="spectrum-Icon spectrum-UIIcon-Dash100"
            ></sp-icon-dash100>
        `, l: () => x`
            <sp-icon-dash200
                id="partialCheckmark"
                class="spectrum-Icon spectrum-UIIcon-Dash200"
            ></sp-icon-dash200>
        `, xl: () => x`
            <sp-icon-dash300
                id="partialCheckmark"
                class="spectrum-Icon spectrum-UIIcon-Dash300"
            ></sp-icon-dash300>
        ` };
var Checkbox = class extends SizedMixin(CheckboxMixin(SpectrumElement), { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.indeterminate = false;
    this.invalid = false;
    this.emphasized = false;
    this.tabIndex = 0;
  }
  connectedCallback() {
    super.connectedCallback(), this.hasAttribute("autofocus") && this.updateComplete.then(() => {
      this.focus();
    });
  }
  static get styles() {
    return [checkbox_css_default, spectrum_icon_checkmark_css_default, spectrum_icon_dash_css_default];
  }
  click() {
    var e36;
    this.disabled || (e36 = this.inputElement) == null || e36.click();
  }
  handleChange() {
    this.indeterminate = false, super.handleChange();
  }
  render() {
    return x`
            ${super.render()}
            <span id="box">
                ${this.checked ? I2[this.size]() : x``}
                ${this.indeterminate ? v4[this.size]() : x``}
            </span>
            <label id="label" for="input"><slot></slot></label>
        `;
  }
  updated(e36) {
    super.updated(e36), e36.has("disabled") && (typeof e36.get("disabled") != "undefined" || this.disabled) && (this.disabled ? (this.inputElement.tabIndex = this.tabIndex, this.tabIndex = -1) : (this.tabIndex = this.inputElement.tabIndex, this.inputElement.removeAttribute("tabindex")), this.inputElement.disabled = this.disabled), e36.has("indeterminate") && (this.inputElement.indeterminate = this.indeterminate), e36.has("invalid") && (this.invalid ? this.inputElement.setAttribute("aria-invalid", "true") : this.inputElement.removeAttribute("aria-invalid"));
  }
};
Checkbox.shadowRootOptions = { ...SpectrumElement.shadowRootOptions, delegatesFocus: true }, r12([n4({ type: Boolean, reflect: true })], Checkbox.prototype, "disabled", 2), r12([n4({ type: Boolean, reflect: true })], Checkbox.prototype, "indeterminate", 2), r12([n4({ type: Boolean, reflect: true })], Checkbox.prototype, "invalid", 2), r12([n4({ type: Boolean, reflect: true })], Checkbox.prototype, "emphasized", 2), r12([n4({ reflect: true, type: Number, attribute: "tabindex" })], Checkbox.prototype, "tabIndex", 2);

// node_modules/@spectrum-web-components/checkbox/sp-checkbox.js
init_define_element();
defineElement("sp-checkbox", Checkbox);

// node_modules/@spectrum-web-components/help-text/src/HelpText.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/help-text/src/help-text.css.js
init_src();
var e24 = i`
    @media (forced-colors:active){:host{--highcontrast-helptext-content-color-default:CanvasText;--highcontrast-helptext-icon-color-default:CanvasText}:host,.text,.icon{forced-color-adjust:none}}:host{--spectrum-helptext-content-color-default:var(--spectrum-neutral-subdued-content-color-default);--spectrum-helptext-icon-color-default:var(--spectrum-neutral-subdued-content-color-default);color:var(--highcontrast-helptext-content-color-default,var(--mod-helptext-content-color-default,var(--spectrum-helptext-content-color-default)));font-size:var(--mod-helptext-font-size,var(--spectrum-helptext-font-size));min-block-size:var(--mod-helptext-min-height,var(--spectrum-helptext-min-height));display:flex}:host([size=s]){--spectrum-helptext-min-height:var(--spectrum-component-height-75);--spectrum-helptext-icon-size:var(--spectrum-workflow-icon-size-75);--spectrum-helptext-font-size:var(--spectrum-font-size-75);--spectrum-helptext-text-to-visual:var(--spectrum-text-to-visual-75);--spectrum-helptext-top-to-workflow-icon:var(--spectrum-help-text-top-to-workflow-icon-small);--spectrum-helptext-bottom-to-workflow-icon:var(--spectrum-helptext-top-to-workflow-icon)}:host,:host{--spectrum-helptext-min-height:var(--spectrum-component-height-75);--spectrum-helptext-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-helptext-font-size:var(--spectrum-font-size-75);--spectrum-helptext-text-to-visual:var(--spectrum-text-to-visual-75);--spectrum-helptext-top-to-workflow-icon:var(--spectrum-help-text-top-to-workflow-icon-medium);--spectrum-helptext-bottom-to-workflow-icon:var(--spectrum-helptext-top-to-workflow-icon)}:host([size=l]){--spectrum-helptext-min-height:var(--spectrum-component-height-100);--spectrum-helptext-icon-size:var(--spectrum-workflow-icon-size-200);--spectrum-helptext-font-size:var(--spectrum-font-size-100);--spectrum-helptext-text-to-visual:var(--spectrum-text-to-visual-100);--spectrum-helptext-top-to-workflow-icon:var(--spectrum-help-text-top-to-workflow-icon-large);--spectrum-helptext-bottom-to-workflow-icon:var(--spectrum-helptext-top-to-workflow-icon)}:host([size=xl]){--spectrum-helptext-min-height:var(--spectrum-component-height-200);--spectrum-helptext-icon-size:var(--spectrum-workflow-icon-size-300);--spectrum-helptext-font-size:var(--spectrum-font-size-200);--spectrum-helptext-text-to-visual:var(--spectrum-text-to-visual-200);--spectrum-helptext-top-to-workflow-icon:var(--spectrum-help-text-top-to-workflow-icon-extra-large);--spectrum-helptext-bottom-to-workflow-icon:var(--spectrum-helptext-top-to-workflow-icon)}:host([variant=neutral]){--spectrum-helptext-content-color-default:var(--spectrum-neutral-subdued-content-color-default);--spectrum-helptext-icon-color-default:var(--spectrum-neutral-subdued-content-color-default)}:host([variant=negative]){--spectrum-helptext-content-color-default:var(--spectrum-negative-color-900);--spectrum-helptext-icon-color-default:var(--spectrum-negative-color-900)}:host([disabled]){--spectrum-helptext-content-color-default:var(--spectrum-disabled-content-color);--spectrum-helptext-icon-color-default:var(--spectrum-disabled-content-color)}:host(:lang(ja)),:host(:lang(ko)),:host(:lang(zh)){--mod-helptext-line-height:var(--mod-helptext-line-height-cjk,var(--spectrum-cjk-line-height-100))}.icon{block-size:var(--mod-helptext-icon-size,var(--spectrum-helptext-icon-size));inline-size:var(--mod-helptext-icon-size,var(--spectrum-helptext-icon-size));flex-shrink:0;margin-inline-end:var(--mod-helptext-text-to-visual,var(--spectrum-helptext-text-to-visual));padding-block-start:var(--mod-helptext-top-to-workflow-icon,var(--spectrum-helptext-top-to-workflow-icon));padding-block-end:var(--mod-helptext-bottom-to-workflow-icon,var(--spectrum-helptext-bottom-to-workflow-icon))}.text{line-height:var(--mod-helptext-line-height,var(--spectrum-line-height-100));padding-block-start:var(--mod-helptext-top-to-text,var(--spectrum-helptext-top-to-text));padding-block-end:var(--mod-helptext-bottom-to-text,var(--spectrum-helptext-bottom-to-text))}:host([variant=neutral]) .text{color:var(--highcontrast-helptext-content-color-default,var(--mod-helptext-content-color-default,var(--spectrum-helptext-content-color-default)))}:host([variant=neutral]) .icon{color:var(--highcontrast-helptext-icon-color-default,var(--mod-helptext-icon-color-default,var(--spectrum-helptext-icon-color-default)))}:host([variant=negative]) .text{color:var(--highcontrast-helptext-content-color-default,var(--mod-helptext-content-color-default,var(--spectrum-helptext-content-color-default)))}:host([variant=negative]) .icon{color:var(--highcontrast-helptext-icon-color-default,var(--mod-helptext-icon-color-default,var(--spectrum-helptext-icon-color-default)))}:host([disabled]) .text{color:var(--highcontrast-helptext-content-color-default,var(--mod-helptext-content-color-default,var(--spectrum-helptext-content-color-default)))}:host([disabled]) .icon{color:var(--highcontrast-helptext-icon-color-default,var(--mod-helptext-icon-color-default,var(--spectrum-helptext-icon-color-default)))}:host{--spectrum-helptext-top-to-text:var(--system-helptext-top-to-text);--spectrum-helptext-bottom-to-text:var(--system-helptext-bottom-to-text)}:host([size=s]){--spectrum-helptext-top-to-text:var(--system-helptext-top-to-text-small);--spectrum-helptext-bottom-to-text:var(--system-helptext-bottom-to-text-small)}:host([size=l]){--spectrum-helptext-top-to-text:var(--system-helptext-top-to-text-large);--spectrum-helptext-bottom-to-text:var(--system-helptext-bottom-to-text-large)}:host([size=xl]){--spectrum-helptext-top-to-text:var(--system-helptext-top-to-text-extra-large);--spectrum-helptext-bottom-to-text:var(--system-helptext-bottom-to-text-extra-large)}
`;
var help_text_css_default = e24;

// node_modules/@spectrum-web-components/help-text/src/HelpText.js
var c22 = Object.defineProperty;
var u18 = Object.getOwnPropertyDescriptor;
var n17 = (i21, t34, l16, r25) => {
  for (var e36 = r25 > 1 ? void 0 : r25 ? u18(t34, l16) : t34, a23 = i21.length - 1, s19; a23 >= 0; a23--) (s19 = i21[a23]) && (e36 = (r25 ? s19(t34, l16, e36) : s19(e36)) || e36);
  return r25 && e36 && c22(t34, l16, e36), e36;
};
var HelpText = class extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.icon = false;
    this.variant = "neutral";
  }
  static get styles() {
    return [help_text_css_default];
  }
  render() {
    return x`
            ${this.variant === "negative" && this.icon ? x`
                      <sp-icon-alert class="icon"></sp-icon-alert>
                  ` : E}
            <div class="text"><slot></slot></div>
        `;
  }
};
n17([n4({ type: Boolean, reflect: true })], HelpText.prototype, "icon", 2), n17([n4({ reflect: true })], HelpText.prototype, "variant", 2);

// node_modules/@spectrum-web-components/help-text/sp-help-text.js
init_define_element();
defineElement("sp-help-text", HelpText);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconDuplicate.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Duplicate.js
var DuplicateIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: c33 = "Duplicate" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${c33}"
  >
    <path
      d="m13.75,2.75c0-.41406-.33594-.75-.75-.75H4.25c-1.24072,0-2.25,1.00928-2.25,2.25v8.75c0,.41406.33594.75.75.75s.75-.33594.75-.75V4.25c0-.41357.33643-.75.75-.75h8.75c.41406,0,.75-.33594.75-.75Z"
      fill="currentColor"
    />
    <path
      d="m14.75,11.5c0,.41406-.33594.75-.75.75h-1.75v1.75c0,.41406-.33594.75-.75.75s-.75-.33594-.75-.75v-1.75h-1.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.75v-1.75c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.75h1.75c.41406,0,.75.33594.75.75Z"
      fill="currentColor"
    />
    <path
      d="m15.75,5H7.25c-1.24072,0-2.25,1.00928-2.25,2.25v8.5c0,1.24072,1.00928,2.25,2.25,2.25h8.5c1.24072,0,2.25-1.00928,2.25-2.25V7.25c0-1.24072-1.00928-2.25-2.25-2.25Zm.75,10.75c0,.41357-.33643.75-.75.75H7.25c-.41357,0-.75-.33643-.75-.75V7.25c0-.41357.33643-.75.75-.75h8.5c.41357,0,.75.33643.75.75v8.5Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Duplicate.js
var DuplicateIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "Duplicate" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${a23}"
    height="${t34}"
    viewBox="0 0 36 36"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <g>
      <path d="M9 8h17V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5V9a1 1 0 0 1 1-1Z" />
      <path
        d="M33 10H11a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1Zm-4 13.5h-5.5V29h-3v-5.5H15v-3h5.5V15h3v5.5H29Z"
      />
    </g>
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconDuplicate.js
var IconDuplicate = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? DuplicateIcon({ hidden: !this.label, title: this.label }) : DuplicateIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-duplicate.js
init_define_element();
defineElement("sp-icon-duplicate", IconDuplicate);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconDelete.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Delete.js
var DeleteIcon = ({ width: l16 = 24, height: e36 = 24, hidden: t34 = false, title: r25 = "Delete" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m8.24902,15.02148c-.40039,0-.7334-.31738-.74805-.7207l-.25-6.5c-.0166-.41406.30664-.7627.71973-.77832.01074-.00098.02051-.00098.03027-.00098.40039,0,.7334.31738.74805.7207l.25,6.5c.0166.41406-.30664.7627-.71973.77832-.01074.00098-.02051.00098-.03027.00098Z"
      fill="currentColor"
    />
    <path
      d="m11.75098,15.02148c-.00977,0-.01953,0-.03027-.00098-.41309-.01562-.73633-.36426-.71973-.77832l.25-6.5c.01465-.40332.34766-.7207.74805-.7207.00977,0,.01953,0,.03027.00098.41309.01562.73633.36426.71973.77832l-.25,6.5c-.01465.40332-.34766.7207-.74805.7207Z"
      fill="currentColor"
    />
    <path
      d="m17,4h-3.5v-.75c0-1.24023-1.00977-2.25-2.25-2.25h-2.5c-1.24023,0-2.25,1.00977-2.25,2.25v.75h-3.5c-.41406,0-.75.33594-.75.75s.33594.75.75.75h.52002l.42236,10.3418c.04785,1.20996,1.03613,2.1582,2.24805,2.1582h7.61914c1.21191,0,2.2002-.94824,2.24805-2.1582l.42236-10.3418h.52002c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75Zm-9-.75c0-.41309.33691-.75.75-.75h2.5c.41309,0,.75.33691.75.75v.75h-4v-.75Zm6.55957,12.53125c-.0166.40332-.3457.71875-.75.71875h-7.61914c-.4043,0-.7334-.31543-.75-.71875l-.41968-10.28125h9.9585l-.41968,10.28125Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Delete.js
var DeleteIcon2 = ({ width: a23 = 24, height: e36 = 24, hidden: t34 = false, title: l16 = "Delete" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M31.5 6H24V4a2 2 0 0 0-2-2H12a2 2 0 0 0-2 2v2H2.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h2l2.413 25.1a1 1 0 0 0 1 .9h18.179a1 1 0 0 0 1-.9L29.5 8h2a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5ZM11.065 29A1 1 0 0 1 10 28.068l-1.071-16a1 1 0 1 1 2-.134l1.071 16A1 1 0 0 1 11.065 29ZM18 28a1 1 0 0 1-2 0V12a1 1 0 0 1 2 0Zm4-22H12V4h10Zm2 22.068a1 1 0 1 1-2-.134l1.071-16a1 1 0 1 1 2 .134Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconDelete.js
var IconDelete = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? DeleteIcon({ hidden: !this.label, title: this.label }) : DeleteIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-delete.js
init_define_element();
defineElement("sp-icon-delete", IconDelete);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCopy.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Copy.js
var CopyIcon = ({ width: r25 = 24, height: l16 = 24, hidden: t34 = false, title: c33 = "Copy" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${r25}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${c33}"
  >
    <path
      d="m11.75,18h-7.5c-1.24023,0-2.25-1.00977-2.25-2.25v-7.5c0-1.24023,1.00977-2.25,2.25-2.25.41406,0,.75.33594.75.75s-.33594.75-.75.75c-.41309,0-.75.33691-.75.75v7.5c0,.41309.33691.75.75.75h7.5c.41309,0,.75-.33691.75-.75,0-.41406.33594-.75.75-.75s.75.33594.75.75c0,1.24023-1.00977,2.25-2.25,2.25Z"
      fill="currentColor"
    />
    <path
      d="m6.75,5c-.41406,0-.75-.33594-.75-.75,0-1.24023,1.00977-2.25,2.25-2.25.41406,0,.75.33594.75.75s-.33594.75-.75.75c-.41309,0-.75.33691-.75.75,0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m13,3.5h-2c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h2c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m13,14h-2c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h2c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m15.75,14c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75c.41309,0,.75-.33691.75-.75,0-.41406.33594-.75.75-.75s.75.33594.75.75c0,1.24023-1.00977,2.25-2.25,2.25Z"
      fill="currentColor"
    />
    <path
      d="m17.25,5c-.41406,0-.75-.33594-.75-.75,0-.41309-.33691-.75-.75-.75-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75c1.24023,0,2.25,1.00977,2.25,2.25,0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m17.25,9.75c-.41406,0-.75-.33594-.75-.75v-2c0-.41406.33594-.75.75-.75s.75.33594.75.75v2c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m6.75,9.75c-.41406,0-.75-.33594-.75-.75v-2c0-.41406.33594-.75.75-.75s.75.33594.75.75v2c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m8.25,14c-1.24023,0-2.25-1.00977-2.25-2.25,0-.41406.33594-.75.75-.75s.75.33594.75.75c0,.41309.33691.75.75.75.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Copy.js
var CopyIcon2 = ({ width: t34 = 24, height: r25 = 24, hidden: h16 = false, title: e36 = "Copy" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${r25}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${h16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <rect height="2" rx=".5" ry=".5" width="2" x="32" y="22" />
    <rect height="2" rx=".5" ry=".5" width="2" x="32" y="18" />
    <rect height="2" rx=".5" ry=".5" width="2" x="32" y="14" />
    <rect height="2" rx=".5" ry=".5" width="2" x="32" y="10" />
    <rect height="2" rx=".5" ry=".5" width="2" x="32" y="6" />
    <rect height="2" rx=".5" ry=".5" width="2" x="32" y="2" />
    <rect height="2" rx=".5" ry=".5" width="2" x="28" y="2" />
    <rect height="2" rx=".5" ry=".5" width="2" x="24" y="2" />
    <rect height="2" rx=".5" ry=".5" width="2" x="20" y="2" />
    <rect height="2" rx=".5" ry=".5" width="2" x="16" y="2" />
    <rect height="2" rx=".5" ry=".5" width="2" x="12" y="2" />
    <rect height="2" rx=".5" ry=".5" width="2" x="12" y="6" />
    <rect height="2" rx=".5" ry=".5" width="2" x="12" y="10" />
    <rect height="2" rx=".5" ry=".5" width="2" x="12" y="14" />
    <rect height="2" rx=".5" ry=".5" width="2" x="12" y="18" />
    <rect height="2" rx=".5" ry=".5" width="2" x="12" y="22" />
    <rect height="2" rx=".5" ry=".5" width="2" x="16" y="22" />
    <rect height="2" rx=".5" ry=".5" width="2" x="20" y="22" />
    <rect height="2" rx=".5" ry=".5" width="2" x="24" y="22" />
    <rect height="2" rx=".5" ry=".5" width="2" x="28" y="22" />
    <path d="M10 12H3a1 1 0 0 0-1 1v20a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1v-7H11a1 1 0 0 1-1-1Z" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCopy.js
var IconCopy = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? CopyIcon({ hidden: !this.label, title: this.label }) : CopyIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-copy.js
init_define_element();
defineElement("sp-icon-copy", IconCopy);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronUp.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ChevronUp.js
var ChevronUpIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Chevron Up" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M3.54492,12.2373c0-.19629.07715-.39355.23047-.54004l5.70312-5.4873c.29004-.28027.74902-.28027,1.03906,0l5.7168,5.5c.29883.28711.30762.7627.02051,1.05957-.28711.29883-.76172.30859-1.05957.02051l-5.19727-4.99902-5.18359,4.98633c-.29785.28809-.77246.27832-1.05957-.02051-.14062-.14453-.20996-.33203-.20996-.51954Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ChevronUp.js
var ChevronUpIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Chevron Up" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M28 21.98a2 2 0 0 1-3.411 1.411l-6.578-6.572-6.578 6.572a2 2 0 0 1-2.874-2.773l.049-.049 7.992-7.984a2 2 0 0 1 2.825 0l7.989 7.983A1.989 1.989 0 0 1 28 21.98Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronUp.js
var IconChevronUp = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ChevronUpIcon({ hidden: !this.label, title: this.label }) : ChevronUpIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-chevron-up.js
init_define_element();
defineElement("sp-icon-chevron-up", IconChevronUp);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronDown.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ChevronDown.js
var ChevronDownIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Chevron Down" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M3.75488,7.24316c.28711-.29883.76172-.3086,1.05957-.02051l5.18359,4.98633,5.19727-4.99902c.29785-.28808.77246-.27832,1.05957.02051.28711.29687.27832.77246-.02051,1.05957l-5.7168,5.5c-.29004.28027-.74902.28027-1.03906,0l-5.70312-5.4873c-.15332-.14649-.23047-.34375-.23047-.54004,0-.18751.06934-.37501.20996-.51954Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ChevronDown.js
var ChevronDownIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Chevron Down" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M8 14.02a2 2 0 0 1 3.411-1.411l6.578 6.572 6.578-6.572a2 2 0 0 1 2.874 2.773l-.049.049-7.992 7.984a2 2 0 0 1-2.825 0l-7.989-7.983A1.989 1.989 0 0 1 8 14.02Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronDown.js
var IconChevronDown = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ChevronDownIcon({ hidden: !this.label, title: this.label }) : ChevronDownIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-chevron-down.js
init_define_element();
defineElement("sp-icon-chevron-down", IconChevronDown);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronDoubleLeft.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ChevronDoubleLeft.js
var ChevronDoubleLeftIcon = ({ width: e36 = 24, height: l16 = 24, hidden: t34 = false, title: r25 = "Chevron Double Left" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M9.86241,16.45508c-.19629,0-.39355-.07715-.54004-.23047l-5.4873-5.70312c-.28027-.29004-.28027-.74902,0-1.03906l5.5-5.7168c.28711-.29883.7627-.30762,1.05957-.02051.29883.28711.30859.76172.02051,1.05957l-4.99902,5.19727,4.98633,5.18359c.28809.29785.27832.77246-.02051,1.05957-.14453.14062-.33203.20996-.51954.20996Z"
      fill="currentColor"
    />
    <path
      d="M15.61241,16.45508c-.19629,0-.39355-.07715-.54004-.23047l-5.4873-5.70312c-.28027-.29004-.28027-.74902,0-1.03906l5.5-5.7168c.28711-.29883.7627-.30762,1.05957-.02051.29883.28711.30859.76172.02051,1.05957l-4.99902,5.19727,4.98633,5.18359c.28809.29785.27832.77246-.02051,1.05957-.14453.14062-.33203.20996-.51954.20996Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ChevronDoubleLeft.js
var ChevronDoubleLeftIcon2 = ({ width: e36 = 24, height: l16 = 24, hidden: t34 = false, title: a23 = "Chevron Double Left" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${l16}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M6 18a1.988 1.988 0 0 0 .585 1.409l7.983 7.98a2 2 0 1 0 2.871-2.772l-.049-.049L10.819 18l6.572-6.57a2 2 0 0 0-2.773-2.87l-.049.049-7.983 7.98A1.988 1.988 0 0 0 6 18Z"
    />
    <path
      d="M18 18a1.988 1.988 0 0 0 .585 1.409l7.983 7.98a2 2 0 1 0 2.871-2.772l-.049-.049L22.819 18l6.572-6.57a2 2 0 0 0-2.773-2.87l-.049.049-7.983 7.98A1.988 1.988 0 0 0 18 18Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronDoubleLeft.js
var IconChevronDoubleLeft = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ChevronDoubleLeftIcon({ hidden: !this.label, title: this.label }) : ChevronDoubleLeftIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-chevron-double-left.js
init_define_element();
defineElement("sp-icon-chevron-double-left", IconChevronDoubleLeft);

// node_modules/@spectrum-web-components/picker/src/Picker.js
init_src();
init_decorators2();
init_directives();
init_MatchMedia();

// node_modules/@spectrum-web-components/picker/src/picker.css.js
init_src();
var o33 = i`
    #button{cursor:pointer;-webkit-user-select:none;user-select:none;font-family:var(--mod-button-font-family,var(--mod-sans-font-family-stack,var(--spectrum-sans-font-family-stack)));-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;line-height:var(--mod-button-line-height,var(--mod-line-height-100,var(--spectrum-line-height-100)));text-transform:none;vertical-align:top;-webkit-appearance:button;transition:background var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,border-color var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,color var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out,box-shadow var(--mod-button-animation-duration,var(--mod-animation-duration-100,var(--spectrum-animation-duration-100)))ease-out;justify-content:center;align-items:center;margin:0;-webkit-text-decoration:none;text-decoration:none;display:inline-flex;position:relative;overflow:visible}#button::-moz-focus-inner{border-style:none;padding:0}#button:focus{outline:none}:host{--spectrum-picker-font-size:var(--spectrum-font-size-100);--spectrum-picker-font-weight:var(--spectrum-regular-font-weight);--spectrum-picker-placeholder-font-style:var(--spectrum-default-font-style);--spectrum-picker-line-height:var(--spectrum-line-height-100);--spectrum-picker-block-size:var(--spectrum-component-height-100);--spectrum-picker-inline-size:var(--spectrum-field-width);--spectrum-picker-border-radius:var(--spectrum-corner-radius-100);--spectrum-picker-spacing-top-to-text:var(--spectrum-component-top-to-text-100);--spectrum-picker-spacing-bottom-to-text:var(--spectrum-component-bottom-to-text-100);--spectrum-picker-spacing-edge-to-text:var(--spectrum-component-edge-to-text-100);--spectrum-picker-spacing-edge-to-text-quiet:var(--spectrum-field-edge-to-text-quiet);--spectrum-picker-spacing-label-to-picker:var(--spectrum-field-label-to-component);--spectrum-picker-spacing-text-to-icon:var(--spectrum-text-to-visual-100);--spectrum-picker-spacing-text-to-icon-inline-end:var(--spectrum-field-text-to-alert-icon-medium);--spectrum-picker-spacing-icon-to-disclosure-icon:var(--spectrum-picker-visual-to-disclosure-icon-medium);--spectrum-picker-spacing-label-to-picker-quiet:var(--spectrum-field-label-to-component-quiet-medium);--spectrum-picker-spacing-top-to-alert-icon:var(--spectrum-field-top-to-alert-icon-medium);--spectrum-picker-spacing-top-to-progress-circle:var(--spectrum-field-top-to-progress-circle-medium);--spectrum-picker-spacing-top-to-disclosure-icon:var(--spectrum-field-top-to-disclosure-icon-100);--spectrum-picker-spacing-edge-to-disclosure-icon:var(--spectrum-field-end-edge-to-disclosure-icon-100);--spectrum-picker-spacing-edge-to-disclosure-icon-quiet:var(--spectrum-picker-end-edge-to-disclousure-icon-quiet);--spectrum-picker-animation-duration:var(--spectrum-animation-duration-100);--spectrum-picker-font-color-default:var(--spectrum-neutral-content-color-default);--spectrum-picker-font-color-default-open:var(--spectrum-neutral-content-color-focus);--spectrum-picker-font-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-picker-font-color-hover-open:var(--spectrum-neutral-content-color-focus-hover);--spectrum-picker-font-color-active:var(--spectrum-neutral-content-color-down);--spectrum-picker-font-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-picker-icon-color-default:var(--spectrum-neutral-content-color-default);--spectrum-picker-icon-color-default-open:var(--spectrum-neutral-content-color-focus);--spectrum-picker-icon-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-picker-icon-color-hover-open:var(--spectrum-neutral-content-color-focus-hover);--spectrum-picker-icon-color-active:var(--spectrum-neutral-content-color-down);--spectrum-picker-icon-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-picker-border-color-error-default:var(--spectrum-negative-border-color-default);--spectrum-picker-border-color-error-default-open:var(--spectrum-negative-border-color-focus);--spectrum-picker-border-color-error-hover:var(--spectrum-negative-border-color-hover);--spectrum-picker-border-color-error-hover-open:var(--spectrum-negative-border-color-focus-hover);--spectrum-picker-border-color-error-active:var(--spectrum-negative-border-color-down);--spectrum-picker-border-color-error-key-focus:var(--spectrum-negative-border-color-key-focus);--spectrum-picker-icon-color-error:var(--spectrum-negative-visual-color);--spectrum-picker-background-color-disabled:var(--spectrum-disabled-background-color);--spectrum-picker-font-color-disabled:var(--spectrum-disabled-content-color);--spectrum-picker-icon-color-disabled:var(--spectrum-disabled-content-color);--spectrum-picker-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--spectrum-picker-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-picker-focus-indicator-color:var(--spectrum-focus-indicator-color)}:host([size=s]){--spectrum-picker-font-size:var(--spectrum-font-size-75);--spectrum-picker-block-size:var(--spectrum-component-height-75);--spectrum-picker-spacing-top-to-text:var(--spectrum-component-top-to-text-75);--spectrum-picker-spacing-bottom-to-text:var(--spectrum-component-bottom-to-text-75);--spectrum-picker-spacing-edge-to-text:var(--spectrum-component-edge-to-text-75);--spectrum-picker-spacing-text-to-icon:var(--spectrum-text-to-visual-75);--spectrum-picker-spacing-text-to-icon-inline-end:var(--spectrum-field-text-to-alert-icon-small);--spectrum-picker-spacing-icon-to-disclosure-icon:var(--spectrum-picker-visual-to-disclosure-icon-small);--spectrum-picker-spacing-label-to-picker-quiet:var(--spectrum-field-label-to-component-quiet-small);--spectrum-picker-spacing-top-to-alert-icon:var(--spectrum-field-top-to-alert-icon-small);--spectrum-picker-spacing-top-to-progress-circle:var(--spectrum-field-top-to-progress-circle-small);--spectrum-picker-spacing-top-to-disclosure-icon:var(--spectrum-field-top-to-disclosure-icon-75);--spectrum-picker-spacing-edge-to-disclosure-icon:var(--spectrum-field-end-edge-to-disclosure-icon-75)}:host([size=l]){--spectrum-picker-font-size:var(--spectrum-font-size-200);--spectrum-picker-block-size:var(--spectrum-component-height-200);--spectrum-picker-spacing-top-to-text:var(--spectrum-component-top-to-text-200);--spectrum-picker-spacing-bottom-to-text:var(--spectrum-component-bottom-to-text-200);--spectrum-picker-spacing-edge-to-text:var(--spectrum-component-edge-to-text-200);--spectrum-picker-spacing-text-to-icon:var(--spectrum-text-to-visual-200);--spectrum-picker-spacing-text-to-icon-inline-end:var(--spectrum-field-text-to-alert-icon-large);--spectrum-picker-spacing-icon-to-disclosure-icon:var(--spectrum-picker-visual-to-disclosure-icon-large);--spectrum-picker-spacing-label-to-picker-quiet:var(--spectrum-field-label-to-component-quiet-large);--spectrum-picker-spacing-top-to-alert-icon:var(--spectrum-field-top-to-alert-icon-large);--spectrum-picker-spacing-top-to-progress-circle:var(--spectrum-field-top-to-progress-circle-large);--spectrum-picker-spacing-top-to-disclosure-icon:var(--spectrum-field-top-to-disclosure-icon-200);--spectrum-picker-spacing-edge-to-disclosure-icon:var(--spectrum-field-end-edge-to-disclosure-icon-200)}:host([size=xl]){--spectrum-picker-font-size:var(--spectrum-font-size-300);--spectrum-picker-block-size:var(--spectrum-component-height-300);--spectrum-picker-spacing-top-to-text:var(--spectrum-component-top-to-text-300);--spectrum-picker-spacing-bottom-to-text:var(--spectrum-component-bottom-to-text-300);--spectrum-picker-spacing-edge-to-text:var(--spectrum-component-edge-to-text-300);--spectrum-picker-spacing-text-to-icon:var(--spectrum-text-to-visual-300);--spectrum-picker-spacing-text-to-icon-inline-end:var(--spectrum-field-text-to-alert-icon-extra-large);--spectrum-picker-spacing-icon-to-disclosure-icon:var(--spectrum-picker-visual-to-disclosure-icon-extra-large);--spectrum-picker-spacing-label-to-picker-quiet:var(--spectrum-field-label-to-component-quiet-extra-large);--spectrum-picker-spacing-top-to-alert-icon:var(--spectrum-field-top-to-alert-icon-extra-large);--spectrum-picker-spacing-top-to-progress-circle:var(--spectrum-field-top-to-progress-circle-extra-large);--spectrum-picker-spacing-top-to-disclosure-icon:var(--spectrum-field-top-to-disclosure-icon-300);--spectrum-picker-spacing-edge-to-disclosure-icon:var(--spectrum-field-end-edge-to-disclosure-icon-300)}@media (forced-colors:active){:host{--highcontrast-picker-focus-indicator-color:Highlight;--highcontrast-picker-border-color-default:ButtonBorder;--highcontrast-picker-border-color-hover:Highlight;--highcontrast-picker-border-color-disabled:GrayText;--highcontrast-picker-content-color-default:ButtonText;--highcontrast-picker-content-color-disabled:GrayText;--highcontrast-picker-background-color:ButtonFace}#button.is-keyboardFocused,#button:focus-visible{--highcontrast-picker-border-color-hover:ButtonText}#button .label,#button:after{forced-color-adjust:none}}#button{box-sizing:border-box;max-inline-size:100%;min-inline-size:calc(var(--spectrum-picker-minimum-width-multiplier)*var(--mod-picker-block-size,var(--spectrum-picker-block-size)));inline-size:var(--mod-picker-inline-size,var(--spectrum-picker-inline-size));block-size:var(--mod-picker-block-size,var(--spectrum-picker-block-size));border-width:var(--mod-picker-border-width,var(--spectrum-picker-border-width));border-radius:var(--mod-picker-border-radius,var(--spectrum-picker-border-radius));transition:background-color var(--mod-picker-animation-duration,var(--spectrum-picker-animation-duration)),box-shadow var(--mod-picker-animation-duration,var(--spectrum-picker-animation-duration)),border-color var(--mod-picker-animation-duration,var(--spectrum-picker-animation-duration))ease-in-out;color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-default,var(--spectrum-picker-font-color-default)));background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-default,var(--spectrum-picker-background-color-default)));border-style:solid;border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-color-default,var(--spectrum-picker-border-color-default)));margin-block-start:var(--mod-picker-spacing-label-to-picker,var(--spectrum-picker-spacing-label-to-picker));padding-block:0;padding-inline-start:var(--mod-picker-spacing-edge-to-text,var(--spectrum-picker-spacing-edge-to-text));padding-inline-end:var(--mod-picker-spacing-edge-to-disclosure-icon,var(--spectrum-picker-spacing-edge-to-disclosure-icon));display:flex}#button:after{pointer-events:none;content:"";block-size:calc(100% + var(--mod-picker-focus-indicator-gap,var(--spectrum-picker-focus-indicator-gap))*2 + var(--mod-picker-border-width,var(--spectrum-picker-border-width))*2);inline-size:calc(100% + var(--mod-picker-focus-indicator-gap,var(--spectrum-picker-focus-indicator-gap))*2 + var(--mod-picker-border-width,var(--spectrum-picker-border-width))*2);border-style:solid;border-width:var(--mod-picker-focus-indicator-thickness,var(--spectrum-picker-focus-indicator-thickness));border-radius:calc(var(--mod-picker-border-radius,var(--spectrum-picker-border-radius)) + var(--mod-picker-focus-indicator-gap,var(--spectrum-picker-focus-indicator-gap)) + var(--mod-picker-border-width,var(--spectrum-picker-border-width)));border-color:#0000;margin-block-start:calc((var(--mod-picker-focus-indicator-gap,var(--spectrum-picker-focus-indicator-gap)) + var(--mod-picker-focus-indicator-thickness,var(--spectrum-picker-focus-indicator-thickness)) + var(--mod-picker-border-width,var(--spectrum-picker-border-width)))*-1);margin-inline-start:calc((var(--mod-picker-focus-indicator-gap,var(--spectrum-picker-focus-indicator-gap)) + var(--mod-picker-focus-indicator-thickness,var(--spectrum-picker-focus-indicator-thickness)) + var(--mod-picker-border-width,var(--spectrum-picker-border-width)))*-1);position:absolute;inset-block:0;inset-inline:0}#button:active{background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-active,var(--spectrum-picker-background-color-active)));border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-active,var(--spectrum-picker-border-color-active)))}#button:active:after{border-color:#0000}#button.placeholder:active .label{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-active,var(--spectrum-picker-font-color-active)))}#button.is-keyboardFocused,#button:focus-visible{background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-key-focus,var(--spectrum-picker-background-color-key-focus)));border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-color-key-focus,var(--spectrum-picker-border-color-key-focus)));color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-key-focus,var(--spectrum-picker-font-color-key-focus)));outline:none}#button.is-keyboardFocused:after,#button:focus-visible:after{border-color:var(--highcontrast-picker-focus-indicator-color,var(--mod-picker-focus-indicator-color,var(--spectrum-picker-focus-indicator-color)))}#button.is-keyboardFocused .label.placeholder,#button:focus-visible .label.placeholder{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-key-focus,var(--spectrum-picker-font-color-key-focus)))}#button.is-keyboardFocused .picker,#button:focus-visible .picker{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-icon-color-key-focus,var(--spectrum-picker-icon-color-key-focus)))}:host([open]) #button:not(.spectrum-Picker--quiet,:disabled,.is-disabled){color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-default-open,var(--spectrum-picker-font-color-default-open)));background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-default-open,var(--spectrum-picker-background-color-default-open)));border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-default-open,var(--spectrum-picker-border-color-default-open)))}:host([open]) #button:not(.spectrum-Picker--quiet,:disabled,.is-disabled) .picker{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-icon-color-default-open,var(--spectrum-picker-icon-color-default-open)))}:host([invalid]) #button:not(:disabled,.is-disabled){border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-color-error-default,var(--spectrum-picker-border-color-error-default)))}:host([invalid]) #button:not(:disabled,.is-disabled) .validation-icon{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-icon-color-error,var(--spectrum-picker-icon-color-error)))}:host([invalid]) #button:not(:disabled,.is-disabled):active{border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-color-error-active,var(--spectrum-picker-border-color-error-active)))}:host([invalid][open]) #button:not(:disabled,.is-disabled){border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-color-error-default-open,var(--spectrum-picker-border-color-error-default-open)))}:host([invalid]) #button.is-keyboardFocused:not(:disabled,.is-disabled),:host([invalid]) #button:not(:disabled,.is-disabled):focus-visible{border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-color-error-key-focus,var(--spectrum-picker-border-color-error-key-focus)))}:host([pending]) #button .picker{color:var(--highcontrast-picker-content-color-disabled,var(--mod-picker-icon-color-disabled,var(--spectrum-picker-icon-color-disabled)))}:host([invalid]) #button .label,:host([pending]) #button .label{margin-inline-end:var(--mod-picker-spacing-text-to-icon-inline-end,var(--mod-picker-spacing-text-to-alert-icon-inline-start,var(--spectrum-picker-spacing-text-to-icon-inline-end)))}.icon{flex-shrink:0;margin-inline-end:var(--mod-picker-spacing-text-to-icon,var(--spectrum-picker-spacing-text-to-icon))}.label{white-space:nowrap;font-size:var(--mod-picker-font-size,var(--spectrum-picker-font-size));line-height:var(--mod-picker-line-height,var(--spectrum-picker-line-height));font-weight:var(--mod-picker-font-weight,var(--spectrum-picker-font-weight));text-overflow:ellipsis;text-align:start;flex:auto;padding-block-start:var(--mod-picker-spacing-top-to-text,var(--spectrum-picker-spacing-top-to-text));padding-block-end:calc(var(--mod-picker-spacing-bottom-to-text,var(--spectrum-picker-spacing-bottom-to-text)) - var(--mod-picker-border-width,var(--spectrum-picker-border-width)));overflow:hidden}.label.placeholder{font-weight:var(--mod-picker-placeholder-font-weight,var(--spectrum-picker-font-weight));font-style:var(--mod-picker-placeholder-font-style,var(--spectrum-picker-placeholder-font-style));transition:color var(--mod-picker-animation-duration,var(--spectrum-picker-animation-duration))ease-in-out;color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-default,var(--spectrum-picker-font-color-default)))}.label.placeholder:active{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-active,var(--spectrum-picker-font-color-active)))}.picker{vertical-align:top;transition:color var(--mod-picker-animation-duration,var(--spectrum-picker-animation-duration))ease-out;margin-inline-start:var(--mod-picker-spacing-icon-to-disclosure-icon,var(--spectrum-picker-spacing-icon-to-disclosure-icon));margin-block:var(--mod-picker-spacing-top-to-disclosure-icon,var(--spectrum-picker-spacing-top-to-disclosure-icon));color:var(--highcontrast-picker-content-color-default,var(--mod-picker-icon-color-default,var(--spectrum-picker-icon-color-default)));flex-shrink:0;display:inline-block;position:relative}.picker:active{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-icon-color-active,var(--spectrum-picker-icon-color-active)))}.validation-icon{flex-shrink:0;margin-block-start:calc(var(--mod-picker-spacing-top-to-alert-icon,var(--spectrum-picker-spacing-top-to-alert-icon)) - var(--mod-picker-border-width,var(--spectrum-picker-border-width)));margin-block-end:calc(var(--mod-picker-spacing-top-to-alert-icon,var(--spectrum-picker-spacing-top-to-alert-icon)) - var(--mod-picker-border-width,var(--spectrum-picker-border-width)))}#button .progress-circle{margin-block-start:calc(var(--mod-picker-spacing-top-to-progress-circle,var(--spectrum-picker-spacing-top-to-progress-circle)) - var(--mod-picker-border-width,var(--spectrum-picker-border-width)));margin-block-end:calc(var(--mod-picker-spacing-top-to-progress-circle,var(--spectrum-picker-spacing-top-to-progress-circle)) - var(--mod-picker-border-width,var(--spectrum-picker-border-width)))}.label~.picker{margin-inline-start:var(--mod-picker-spacing-text-to-icon,var(--spectrum-picker-spacing-text-to-icon))}:host([quiet]) #button{inline-size:auto;min-inline-size:0;padding-inline:var(--mod-picker-spacing-edge-to-text-quiet,var(--spectrum-picker-spacing-edge-to-text-quiet));color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-default,var(--spectrum-picker-font-color-default)));background-color:initial;background-color:var(--highcontrast-picker-background-color,transparent);border:none;border-radius:0;margin-block-start:calc(var(--mod-picker-spacing-label-to-picker-quiet,var(--spectrum-picker-spacing-label-to-picker-quiet)) + 1px)}:host([quiet]) #button.label-inline{margin-block-start:0}:host([quiet]) #button .picker{margin-inline-end:var(--mod-picker-spacing-edge-to-disclosure-icon-quiet,var(--spectrum-picker-spacing-edge-to-disclosure-icon-quiet))}:host([quiet]) #button:after{border:none;block-size:auto;inline-size:auto}@media (hover:hover){#button:hover{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-hover,var(--spectrum-picker-font-color-hover)));background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-hover,var(--spectrum-picker-background-color-hover)));border-color:var(--highcontrast-picker-border-color-hover,var(--mod-picker-border-color-hover,var(--spectrum-picker-border-color-hover)))}#button:hover .picker{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-icon-color-hover,var(--spectrum-picker-icon-color-hover)))}:host([open]) #button:not(.spectrum-Picker--quiet,:disabled,.is-disabled):hover{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-hover-open,var(--spectrum-picker-font-color-hover-open)));background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-hover-open,var(--spectrum-picker-background-color-hover-open)));border-color:var(--highcontrast-picker-border-color-hover,var(--mod-picker-border-color-hover-open,var(--spectrum-picker-border-color-hover-open)))}:host([open]) #button:not(.spectrum-Picker--quiet,:disabled,.is-disabled):hover .picker{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-icon-color-hover-open,var(--spectrum-picker-icon-color-hover-open)))}:host([invalid]) #button:not(:disabled,.is-disabled):hover{border-color:var(--highcontrast-picker-border-color-hover,var(--mod-picker-border-color-error-hover,var(--spectrum-picker-border-color-error-hover)))}:host([invalid][open]) #button:not(:disabled,.is-disabled):hover{border-color:var(--highcontrast-picker-border-color-hover,var(--mod-picker-border-color-error-hover-open,var(--spectrum-picker-border-color-error-hover-open)))}.label.placeholder:hover{color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-hover,var(--spectrum-picker-font-color-hover)))}:host([quiet]) #button:hover{background-color:initial;background-color:var(--highcontrast-picker-background-color,transparent)}}:host([quiet]) #button.is-keyboardFocused,:host([quiet]) #button:focus-visible{background-color:initial;background-color:var(--highcontrast-picker-background-color,transparent)}:host([quiet]) #button.is-keyboardFocused:after,:host([quiet]) #button:focus-visible:after{box-shadow:0 var(--mod-picker-focus-indicator-thickness,var(--spectrum-picker-focus-indicator-thickness))0 0 var(--highcontrast-picker-focus-indicator-color,var(--mod-picker-focus-indicator-color,var(--spectrum-picker-focus-indicator-color)));margin:calc((var(--mod-picker-focus-indicator-gap,var(--spectrum-picker-focus-indicator-gap)) + var(--mod-picker-border-width,var(--spectrum-picker-border-width)))*-1)0;border:none;border-radius:0}:host([quiet][open]) #button,:host([quiet][disabled]) #button#button,:host([quiet]) #button#button:disabled,:host([quiet]) #button:active{background-color:initial;background-color:var(--highcontrast-picker-background-color,transparent)}.label-inline{vertical-align:top;display:inline-flex}:host([disabled]) #button,#button:disabled{cursor:default;background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-disabled,var(--spectrum-picker-background-color-disabled)));border-color:var(--highcontrast-picker-border-color-disabled,var(--spectrum-picker-border-color-disabled));color:var(--highcontrast-picker-content-color-disabled,var(--mod-picker-font-color-disabled,var(--spectrum-picker-font-color-disabled)))}:host([disabled]) #button .icon,:host([disabled]) #button .picker,:host([disabled]) #button .validation-icon,#button:disabled .icon,#button:disabled .picker,#button:disabled .validation-icon{color:var(--highcontrast-picker-content-color-disabled,var(--mod-picker-icon-color-disabled,var(--spectrum-picker-icon-color-disabled)))}:host([disabled]) #button .label.placeholder,#button:disabled .label.placeholder{color:var(--highcontrast-picker-content-color-disabled,var(--mod-picker-font-color-disabled,var(--spectrum-picker-font-color-disabled)))}:host{--spectrum-picker-background-color-default:var(--system-picker-background-color-default);--spectrum-picker-background-color-default-open:var(--system-picker-background-color-default-open);--spectrum-picker-background-color-hover:var(--system-picker-background-color-hover);--spectrum-picker-background-color-hover-open:var(--system-picker-background-color-hover-open);--spectrum-picker-background-color-active:var(--system-picker-background-color-active);--spectrum-picker-background-color-key-focus:var(--system-picker-background-color-key-focus);--spectrum-picker-border-color-default:var(--system-picker-border-color-default);--spectrum-picker-border-color-default-open:var(--system-picker-border-color-default-open);--spectrum-picker-border-color-hover:var(--system-picker-border-color-hover);--spectrum-picker-border-color-hover-open:var(--system-picker-border-color-hover-open);--spectrum-picker-border-color-active:var(--system-picker-border-color-active);--spectrum-picker-border-color-key-focus:var(--system-picker-border-color-key-focus);--spectrum-picker-border-color-disabled:var(--system-picker-border-color-disabled);--spectrum-picker-border-width:var(--system-picker-border-width)}:host{--mod-popover-inline-size:var(--mod-picker-inline-size,var(--spectrum-picker-inline-size));vertical-align:top;max-inline-size:100%;inline-size:var(--mod-picker-inline-size,var(--spectrum-picker-inline-size));min-inline-size:calc(var(--spectrum-picker-minimum-width-multiplier)*var(--mod-picker-block-size,var(--spectrum-picker-block-size)));display:inline-flex}:host([quiet]){width:auto;min-width:0}:host([disabled]){pointer-events:none}#button{width:100%;min-width:100%;max-width:100%}#icon:not([hidden]){display:inline-flex}:host([readonly]) #button{user-select:inherit}.picker,.validation-icon{flex-shrink:0}sp-overlay{pointer-events:none}sp-menu{pointer-events:initial}:host>sp-menu{display:none}:host([focused]:not([quiet])) #button #label.placeholder{color:var(--spectrum-picker-placeholder-text-color-key-focus,var(--spectrum-alias-placeholder-text-color-hover))}#label.visually-hidden~.picker{margin-inline-start:auto}:host([focused]:not([quiet],[pending])) #button .picker{color:var(--spectrum-picker-icon-color-key-focus,var(--spectrum-alias-icon-color-focus))}.visually-hidden{clip:rect(0,0,0,0);clip-path:inset(50%);white-space:nowrap;border:0;width:1px;height:1px;margin:0 -1px -1px 0;padding:0;position:absolute;overflow:hidden}sp-overlay:not(:defined){display:none}#button.remove-focus-ring-safari-hack:focus-visible{background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-default,var(--spectrum-picker-background-color-default)));border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-color-default,var(--spectrum-picker-border-color-default)));color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-default,var(--spectrum-picker-font-color-default)))}#button.remove-focus-ring-safari-hack:after{border:none}#button.remove-focus-ring-safari-hack:focus-visible:after{box-shadow:none}#button.remove-focus-ring-safari-hack:active{background-color:var(--highcontrast-picker-background-color,var(--mod-picker-background-color-default,var(--spectrum-picker-background-color-default)));border-color:var(--highcontrast-picker-border-color-default,var(--mod-picker-border-color-default,var(--spectrum-picker-border-color-default)));color:var(--highcontrast-picker-content-color-default,var(--mod-picker-font-color-default,var(--spectrum-picker-font-color-default)))}
`;
var picker_css_default = o33;

// node_modules/@spectrum-web-components/picker/src/InteractionController.js
var InteractionTypes2 = ((t34) => (t34[t34.desktop = 0] = "desktop", t34[t34.mobile = 1] = "mobile", t34))(InteractionTypes2 || {});
var SAFARI_FOCUS_RING_CLASS = "remove-focus-ring-safari-hack";
var InteractionController2 = class {
  constructor(e36, t34) {
    this.target = e36;
    this.host = t34;
    this.preventNextToggle = "no";
    this.pointerdownState = false;
    this.enterKeydownOn = null;
    this._open = false;
    this.target = e36, this.host = t34, this.host.addController(this), this.init();
  }
  get activelyOpening() {
    return false;
  }
  get open() {
    return this._open;
  }
  set open(e36) {
    if (this._open !== e36) {
      if (this._open = e36, this.overlay) {
        this.host.open = e36;
        return;
      }
      customElements.whenDefined("sp-overlay").then(async () => {
        const { Overlay: t34 } = await Promise.resolve().then(() => (init_Overlay(), Overlay_exports));
        this.overlay = new t34(), this.host.open = true, this.host.requestUpdate();
      }), Promise.resolve().then(() => init_sp_overlay());
    }
  }
  get overlay() {
    return this._overlay;
  }
  set overlay(e36) {
    e36 && this.overlay !== e36 && (this._overlay = e36, this.initOverlay());
  }
  releaseDescription() {
  }
  handleBeforetoggle(e36) {
    var t34;
    e36.composedPath()[0] === e36.target && (e36.newState === "closed" && (this.preventNextToggle === "no" ? this.open = false : this.pointerdownState || (t34 = this.overlay) == null || t34.manuallyKeepOpen()), this.open || (this.host.optionsMenu.updateSelectedItemIndex(), this.host.optionsMenu.closeDescendentOverlays()));
  }
  initOverlay() {
    this.overlay && (this.overlay.addEventListener("beforetoggle", (e36) => {
      this.handleBeforetoggle(e36);
    }), this.overlay.type = this.host.isMobile.matches && !this.host.forcePopover ? "modal" : "auto", this.overlay.triggerElement = this.host, this.overlay.placement = this.host.isMobile.matches && !this.host.forcePopover ? void 0 : this.host.placement, this.overlay.receivesFocus = "false", this.overlay.willPreventClose = this.preventNextToggle !== "no" && this.open, this.overlay.addEventListener("slottable-request", this.host.handleSlottableRequest));
  }
  handlePointerdown(e36) {
  }
  handleButtonFocus(e36) {
    this.preventNextToggle === "maybe" && e36.relatedTarget === this.host.optionsMenu && (this.preventNextToggle = "yes"), this.preventNextToggle === "no" && this.host.close();
  }
  handleActivate(e36) {
  }
  init() {
  }
  abort() {
    var e36;
    this.releaseDescription(), (e36 = this.abortController) == null || e36.abort();
  }
  hostConnected() {
    this.init(), this.host.addEventListener("sp-opened", () => {
      this.host.optionsMenu.shouldSupportDragAndSelect = !this.host.isMobile.matches;
    }), this.host.addEventListener("sp-closed", () => {
      !this.open && this.host.optionsMenu.matches(":focus-within") && !this.host.button.matches(":focus") && this.host.button.focus();
    });
  }
  hostDisconnected() {
    var e36;
    (e36 = this.abortController) == null || e36.abort();
  }
  hostUpdated() {
    this.overlay && this.host.dependencyManager.loaded && this.host.open !== this.overlay.open && (this.overlay.willPreventClose = this.preventNextToggle !== "no", this.overlay.open = this.host.open);
  }
};

// node_modules/@spectrum-web-components/picker/src/DesktopController.js
var DesktopController = class extends InteractionController2 {
  constructor() {
    super(...arguments);
    this.type = InteractionTypes2.desktop;
  }
  handlePointerdown(e36) {
    if (e36.button !== 0 || e36.pointerType === "touch") return;
    this.pointerdownState = this.open, this.preventNextToggle = "maybe";
    let n25 = 0;
    const t34 = () => {
      cancelAnimationFrame(n25), n25 = requestAnimationFrame(async () => {
        document.removeEventListener("pointerup", t34), document.removeEventListener("pointercancel", t34), this.target.removeEventListener("click", t34), requestAnimationFrame(() => {
          this.preventNextToggle = "no";
        });
      });
    };
    document.addEventListener("pointerup", t34), document.addEventListener("pointercancel", t34), this.target.addEventListener("click", t34), this.handleActivate();
  }
  handleActivate(e36) {
    this.enterKeydownOn && this.enterKeydownOn !== this.target || this.preventNextToggle !== "yes" && ((e36 == null ? void 0 : e36.type) === "click" && this.open !== this.pointerdownState || this.host.toggle());
  }
  init() {
    var n25;
    (n25 = this.abortController) == null || n25.abort(), this.abortController = new AbortController();
    const { signal: e36 } = this.abortController;
    this.target.addEventListener("click", (t34) => this.handleActivate(t34), { signal: e36 }), this.target.addEventListener("pointerdown", (t34) => this.handlePointerdown(t34), { signal: e36 }), this.target.addEventListener("focus", (t34) => this.handleButtonFocus(t34), { signal: e36 });
  }
};

// node_modules/@spectrum-web-components/picker/src/MobileController.js
init_src2();
var MobileController = class extends InteractionController2 {
  constructor() {
    super(...arguments);
    this.type = InteractionTypes2.mobile;
  }
  handleClick() {
    this.host.disabled || (this.preventNextToggle == "no" && this.host.toggle(), this.preventNextToggle = "no");
  }
  handlePointerdown() {
    this.preventNextToggle = this.open ? "yes" : "no", isWebKit() && this.target.classList.add(SAFARI_FOCUS_RING_CLASS);
  }
  handleFocusOut() {
    this.host.open || isWebKit() && this.target.classList.contains(SAFARI_FOCUS_RING_CLASS) && this.target.classList.remove(SAFARI_FOCUS_RING_CLASS);
  }
  init() {
    var i21;
    (i21 = this.abortController) == null || i21.abort(), this.abortController = new AbortController();
    const { signal: t34 } = this.abortController;
    this.target.addEventListener("click", () => this.handleClick(), { signal: t34 }), this.target.addEventListener("pointerdown", () => this.handlePointerdown(), { signal: t34 }), this.target.addEventListener("focusout", () => this.handleFocusOut(), { signal: t34 });
  }
};

// node_modules/@spectrum-web-components/picker/src/strategies.js
var strategies2 = { desktop: DesktopController, mobile: MobileController };

// node_modules/@spectrum-web-components/picker/src/Picker.js
var I3 = Object.defineProperty;
var M3 = Object.getOwnPropertyDescriptor;
var i15 = (p30, d22, e36, t34) => {
  for (var s19 = t34 > 1 ? void 0 : t34 ? M3(d22, e36) : d22, n25 = p30.length - 1, l16; n25 >= 0; n25--) (l16 = p30[n25]) && (s19 = (t34 ? l16(d22, e36, s19) : l16(s19)) || s19);
  return t34 && s19 && I3(d22, e36, s19), s19;
};
var T4 = { s: "spectrum-UIIcon-ChevronDown75", m: "spectrum-UIIcon-ChevronDown100", l: "spectrum-UIIcon-ChevronDown200", xl: "spectrum-UIIcon-ChevronDown300" };
var DESCRIPTION_ID = "option-picker";
var PickerBase = class extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.isMobile = new MatchMediaController(this, IS_MOBILE);
    this.dependencyManager = new DependencyManagerController(this);
    this.deprecatedMenu = null;
    this.disabled = false;
    this.focused = false;
    this.invalid = false;
    this.forcePopover = false;
    this.pending = false;
    this.pendingLabel = "Pending";
    this.open = false;
    this.readonly = false;
    this.selects = "single";
    this.placement = "bottom-start";
    this.quiet = false;
    this.value = "";
    this.listRole = "listbox";
    this.itemRole = "option";
    this.handleEscape = (e36) => {
      e36.key === "Escape" && this.open && (e36.stopPropagation(), e36.preventDefault(), this.toggle(false));
    };
    this.handleKeydown = (e36) => {
      if (this.focused = true, !!["ArrowUp", "ArrowDown", "Enter", " ", "Escape"].includes(e36.key)) {
        if (e36.key === "Escape") {
          this.handleEscape(e36);
          return;
        }
        e36.stopPropagation(), e36.preventDefault(), this.keyboardOpen();
      }
    };
    this.handleSlottableRequest = (e36) => {
    };
    this.applyFocusElementLabel = (e36, t34) => {
      this.appliedLabel = e36, this.labelAlignment = t34.sideAligned ? "inline" : void 0;
    };
    this.hasRenderedOverlay = false;
    this.willManageSelection = false;
    this.selectionPromise = Promise.resolve();
    this.recentlyConnected = false;
    this.enterKeydownOn = null;
    this.handleEnterKeydown = (e36) => {
      if (e36.key !== "Enter") return;
      const t34 = e36 == null ? void 0 : e36.target;
      if (!t34.open && t34.hasSubmenu) {
        e36.preventDefault();
        return;
      }
      if (this.enterKeydownOn) {
        e36.preventDefault();
        return;
      }
      this.enterKeydownOn = e36.target, this.addEventListener("keyup", async (s19) => {
        s19.key === "Enter" && (this.enterKeydownOn = null);
      }, { once: true });
    };
  }
  get menuItems() {
    return this.optionsMenu.childItems;
  }
  get selfManageFocusElement() {
    return true;
  }
  get selectedItem() {
    return this._selectedItem;
  }
  set selectedItem(e36) {
    if (this.selectedItemContent = e36 ? e36.itemChildren : void 0, e36 === this.selectedItem) return;
    const t34 = this.selectedItem;
    this._selectedItem = e36, this.requestUpdate("selectedItem", t34);
  }
  get focusElement() {
    return this.open ? this.optionsMenu : this.button;
  }
  forceFocusVisible() {
    this.disabled || (this.focused = true);
  }
  click() {
    this.toggle();
  }
  handleButtonClick() {
    this.disabled || this.toggle();
  }
  handleButtonBlur() {
    this.focused = false;
  }
  focus(e36) {
    var t34;
    (t34 = this.focusElement) == null || t34.focus(e36);
  }
  handleHelperFocus() {
    this.focused = true, this.button.focus();
  }
  handleFocus() {
    !this.disabled && this.focusElement && (this.focused = this.hasVisibleFocusInTree());
  }
  handleChange(e36) {
    this.strategy && (this.strategy.preventNextToggle = "no");
    const t34 = e36.target, [s19] = t34.selectedItems;
    e36.stopPropagation(), e36.cancelable ? this.setValueFromItem(s19, e36) : (this.open = false, this.strategy && (this.strategy.open = false));
  }
  handleButtonFocus(e36) {
    var t34;
    (t34 = this.strategy) == null || t34.handleButtonFocus(e36);
  }
  async keyboardOpen() {
    var e36;
    !this.open || !this.strategy.open ? (this.addEventListener("sp-opened", () => {
      var t34;
      return (t34 = this.optionsMenu) == null ? void 0 : t34.focusOnFirstSelectedItem();
    }, { once: true }), this.toggle(true)) : (e36 = this.optionsMenu) == null || e36.focusOnFirstSelectedItem();
  }
  async setValueFromItem(e36, t34) {
    var a23;
    this.open = false;
    const s19 = this.selectedItem, n25 = this.value;
    if (this.selectedItem = e36, this.value = (a23 = e36 == null ? void 0 : e36.value) != null ? a23 : "", await this.updateComplete, !this.dispatchEvent(new Event("change", { bubbles: true, cancelable: true, composed: true })) && this.selects) {
      t34 && t34.preventDefault(), this.setMenuItemSelected(this.selectedItem, false), s19 && this.setMenuItemSelected(s19, true), this.selectedItem = s19, this.value = n25, this.open = true, this.strategy && (this.strategy.open = true);
      return;
    } else if (!this.selects) {
      this.selectedItem = s19, this.value = n25;
      return;
    }
    s19 && this.setMenuItemSelected(s19, false), this.setMenuItemSelected(e36, !!this.selects);
  }
  setMenuItemSelected(e36, t34) {
    this.selects != null && (e36.selected = t34);
  }
  toggle(e36) {
    if (this.readonly || this.pending || this.disabled) return;
    const t34 = typeof e36 != "undefined" ? e36 : !this.open;
    this.open = t34, this.strategy && (this.strategy.open = this.open);
  }
  close() {
    this.readonly || this.strategy && (this.open = false, this.strategy.open = false);
  }
  get containerStyles() {
    return this.isMobile.matches ? { "--swc-menu-width": "100%" } : {};
  }
  get selectedItemContent() {
    return this._selectedItemContent || { icon: [], content: [] };
  }
  set selectedItemContent(e36) {
    if (e36 === this.selectedItemContent) return;
    const t34 = this.selectedItemContent;
    this._selectedItemContent = e36, this.requestUpdate("selectedItemContent", t34);
  }
  handleTooltipSlotchange(e36) {
    var t34;
    this.tooltipEl = e36.target.assignedElements()[0], (t34 = this.tooltipEl) != null && t34.selfManaged && this.updateComplete.then(() => {
      var s19;
      (s19 = this.tooltipEl) != null && s19.overlayElement && this.button && (this.tooltipEl.overlayElement.triggerElement = this.button);
    });
  }
  renderLabelContent(e36) {
    return this.value && this.selectedItem ? e36 : x`
            <slot name="label" id="label">
                <span
                    aria-hidden=${o9(this.appliedLabel ? void 0 : "true")}
                >
                    ${this.label}
                </span>
            </slot>
        `;
  }
  renderLoader() {
    return Promise.resolve().then(() => init_sp_progress_circle()), x`
            <sp-progress-circle
                size="s"
                indeterminate
                role="presentation"
                class="progress-circle"
            ></sp-progress-circle>
        `;
  }
  get buttonContent() {
    const e36 = { "visually-hidden": this.icons === "only" && !!this.value, placeholder: !this.value, label: true }, t34 = this.appliedLabel || this.label;
    return [x`
                <span id="icon" ?hidden=${this.icons === "none"}>
                    ${this.selectedItemContent.icon}
                </span>
                <span
                    id=${o9(this.value && this.selectedItem ? "label" : void 0)}
                    class=${e10(e36)}
                >
                    ${this.renderLabelContent(this.selectedItemContent.content)}
                </span>
                ${this.value && this.selectedItem ? x`
                          <span
                              aria-hidden="true"
                              class="visually-hidden"
                              id="applied-label"
                          >
                              ${t34}
                              <slot name="label"></slot>
                          </span>
                      ` : x`
                          <span hidden id="applied-label">${t34}</span>
                      `}
                ${this.invalid && !this.pending ? x`
                          <sp-icon-alert
                              class="validation-icon"
                          ></sp-icon-alert>
                      ` : E}
                ${this.pending ? x`
                          ${this.renderLoader()}
                          <span
                              aria-hidden="true"
                              class="visually-hidden"
                              id="pending-label"
                          >
                              ${this.pendingLabel}
                          </span>
                      ` : E}
                <sp-icon-chevron100
                    class="picker ${T4[this.size]}"
                ></sp-icon-chevron100>
            `];
  }
  hasAccessibleLabel() {
    var s19, n25, l16, a23, m18, b12, f11;
    const e36 = ((s19 = this.querySelector('[slot="label"]')) == null ? void 0 : s19.textContent) && ((l16 = (n25 = this.querySelector('[slot="label"]')) == null ? void 0 : n25.textContent) == null ? void 0 : l16.trim()) !== "", t34 = ((m18 = (a23 = this.querySelector('[slot="label"]')) == null ? void 0 : a23.getAttribute("alt")) == null ? void 0 : m18.trim()) && ((f11 = (b12 = this.querySelector('[slot="label"]')) == null ? void 0 : b12.getAttribute("alt")) == null ? void 0 : f11.trim()) !== "";
    return !!this.label || !!this.getAttribute("aria-label") || !!this.getAttribute("aria-labelledby") || !!this.appliedLabel || !!e36 || !!t34;
  }
  warnNoLabel() {
    window.__swc.warn(this, `<${this.localName}> needs one of the following to be accessible:`, "https://opensource.adobe.com/spectrum-web-components/components/picker/#accessibility", { type: "accessibility", issues: [`an <sp-field-label> element with a \`for\` attribute referencing the \`id\` of the \`<${this.localName}>\`, or`, 'value supplied to the "label" attribute, which will be displayed visually as placeholder text, or', 'text content supplied in a <span> with slot="label", which will also be displayed visually as placeholder text.'] });
  }
  renderOverlay(e36) {
    var s19, n25, l16;
    if (((s19 = this.strategy) == null ? void 0 : s19.overlay) === void 0) return e36;
    const t34 = this.renderContainer(e36);
    return B(t34, (n25 = this.strategy) == null ? void 0 : n25.overlay, { host: this }), (l16 = this.strategy) == null ? void 0 : l16.overlay;
  }
  get renderDescriptionSlot() {
    return x`
            <div id=${DESCRIPTION_ID}>
                <slot name="description"></slot>
            </div>
        `;
  }
  render() {
    return this.tooltipEl && (this.tooltipEl.disabled = this.open), x`
            <button
                aria-controls=${o9(this.open ? "menu" : void 0)}
                aria-describedby="tooltip ${DESCRIPTION_ID}"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="true"
                aria-labelledby="icon label applied-label pending-label"
                id="button"
                class=${o9(this.labelAlignment ? `label-${this.labelAlignment}` : void 0)}
                @focus=${this.handleButtonFocus}
                @blur=${this.handleButtonBlur}
                @keydown=${{ handleEvent: this.handleEnterKeydown, capture: true }}
                ?disabled=${this.disabled}
            >
                ${this.buttonContent}
            </button>
            <slot
                aria-hidden="true"
                name="tooltip"
                id="tooltip"
                @keydown=${this.handleKeydown}
                @slotchange=${this.handleTooltipSlotchange}
            ></slot>
            ${this.renderMenu} ${this.renderDescriptionSlot}
        `;
  }
  willUpdate(e36) {
    super.willUpdate(e36), e36.has("tabIndex") && this.tabIndex && (this.button.tabIndex = this.tabIndex, this.removeAttribute("tabindex"));
  }
  update(e36) {
    var t34, s19;
    this.selects && (this.selects = "single"), e36.has("disabled") && this.disabled && this.close(), e36.has("pending") && this.pending && this.close(), e36.has("value") && this.shouldScheduleManageSelection(), this.hasUpdated || (this.deprecatedMenu = this.querySelector(":scope > sp-menu"), (t34 = this.deprecatedMenu) == null || t34.toggleAttribute("ignore", true), (s19 = this.deprecatedMenu) == null || s19.setAttribute("selects", "inherit")), super.update(e36);
  }
  bindButtonKeydownListener() {
    this.button.addEventListener("keydown", this.handleKeydown);
  }
  updated(e36) {
    super.updated(e36), e36.has("open") && (this.strategy.open = this.open);
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.bindButtonKeydownListener(), this.bindEvents();
  }
  get dismissHelper() {
    return x`
            <div class="visually-hidden">
                <button
                    tabindex="-1"
                    aria-label="Dismiss"
                    @click=${this.close}
                ></button>
            </div>
        `;
  }
  renderContainer(e36) {
    const t34 = x`
            ${this.dismissHelper} ${e36} ${this.dismissHelper}
        `;
    return this.isMobile.matches && !this.forcePopover ? (this.dependencyManager.add("sp-tray"), Promise.resolve().then(() => init_sp_tray()), x`
                <sp-tray
                    id="popover"
                    role="presentation"
                    style=${o10(this.containerStyles)}
                >
                    ${t34}
                </sp-tray>
            `) : (this.dependencyManager.add("sp-popover"), Promise.resolve().then(() => init_sp_popover()), x`
            <sp-popover
                id="popover"
                role="presentation"
                style=${o10(this.containerStyles)}
                placement=${this.placement}
            >
                ${t34}
            </sp-popover>
        `);
  }
  onScroll() {
    this.dispatchEvent(new Event("scroll", { cancelable: true, composed: true }));
  }
  get renderMenu() {
    const e36 = x`
            <sp-menu
                aria-labelledby="applied-label"
                @change=${this.handleChange}
                id="menu"
                @keydown=${{ handleEvent: this.handleEnterKeydown, capture: true }}
                @scroll=${this.onScroll}
                role=${this.listRole}
                .selects=${this.selects}
                .selected=${this.value ? [this.value] : []}
                size=${this.size}
                @sp-menu-item-keydown=${this.handleEscape}
                @sp-menu-item-added-or-updated=${this.shouldManageSelection}
            >
                <slot @slotchange=${this.shouldScheduleManageSelection}></slot>
            </sp-menu>
        `;
    return this.hasRenderedOverlay = this.hasRenderedOverlay || this.focused || this.open || !!this.deprecatedMenu, this.hasRenderedOverlay ? (this.dependencyManager.loaded && this.dependencyManager.add("sp-overlay"), this.renderOverlay(e36)) : e36;
  }
  shouldScheduleManageSelection(e36) {
    !this.willManageSelection && (!e36 || e36.target.getRootNode().host === this) && (this.willManageSelection = true, requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        this.manageSelection();
      });
    }));
  }
  shouldManageSelection() {
    this.willManageSelection || (this.willManageSelection = true, this.manageSelection());
  }
  async manageSelection() {
    if (this.selects == null) return;
    this.selectionPromise = new Promise((t34) => this.selectionResolver = t34);
    let e36;
    await this.optionsMenu.updateComplete, this.recentlyConnected && (await new Promise((t34) => requestAnimationFrame(() => t34(true))), this.recentlyConnected = false), this.menuItems.forEach((t34) => {
      this.value === t34.value && !t34.disabled ? e36 = t34 : t34.selected = false;
    }), e36 ? (e36.selected = !!this.selects, this.selectedItem = e36) : (this.value = "", this.selectedItem = void 0), this.open && (await this.optionsMenu.updateComplete, this.optionsMenu.updateSelectedItemIndex()), this.selectionResolver(), this.willManageSelection = false;
  }
  async getUpdateComplete() {
    const e36 = await super.getUpdateComplete();
    return await this.selectionPromise, e36;
  }
  bindEvents() {
    var e36;
    (e36 = this.strategy) == null || e36.abort(), this.isMobile.matches ? this.strategy = new strategies2.mobile(this.button, this) : this.strategy = new strategies2.desktop(this.button, this);
  }
  connectedCallback() {
    super.connectedCallback(), this.updateComplete.then(() => {
      var t34;
      if (!((t34 = this.tooltipEl) != null && t34.selfManaged)) return;
      const e36 = this.tooltipEl.overlayElement;
      e36 && (e36.triggerElement = this.button);
    }), this.recentlyConnected = this.hasUpdated, this.addEventListener("focus", this.handleFocus);
  }
  disconnectedCallback() {
    var e36;
    this.close(), (e36 = this.strategy) == null || e36.releaseDescription(), super.disconnectedCallback();
  }
};
PickerBase.shadowRootOptions = { ...SpectrumElement.shadowRootOptions, delegatesFocus: true }, i15([r5()], PickerBase.prototype, "appliedLabel", 2), i15([e5("#button")], PickerBase.prototype, "button", 2), i15([n4({ type: Boolean, reflect: true })], PickerBase.prototype, "disabled", 2), i15([n4({ type: Boolean, reflect: true })], PickerBase.prototype, "focused", 2), i15([n4({ type: String, reflect: true })], PickerBase.prototype, "icons", 2), i15([n4({ type: Boolean, reflect: true })], PickerBase.prototype, "invalid", 2), i15([n4({ type: Boolean, reflect: true, attribute: "force-popover" })], PickerBase.prototype, "forcePopover", 2), i15([n4({ type: Boolean, reflect: true })], PickerBase.prototype, "pending", 2), i15([n4({ type: String, attribute: "pending-label" })], PickerBase.prototype, "pendingLabel", 2), i15([n4()], PickerBase.prototype, "label", 2), i15([n4({ type: Boolean, reflect: true })], PickerBase.prototype, "open", 2), i15([n4({ type: Boolean, reflect: true })], PickerBase.prototype, "readonly", 2), i15([r5()], PickerBase.prototype, "labelAlignment", 2), i15([e5("sp-menu")], PickerBase.prototype, "optionsMenu", 2), i15([e5("sp-overlay")], PickerBase.prototype, "overlayElement", 2), i15([n4()], PickerBase.prototype, "placement", 2), i15([n4({ type: Boolean, reflect: true })], PickerBase.prototype, "quiet", 2), i15([n4({ type: String })], PickerBase.prototype, "value", 2), i15([n4({ attribute: false })], PickerBase.prototype, "selectedItem", 1), i15([r5()], PickerBase.prototype, "selectedItemContent", 1);
var Picker = class extends PickerBase {
  constructor() {
    super(...arguments);
    this.handleKeydown = (e36) => {
      var a23;
      const { key: t34 } = e36, s19 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " ", "Escape"].includes(t34), n25 = ["ArrowUp", "ArrowDown", "Enter", " "].includes(t34);
      if (this.focused = true, t34 === "Escape") {
        this.handleEscape(e36);
        return;
      }
      if (!s19 || this.readonly || this.pending) return;
      if (n25) {
        this.keyboardOpen(), e36.preventDefault();
        return;
      }
      e36.preventDefault();
      const l16 = (a23 = this.optionsMenu) == null ? void 0 : a23.getNeighboringFocusableElement(this.selectedItem, t34 === "ArrowLeft");
      (!this.value || l16 !== this.selectedItem) && l16 && this.setValueFromItem(l16);
    };
  }
  static get styles() {
    return [picker_css_default, spectrum_icon_chevron_css_default];
  }
  get containerStyles() {
    const e36 = super.containerStyles;
    return this.quiet || (e36["min-width"] = `${this.offsetWidth}px`), e36;
  }
};

// node_modules/@spectrum-web-components/picker/sp-picker.js
init_define_element();
defineElement("sp-picker", Picker);

// node_modules/@spectrum-web-components/picker-button/src/PickerButton.js
init_src();
init_directives();
init_decorators2();
init_observe_slot_presence();

// node_modules/@spectrum-web-components/picker-button/src/picker-button.css.js
init_src();
var o34 = i`
    .root{--spectrum-picker-button-height:var(--spectrum-component-height-100);--spectrum-picker-button-width:var(--spectrum-component-height-100);--spectrum-picker-button-gap:var(--spectrum-text-to-visual-50);--spectrum-picker-button-label-padding:var(--spectrum-text-to-visual-50);--spectrum-picker-button-fill-padding:var(--spectrum-field-edge-to-disclosure-icon-100);--spectrum-picker-button-icon-color:var(--spectrum-neutral-content-color-default);--spectrum-picker-button-icon-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-picker-button-icon-color-down:var(--spectrum-neutral-content-color-down);--spectrum-picker-button-icon-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-picker-button-font-color:var(--spectrum-neutral-content-color-default);--spectrum-picker-button-font-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-picker-button-font-color-down:var(--spectrum-neutral-content-color-down);--spectrum-picker-button-font-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-picker-button-font-family:var(--spectrum-sans-font-family-stack);--spectrum-picker-button-font-style:var(--spectrum-default-font-style);--spectrum-picker-button-font-weight:var(--spectrum-body-sans-serif-font-weight);--spectrum-picker-button-font-size:var(--spectrum-font-size-100);--spectrum-picker-button-border-radius-rounded:var(--spectrum-corner-radius-200);--spectrum-picker-button-background-animation-duration:var(--spectrum-animation-duration-100)}@media (hover:hover){.root:hover{--mod-picker-button-background-color:var(--mod-picker-button-background-color-hover,var(--spectrum-picker-button-background-color-hover));--mod-picker-button-font-color:var(--mod-picker-button-font-color-hover,var(--spectrum-picker-button-font-color-hover));--mod-picker-button-icon-color:var(--mod-picker-button-icon-color-hover,var(--spectrum-picker-button-icon-color-hover))}}:host([open]) .root,:host(:is(:active,[active])) .root{--mod-picker-button-background-color:var(--mod-picker-button-background-color-down,var(--spectrum-picker-button-background-color-down));--mod-picker-button-font-color:var(--mod-picker-button-font-color-down,var(--spectrum-picker-button-font-color-down));--mod-picker-button-icon-color:var(--mod-picker-button-icon-color-down,var(--spectrum-picker-button-icon-color-down))}:host([focused]) .root,.root.is-keyboardFocused,.root:focus,.root:focus-visible{--mod-picker-button-background-color:var(--mod-picker-button-background-color-key-focus,var(--spectrum-picker-button-background-color-key-focus));--mod-picker-button-font-color:var(--mod-picker-button-font-color-key-focus,var(--spectrum-picker-button-font-color-key-focus));--mod-picker-button-icon-color:var(--mod-picker-button-icon-color-key-focus,var(--spectrum-picker-button-icon-color-key-focus))}:host([disabled]) .root{--mod-picker-button-background-color:var(--mod-picker-button-background-color-disabled,var(--spectrum-disabled-background-color));--mod-picker-button-background-color-hover:var(--mod-picker-button-background-color-hover-disabled,var(--spectrum-disabled-background-color));--mod-picker-button-background-color-down:var(--mod-picker-button-background-color-down-disabled,var(--spectrum-disabled-background-color));--mod-picker-button-border-color:var(--mod-picker-button-border-color-disabled,var(--spectrum-disabled-background-color));--mod-picker-button-font-color:var(--mod-picker-button-font-color-disabled,var(--spectrum-disabled-content-color));--mod-picker-button-font-color-hover:var(--mod-picker-button-font-color-hover-disabled,var(--spectrum-disabled-content-color));--mod-picker-button-font-color-down:var(--mod-picker-button-font-color-down-disabled,var(--spectrum-disabled-content-color));--mod-picker-button-icon-color:var(--mod-picker-button-icon-color-disabled,var(--spectrum-disabled-content-color));--mod-picker-button-icon-color-hover:var(--mod-picker-button-icon-color-hover-disabled,var(--spectrum-disabled-content-color));--mod-picker-button-icon-color-down:var(--mod-picker-button-icon-color-down-disabled,var(--spectrum-disabled-content-color))}:host([quiet]) .root{--mod-picker-button-background-color:var(--mod-picker-button-background-color-quiet,transparent);--mod-picker-button-background-color-hover:var(--mod-picker-button-background-color-hover-quiet,transparent);--mod-picker-button-background-color-down:var(--mod-picker-button-background-color-down-quiet,transparent);--mod-picker-button-background-color-key-focus:var(--mod-picker-button-background-color-key-focus-quiet,transparent);--mod-picker-button-border-color:var(--mod-picker-button-border-color-quiet,transparent)}:host([size=s]) .root{--spectrum-picker-button-height:var(--spectrum-component-height-75);--spectrum-picker-button-width:var(--spectrum-component-height-75);--spectrum-picker-button-label-padding:var(--spectrum-spacing-75);--spectrum-picker-button-font-size:var(--spectrum-font-size-75);--spectrum-picker-button-fill-padding:var(--spectrum-field-edge-to-disclosure-icon-75)}:host([size=l]) .root{--spectrum-picker-button-height:var(--spectrum-component-height-200);--spectrum-picker-button-width:var(--spectrum-component-height-200);--spectrum-picker-button-label-padding:var(--spectrum-text-to-visual-200);--spectrum-picker-button-font-size:var(--spectrum-font-size-200);--spectrum-picker-button-fill-padding:var(--spectrum-field-edge-to-disclosure-icon-200)}:host([size=xl]) .root{--spectrum-picker-button-height:var(--spectrum-component-height-300);--spectrum-picker-button-width:var(--spectrum-component-height-300);--spectrum-picker-button-label-padding:var(--spectrum-text-to-visual-300);--spectrum-picker-button-font-size:var(--spectrum-font-size-300);--spectrum-picker-button-fill-padding:var(--spectrum-field-edge-to-disclosure-icon-300)}.root{background-color:initial;block-size:var(--mod-picker-button-width,var(--spectrum-picker-button-width));box-sizing:border-box;padding:var(--mod-picker-button-padding,var(--spectrum-picker-button-padding));border-style:none;justify-content:center;align-items:center;display:flex}.root.uiicononly{inline-size:var(--mod-picker-button-height,var(--spectrum-picker-button-height))}.spectrum-PickerButton-label{color:var(--mod-picker-button-font-color,var(--spectrum-picker-button-font-color));white-space:nowrap;font-family:var(--mod-picker-button-font-family,var(--spectrum-picker-button-font-family));font-style:var(--mod-picker-button-font-style,var(--spectrum-picker-button-font-style));font-weight:var(--mod-picker-button-font-weight,var(--spectrum-picker-button-font-weight));font-size:var(--mod-picker-button-font-size,var(--spectrum-picker-button-font-size));flex:auto;padding-block-start:var(--mod-picker-button-label-padding,var(--spectrum-picker-button-label-padding));padding-block-end:var(--mod-picker-button-label-padding,var(--spectrum-picker-button-label-padding));overflow:hidden}.uiicononly .spectrum-PickerButton-label{display:none}.spectrum-PickerButton-fill{box-sizing:border-box;justify-content:center;align-items:center;gap:var(--mod-picker-button-gap,var(--spectrum-picker-button-gap));background-color:var(--mod-picker-button-background-color,var(--spectrum-picker-button-background-color));border-color:var(--mod-picker-button-border-color,var(--spectrum-picker-button-border-color));border-width:var(--mod-picker-button-border-width,var(--spectrum-picker-button-border-width));block-size:100%;inline-size:100%;padding:calc(var(--mod-picker-button-fill-padding,var(--spectrum-picker-button-fill-padding)) - var(--mod-picker-button-padding,var(--spectrum-picker-button-padding)) - var(--mod-picker-button-border-width,var(--spectrum-picker-button-border-width)));transition:border-color var(--mod-picker-button-background-animation-duration,var(--spectrum-picker-button-background-animation-duration))ease-in-out;border-style:solid;border-start-start-radius:var(--mod-picker-button-border-radius,var(--spectrum-picker-button-border-radius));border-start-end-radius:var(--mod-picker-button-border-radius,var(--spectrum-picker-button-border-radius));border-end-end-radius:var(--mod-picker-button-border-radius,var(--spectrum-picker-button-border-radius));border-end-start-radius:var(--mod-picker-button-border-radius,var(--spectrum-picker-button-border-radius));display:flex}:host([position=right]) .spectrum-PickerButton-fill{border-start-start-radius:var(--mod-picker-button-border-radius-sided,var(--spectrum-picker-button-border-radius-sided));border-end-start-radius:var(--mod-picker-button-border-radius-sided,var(--spectrum-picker-button-border-radius-sided))}:host([position=right][rounded]) .spectrum-PickerButton-fill{border-start-start-radius:var(--mod-picker-button-border-radius-rounded-sided,var(--spectrum-picker-button-border-radius-rounded-sided));border-end-start-radius:var(--mod-picker-button-border-radius-rounded-sided,var(--spectrum-picker-button-border-radius-rounded-sided))}:host([position=left]) .spectrum-PickerButton-fill{border-start-end-radius:var(--mod-picker-button-border-radius-sided,var(--spectrum-picker-button-border-radius-sided));border-end-end-radius:var(--mod-picker-button-border-radius-sided,var(--spectrum-picker-button-border-radius-sided))}:host([position=left][rounded]) .spectrum-PickerButton-fill{border-start-end-radius:var(--mod-picker-button-border-radius-rounded-sided,var(--spectrum-picker-button-border-radius-rounded-sided));border-end-end-radius:var(--mod-picker-button-border-radius-rounded-sided,var(--spectrum-picker-button-border-radius-rounded-sided))}:host([rounded]) .spectrum-PickerButton-fill{border-start-start-radius:var(--mod-picker-button-border-radius-rounded,var(--spectrum-picker-button-border-radius-rounded));border-start-end-radius:var(--mod-picker-button-border-radius-rounded,var(--spectrum-picker-button-border-radius-rounded));border-end-end-radius:var(--mod-picker-button-border-radius-rounded,var(--spectrum-picker-button-border-radius-rounded));border-end-start-radius:var(--mod-picker-button-border-radius-rounded,var(--spectrum-picker-button-border-radius-rounded))}.uiicononly .spectrum-PickerButton-fill{padding:0}.textuiicon .spectrum-PickerButton-fill{inline-size:auto}.spectrum-PickerButton-icon{color:var(--mod-picker-button-icon-color,var(--spectrum-picker-button-icon-color));flex-shrink:0}.root{--spectrum-picker-button-background-color:var(--system-picker-button-background-color);--spectrum-picker-button-background-color-hover:var(--system-picker-button-background-color-hover);--spectrum-picker-button-background-color-down:var(--system-picker-button-background-color-down);--spectrum-picker-button-background-color-key-focus:var(--system-picker-button-background-color-key-focus);--spectrum-picker-button-border-color:var(--system-picker-button-border-color);--spectrum-picker-button-border-radius:var(--system-picker-button-border-radius);--spectrum-picker-button-border-radius-rounded-sided:var(--system-picker-button-border-radius-rounded-sided);--spectrum-picker-button-border-radius-sided:var(--system-picker-button-border-radius-sided);--spectrum-picker-button-border-width:var(--system-picker-button-border-width);--spectrum-picker-button-padding:var(--system-picker-button-padding)}:host{display:inline-flex}.root{display:flex}
`;
var picker_button_css_default = o34;

// node_modules/@spectrum-web-components/picker-button/src/PickerButton.js
var a10 = Object.defineProperty;
var p15 = Object.getOwnPropertyDescriptor;
var i16 = (r25, t34, o52, s19) => {
  for (var e36 = s19 > 1 ? void 0 : s19 ? p15(t34, o52) : t34, l16 = r25.length - 1, n25; l16 >= 0; l16--) (n25 = r25[l16]) && (e36 = (s19 ? n25(t34, o52, e36) : n25(e36)) || e36);
  return s19 && e36 && a10(t34, o52, e36), e36;
};
var x3 = { s: "spectrum-UIIcon-ChevronDown75", m: "spectrum-UIIcon-ChevronDown100", l: "spectrum-UIIcon-ChevronDown200", xl: "spectrum-UIIcon-ChevronDown300" };
var PickerButton = class extends SizedMixin(ObserveSlotPresence(ButtonBase, '[slot="label"]')) {
  constructor() {
    super(...arguments);
    this.invalid = false;
    this.position = "right";
  }
  static get styles() {
    return [picker_button_css_default, spectrum_icon_chevron_css_default];
  }
  get hasText() {
    return this.slotContentIsPresent;
  }
  render() {
    const o52 = { root: true, uiicononly: !this.hasText, textuiicon: this.hasText };
    return x`
            <div class=${e10(o52)}>
                <div class="spectrum-PickerButton-fill">
                    <span
                        class="spectrum-PickerButton-label is-placeholder"
                        ?hidden=${!this.hasText}
                    >
                        <slot name="label"></slot>
                    </span>
                    <slot name="icon">
                        <sp-icon-chevron100
                            class="spectrum-PickerButton-icon spectrum-Icon ${x3[this.size]}"
                        ></sp-icon-chevron100>
                    </slot>
                </div>
            </div>
        `;
  }
};
i16([n4({ type: Boolean, reflect: true })], PickerButton.prototype, "invalid", 2), i16([n4({ reflect: true })], PickerButton.prototype, "position", 2);

// node_modules/@spectrum-web-components/picker-button/sp-picker-button.js
init_define_element();
defineElement("sp-picker-button", PickerButton);

// node_modules/@spectrum-web-components/action-menu/src/ActionMenu.js
init_src();
init_decorators2();
init_directives();
init_decorators2();
init_observe_slot_presence();
init_observe_slot_text();

// node_modules/@spectrum-web-components/action-menu/src/action-menu.css.js
init_src();
var o35 = i`
    :host{display:inline-flex}:host([quiet]){min-width:0}:host>sp-menu{display:none}::slotted([slot=icon]),.icon{flex-shrink:0}#popover{max-width:none}:host([dir=ltr]) ::slotted([slot=icon]),:host([dir=ltr]) .icon{margin-left:calc(-1*(var(--spectrum-actionbutton-textonly-padding-left-adjusted) - var(--spectrum-actionbutton-padding-left-adjusted)))}:host([dir=rtl]) ::slotted([slot=icon]),:host([dir=rtl]) .icon{margin-right:calc(-1*(var(--spectrum-actionbutton-textonly-padding-left-adjusted) - var(--spectrum-actionbutton-padding-left-adjusted)))}:host([dir]) slot[icon-only]::slotted([slot=icon]),:host([dir]) slot[icon-only] .icon{margin-inline:calc((var(--custom-actionbutton-edge-to-text,var(--spectrum-actionbutton-edge-to-text)) - var(--custom-actionbutton-edge-to-visual-only,var(--spectrum-actionbutton-edge-to-visual-only)))*-1)}sp-overlay:not(:defined){display:none}
`;
var action_menu_css_default = o35;

// node_modules/@spectrum-web-components/action-menu/src/ActionMenu.js
init_slottable_request_event();
var h10 = Object.defineProperty;
var c23 = Object.getOwnPropertyDescriptor;
var o36 = (a23, l16, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? c23(l16, e36) : l16, r25 = a23.length - 1, n25; r25 >= 0; r25--) (n25 = a23[r25]) && (t34 = (i21 ? n25(l16, e36, t34) : n25(t34)) || t34);
  return i21 && t34 && h10(l16, e36, t34), t34;
};
var ActionMenu = class extends ObserveSlotPresence(ObserveSlotText(PickerBase, "label"), '[slot="label-only"]') {
  constructor() {
    super(...arguments);
    this.selects = void 0;
    this.listRole = "menu";
    this.itemRole = "menuitem";
    this.handleSlottableRequest = (e36) => {
      this.dispatchEvent(new SlottableRequestEvent(e36.name, e36.data));
    };
  }
  static get styles() {
    return [action_menu_css_default];
  }
  get hasLabel() {
    return this.slotHasContent;
  }
  get labelOnly() {
    return this.slotContentIsPresent;
  }
  get buttonContent() {
    return [x`
                ${this.labelOnly ? x`` : x`
                          <slot
                              name="icon"
                              slot="icon"
                              ?icon-only=${!this.hasLabel}
                              ?hidden=${this.labelOnly}
                          >
                              <sp-icon-more
                                  class="icon"
                                  size=${this.size}
                              ></sp-icon-more>
                          </slot>
                      `}
                <slot name="label" ?hidden=${!this.hasLabel}></slot>
                <slot name="label-only"></slot>
            `];
  }
  render() {
    return this.tooltipEl && (this.tooltipEl.disabled = this.open), x`
            <sp-action-button
                aria-describedby=${DESCRIPTION_ID}
                ?quiet=${this.quiet}
                ?selected=${this.open}
                static-color=${o9(this.staticColor)}
                aria-haspopup="true"
                aria-controls=${o9(this.open ? "menu" : void 0)}
                aria-expanded=${this.open ? "true" : "false"}
                aria-label=${o9(this.label || void 0)}
                id="button"
                class="button"
                size=${this.size}
                @blur=${this.handleButtonBlur}
                @focus=${this.handleButtonFocus}
                @keydown=${{ handleEvent: this.handleEnterKeydown, capture: true }}
                ?disabled=${this.disabled}
            >
                ${this.buttonContent}
            </sp-action-button>
            <slot
                name="tooltip"
                @slotchange=${this.handleTooltipSlotchange}
            ></slot>
            ${this.renderMenu} ${this.renderDescriptionSlot}
        `;
  }
  update(e36) {
    e36.has("invalid") && (this.invalid = false), super.update(e36);
  }
  hasAccessibleLabel() {
    return !!this.label || !!this.getAttribute("aria-label") || !!this.getAttribute("aria-labelledby") || !!this.appliedLabel || this.hasLabel || this.labelOnly;
  }
  warnNoLabel() {
    window.__swc.warn(this, `<${this.localName}> needs one of the following to be accessible:`, "https://opensource.adobe.com/spectrum-web-components/components/action-menu/#accessibility", { type: "accessibility", issues: [`an <sp-field-label> element with a \`for\` attribute referencing the \`id\` of the \`<${this.localName}>\`, or`, 'value supplied to the "label" attribute, which will be displayed visually as placeholder text', 'text content supplied in a <span> with slot="label", or, text content supplied in a <span> with slot="label-only"', "which will also be displayed visually as placeholder text."] });
  }
};
o36([n4({ type: String })], ActionMenu.prototype, "selects", 2), o36([n4({ reflect: true, attribute: "static-color" })], ActionMenu.prototype, "staticColor", 2), o36([r5()], ActionMenu.prototype, "labelOnly", 1);

// node_modules/@spectrum-web-components/action-menu/sp-action-menu.js
init_define_element();
defineElement("sp-action-menu", ActionMenu);

// node_modules/@spectrum-web-components/radio/src/Radio.js
init_src();
init_decorators2();
init_focus_visible();

// node_modules/@spectrum-web-components/radio/src/radio.css.js
init_src();
var r14 = i`
    @media (forced-colors:active){:host{--highcontrast-radio-neutral-content-color:CanvasText;--highcontrast-radio-neutral-content-color-hover:CanvasText;--highcontrast-radio-neutral-content-color-down:CanvasText;--highcontrast-radio-neutral-content-color-focus:CanvasText;--highcontrast-radio-button-border-color-default:ButtonText;--highcontrast-radio-button-border-color-hover:Highlight;--highcontrast-radio-button-border-color-down:ButtonText;--highcontrast-radio-button-border-color-focus:Highlight;--highcontrast-radio-emphasized-accent-color:ButtonText;--highcontrast-radio-emphasized-accent-color-hover:Highlight;--highcontrast-radio-emphasized-accent-color-down:ButtonText;--highcontrast-radio-emphasized-accent-color-focus:Highlight;--highcontrast-radio-button-checked-border-color-default:Highlight;--highcontrast-radio-button-checked-border-color-hover:Highlight;--highcontrast-radio-button-checked-border-color-down:Highlight;--highcontrast-radio-button-checked-border-color-focus:Highlight;--highcontrast-radio-disabled-content-color:GrayText;--highcontrast-radio-disabled-border-color:GrayText;--highcontrast-radio-focus-indicator-color:CanvasText}#button:after{forced-color-adjust:none}}:host{vertical-align:top;min-block-size:var(--mod-radio-height,var(--spectrum-radio-height));align-items:flex-start;max-inline-size:100%;display:inline-flex;position:relative}:host(:active) #button:before{border-color:var(--highcontrast-radio-button-border-color-down,var(--mod-radio-button-border-color-down,var(--spectrum-radio-button-border-color-down)))}:host(:active[checked]) #input+#button:before{border-color:var(--highcontrast-radio-button-checked-border-color-down,var(--mod-radio-button-checked-border-color-down,var(--spectrum-radio-button-checked-border-color-down)))}:host(:active) #label{color:var(--highcontrast-radio-neutral-content-color-down,var(--mod-radio-neutral-content-color-down,var(--spectrum-radio-neutral-content-color-down)))}:host(:focus-visible) #button:before{border-color:var(--highcontrast-radio-button-border-color-focus,var(--mod-radio-button-border-color-focus,var(--spectrum-radio-button-border-color-focus)))}:host(:focus-visible) #button:after{border-style:solid;border-color:var(--highcontrast-radio-focus-indicator-color,var(--mod-radio-focus-indicator-color,var(--spectrum-radio-focus-indicator-color)));border-width:var(--mod-radio-focus-indicator-thickness,var(--spectrum-radio-focus-indicator-thickness));inline-size:calc(var(--spectrum-radio-button-control-size) + var(--spectrum-radio-focus-indicator-gap)*2);block-size:calc(var(--spectrum-radio-button-control-size) + var(--spectrum-radio-focus-indicator-gap)*2)}:host(:focus-visible[checked]) #input+#button:before{border-color:var(--highcontrast-radio-button-checked-border-color-focus,var(--mod-radio-button-checked-border-color-focus,var(--spectrum-radio-button-checked-border-color-focus)))}:host(:focus-visible) #label{color:var(--highcontrast-radio-neutral-content-color-focus,var(--mod-radio-neutral-content-color-focus,var(--spectrum-radio-neutral-content-color-focus)))}:host([readonly]) #input:read-only{cursor:auto}:host([readonly]) #button{clip:rect(1px,1px,1px,1px);clip-path:inset(50%);position:fixed;inset-block-end:100%;inset-inline-end:100%}:host([readonly][checked][disabled]) #input~#label,:host([readonly][disabled]) #input~#label,:host([readonly]) #label{color:var(--highcontrast-radio-neutral-content-color,var(--mod-radio-neutral-content-color,var(--spectrum-radio-neutral-content-color)));margin-inline-start:0}:host([emphasized][checked]) #input+#button:before{border-color:var(--highcontrast-radio-emphasized-accent-color,var(--mod-radio-emphasized-accent-color,var(--spectrum-radio-emphasized-accent-color)))}@media (hover:hover){:host(:hover) #button:before{border-color:var(--highcontrast-radio-button-border-color-hover,var(--mod-radio-button-border-color-hover,var(--spectrum-radio-button-border-color-hover)))}:host([checked]:hover) #input+#button:before{border-color:var(--highcontrast-radio-button-checked-border-color-hover,var(--mod-radio-button-checked-border-color-hover,var(--spectrum-radio-button-checked-border-color-hover)))}:host(:hover) #label{color:var(--highcontrast-radio-neutral-content-color-hover,var(--mod-radio-neutral-content-color-hover,var(--spectrum-radio-neutral-content-color-hover)))}:host([emphasized][checked]:hover) #input+#button:before{border-color:var(--highcontrast-radio-emphasized-accent-color-hover,var(--mod-radio-emphasized-accent-color-hover,var(--spectrum-radio-emphasized-accent-color-hover)))}}:host([emphasized]:active[checked]) #input+#button:before{border-color:var(--highcontrast-radio-emphasized-accent-color-down,var(--mod-radio-emphasized-accent-color-down,var(--spectrum-radio-emphasized-accent-color-down)))}:host([emphasized]:focus-visible[checked]) #input+#button:before{border-color:var(--highcontrast-radio-emphasized-accent-color-focus,var(--mod-radio-emphasized-accent-color-focus,var(--spectrum-radio-emphasized-accent-color-focus)))}:host([checked][disabled]) #input+#button:before,:host([disabled]) #input+#button:before{border-color:var(--highcontrast-radio-disabled-border-color,var(--mod-radio-disabled-border-color,var(--spectrum-radio-disabled-border-color)))}:host([checked][disabled]) #input~#label,:host([disabled]) #input~#label{color:var(--highcontrast-radio-disabled-content-color,var(--mod-radio-disabled-content-color,var(--spectrum-radio-disabled-content-color)))}#input{font-family:inherit;font-size:100%;line-height:var(--mod-radio-line-height,var(--spectrum-radio-line-height));box-sizing:border-box;opacity:0;z-index:1;cursor:pointer;block-size:100%;inline-size:100%;margin:0;padding:0;position:absolute;overflow:visible}:host([disabled]) #input{cursor:default}:host([checked]) #input+#button:before{border-width:calc(var(--spectrum-radio-button-control-size)/2 - var(--spectrum-radio-button-selection-indicator)/2);border-color:var(--highcontrast-radio-button-checked-border-color-default,var(--mod-radio-button-checked-border-color-default,var(--spectrum-radio-button-checked-border-color-default)))}#input:focus-visible+#button:after{border-width:var(--mod-radio-focus-indicator-thickness,var(--spectrum-radio-focus-indicator-thickness));border-color:var(--highcontrast-radio-focus-indicator-color,var(--mod-radio-focus-indicator-color,var(--spectrum-radio-focus-indicator-color)));inline-size:calc(var(--spectrum-radio-button-control-size) + var(--spectrum-radio-focus-indicator-gap)*2);block-size:calc(var(--spectrum-radio-button-control-size) + var(--spectrum-radio-focus-indicator-gap)*2);border-style:solid}#label{text-align:start;font-size:var(--mod-radio-font-size,var(--spectrum-radio-font-size));color:var(--highcontrast-radio-neutral-content-color,var(--mod-radio-neutral-content-color,var(--spectrum-radio-neutral-content-color)));line-height:var(--mod-radio-line-height,var(--spectrum-radio-line-height));transition:color var(--mod-radio-animation-duration,var(--spectrum-radio-animation-duration))ease-in-out;margin-block-start:var(--spectrum-radio-label-top-to-text);margin-block-end:var(--spectrum-radio-label-bottom-to-text);margin-inline-start:var(--mod-radio-text-to-control,var(--spectrum-radio-text-to-control))}#label:lang(ja),#label:lang(ko),#label:lang(zh){line-height:var(--mod-radio-line-height-cjk,var(--spectrum-radio-line-height-cjk))}#button{box-sizing:border-box;inline-size:var(--mod-radio-button-control-size,var(--spectrum-radio-button-control-size));block-size:var(--mod-radio-button-control-size,var(--spectrum-radio-button-control-size));flex-grow:0;flex-shrink:0;margin-block-start:var(--mod-radio-button-top-to-control,var(--spectrum-radio-button-top-to-control));position:relative}#button:before{z-index:0;content:"";box-sizing:border-box;inline-size:var(--mod-radio-button-control-size,var(--spectrum-radio-button-control-size));block-size:var(--mod-radio-button-control-size,var(--spectrum-radio-button-control-size));background-color:var(--highcontrast-radio-button-background-color,var(--mod-radio-button-background-color,var(--spectrum-radio-button-background-color)));border-width:var(--mod-radio-border-width,var(--spectrum-radio-border-width));border-color:var(--highcontrast-radio-button-border-color-default,var(--mod-radio-button-border-color-default,var(--spectrum-radio-button-border-color-default)));transition:border var(--mod-radio-animation-duration,var(--spectrum-radio-animation-duration))ease-in-out,box-shadow var(--mod-radio-animation-duration,var(--spectrum-radio-animation-duration))ease-in-out;border-style:solid;border-radius:50%;display:block;position:absolute}#button:after{content:"";transition:opacity var(--mod-radio-animation-duration,var(--spectrum-radio-animation-duration))ease-out,margin var(--mod-radio-animation-duration,var(--spectrum-radio-animation-duration))ease-out;border-radius:50%;display:block;position:absolute;inset-block-start:50%;inset-inline-start:50%;transform:translate(-50%)translateY(-50%)}:host:dir(rtl) #button:after,:host([dir=rtl]) #button:after{transform:translate(50%)translateY(-50%)}:host{--spectrum-radio-button-border-color-default:var(--system-radio-button-border-color-default);--spectrum-radio-button-border-color-hover:var(--system-radio-button-border-color-hover);--spectrum-radio-button-border-color-down:var(--system-radio-button-border-color-down);--spectrum-radio-button-border-color-focus:var(--system-radio-button-border-color-focus);--spectrum-radio-neutral-content-color:var(--system-radio-neutral-content-color);--spectrum-radio-neutral-content-color-hover:var(--system-radio-neutral-content-color-hover);--spectrum-radio-neutral-content-color-down:var(--system-radio-neutral-content-color-down);--spectrum-radio-neutral-content-color-focus:var(--system-radio-neutral-content-color-focus);--spectrum-radio-focus-indicator-thickness:var(--system-radio-focus-indicator-thickness);--spectrum-radio-focus-indicator-gap:var(--system-radio-focus-indicator-gap);--spectrum-radio-focus-indicator-color:var(--system-radio-focus-indicator-color);--spectrum-radio-disabled-content-color:var(--system-radio-disabled-content-color);--spectrum-radio-disabled-border-color:var(--system-radio-disabled-border-color);--spectrum-radio-emphasized-accent-color:var(--system-radio-emphasized-accent-color);--spectrum-radio-emphasized-accent-color-hover:var(--system-radio-emphasized-accent-color-hover);--spectrum-radio-emphasized-accent-color-down:var(--system-radio-emphasized-accent-color-down);--spectrum-radio-emphasized-accent-color-focus:var(--system-radio-emphasized-accent-color-focus);--spectrum-radio-border-width:var(--system-radio-border-width);--spectrum-radio-button-background-color:var(--system-radio-button-background-color);--spectrum-radio-button-checked-border-color-default:var(--system-radio-button-checked-border-color-default);--spectrum-radio-button-checked-border-color-hover:var(--system-radio-button-checked-border-color-hover);--spectrum-radio-button-checked-border-color-down:var(--system-radio-button-checked-border-color-down);--spectrum-radio-button-checked-border-color-focus:var(--system-radio-button-checked-border-color-focus);--spectrum-radio-line-height:var(--system-radio-line-height);--spectrum-radio-animation-duration:var(--system-radio-animation-duration);--spectrum-radio-height:var(--system-radio-height);--spectrum-radio-button-control-size:var(--system-radio-button-control-size);--spectrum-radio-text-to-control:var(--system-radio-text-to-control);--spectrum-radio-label-top-to-text:var(--system-radio-label-top-to-text);--spectrum-radio-label-bottom-to-text:var(--system-radio-label-bottom-to-text);--spectrum-radio-button-top-to-control:var(--system-radio-button-top-to-control);--spectrum-radio-font-size:var(--system-radio-font-size)}:host(:lang(ja)){--spectrum-radio-line-height-cjk:var(--system-radio-lang-ja-line-height-cjk)}:host(:lang(zh)){--spectrum-radio-line-height-cjk:var(--system-radio-lang-zh-line-height-cjk)}:host(:lang(ko)){--spectrum-radio-line-height-cjk:var(--system-radio-lang-ko-line-height-cjk)}:host{--spectrum-radio-height:var(--system-radio-size-m-height);--spectrum-radio-button-control-size:var(--system-radio-size-m-button-control-size);--spectrum-radio-text-to-control:var(--system-radio-size-m-text-to-control);--spectrum-radio-label-top-to-text:var(--system-radio-size-m-label-top-to-text);--spectrum-radio-label-bottom-to-text:var(--system-radio-size-m-label-bottom-to-text);--spectrum-radio-button-top-to-control:var(--system-radio-size-m-button-top-to-control);--spectrum-radio-font-size:var(--system-radio-size-m-font-size)}:host([size=s]){--spectrum-radio-height:var(--system-radio-size-s-height);--spectrum-radio-button-control-size:var(--system-radio-size-s-button-control-size);--spectrum-radio-text-to-control:var(--system-radio-size-s-text-to-control);--spectrum-radio-label-top-to-text:var(--system-radio-size-s-label-top-to-text);--spectrum-radio-label-bottom-to-text:var(--system-radio-size-s-label-bottom-to-text);--spectrum-radio-button-top-to-control:var(--system-radio-size-s-button-top-to-control);--spectrum-radio-font-size:var(--system-radio-size-s-font-size)}:host([size=l]){--spectrum-radio-height:var(--system-radio-size-l-height);--spectrum-radio-button-control-size:var(--system-radio-size-l-button-control-size);--spectrum-radio-text-to-control:var(--system-radio-size-l-text-to-control);--spectrum-radio-label-top-to-text:var(--system-radio-size-l-label-top-to-text);--spectrum-radio-label-bottom-to-text:var(--system-radio-size-l-label-bottom-to-text);--spectrum-radio-button-top-to-control:var(--system-radio-size-l-button-top-to-control);--spectrum-radio-font-size:var(--system-radio-size-l-font-size)}:host([size=xl]){--spectrum-radio-height:var(--system-radio-size-xl-height);--spectrum-radio-button-control-size:var(--system-radio-size-xl-button-control-size);--spectrum-radio-text-to-control:var(--system-radio-size-xl-text-to-control);--spectrum-radio-label-top-to-text:var(--system-radio-size-xl-label-top-to-text);--spectrum-radio-label-bottom-to-text:var(--system-radio-size-xl-label-bottom-to-text);--spectrum-radio-button-top-to-control:var(--system-radio-size-xl-button-top-to-control);--spectrum-radio-font-size:var(--system-radio-size-xl-font-size)}:host([emphasized]){--spectrum-radio-button-checked-border-color-default:var(--system-radio-emphasized-button-checked-border-color-default);--spectrum-radio-button-checked-border-color-hover:var(--system-radio-emphasized-button-checked-border-color-hover);--spectrum-radio-button-checked-border-color-down:var(--system-radio-emphasized-button-checked-border-color-down);--spectrum-radio-button-checked-border-color-focus:var(--system-radio-emphasized-button-checked-border-color-focus)}:host(:focus){outline:none}:host([disabled]){pointer-events:none}:host([dir=rtl]) #button:after{transform:translate(50%)translateY(-50%)}
`;
var radio_css_default = r14;

// node_modules/@spectrum-web-components/radio/src/Radio.js
var u19 = Object.defineProperty;
var c24 = Object.getOwnPropertyDescriptor;
var t22 = (l16, s19, e36, a23) => {
  for (var i21 = a23 > 1 ? void 0 : a23 ? c24(s19, e36) : s19, d22 = l16.length - 1, o52; d22 >= 0; d22--) (o52 = l16[d22]) && (i21 = (a23 ? o52(s19, e36, i21) : o52(i21)) || i21);
  return a23 && i21 && u19(s19, e36, i21), i21;
};
var Radio = class extends SizedMixin(FocusVisiblePolyfillMixin(SpectrumElement), { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.autofocus = false;
    this.value = "";
    this.checked = false;
    this.disabled = false;
    this.emphasized = false;
    this.invalid = false;
    this.readonly = false;
  }
  static get styles() {
    return [radio_css_default];
  }
  click() {
    this.disabled || this.activate();
  }
  manageAutoFocus() {
    this.autofocus && (this.dispatchEvent(new KeyboardEvent("keydown", { code: "Tab" })), this.focus());
  }
  activate() {
    this.checked || (this.checked = true, this.dispatchEvent(new Event("change", { bubbles: true, composed: true })));
  }
  handleKeyup(e36) {
    e36.code === "Space" && this.activate();
  }
  render() {
    return x`
            <div id="input"></div>
            <span id="button"></span>
            <span id="label" role="presentation"><slot></slot></span>
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.setAttribute("role", "radio"), this.hasAttribute("tabindex") || (this.tabIndex = 0), this.manageAutoFocus(), this.addEventListener("click", this.activate), this.addEventListener("keyup", this.handleKeyup);
  }
  updated(e36) {
    super.updated(e36), e36.has("invalid") && (this.invalid ? this.setAttribute("aria-invalid", "true") : this.removeAttribute("aria-invalid")), e36.has("checked") && (this.checked ? this.setAttribute("aria-checked", "true") : this.setAttribute("aria-checked", "false")), e36.has("disabled") && (this.disabled ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled"));
  }
};
t22([n4({ type: Boolean })], Radio.prototype, "autofocus", 2), t22([n4({ type: String, reflect: true })], Radio.prototype, "value", 2), t22([n4({ type: Boolean, reflect: true })], Radio.prototype, "checked", 2), t22([n4({ type: Boolean, reflect: true })], Radio.prototype, "disabled", 2), t22([n4({ type: Boolean, reflect: true })], Radio.prototype, "emphasized", 2), t22([n4({ type: Boolean, reflect: true })], Radio.prototype, "invalid", 2), t22([n4({ type: Boolean, reflect: true })], Radio.prototype, "readonly", 2);

// node_modules/@spectrum-web-components/radio/sp-radio.js
init_define_element();
defineElement("sp-radio", Radio);

// node_modules/@spectrum-web-components/radio/src/RadioGroup.js
init_decorators2();
init_focus_visible();

// node_modules/@spectrum-web-components/field-group/src/FieldGroup.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/field-group/src/field-group.css.js
init_src();
var o37 = i`
    .spectrum-FieldGroup--toplabel{flex-direction:column}.spectrum-FieldGroup--sidelabel{flex-direction:row}.group{flex-flow:column wrap;display:flex}:host([vertical]) .group{flex-direction:column}:host([horizontal]) .group{flex-direction:row}:host([horizontal]) .group slot:not([name])::slotted(:not(:last-child)){margin-inline-end:var(--spectrum-fieldgroup-margin)}:host([horizontal]) .group .spectrum-HelpText{flex-basis:100%}:host{--spectrum-fieldgroup-margin:var(--system-field-group-margin);--spectrum-fieldgroup-readonly-delimiter:var(--system-field-group-readonly-delimiter)}:host([horizontal][dir=rtl]) slot:not([name])::slotted(:not(:last-child)),:host([dir=rtl]:not([vertical])) slot:not([name])::slotted(:not(:last-child)){margin:0 0 0 var(--spectrum-fieldgroup-margin)}:host([horizontal][dir=ltr]) slot:not([name])::slotted(:not(:last-child)),:host([dir=ltr]:not([vertical])) slot:not([name])::slotted(:not(:last-child)){margin:0 var(--spectrum-fieldgroup-margin)0 0}
`;
var field_group_css_default = o37;

// node_modules/@spectrum-web-components/field-group/src/FieldGroup.js
var d11 = Object.defineProperty;
var u20 = Object.getOwnPropertyDescriptor;
var l11 = (o52, r25, e36, a23) => {
  for (var t34 = a23 > 1 ? void 0 : a23 ? u20(r25, e36) : r25, s19 = o52.length - 1, p30; s19 >= 0; s19--) (p30 = o52[s19]) && (t34 = (a23 ? p30(r25, e36, t34) : p30(t34)) || t34);
  return a23 && t34 && d11(r25, e36, t34), t34;
};
var FieldGroup = class extends ManageHelpText(SpectrumElement, { mode: "external" }) {
  constructor() {
    super(...arguments);
    this.horizontal = false;
    this.invalid = false;
    this.label = "";
    this.vertical = false;
  }
  static get styles() {
    return [field_group_css_default];
  }
  handleSlotchange() {
  }
  render() {
    return x`
            <div class="group" role="presentation">
                <slot @slotchange=${this.handleSlotchange}></slot>
            </div>
            ${this.renderHelpText(this.invalid)}
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.hasAttribute("role") || this.setAttribute("role", "group");
  }
  updated(e36) {
    super.updated(e36), e36.has("label") && (this.label ? this.setAttribute("aria-label", this.label) : this.removeAttribute("aria-label"));
  }
};
l11([n4({ type: Boolean, reflect: true })], FieldGroup.prototype, "horizontal", 2), l11([n4({ type: Boolean, reflect: true })], FieldGroup.prototype, "invalid", 2), l11([n4()], FieldGroup.prototype, "label", 2), l11([n4({ type: Boolean, reflect: true })], FieldGroup.prototype, "vertical", 2);

// node_modules/@spectrum-web-components/radio/src/RadioGroup.js
var c25 = Object.defineProperty;
var n19 = Object.getOwnPropertyDescriptor;
var a11 = (l16, d22, e36, t34) => {
  for (var i21 = t34 > 1 ? void 0 : t34 ? n19(d22, e36) : d22, s19 = l16.length - 1, o52; s19 >= 0; s19--) (o52 = l16[s19]) && (i21 = (t34 ? o52(d22, e36, i21) : o52(i21)) || i21);
  return t34 && i21 && c25(d22, e36, i21), i21;
};
var RadioGroup = class extends FocusVisiblePolyfillMixin(FieldGroup) {
  constructor() {
    super(...arguments);
    this.name = "";
    this.rovingTabindexController = new RovingTabindexController(this, { focusInIndex: (e36) => e36.findIndex((t34) => this.selected ? !t34.disabled && t34.value === this.selected : !t34.disabled), elementEnterAction: (e36) => {
      this._setSelected(e36.value);
    }, elements: () => this.buttons, isFocusableElement: (e36) => !e36.disabled });
    this.selected = "";
  }
  get buttons() {
    return this.defaultNodes.filter((e36) => e36 instanceof Radio);
  }
  focus() {
    this.rovingTabindexController.focus();
  }
  _setSelected(e36) {
    if (e36 === this.selected) return;
    const t34 = this.selected, i21 = e36 ? this.querySelector(`sp-radio[value="${e36}"]`) : void 0;
    if (this.selected = i21 ? e36 : "", !this.dispatchEvent(new Event("change", { cancelable: true, bubbles: true, composed: true }))) {
      this.selected = t34;
      return;
    }
    this.validateRadios();
  }
  willUpdate(e36) {
    if (!this.hasUpdated) {
      this.setAttribute("role", "radiogroup");
      const t34 = this.querySelector("sp-radio[checked]"), i21 = t34 ? t34.value : "";
      if (this.selected = i21 || this.selected, this.selected && this.selected !== i21) {
        const s19 = this.querySelector(`sp-radio[value="${this.selected}"]`);
        s19 && (s19.checked = true);
      }
      this.shadowRoot.addEventListener("change", (s19) => {
        s19.stopPropagation();
        const o52 = s19.target;
        this._setSelected(o52.value);
      });
    }
    e36.has("selected") && this.validateRadios();
  }
  async validateRadios() {
    let e36 = false;
    this.hasUpdated || await this.updateComplete, this.buttons.map((t34) => {
      t34.checked = this.selected === t34.value, e36 = e36 || t34.checked;
    }), e36 || (this.selected = "");
  }
  handleSlotchange() {
    this.rovingTabindexController.clearElementCache();
  }
};
a11([n4({ type: String })], RadioGroup.prototype, "name", 2), a11([n5()], RadioGroup.prototype, "defaultNodes", 2), a11([n4({ reflect: true })], RadioGroup.prototype, "selected", 2);

// node_modules/@spectrum-web-components/radio/sp-radio-group.js
init_define_element();
defineElement("sp-radio-group", RadioGroup);

// node_modules/@spectrum-web-components/tags/src/Tags.js
init_src();
init_decorators2();
init_focus_visible();

// node_modules/@spectrum-web-components/tags/src/Tag.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/button/sp-clear-button.js
init_define_element();
defineElement("sp-clear-button", ClearButton);

// node_modules/@spectrum-web-components/tags/src/tag.css.js
init_src();
var t23 = i`
    :host{--spectrum-avatar-opacity-disabled:.3;--spectrum-tag-animation-duration:var(--spectrum-animation-duration-100);--spectrum-tag-border-width:var(--spectrum-border-width-100);--spectrum-tag-focus-ring-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-tag-focus-ring-gap:var(--spectrum-focus-indicator-gap);--spectrum-tag-focus-ring-color:var(--spectrum-focus-indicator-color);--spectrum-tag-label-line-height:var(--spectrum-line-height-100);--spectrum-tag-label-font-weight:var(--spectrum-regular-font-weight);--spectrum-tag-background-color-selected:var(--spectrum-neutral-background-color-selected-default);--spectrum-tag-background-color-selected-hover:var(--spectrum-neutral-background-color-selected-hover);--spectrum-tag-background-color-selected-active:var(--spectrum-neutral-background-color-selected-down);--spectrum-tag-background-color-selected-focus:var(--spectrum-neutral-background-color-selected-key-focus);--spectrum-tag-border-color-invalid:var(--spectrum-negative-color-900);--spectrum-tag-border-color-invalid-hover:var(--spectrum-negative-color-1000);--spectrum-tag-border-color-invalid-active:var(--spectrum-negative-color-1100);--spectrum-tag-border-color-invalid-focus:var(--spectrum-negative-color-1000);--spectrum-tag-content-color-invalid:var(--spectrum-negative-content-color-default);--spectrum-tag-content-color-invalid-hover:var(--spectrum-negative-content-color-hover);--spectrum-tag-content-color-invalid-active:var(--spectrum-negative-content-color-down);--spectrum-tag-content-color-invalid-focus:var(--spectrum-negative-content-color-key-focus);--spectrum-tag-border-color-invalid-selected:var(--spectrum-negative-background-color-default);--spectrum-tag-border-color-invalid-selected-hover:var(--spectrum-negative-background-color-hover);--spectrum-tag-border-color-invalid-selected-focus:var(--spectrum-negative-background-color-down);--spectrum-tag-border-color-invalid-selected-active:var(--spectrum-negative-background-color-key-focus);--spectrum-tag-background-color-invalid-selected:var(--spectrum-negative-background-color-default);--spectrum-tag-background-color-invalid-selected-hover:var(--spectrum-negative-background-color-hover);--spectrum-tag-background-color-invalid-selected-active:var(--spectrum-negative-background-color-down);--spectrum-tag-background-color-invalid-selected-focus:var(--spectrum-negative-background-color-key-focus);--spectrum-tag-content-color-invalid-selected:var(--spectrum-white);--spectrum-tag-border-color-emphasized:var(--spectrum-accent-background-color-default);--spectrum-tag-border-color-emphasized-hover:var(--spectrum-accent-background-color-hover);--spectrum-tag-border-color-emphasized-active:var(--spectrum-accent-background-color-down);--spectrum-tag-border-color-emphasized-focus:var(--spectrum-accent-background-color-key-focus);--spectrum-tag-background-color-emphasized:var(--spectrum-accent-background-color-default);--spectrum-tag-background-color-emphasized-hover:var(--spectrum-accent-background-color-hover);--spectrum-tag-background-color-emphasized-active:var(--spectrum-accent-background-color-down);--spectrum-tag-background-color-emphasized-focus:var(--spectrum-accent-background-color-key-focus);--spectrum-tag-content-color-emphasized:var(--spectrum-white);--spectrum-tag-content-color-disabled:var(--spectrum-disabled-content-color)}:host,:host{--spectrum-tag-height:var(--spectrum-component-height-100);--spectrum-tag-font-size:var(--spectrum-font-size-100);--spectrum-tag-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-tag-clear-button-spacing-inline-start:var(--spectrum-text-to-visual-100);--spectrum-tag-clear-button-spacing-block:var(--spectrum-tag-top-to-cross-icon-medium);--spectrum-tag-icon-spacing-block-start:var(--spectrum-component-top-to-workflow-icon-100);--spectrum-tag-icon-spacing-block-end:var(--spectrum-component-top-to-workflow-icon-100);--spectrum-tag-icon-spacing-inline-end:var(--spectrum-text-to-visual-100);--spectrum-tag-avatar-spacing-block-start:var(--spectrum-tag-top-to-avatar-medium);--spectrum-tag-avatar-spacing-block-end:var(--spectrum-tag-top-to-avatar-medium);--spectrum-tag-avatar-spacing-inline-end:var(--spectrum-text-to-visual-100);--spectrum-tag-label-spacing-block:var(--spectrum-component-top-to-text-100);--spectrum-tag-corner-radius:var(--spectrum-tag-size-medium-corner-radius);--spectrum-tag-spacing-inline-start:var(--spectrum-tag-size-medium-spacing-inline-start);--spectrum-tag-label-spacing-inline-end:var(--spectrum-tag-size-medium-label-spacing-inline-end);--spectrum-tag-clear-button-spacing-inline-end:var(--spectrum-tag-size-medium-clear-button-spacing-inline-end)}:host([size=s]){--spectrum-tag-height:var(--spectrum-component-height-75);--spectrum-tag-font-size:var(--spectrum-font-size-75);--spectrum-tag-icon-size:var(--spectrum-workflow-icon-size-75);--spectrum-tag-clear-button-spacing-inline-start:var(--spectrum-text-to-visual-75);--spectrum-tag-clear-button-spacing-block:var(--spectrum-tag-top-to-cross-icon-small);--spectrum-tag-icon-spacing-block-start:var(--spectrum-component-top-to-workflow-icon-75);--spectrum-tag-icon-spacing-block-end:var(--spectrum-component-top-to-workflow-icon-75);--spectrum-tag-icon-spacing-inline-end:var(--spectrum-text-to-visual-75);--spectrum-tag-avatar-spacing-block-start:var(--spectrum-tag-top-to-avatar-small);--spectrum-tag-avatar-spacing-block-end:var(--spectrum-tag-top-to-avatar-small);--spectrum-tag-avatar-spacing-inline-end:var(--spectrum-text-to-visual-75);--spectrum-tag-label-spacing-block:var(--spectrum-component-top-to-text-75);--spectrum-tag-corner-radius:var(--spectrum-tag-size-small-corner-radius);--spectrum-tag-spacing-inline-start:var(--spectrum-tag-size-small-spacing-inline-start);--spectrum-tag-label-spacing-inline-end:var(--spectrum-tag-size-small-label-spacing-inline-end);--spectrum-tag-clear-button-spacing-inline-end:var(--spectrum-tag-size-small-clear-button-spacing-inline-end)}:host([size=l]){--spectrum-tag-height:var(--spectrum-component-height-200);--spectrum-tag-font-size:var(--spectrum-font-size-200);--spectrum-tag-icon-size:var(--spectrum-workflow-icon-size-200);--spectrum-tag-clear-button-spacing-inline-start:var(--spectrum-text-to-visual-200);--spectrum-tag-clear-button-spacing-block:var(--spectrum-tag-top-to-cross-icon-large);--spectrum-tag-icon-spacing-block-start:var(--spectrum-component-top-to-workflow-icon-200);--spectrum-tag-icon-spacing-block-end:var(--spectrum-component-top-to-workflow-icon-200);--spectrum-tag-icon-spacing-inline-end:var(--spectrum-text-to-visual-200);--spectrum-tag-avatar-spacing-block-start:var(--spectrum-tag-top-to-avatar-large);--spectrum-tag-avatar-spacing-block-end:var(--spectrum-tag-top-to-avatar-large);--spectrum-tag-avatar-spacing-inline-end:var(--spectrum-text-to-visual-200);--spectrum-tag-label-spacing-block:var(--spectrum-component-top-to-text-200);--spectrum-tag-corner-radius:var(--spectrum-tag-size-large-corner-radius);--spectrum-tag-spacing-inline-start:var(--spectrum-tag-size-large-spacing-inline-start);--spectrum-tag-label-spacing-inline-end:var(--spectrum-tag-size-large-label-spacing-inline-end);--spectrum-tag-clear-button-spacing-inline-end:var(--spectrum-tag-size-large-clear-button-spacing-inline-end)}:host{border-color:var(--highcontrast-tag-border-color,var(--mod-tag-border-color,var(--spectrum-tag-border-color)));background-color:var(--highcontrast-tag-background-color,var(--mod-tag-background-color,var(--spectrum-tag-background-color)));color:var(--highcontrast-tag-content-color,var(--mod-tag-content-color,var(--spectrum-tag-content-color)));border-radius:var(--mod-tag-corner-radius,var(--spectrum-tag-corner-radius));border-width:var(--mod-tag-border-width,var(--spectrum-tag-border-width));block-size:var(--mod-tag-height,var(--spectrum-tag-height));box-sizing:border-box;vertical-align:bottom;-webkit-user-select:none;user-select:none;max-inline-size:100%;transition:border-color var(--mod-tag-animation-duration,var(--spectrum-tag-animation-duration))ease-in-out,color var(--mod-tag-animation-duration,var(--spectrum-tag-animation-duration))ease-in-out,box-shadow var(--mod-tag-animation-duration,var(--spectrum-tag-animation-duration))ease-in-out,background-color var(--mod-tag-animation-duration,var(--spectrum-tag-animation-duration))ease-in-out;border-style:solid;outline:none;align-items:center;padding-inline-start:calc(var(--mod-tag-spacing-inline-start,var(--spectrum-tag-spacing-inline-start)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));padding-inline-end:0;display:inline-flex;position:relative}::slotted([slot=icon]){block-size:var(--mod-tag-icon-size,var(--spectrum-tag-icon-size));inline-size:var(--mod-tag-icon-size,var(--spectrum-tag-icon-size));flex-shrink:0;margin-block-start:calc(var(--mod-tag-icon-spacing-block-start,var(--spectrum-tag-icon-spacing-block-start)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));margin-block-end:calc(var(--mod-tag-icon-spacing-block-end,var(--spectrum-tag-icon-spacing-block-end)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));margin-inline-end:var(--mod-tag-icon-spacing-inline-end,var(--spectrum-tag-icon-spacing-inline-end))}::slotted([slot=avatar]){margin-block-start:calc(var(--mod-tag-avatar-spacing-block-start,var(--spectrum-tag-avatar-spacing-block-start)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));margin-block-end:calc(var(--mod-tag-avatar-spacing-block-end,var(--spectrum-tag-avatar-spacing-block-end)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));margin-inline-end:var(--mod-tag-avatar-spacing-inline-end,var(--spectrum-tag-avatar-spacing-inline-end))}.clear-button{--mod-clear-button-width:fit-content;--spectrum-clearbutton-fill-size:fit-content;--spectrum-clearbutton-fill-background-color:transparent;box-sizing:border-box;color:currentColor;margin-inline-start:calc(var(--mod-tag-clear-button-spacing-inline-start,var(--spectrum-tag-clear-button-spacing-inline-start)) + var(--mod-tag-label-spacing-inline-end,var(--spectrum-tag-label-spacing-inline-end))*-1);margin-inline-end:calc(var(--mod-tag-clear-button-spacing-inline-end,var(--spectrum-tag-clear-button-spacing-inline-end)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));padding-block-start:calc(var(--mod-tag-clear-button-spacing-block,var(--spectrum-tag-clear-button-spacing-block)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));padding-block-end:calc(var(--mod-tag-clear-button-spacing-block,var(--spectrum-tag-clear-button-spacing-block)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)))}.clear-button .spectrum-ClearButton-fill{background-color:var(--mod-clearbutton-fill-background-color,var(--spectrum-clearbutton-fill-background-color));inline-size:var(--mod-clearbutton-fill-size,var(--spectrum-clearbutton-fill-size));block-size:var(--mod-clearbutton-fill-size,var(--spectrum-clearbutton-fill-size))}.label{box-sizing:border-box;block-size:100%;line-height:var(--mod-tag-label-line-height,var(--spectrum-tag-label-line-height));font-weight:var(--mod-tag-label-font-weight,var(--spectrum-tag-label-font-weight));font-size:var(--mod-tag-font-size,var(--spectrum-tag-font-size));cursor:default;white-space:nowrap;text-overflow:ellipsis;flex:auto;margin-inline-end:calc(var(--mod-tag-label-spacing-inline-end,var(--spectrum-tag-label-spacing-inline-end)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));padding-block-start:calc(var(--mod-tag-label-spacing-block,var(--spectrum-tag-label-spacing-block)) - var(--mod-tag-border-width,var(--spectrum-tag-border-width)));overflow:hidden}:host(:is(:active,[active])){border-color:var(--highcontrast-tag-border-color-active,var(--mod-tag-border-color-active,var(--spectrum-tag-border-color-active)));background-color:var(--highcontrast-tag-background-color-active,var(--mod-tag-background-color-active,var(--spectrum-tag-background-color-active)));color:var(--highcontrast-tag-content-color-active,var(--mod-tag-content-color-active,var(--spectrum-tag-content-color-active)))}:host([focused]),:host(:focus-visible){border-color:var(--highcontrast-tag-border-color-focus,var(--mod-tag-border-color-focus,var(--spectrum-tag-border-color-focus)));background-color:var(--highcontrast-tag-background-color-focus,var(--mod-tag-background-color-focus,var(--spectrum-tag-background-color-focus)));color:var(--highcontrast-tag-content-color-focus,var(--mod-tag-content-color-focus,var(--spectrum-tag-content-color-focus)))}:host([focused]):after,:host(:focus-visible):after{content:"";border-color:var(--highcontrast-tag-focus-ring-color,var(--mod-tag-focus-ring-color,var(--spectrum-tag-focus-ring-color)));border-radius:calc(var(--mod-tag-corner-radius,var(--spectrum-tag-corner-radius)) + var(--mod-tag-focus-ring-gap,var(--spectrum-tag-focus-ring-gap)) + var(--mod-tag-border-width,var(--spectrum-tag-border-width)));border-width:var(--mod-tag-focus-ring-thickness,var(--spectrum-tag-focus-ring-thickness));pointer-events:none;border-style:solid;display:inline-block;position:absolute;inset-block-start:calc(var(--mod-tag-focus-ring-gap,var(--spectrum-tag-focus-ring-gap))*-1 - var(--mod-tag-border-width,var(--spectrum-tag-border-width)) - var(--mod-tag-focus-ring-thickness,var(--spectrum-tag-focus-ring-thickness)));inset-block-end:calc(var(--mod-tag-focus-ring-gap,var(--spectrum-tag-focus-ring-gap))*-1 - var(--mod-tag-border-width,var(--spectrum-tag-border-width)) - var(--mod-tag-focus-ring-thickness,var(--spectrum-tag-focus-ring-thickness)));inset-inline-start:calc(var(--mod-tag-focus-ring-gap,var(--spectrum-tag-focus-ring-gap))*-1 - var(--mod-tag-border-width,var(--spectrum-tag-border-width)) - var(--mod-tag-focus-ring-thickness,var(--spectrum-tag-focus-ring-thickness)));inset-inline-end:calc(var(--mod-tag-focus-ring-gap,var(--spectrum-tag-focus-ring-gap))*-1 - var(--mod-tag-border-width,var(--spectrum-tag-border-width)) - var(--mod-tag-focus-ring-thickness,var(--spectrum-tag-focus-ring-thickness)))}:host([selected]){border-color:var(--highcontrast-tag-border-color-selected,var(--mod-tag-border-color-selected,var(--spectrum-tag-border-color-selected)));background-color:var(--highcontrast-tag-background-color-selected,var(--mod-tag-background-color-selected,var(--spectrum-tag-background-color-selected)));color:var(--highcontrast-tag-content-color-selected,var(--mod-tag-content-color-selected,var(--spectrum-tag-content-color-selected)))}:host([selected]:is(:active,[active])){border-color:var(--highcontrast-tag-border-color-selected-active,var(--mod-tag-border-color-selected-active,var(--spectrum-tag-border-color-selected-active)));background-color:var(--highcontrast-tag-background-color-selected-active,var(--mod-tag-background-color-selected-active,var(--spectrum-tag-background-color-selected-active)))}:host([selected][focused]),:host([selected]:focus-visible){border-color:var(--highcontrast-tag-border-color-selected-focus,var(--mod-tag-border-color-selected-focus,var(--spectrum-tag-border-color-selected-focus)));background-color:var(--highcontrast-tag-background-color-selected-focus,var(--mod-tag-background-color-selected-focus,var(--spectrum-tag-background-color-selected-focus)))}:host([invalid]){border-color:var(--highcontrast-tag-border-color-invalid,var(--mod-tag-border-color-invalid,var(--spectrum-tag-border-color-invalid)));color:var(--highcontrast-tag-content-color-invalid,var(--mod-tag-content-color-invalid,var(--spectrum-tag-content-color-invalid)))}:host([invalid]:is(:active,[active])){border-color:var(--highcontrast-tag-border-color-invalid-active,var(--mod-tag-border-color-invalid-active,var(--spectrum-tag-border-color-invalid-active)));color:var(--highcontrast-tag-content-color-invalid-active,var(--mod-tag-content-color-invalid-active,var(--spectrum-tag-content-color-invalid-active)))}:host([invalid][focused]),:host([invalid]:focus-visible){border-color:var(--highcontrast-tag-border-color-invalid-focus,var(--mod-tag-border-color-invalid-focus,var(--spectrum-tag-border-color-invalid-focus)));color:var(--highcontrast-tag-content-color-invalid-focus,var(--mod-tag-content-color-invalid-focus,var(--spectrum-tag-content-color-invalid-focus)))}:host([invalid][selected]){border-color:var(--highcontrast-tag-border-color-invalid-selected,var(--mod-tag-border-color-invalid-selected,var(--spectrum-tag-border-color-invalid-selected)));background-color:var(--highcontrast-tag-background-color-invalid-selected,var(--mod-tag-background-color-invalid-selected,var(--spectrum-tag-background-color-invalid-selected)));color:var(--highcontrast-tag-content-color-invalid-selected,var(--mod-tag-content-color-invalid-selected,var(--spectrum-tag-content-color-invalid-selected)))}:host([invalid][selected]:is(:active,[active])){border-color:var(--highcontrast-tag-border-color-invalid-selected-active,var(--mod-tag-border-color-invalid-selected-active,var(--spectrum-tag-border-color-invalid-selected-active)));background-color:var(--highcontrast-tag-background-color-invalid-selected-active,var(--mod-tag-background-color-invalid-selected-active,var(--spectrum-tag-background-color-invalid-selected-active)))}:host([invalid][selected][focused]),:host([invalid][selected]:focus-visible){border-color:var(--highcontrast-tag-border-color-invalid-selected-focus,var(--mod-tag-border-color-invalid-selected-focus,var(--spectrum-tag-border-color-invalid-selected-focus)));background-color:var(--highcontrast-tag-background-color-invalid-selected-focus,var(--mod-tag-background-color-invalid-selected-focus,var(--spectrum-tag-background-color-invalid-selected-focus)))}:host([emphasized]){border-color:var(--highcontrast-tag-border-color-emphasized,var(--mod-tag-border-color-emphasized,var(--spectrum-tag-border-color-emphasized)));background-color:var(--highcontrast-tag-background-color-emphasized,var(--mod-tag-background-color-emphasized,var(--spectrum-tag-background-color-emphasized)));color:var(--highcontrast-tag-content-color-emphasized,var(--mod-tag-content-color-emphasized,var(--spectrum-tag-content-color-emphasized)))}@media (hover:hover){:host(:hover){border-color:var(--highcontrast-tag-border-color-hover,var(--mod-tag-border-color-hover,var(--spectrum-tag-border-color-hover)));background-color:var(--highcontrast-tag-background-color-hover,var(--mod-tag-background-color-hover,var(--spectrum-tag-background-color-hover)));color:var(--highcontrast-tag-content-color-hover,var(--mod-tag-content-color-hover,var(--spectrum-tag-content-color-hover)))}:host([selected]:hover){border-color:var(--highcontrast-tag-border-color-selected-hover,var(--mod-tag-border-color-selected-hover,var(--spectrum-tag-border-color-selected-hover)));background-color:var(--highcontrast-tag-background-color-selected-hover,var(--mod-tag-background-color-selected-hover,var(--spectrum-tag-background-color-selected-hover)));color:var(--highcontrast-tag-content-color-selected,var(--mod-tag-content-color-selected,var(--spectrum-tag-content-color-selected)))}:host([invalid]:hover){border-color:var(--highcontrast-tag-border-color-invalid-hover,var(--mod-tag-border-color-invalid-hover,var(--spectrum-tag-border-color-invalid-hover)));color:var(--highcontrast-tag-content-color-invalid-hover,var(--mod-tag-content-color-invalid-hover,var(--spectrum-tag-content-color-invalid-hover)))}:host([invalid][selected]:hover){border-color:var(--highcontrast-tag-border-color-invalid-selected-hover,var(--mod-tag-border-color-invalid-selected-hover,var(--spectrum-tag-border-color-invalid-selected-hover)));background-color:var(--highcontrast-tag-background-color-invalid-selected-hover,var(--mod-tag-background-color-invalid-selected-hover,var(--spectrum-tag-background-color-invalid-selected-hover)));color:var(--highcontrast-tag-content-color-invalid-selected,var(--mod-tag-content-color-invalid-selected,var(--spectrum-tag-content-color-invalid-selected)))}:host([emphasized]:hover){border-color:var(--highcontrast-tag-border-color-emphasized-hover,var(--mod-tag-border-color-emphasized-hover,var(--spectrum-tag-border-color-emphasized-hover)));background-color:var(--highcontrast-tag-background-color-emphasized-hover,var(--mod-tag-background-color-emphasized-hover,var(--spectrum-tag-background-color-emphasized-hover)));color:var(--highcontrast-tag-content-color-emphasized,var(--mod-tag-content-color-emphasized,var(--spectrum-tag-content-color-emphasized)))}}:host([emphasized]:is(:active,[active])){border-color:var(--highcontrast-tag-border-color-emphasized-active,var(--mod-tag-border-color-emphasized-active,var(--spectrum-tag-border-color-emphasized-active)));background-color:var(--highcontrast-tag-background-color-emphasized-active,var(--mod-tag-background-color-emphasized-active,var(--spectrum-tag-background-color-emphasized-active)))}:host([emphasized][focused]),:host([emphasized]:focus-visible){border-color:var(--highcontrast-tag-border-color-emphasized-focus,var(--mod-tag-border-color-emphasized-focus,var(--spectrum-tag-border-color-emphasized-focus)));background-color:var(--highcontrast-tag-background-color-emphasized-focus,var(--mod-tag-background-color-emphasized-focus,var(--spectrum-tag-background-color-emphasized-focus)))}:host([disabled]){border-color:var(--highcontrast-tag-border-color-disabled,var(--mod-tag-border-color-disabled,var(--spectrum-tag-border-color-disabled)));background-color:var(--highcontrast-tag-background-color-disabled,var(--mod-tag-background-color-disabled,var(--spectrum-tag-background-color-disabled)));color:var(--highcontrast-tag-content-color-disabled,var(--mod-tag-content-color-disabled,var(--spectrum-tag-content-color-disabled)));pointer-events:none}:host([disabled]) ::slotted([slot=avatar]){opacity:var(--mod-avatar-opacity-disabled,var(--spectrum-avatar-opacity-disabled))}@media (forced-colors:active){:host{--highcontrast-tag-border-color:ButtonText;--highcontrast-tag-border-color-hover:ButtonText;--highcontrast-tag-border-color-active:ButtonText;--highcontrast-tag-border-color-focus:Highlight;--highcontrast-tag-background-color:ButtonFace;--highcontrast-tag-background-color-hover:ButtonFace;--highcontrast-tag-background-color-active:ButtonFace;--highcontrast-tag-background-color-focus:ButtonFace;--highcontrast-tag-content-color:ButtonText;--highcontrast-tag-content-color-hover:ButtonText;--highcontrast-tag-content-color-active:ButtonText;--highcontrast-tag-content-color-focus:ButtonText;--highcontrast-tag-focus-ring-color:Highlight;forced-color-adjust:none}:host([selected]){--highcontrast-tag-border-color-selected:Highlight;--highcontrast-tag-border-color-selected-hover:Highlight;--highcontrast-tag-border-color-selected-active:Highlight;--highcontrast-tag-border-color-selected-focus:Highlight;--highcontrast-tag-background-color-selected:Highlight;--highcontrast-tag-background-color-selected-hover:Highlight;--highcontrast-tag-background-color-selected-active:Highlight;--highcontrast-tag-background-color-selected-focus:Highlight;--highcontrast-tag-content-color-selected:HighlightText}:host([disabled]){--highcontrast-tag-border-color-disabled:GrayText;--highcontrast-tag-background-color-disabled:ButtonFace;--highcontrast-tag-content-color-disabled:GrayText}:host([invalid]){--highcontrast-tag-border-color-invalid:Highlight;--highcontrast-tag-border-color-invalid-hover:Highlight;--highcontrast-tag-border-color-invalid-active:Highlight;--highcontrast-tag-border-color-invalid-focus:Highlight;--highcontrast-tag-content-color-invalid:CanvasText;--highcontrast-tag-content-color-invalid-hover:CanvasText;--highcontrast-tag-content-color-invalid-active:CanvasText;--highcontrast-tag-content-color-invalid-focus:CanvasText}:host([invalid][selected]){--highcontrast-tag-border-color-invalid-selected:Highlight;--highcontrast-tag-border-color-invalid-selected-hover:Highlight;--highcontrast-tag-border-color-invalid-selected-focus:Highlight;--highcontrast-tag-border-color-invalid-selected-active:Highlight;--highcontrast-tag-background-color-invalid-selected:Highlight;--highcontrast-tag-background-color-invalid-selected-hover:Highlight;--highcontrast-tag-background-color-invalid-selected-active:Highlight;--highcontrast-tag-background-color-invalid-selected-focus:Highlight;--highcontrast-tag-content-color-invalid-selected:HighlightText}:host([emphasized]){--highcontrast-tag-border-color-emphasized:Highlight;--highcontrast-tag-border-color-emphasized-hover:Highlight;--highcontrast-tag-border-color-emphasized-active:Highlight;--highcontrast-tag-border-color-emphasized-focus:Highlight;--highcontrast-tag-background-color-emphasized:ButtonFace;--highcontrast-tag-background-color-emphasized-hover:ButtonFace;--highcontrast-tag-background-color-emphasized-active:ButtonFace;--highcontrast-tag-background-color-emphasized-focus:ButtonFace;--highcontrast-tag-content-color-emphasized:CanvasText}}:host{--spectrum-tag-background-color:var(--system-tag-background-color);--spectrum-tag-background-color-hover:var(--system-tag-background-color-hover);--spectrum-tag-background-color-active:var(--system-tag-background-color-active);--spectrum-tag-background-color-focus:var(--system-tag-background-color-focus);--spectrum-tag-size-small-corner-radius:var(--system-tag-size-small-corner-radius);--spectrum-tag-size-medium-corner-radius:var(--system-tag-size-medium-corner-radius);--spectrum-tag-size-large-corner-radius:var(--system-tag-size-large-corner-radius);--spectrum-tag-border-color:var(--system-tag-border-color);--spectrum-tag-border-color-hover:var(--system-tag-border-color-hover);--spectrum-tag-border-color-active:var(--system-tag-border-color-active);--spectrum-tag-border-color-focus:var(--system-tag-border-color-focus);--spectrum-tag-content-color:var(--system-tag-content-color);--spectrum-tag-content-color-hover:var(--system-tag-content-color-hover);--spectrum-tag-content-color-active:var(--system-tag-content-color-active);--spectrum-tag-content-color-focus:var(--system-tag-content-color-focus);--spectrum-tag-content-color-selected:var(--system-tag-content-color-selected);--spectrum-tag-border-color-selected:var(--system-tag-border-color-selected);--spectrum-tag-border-color-selected-hover:var(--system-tag-border-color-selected-hover);--spectrum-tag-border-color-selected-active:var(--system-tag-border-color-selected-active);--spectrum-tag-border-color-selected-focus:var(--system-tag-border-color-selected-focus);--spectrum-tag-border-color-disabled:var(--system-tag-border-color-disabled);--spectrum-tag-background-color-disabled:var(--system-tag-background-color-disabled);--spectrum-tag-size-small-spacing-inline-start:var(--system-tag-size-small-spacing-inline-start);--spectrum-tag-size-small-label-spacing-inline-end:var(--system-tag-size-small-label-spacing-inline-end);--spectrum-tag-size-small-clear-button-spacing-inline-end:var(--system-tag-size-small-clear-button-spacing-inline-end);--spectrum-tag-size-medium-spacing-inline-start:var(--system-tag-size-medium-spacing-inline-start);--spectrum-tag-size-medium-label-spacing-inline-end:var(--system-tag-size-medium-label-spacing-inline-end);--spectrum-tag-size-medium-clear-button-spacing-inline-end:var(--system-tag-size-medium-clear-button-spacing-inline-end);--spectrum-tag-size-large-spacing-inline-start:var(--system-tag-size-large-spacing-inline-start);--spectrum-tag-size-large-label-spacing-inline-end:var(--system-tag-size-large-label-spacing-inline-end);--spectrum-tag-size-large-clear-button-spacing-inline-end:var(--system-tag-size-large-clear-button-spacing-inline-end)}:host([invalid]) .clear-button{--spectrum-clearbutton-medium-icon-color:var(--spectrum-tag-icon-color-error-key-focus,var(--spectrum-red-600));--spectrum-clearbutton-medium-icon-color-hover:var(--spectrum-clearbutton-medium-icon-color);--spectrum-clearbutton-medium-icon-color-down:var(--spectrum-tag-deletable-icon-color-error-down,var(--spectrum-red-700))}:host([invalid]):hover .clear-button,:host([invalid]:is(:active,[active])) .clear-button{--spectrum-clearbutton-medium-icon-color:var(--spectrum-tag-icon-color-error-hover,var(--spectrum-red-600));--spectrum-clearbutton-medium-icon-color-hover:var(--spectrum-clearbutton-medium-icon-color);--spectrum-clearbutton-medium-icon-color-down:var(--spectrum-tag-deletable-icon-color-error-down,var(--spectrum-red-700))}:host([size=xs]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-50)}:host([size=s]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-75)}:host([size=m]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-100)}:host([size=l]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-200)}:host([size=xl]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-300)}:host([size=xxl]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-400)}
`;
var tag_css_default = t23;

// node_modules/@spectrum-web-components/tags/src/Tag.js
var u21 = Object.defineProperty;
var p16 = Object.getOwnPropertyDescriptor;
var r15 = (l16, i21, e36, s19) => {
  for (var t34 = s19 > 1 ? void 0 : s19 ? p16(i21, e36) : i21, a23 = l16.length - 1, o52; a23 >= 0; a23--) (o52 = l16[a23]) && (t34 = (s19 ? o52(i21, e36, t34) : o52(t34)) || t34);
  return s19 && t34 && u21(i21, e36, t34), t34;
};
var Tag = class extends SizedMixin(SpectrumElement, { validSizes: ["s", "m", "l"], noDefaultSize: true }) {
  constructor() {
    super();
    this.deletable = false;
    this.disabled = false;
    this.readonly = false;
    this.handleFocusin = () => {
      this.addEventListener("focusout", this.handleFocusout), this.addEventListener("keydown", this.handleKeydown);
    };
    this.handleFocusout = () => {
      this.removeEventListener("keydown", this.handleKeydown), this.removeEventListener("focusout", this.handleFocusout);
    };
    this.handleKeydown = (e36) => {
      if (!this.deletable || this.disabled) return;
      const { code: s19 } = e36;
      switch (s19) {
        case "Backspace":
        case "Space":
        case "Delete":
          this.delete();
        default:
          return;
      }
    };
    this.addEventListener("focusin", this.handleFocusin);
  }
  static get styles() {
    return [tag_css_default];
  }
  delete() {
    this.readonly || !this.dispatchEvent(new Event("delete", { bubbles: true, cancelable: true, composed: true })) || this.remove();
  }
  render() {
    return x`
            <slot name="avatar"></slot>
            <slot name="icon"></slot>
            <span class="label"><slot></slot></span>
            ${this.deletable ? x`
                      <sp-clear-button
                          class="clear-button"
                          ?disabled=${this.disabled}
                          label="Remove"
                          size="s"
                          tabindex="-1"
                          @click=${this.delete}
                      ></sp-clear-button>
                  ` : E}
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.hasAttribute("role") || this.setAttribute("role", "listitem"), this.deletable && this.setAttribute("tabindex", "0");
  }
  updated(e36) {
    super.updated(e36), e36.has("disabled") && (this.disabled ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled"));
  }
};
r15([n4({ type: Boolean, reflect: true })], Tag.prototype, "deletable", 2), r15([n4({ type: Boolean, reflect: true })], Tag.prototype, "disabled", 2), r15([n4({ type: Boolean, reflect: true })], Tag.prototype, "readonly", 2);

// node_modules/@spectrum-web-components/tags/src/tags.css.js
init_src();
var t24 = i`
    :host{--spectrum-tag-group-item-margin-block:var(--spectrum-spacing-75);--spectrum-tag-group-item-margin-inline:var(--spectrum-spacing-75);flex-wrap:wrap;margin:0;padding:0;list-style:none;display:inline-flex}::slotted(*){margin-block:var(--mod-tag-group-item-margin-block,var(--spectrum-tag-group-item-margin-block));margin-inline:var(--mod-tag-group-item-margin-inline,var(--spectrum-tag-group-item-margin-inline))}:host{--mod-clear-button-width:fit-content;margin:0;padding:0;list-style:none;display:inline-flex}
`;
var tags_css_default = t24;

// node_modules/@spectrum-web-components/tags/src/Tags.js
var g6 = Object.defineProperty;
var f8 = Object.getOwnPropertyDescriptor;
var h11 = (r25, n25, e36, t34) => {
  for (var s19 = t34 > 1 ? void 0 : t34 ? f8(n25, e36) : n25, o52 = r25.length - 1, i21; o52 >= 0; o52--) (i21 = r25[o52]) && (s19 = (t34 ? i21(n25, e36, s19) : i21(s19)) || s19);
  return t34 && s19 && g6(n25, e36, s19), s19;
};
var Tags = class extends FocusVisiblePolyfillMixin(SpectrumElement) {
  constructor() {
    super();
    this.rovingTabindexController = new RovingTabindexController(this, { focusInIndex: (e36) => e36.findIndex((t34) => !t34.disabled && t34.deletable), elements: () => this.tags, isFocusableElement: (e36) => !e36.disabled && e36.deletable });
    this.handleFocusin = () => {
      this.addEventListener("focusout", this.handleFocusout), this.addEventListener("keydown", this.handleKeydown);
    };
    this.handleKeydown = (e36) => {
      const { code: t34 } = e36;
      if (t34 !== "PageUp" && t34 !== "PageDown") return;
      const s19 = (d22, c33) => d22[(d22.length + c33) % d22.length], o52 = [...this.getRootNode().querySelectorAll("sp-tags")];
      if (o52.length < 2) return;
      e36.preventDefault();
      const i21 = o52.indexOf(this), u36 = t34 === "PageUp" ? -1 : 1;
      let l16 = i21 + u36, a23 = s19(o52, l16);
      for (; !a23.tags.length; ) l16 += u36, a23 = s19(o52, l16);
      a23.focus();
    };
    this.handleFocusout = () => {
      this.removeEventListener("keydown", this.handleKeydown), this.removeEventListener("focusout", this.handleFocusout);
    };
    this.addEventListener("focusin", this.handleFocusin);
  }
  static get styles() {
    return [tags_css_default];
  }
  get tags() {
    return this.defaultNodes.filter((e36) => e36 instanceof Tag);
  }
  focus() {
    this.rovingTabindexController.focus();
  }
  handleSlotchange() {
    this.rovingTabindexController.clearElementCache();
  }
  render() {
    return x`
            <slot @slotchange=${this.handleSlotchange}></slot>
        `;
  }
  firstUpdated() {
    this.hasAttribute("role") || this.setAttribute("role", "list"), this.hasAttribute("aria-label") || this.setAttribute("aria-label", "Tags");
  }
};
h11([n5()], Tags.prototype, "defaultNodes", 2);

// node_modules/@spectrum-web-components/tags/sp-tags.js
init_define_element();
defineElement("sp-tags", Tags);

// node_modules/@spectrum-web-components/tags/sp-tag.js
init_define_element();
defineElement("sp-tag", Tag);

// src/features/toolbar/ee-toolbar.js
init_sp_popover();

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTable.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Table.js
var TableIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Table" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M15.75,2H4.25c-1.24072,0-2.25,1.00977-2.25,2.25v11.5c0,1.24023,1.00928,2.25,2.25,2.25h11.5c1.24072,0,2.25-1.00977,2.25-2.25V4.25c0-1.24023-1.00928-2.25-2.25-2.25ZM3.5,9h3v3h-3v-3ZM8,9h8.5v3h-8.5v-3ZM3.5,4.25c0-.41309.33643-.75.75-.75h11.5c.41357,0,.75.33691.75.75v3.25H3.5v-3.25ZM3.5,15.75v-2.25h3v3h-2.25c-.41357,0-.75-.33691-.75-.75ZM16.5,15.75c0,.41309-.33643.75-.75.75h-7.75v-3h8.5v2.25Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Table.js
var TableIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: l16 = "Table" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1ZM12 32H4v-4h8Zm0-6H4v-4h8Zm0-6H4v-4h8Zm20 12H14v-4h18Zm0-6H14v-4h18Zm0-6H14v-4h18Zm0-6H4V4h28Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTable.js
var IconTable = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TableIcon({ hidden: !this.label, title: this.label }) : TableIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-table.js
init_define_element();
defineElement("sp-icon-table", IconTable);

// node_modules/@spectrum-web-components/status-light/src/StatusLight.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/status-light/src/status-light.css.js
init_src();
var s11 = i`
    :host([dir]),:host{--spectrum-statuslight-height:var(--spectrum-component-height-100);--spectrum-statuslight-dot-size:var(--spectrum-status-light-dot-size-medium);--spectrum-statuslight-font-size:var(--spectrum-font-size-100);--spectrum-statuslight-spacing-dot-to-label:var(--spectrum-text-to-visual-100);--spectrum-statuslight-spacing-top-to-dot:var(--spectrum-status-light-top-to-dot-medium);--spectrum-statuslight-spacing-top-to-label:var(--spectrum-component-top-to-text-100);--spectrum-statuslight-spacing-bottom-to-label:var(--spectrum-component-bottom-to-text-100)}:host([size=s]){--spectrum-statuslight-height:var(--spectrum-component-height-75);--spectrum-statuslight-dot-size:var(--spectrum-status-light-dot-size-small);--spectrum-statuslight-font-size:var(--spectrum-font-size-75);--spectrum-statuslight-spacing-dot-to-label:var(--spectrum-text-to-visual-75);--spectrum-statuslight-spacing-top-to-dot:var(--spectrum-status-light-top-to-dot-small);--spectrum-statuslight-spacing-top-to-label:var(--spectrum-component-top-to-text-75);--spectrum-statuslight-spacing-bottom-to-label:var(--spectrum-component-bottom-to-text-75)}:host([size=l]){--spectrum-statuslight-height:var(--spectrum-component-height-200);--spectrum-statuslight-dot-size:var(--spectrum-status-light-dot-size-large);--spectrum-statuslight-font-size:var(--spectrum-font-size-200);--spectrum-statuslight-spacing-dot-to-label:var(--spectrum-text-to-visual-200);--spectrum-statuslight-spacing-top-to-dot:var(--spectrum-status-light-top-to-dot-large);--spectrum-statuslight-spacing-top-to-label:var(--spectrum-component-top-to-text-200);--spectrum-statuslight-spacing-bottom-to-label:var(--spectrum-component-bottom-to-text-200)}:host([size=xl]){--spectrum-statuslight-height:var(--spectrum-component-height-300);--spectrum-statuslight-dot-size:var(--spectrum-status-light-dot-size-extra-large);--spectrum-statuslight-font-size:var(--spectrum-font-size-300);--spectrum-statuslight-spacing-dot-to-label:var(--spectrum-text-to-visual-300);--spectrum-statuslight-spacing-top-to-dot:var(--spectrum-status-light-top-to-dot-extra-large);--spectrum-statuslight-spacing-top-to-label:var(--spectrum-component-top-to-text-300);--spectrum-statuslight-spacing-bottom-to-label:var(--spectrum-component-bottom-to-text-300)}:host([dir]){--spectrum-statuslight-corner-radius:50%;--spectrum-statuslight-font-weight:400;--spectrum-statuslight-border-width:var(--spectrum-border-width-100);--spectrum-statuslight-line-height:var(--spectrum-line-height-100);--spectrum-statuslight-line-height-cjk:var(--spectrum-cjk-line-height-100);--spectrum-statuslight-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-statuslight-subdued-content-color-default:var(--spectrum-neutral-subdued-content-color-default);--spectrum-statuslight-semantic-neutral-color:var(--spectrum-neutral-visual-color);--spectrum-statuslight-semantic-accent-color:var(--spectrum-accent-visual-color);--spectrum-statuslight-semantic-negative-color:var(--spectrum-negative-visual-color);--spectrum-statuslight-semantic-info-color:var(--spectrum-informative-visual-color);--spectrum-statuslight-semantic-notice-color:var(--spectrum-notice-visual-color);--spectrum-statuslight-semantic-positive-color:var(--spectrum-positive-visual-color);--spectrum-statuslight-nonsemantic-gray-color:var(--spectrum-gray-visual-color);--spectrum-statuslight-nonsemantic-red-color:var(--spectrum-red-visual-color);--spectrum-statuslight-nonsemantic-orange-color:var(--spectrum-orange-visual-color);--spectrum-statuslight-nonsemantic-yellow-color:var(--spectrum-yellow-visual-color);--spectrum-statuslight-nonsemantic-chartreuse-color:var(--spectrum-chartreuse-visual-color);--spectrum-statuslight-nonsemantic-celery-color:var(--spectrum-celery-visual-color);--spectrum-statuslight-nonsemantic-green-color:var(--spectrum-green-visual-color);--spectrum-statuslight-nonsemantic-seafoam-color:var(--spectrum-seafoam-visual-color);--spectrum-statuslight-nonsemantic-cyan-color:var(--spectrum-cyan-visual-color);--spectrum-statuslight-nonsemantic-blue-color:var(--spectrum-blue-visual-color);--spectrum-statuslight-nonsemantic-indigo-color:var(--spectrum-indigo-visual-color);--spectrum-statuslight-nonsemantic-purple-color:var(--spectrum-purple-visual-color);--spectrum-statuslight-nonsemantic-fuchsia-color:var(--spectrum-fuchsia-visual-color);--spectrum-statuslight-nonsemantic-magenta-color:var(--spectrum-magenta-visual-color);min-block-size:var(--mod-statuslight-height,var(--spectrum-statuslight-height));box-sizing:border-box;font-size:var(--mod-statuslight-font-size,var(--spectrum-statuslight-font-size));font-weight:400;font-weight:var(--mod-statuslight-font-weight,var(--spectrum-statuslight-font-weight));line-height:var(--mod-statuslight-line-height,var(--spectrum-statuslight-line-height));color:var(--highcontrast-statuslight-content-color-default,var(--mod-statuslight-content-color-default,var(--spectrum-statuslight-content-color-default)));flex-direction:row;align-items:flex-start;padding-block-start:var(--mod-statuslight-spacing-top-to-label,var(--spectrum-statuslight-spacing-top-to-label));padding-block-end:var(--mod-statuslight-spacing-bottom-to-label,var(--spectrum-statuslight-spacing-bottom-to-label));padding-inline:0;display:flex}:host(:lang(ja)),:host(:lang(ko)),:host(:lang(zh)){line-height:var(--mod-statuslight-line-height-cjk,var(--spectrum-statuslight-line-height-cjk))}:host:before{--spectrum-statuslight-spacing-computed-top-to-dot:calc(var(--mod-statuslight-spacing-top-to-dot,var(--spectrum-statuslight-spacing-top-to-dot)) - var(--mod-statuslight-spacing-top-to-label,var(--spectrum-statuslight-spacing-top-to-label)));content:"";inline-size:var(--mod-statuslight-dot-size,var(--spectrum-statuslight-dot-size));block-size:var(--mod-statuslight-dot-size,var(--spectrum-statuslight-dot-size));border-radius:var(--mod-statuslight-corner-radius,var(--spectrum-statuslight-corner-radius));flex-grow:0;flex-shrink:0;margin-block-start:var(--spectrum-statuslight-spacing-computed-top-to-dot);margin-inline-end:var(--mod-statuslight-spacing-dot-to-label,var(--spectrum-statuslight-spacing-dot-to-label));display:inline-block}:host([variant=neutral]){color:var(--highcontrast-statuslight-subdued-content-color-default,var(--mod-statuslight-subdued-content-color-default,var(--spectrum-statuslight-subdued-content-color-default)));font-style:italic}:host([variant=neutral]):before{background-color:var(--mod-statuslight-semantic-neutral-color,var(--spectrum-statuslight-semantic-neutral-color))}.spectrum-StatusLight--accent:before{background-color:var(--mod-statuslight-semantic-accent-color,var(--spectrum-statuslight-semantic-accent-color))}:host([variant=info]):before{background-color:var(--mod-statuslight-semantic-info-color,var(--spectrum-statuslight-semantic-info-color))}:host([variant=negative]):before{background-color:var(--mod-statuslight-semantic-negative-color,var(--spectrum-statuslight-semantic-negative-color))}:host([variant=notice]):before{background-color:var(--mod-statuslight-semantic-notice-color,var(--spectrum-statuslight-semantic-notice-color))}:host([variant=positive]):before{background-color:var(--mod-statuslight-semantic-positive-color,var(--spectrum-statuslight-semantic-positive-color))}.spectrum-StatusLight--gray:before{background-color:var(--mod-statuslight-nonsemantic-gray-color,var(--spectrum-statuslight-nonsemantic-gray-color))}.spectrum-StatusLight--red:before{background-color:var(--mod-statuslight-nonsemantic-red-color,var(--spectrum-statuslight-nonsemantic-red-color))}.spectrum-StatusLight--orange:before{background-color:var(--mod-statuslight-nonsemantic-orange-color,var(--spectrum-statuslight-nonsemantic-orange-color))}:host([variant=yellow]):before{background-color:var(--mod-statuslight-nonsemantic-yellow-color,var(--spectrum-statuslight-nonsemantic-yellow-color))}:host([variant=chartreuse]):before{background-color:var(--mod-statuslight-nonsemantic-chartreuse-color,var(--spectrum-statuslight-nonsemantic-chartreuse-color))}:host([variant=celery]):before{background-color:var(--mod-statuslight-nonsemantic-celery-color,var(--spectrum-statuslight-nonsemantic-celery-color))}.spectrum-StatusLight--green:before{background-color:var(--mod-statuslight-nonsemantic-green-color,var(--spectrum-statuslight-nonsemantic-green-color))}:host([variant=seafoam]):before{background-color:var(--mod-statuslight-nonsemantic-seafoam-color,var(--spectrum-statuslight-nonsemantic-seafoam-color))}.spectrum-StatusLight--cyan:before{background-color:var(--mod-statuslight-nonsemantic-cyan-color,var(--spectrum-statuslight-nonsemantic-cyan-color))}.spectrum-StatusLight--blue:before{background-color:var(--mod-statuslight-nonsemantic-blue-color,var(--spectrum-statuslight-nonsemantic-blue-color))}:host([variant=indigo]):before{background-color:var(--mod-statuslight-nonsemantic-indigo-color,var(--spectrum-statuslight-nonsemantic-indigo-color))}:host([variant=purple]):before{background-color:var(--mod-statuslight-nonsemantic-purple-color,var(--spectrum-statuslight-nonsemantic-purple-color))}:host([variant=fuchsia]):before{background-color:var(--mod-statuslight-nonsemantic-fuchsia-color,var(--spectrum-statuslight-nonsemantic-fuchsia-color))}:host([variant=magenta]):before{background-color:var(--mod-statuslight-nonsemantic-magenta-color,var(--spectrum-statuslight-nonsemantic-magenta-color))}@media (forced-colors:active){:host([dir]){--highcontrast-statuslight-content-color-default:CanvasText;--highcontrast-statuslight-subdued-content-color-default:CanvasText;forced-color-adjust:none}:host:before{forced-color-adjust:none;border:var(--mod-statuslight-border-width,var(--spectrum-statuslight-border-width))solid ButtonText}}:host([disabled]):before{background-color:var(--spectrum-statuslight-dot-color-disabled,var(--spectrum-gray-400))}
`;
var status_light_css_default = s11;

// node_modules/@spectrum-web-components/status-light/src/StatusLight.js
var d12 = Object.defineProperty;
var p17 = Object.getOwnPropertyDescriptor;
var o38 = (l16, r25, t34, i21) => {
  for (var e36 = i21 > 1 ? void 0 : i21 ? p17(r25, t34) : r25, a23 = l16.length - 1, s19; a23 >= 0; a23--) (s19 = l16[a23]) && (e36 = (i21 ? s19(r25, t34, e36) : s19(e36)) || e36);
  return i21 && e36 && d12(r25, t34, e36), e36;
};
var StatusLight = class extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.variant = "info";
  }
  static get styles() {
    return [status_light_css_default];
  }
  render() {
    return x`
            <slot></slot>
        `;
  }
  updated(t34) {
    super.updated(t34), t34.has("disabled") && (this.disabled ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled"));
  }
};
o38([n4({ type: Boolean, reflect: true })], StatusLight.prototype, "disabled", 2), o38([n4({ reflect: true })], StatusLight.prototype, "variant", 2);

// node_modules/@spectrum-web-components/status-light/sp-status-light.js
init_define_element();
defineElement("sp-status-light", StatusLight);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLockClosed.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/LockClosed.js
var LockClosedIcon = ({ width: a23 = 24, height: e36 = 24, hidden: t34 = false, title: l16 = "Lock Closed" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${a23}"
    height="${e36}"
    viewBox="0 0 36 36"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M29 16h-1v-2a10 10 0 0 0-20 0v2H7a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V17a1 1 0 0 0-1-1Zm-17-2a6 6 0 0 1 12 0v2H12Zm8 12.222V29a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2.778a3 3 0 1 1 4 0Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Lock.js
var LockIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: c33 = "Lock" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${c33}"
  >
    <path
      d="M11.25,11.5c0-.68945-.56055-1.25-1.25-1.25s-1.25.56055-1.25,1.25c0,.40259.20361.74487.5.97363v.77637c0,.41406.33594.75.75.75s.75-.33594.75-.75v-.77637c.29639-.22876.5-.57104.5-.97363Z"
      fill="currentColor"
    />
    <path
      d="M15,7.02539v-.52539c0-2.75684-2.24316-5-5-5s-5,2.24316-5,5v.52539c-1.12158.12622-2,1.07007-2,2.22461v6.5c0,1.24023,1.00977,2.25,2.25,2.25h9.5c1.24023,0,2.25-1.00977,2.25-2.25v-6.5c0-1.15454-.87842-2.09839-2-2.22461ZM10,3c1.92969,0,3.5,1.57031,3.5,3.5v.5h-7v-.5c0-1.92969,1.57031-3.5,3.5-3.5ZM15.5,15.75c0,.41309-.33691.75-.75.75H5.25c-.41309,0-.75-.33691-.75-.75v-6.5c0-.41309.33691-.75.75-.75h9.5c.41309,0,.75.33691.75.75v6.5Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLockClosed.js
var IconLockClosed = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? LockClosedIcon({ hidden: !this.label, title: this.label }) : LockIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-lock-closed.js
init_define_element();
defineElement("sp-icon-lock-closed", IconLockClosed);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLockOpen.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/LockOpen.js
var LockOpenIcon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: l16 = "Lock Open" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M11.25,12.5c0-.68945-.56055-1.25-1.25-1.25s-1.25.56055-1.25,1.25c0,.40259.20361.74487.5.97363v.77637c0,.41406.33594.75.75.75s.75-.33594.75-.75v-.77637c.29639-.22876.5-.57104.5-.97363Z"
      fill="currentColor"
    />
    <path
      d="M14.75,8H6.5v-2.75c0-1.92969,1.57031-3.5,3.5-3.5.86523,0,1.69629.31836,2.33887.89551.30664.27734.7832.25293,1.05859-.05664.27734-.30762.25195-.78223-.05664-1.05859-.91797-.8252-2.10449-1.28027-3.34082-1.28027-2.75684,0-5,2.24316-5,5v2.77539c-1.12158.12622-2,1.07007-2,2.22461v6.5c0,1.24023,1.00977,2.25,2.25,2.25h9.5c1.24023,0,2.25-1.00977,2.25-2.25v-6.5c0-1.24023-1.00977-2.25-2.25-2.25ZM15.5,16.75c0,.41309-.33691.75-.75.75H5.25c-.41309,0-.75-.33691-.75-.75v-6.5c0-.41309.33691-.75.75-.75h9.5c.41309,0,.75.33691.75.75v6.5Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/LockOpen.js
var LockOpenIcon2 = ({ width: a23 = 24, height: e36 = 24, hidden: t34 = false, title: l16 = "Lock Open" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${a23}"
    height="${e36}"
    viewBox="0 0 36 36"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M29 16H11.9v-5.648A6.213 6.213 0 0 1 18 4a6.142 6.142 0 0 1 5.507 3.419c.31.639.266 1.146.777 1.146a.508.508 0 0 0 .186-.036l2.682-1.069a.514.514 0 0 0 .322-.471C27.474 5.513 24.167.2 18 .2 11.143.2 8 6.505 8 10.292V16H7a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V17a1 1 0 0 0-1-1Zm-9 10.222V29a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2.778a3 3 0 1 1 4 0Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLockOpen.js
var IconLockOpen = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? LockOpenIcon({ hidden: !this.label, title: this.label }) : LockOpenIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-lock-open.js
init_define_element();
defineElement("sp-icon-lock-open", IconLockOpen);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextBold.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/TextBold.js
var TextBoldIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Text Bold" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m13.98926,2.01465H5.51074c-1.38477,0-2.51074,1.17773-2.51074,2.625v1.11035c0,.62109.50391,1.125,1.125,1.125s1.125-.50391,1.125-1.125v-1.11035c0-.2207.1377-.375.26074-.375h2.48926v11.44531c0,.00488.00146.00977.00146.01465h-.57178c-.62109,0-1.125.50391-1.125,1.125s.50391,1.125,1.125,1.125h4.64062c.62109,0,1.125-.50391,1.125-1.125s-.50391-1.125-1.125-1.125h-.57178c0-.00488.00146-.00977.00146-.01465V4.26465h2.48926c.12305,0,.26074.1543.26074.375v1.11035c0,.62109.50391,1.125,1.125,1.125s1.125-.50391,1.125-1.125v-1.11035c0-1.44727-1.12598-2.625-2.51074-2.625Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/TextBold.js
var TextBoldIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "Text Bold" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M1 4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-3V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextBold.js
var IconTextBold = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TextBoldIcon({ hidden: !this.label, title: this.label }) : TextBoldIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-text-bold.js
init_define_element();
defineElement("sp-icon-text-bold", IconTextBold);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextItalic.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/TextItalic.js
var TextItalicIcon = ({ width: t34 = 24, height: l16 = 24, hidden: e36 = false, title: r25 = "Text Italic" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m16.6543,2.75586c-.38184-.48047-.95312-.75586-1.56641-.75586H6.04102c-.93457,0-1.75391.59668-2.13867,1.55957l-.55762,1.4043c-.15234.38477.03516.82031.4209.97363.38184.15332.81934-.03418.97363-.4209l.55664-1.40234c.05762-.14355.28223-.61426.74512-.61426h3.7207l-3.49219,13h-1.60742c-.41406,0-.75.33594-.75.75s.33594.75.75.75h4.63965c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75h-1.47852l3.49219-13h3.77246c.20996,0,.33496.11816.3916.18848.05566.07129.14258.21973.09473.4248l-.25,1.07715c-.09375.4043.15723.80664.56055.90039.05762.01367.11426.01953.1709.01953.34082,0,.64941-.23438.72949-.58008l.25-1.07715c.13965-.59766,0-1.2168-.38086-1.69727Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/TextItalic.js
var TextItalicIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: l16 = false, title: e36 = "Text Italic" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="M7.919 4a1.561 1.561 0 0 0-1.351 1l-2.109 6a.685.685 0 0 0 .649 1h2a1.557 1.557 0 0 0 1.351-1l1.055-3h8l-7.028 20h-3a1.557 1.557 0 0 0-1.351 1l-.7 2a.685.685 0 0 0 .649 1h10a1.557 1.557 0 0 0 1.351-1l.7-2a.684.684 0 0 0-.649-1h-3l7.028-20h8l-1.055 3a.685.685 0 0 0 .649 1h2a1.557 1.557 0 0 0 1.351-1l2.109-6a.686.686 0 0 0-.649-1Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextItalic.js
var IconTextItalic = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TextItalicIcon({ hidden: !this.label, title: this.label }) : TextItalicIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-text-italic.js
init_define_element();
defineElement("sp-icon-text-italic", IconTextItalic);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextUnderline.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/TextUnderline.js
var TextUnderlineIcon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: l16 = "Text Underline" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m14.52246,2H5.47754c-1.22852,0-2.22754,1.00977-2.22754,2.25v1.11035c0,.41406.33594.75.75.75s.75-.33594.75-.75v-1.11035c0-.41309.32617-.75.72754-.75h3.77246v11h-1.57031c-.41406,0-.75.33594-.75.75s.33594.75.75.75h4.64062c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75h-1.57031V3.5h3.77246c.40137,0,.72754.33691.72754.75v1.11035c0,.41406.33594.75.75.75s.75-.33594.75-.75v-1.11035c0-1.24023-.99902-2.25-2.22754-2.25Z"
      fill="currentColor"
    />
    <path
      d="m16.25,19H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h12.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Underline.js
var UnderlineIcon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Underline" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <rect height="2" rx=".5" ry=".5" width="22" x="7" y="30" />
    <path
      d="M22.5 4.012a.5.5 0 0 0-.5.5v13.5s.482 6.2-5 6.2c-5.459 0-5-6.2-5-6.2v-13.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v13.5c0 1.412-.141 10 9 10S26 19 26 17.988V4.512a.5.5 0 0 0-.5-.5Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextUnderline.js
var IconTextUnderline = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TextUnderlineIcon({ hidden: !this.label, title: this.label }) : UnderlineIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-text-underline.js
init_define_element();
defineElement("sp-icon-text-underline", IconTextUnderline);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextStrikethrough.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/TextStrikethrough.js
var TextStrikethroughIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: l16 = "Text Strikethrough" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m14.5,2H5.5c-1.24023,0-2.25,1.00977-2.25,2.25v1.11035c0,.41406.33594.75.75.75s.75-.33594.75-.75v-1.11035c0-.41309.33691-.75.75-.75h3.75v3.75c0,.41406.33594.75.75.75s.75-.33594.75-.75v-3.75h3.75c.41309,0,.75.33691.75.75v1.11035c0,.41406.33594.75.75.75s.75-.33594.75-.75v-1.11035c0-1.24023-1.00977-2.25-2.25-2.25Z"
      fill="currentColor"
    />
    <path
      d="m16.25,9.25H3.75c-.41406,0-.75.33594-.75.75s.33594.75.75.75h5.5v5.75h-1.5498c-.41406,0-.75.33594-.75.75s.33594.75.75.75h4.63965c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75h-1.58984v-5.75h5.5c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/TextStrikethrough.js
var TextStrikethroughIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Text Strikethrough" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M23 28h-3v-6h-4v6h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1ZM31 4H5a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v8h4V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1Z"
    />
    <rect height="2" rx=".5" ry=".5" width="28" x="4" y="18" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextStrikethrough.js
var IconTextStrikethrough = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TextStrikethroughIcon({ hidden: !this.label, title: this.label }) : TextStrikethroughIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-text-strikethrough.js
init_define_element();
defineElement("sp-icon-text-strikethrough", IconTextStrikethrough);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPaste.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Paste.js
var PasteIcon = ({ width: e36 = 24, height: t34 = 24, hidden: c33 = false, title: r25 = "Paste" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${c33 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <circle cx="10" cy="4" r="1" fill="currentColor" />
    <path
      d="m15.75,18H4.25c-1.24023,0-2.25-1.00977-2.25-2.25V6.25c0-1.24023,1.00977-2.25,2.25-2.25h2.25195c.02637-.9248.40723-1.7832,1.0791-2.42578.69629-.66602,1.61914-1.0166,2.57617-.96582,1.75293.07617,3.19434,1.57129,3.33203,3.3916h2.26074c1.24023,0,2.25,1.00977,2.25,2.25v9.5c0,1.24023-1.00977,2.25-2.25,2.25ZM4.25,5.5c-.41309,0-.75.33691-.75.75v9.5c0,.41309.33691.75.75.75h11.5c.41309,0,.75-.33691.75-.75V6.25c0-.41309-.33691-.75-.75-.75h-.75v1.25c0,1.24023-1.00977,2.25-2.25,2.25h-5.5c-1.24023,0-2.25-1.00977-2.25-2.25l-.03613-1.25h-.71387Zm2.25,0v1.25c0,.41309.33691.75.75.75h5.5c.41309,0,.75-.33691.75-.75v-1.25h-.75c-.41406,0-.75-.33594-.75-.75v-.46582c0-1.15527-.85645-2.13184-1.9082-2.17773-.55762-.0127-1.07617.1709-1.47363.55176-.39844.38086-.61816.89453-.61816,1.44629v.64551c0,.41406-.33594.75-.75.75h-.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Paste.js
var PasteIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Paste" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M28 6v5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V6H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Z"
    />
    <path d="M22 6V4a4 4 0 0 0-8 0v2h-4v4h16V6Zm-2 0h-4V4a2 2 0 0 1 4 0Z" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPaste.js
var IconPaste = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? PasteIcon({ hidden: !this.label, title: this.label }) : PasteIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-paste.js
init_define_element();
defineElement("sp-icon-paste", IconPaste);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextAlignLeft.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/TextAlignLeft.js
var TextAlignLeftIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Text Align Left" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m16.25,4.5H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h12.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m13.75,8.5H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m16.25,12.5H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h12.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m13.75,16.5H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/TextAlignLeft.js
var TextAlignLeftIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: i21 = "Text Align Left" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${i21}"
  >
    <rect height="4" rx="1" ry="1" width="24" x="4" y="28" />
    <rect height="4" rx="1" ry="1" width="30" x="4" y="4" />
    <rect height="4" rx="1" ry="1" width="24" x="4" y="12" />
    <rect height="4" rx="1" ry="1" width="30" x="4" y="20" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextAlignLeft.js
var IconTextAlignLeft = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TextAlignLeftIcon({ hidden: !this.label, title: this.label }) : TextAlignLeftIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-text-align-left.js
init_define_element();
defineElement("sp-icon-text-align-left", IconTextAlignLeft);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextAlignCenter.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/TextAlignCenter.js
var TextAlignCenterIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: l16 = "Text Align Center" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m16.25,4.5H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h12.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m14.5,8.5H5.5c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h9c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m16.25,12.5H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h12.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m14.5,16.5H5.5c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h9c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/TextAlignCenter.js
var TextAlignCenterIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: i21 = "Text Align Center" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${i21}"
  >
    <rect height="4" rx="1" ry="1" width="20" x="8" y="28" />
    <rect height="4" rx="1" ry="1" width="32" x="2" y="20" />
    <rect height="4" rx="1" ry="1" width="32" x="2" y="4" />
    <rect height="4" rx="1" ry="1" width="20" x="8" y="12" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextAlignCenter.js
var IconTextAlignCenter = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TextAlignCenterIcon({ hidden: !this.label, title: this.label }) : TextAlignCenterIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-text-align-center.js
init_define_element();
defineElement("sp-icon-text-align-center", IconTextAlignCenter);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextAlignRight.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/TextAlignRight.js
var TextAlignRightIcon = ({ width: t34 = 24, height: l16 = 24, hidden: r25 = false, title: e36 = "Text Align Right" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="m16.25,4.5H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h12.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m16.25,8.5H6.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m16.25,12.5H3.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h12.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m16.25,16.5H6.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/TextAlignRight.js
var TextAlignRightIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: i21 = "Text Align Right" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${i21}"
  >
    <rect height="4" rx="1" ry="1" width="24" x="8" y="28" />
    <rect height="4" rx="1" ry="1" width="30" x="2" y="4" />
    <rect height="4" rx="1" ry="1" width="24" x="8" y="12" />
    <rect height="4" rx="1" ry="1" width="30" x="2" y="20" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTextAlignRight.js
var IconTextAlignRight = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TextAlignRightIcon({ hidden: !this.label, title: this.label }) : TextAlignRightIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-text-align-right.js
init_define_element();
defineElement("sp-icon-text-align-right", IconTextAlignRight);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconListBulleted.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ListBulleted.js
var ListBulletedIcon = ({ width: l16 = 24, height: r25 = 24, hidden: e36 = false, title: t34 = "List Bulleted" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="m17.25,16.52148H7.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m17.25,10.52148H7.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m17.25,4.52148H7.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <circle cx="3.5" cy="3.77108" r="1.5" fill="currentColor" />
    <circle cx="3.5" cy="9.77108" r="1.5" fill="currentColor" />
    <circle cx="3.5" cy="15.77108" r="1.5" fill="currentColor" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/TextBulleted.js
var TextBulletedIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: h16 = "Text Bulleted" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${h16}"
  >
    <rect height="6" rx="2.8" ry="2.8" width="6" x="4" y="2" />
    <rect height="6" rx="2.8" ry="2.8" width="6" x="4" y="14" />
    <rect height="6" rx="2.8" ry="2.8" width="6" x="4" y="26" />
    <rect height="4" rx="1" ry="1" width="22" x="12" y="28" />
    <rect height="4" rx="1" ry="1" width="22" x="12" y="16" />
    <rect height="4" rx="1" ry="1" width="22" x="12" y="4" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconListBulleted.js
var IconListBulleted = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ListBulletedIcon({ hidden: !this.label, title: this.label }) : TextBulletedIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-list-bulleted.js
init_define_element();
defineElement("sp-icon-list-bulleted", IconListBulleted);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconListNumbered.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ListNumbered.js
var ListNumberedIcon = ({ width: t34 = 24, height: r25 = 24, hidden: e36 = false, title: l16 = "List Numbered" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m17.25,16.52148H7.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="m17.25,10.52148H7.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="m17.25,4.52148H7.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h10c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
      stroke-width="0"
    />
    <g>
      <path
        d="m3.10986,5.51953v-2.625h-.02344l-.44824.31055c-.10547.07324-.17285.09668-.29004.09668-.23145,0-.41016-.17285-.41016-.41895,0-.17285.07031-.31348.23438-.4248l.76758-.5127c.24609-.16406.45996-.1875.7002-.1875.44824,0,.71191.26953.71191.69434v3.06738c0,.37207-.24902.6123-.62109.6123s-.62109-.24023-.62109-.6123Z"
        fill="currentColor"
        stroke-width="0"
      />
      <path
        d="m1.70508,11.52246c0-.22852.10547-.4043.33984-.60059l1.16309-.99609c.47461-.40723.60938-.5918.60938-.84375,0-.2666-.20508-.45117-.50684-.45117-.22266,0-.375.10254-.5332.33105-.16406.24023-.31348.32812-.55078.32812-.31641,0-.50977-.18457-.50977-.4834,0-.09668.01758-.1875.05566-.27539.22266-.50391.81738-.81738,1.55566-.81738,1.02832,0,1.68457.51855,1.68457,1.28613,0,.56836-.29297.86426-.94922,1.43262l-.77051.66504v.02344h1.3418c.31055,0,.48633.18457.48633.46875,0,.27832-.17578.46875-.48633.46875h-2.34961c-.4043,0-.58008-.22559-.58008-.53613Z"
        fill="currentColor"
        stroke-width="0"
      />
      <path
        d="m1.67871,17.30566c-.02637-.07324-.03809-.15527-.03809-.21973,0-.30762.20508-.49805.53906-.49805.23145,0,.38379.07617.50684.25488.1582.23145.31348.36914.68262.36914.31055,0,.5332-.1875.5332-.44824,0-.30176-.23145-.46289-.66211-.46289h-.0293c-.29004,0-.43652-.16113-.43652-.41016,0-.2373.14648-.40723.43652-.40723h.0293c.38379,0,.60645-.16699.60645-.43945,0-.26074-.19336-.4248-.50684-.4248-.25195,0-.43066.10254-.55078.31348-.14062.24902-.29297.33984-.5625.33984-.33984,0-.50684-.19922-.50684-.47461,0-.08203.01172-.14648.04102-.22852.14941-.40723.66504-.85547,1.57324-.85547.94043,0,1.65527.39844,1.65527,1.15137,0,.54785-.40137.8877-.86719.98145v.02344c.64453.06738,1.04297.42188,1.04297.98438,0,.80859-.69434,1.32129-1.8252,1.32129-.98438,0-1.51758-.46875-1.66113-.87012Z"
        fill="currentColor"
        stroke-width="0"
      />
    </g>
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconListNumbered.js
var IconListNumbered = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ListNumberedIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-list-numbered.js
init_define_element();
defineElement("sp-icon-list-numbered", IconListNumbered);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLinkOff.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/LinkOff.js
var LinkOffIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: a23 = "Link Off" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 36 36"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="m11.136 9.523-1.496 1.44-5.328-5.24 1.496-1.439 5.328 5.239zM31.801 30.277l-1.496 1.439-5.299-5.334 1.495-1.439 5.3 5.334zM11.057 1.8h2.314v4.629h-2.314zM1.8 11.057h4.629v2.314H1.8zM29.571 22.629H34.2v2.314h-4.629zM22.629 29.571h2.314V34.2h-2.314zM18.053 23.708l-5.84 5.878a4.101 4.101 0 0 1-5.8-5.8l5.858-5.858-2.171-2.174-5.861 5.858A7.176 7.176 0 0 0 14.388 31.76l5.842-5.874ZM17.917 12.258l5.84-5.878a4.101 4.101 0 1 1 5.8 5.8l-5.858 5.858 2.171 2.174 5.861-5.858A7.176 7.176 0 1 0 21.582 4.206L15.74 10.08Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Unlink.js
var UnlinkIcon = ({ width: l16 = 24, height: r25 = 24, hidden: t34 = false, title: c33 = "Unlink" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${c33}"
  >
    <path
      d="m13.5,17.77148c-.32031,0-.61621-.20605-.71582-.52734l-.82129-2.64258c-.12305-.39551.09766-.81641.49316-.93848.40039-.125.81641.09863.93848.49316l.82129,2.64258c.12305.39551-.09766.81641-.49316.93848-.07422.02344-.14941.03418-.22266.03418Z"
      fill="currentColor"
    />
    <path
      d="m17,14.27148c-.07422,0-.14941-.01074-.22363-.03418l-2.65723-.8291c-.39551-.12305-.61523-.54395-.49219-.93945.12207-.39551.54395-.62012.93945-.49219l2.65723.8291c.39551.12305.61523.54395.49219.93945-.09961.32031-.39648.52637-.71582.52637Z"
      fill="currentColor"
    />
    <path
      d="m7.31641,6.40527c-.32031,0-.61621-.20605-.7168-.52832l-.81641-2.63379c-.12207-.39551.09863-.81543.49512-.93848.39453-.12207.81445.09863.93848.49512l.81641,2.63379c.12207.39551-.09863.81543-.49512.93848-.07324.02246-.14844.0332-.22168.0332Z"
      fill="currentColor"
    />
    <path
      d="m5.63965,8.09082c-.07324,0-.14844-.01074-.22266-.03418l-2.63965-.81934c-.39551-.12207-.61621-.54297-.49316-.93848.12305-.39453.54004-.61523.93848-.49316l2.63965.81934c.39551.12207.61621.54297.49316.93848-.09961.32129-.39551.52734-.71582.52734Z"
      fill="currentColor"
    />
    <path
      d="m5.31348,18.76953c-1.04102,0-2.08105-.39648-2.87305-1.18848-1.58496-1.58398-1.58496-4.16309,0-5.74707l1.92676-1.92676c.29297-.29297.76758-.29297,1.06055,0s.29297.76758,0,1.06055l-1.92676,1.92676c-1,1-1,2.62598,0,3.62598,1.00098,1.00098,2.62695.99707,3.62598,0l1.95215-1.95312c.29199-.29199.7666-.29395,1.06055,0,.29297.29199.29297.76758,0,1.06055l-1.95215,1.95312c-.79199.79199-1.83301,1.1875-2.87402,1.18848Z"
      fill="currentColor"
    />
    <path
      d="m15.10059,10.35645c-.19238,0-.38379-.07324-.53027-.21973-.29297-.29297-.29297-.76758,0-1.06055l1.92773-1.92773c1-1,1-2.62695.00098-3.62598-.96875-.96875-2.65723-.96875-3.62598,0l-1.95215,1.95215c-.29297.29297-.76758.29297-1.06055,0s-.29297-.76758,0-1.06055l1.95215-1.95215c.76758-.76758,1.78809-1.19141,2.87402-1.19141,1.08496,0,2.10547.42383,2.87305,1.19141,1.58398,1.58398,1.58398,4.16211,0,5.74609l-1.92871,1.92871c-.14648.14648-.33789.21973-.53027.21973Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLinkOff.js
var IconLinkOff = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? LinkOffIcon({ hidden: !this.label, title: this.label }) : UnlinkIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-link-off.js
init_define_element();
defineElement("sp-icon-link-off", IconLinkOff);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconMagicWand.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/MagicWand.js
var MagicWandIcon = ({ width: l16 = 24, height: t34 = 24, hidden: r25 = false, title: c33 = "Magic Wand" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${c33}"
  >
    <path
      d="m15.0498,7.2002c0-.60156-.23438-1.16699-.6582-1.59082-.84863-.84961-2.33301-.85156-3.18262,0l-1.82129,1.82129c-.02148.02148-.04199.04492-.06055.06836-.02441.01855-.04688.03906-.06934.06152L1.65918,15.15918c-.4248.4248-.65918.99023-.65918,1.59082s.23438,1.16602.65918,1.59082.99023.65918,1.59082.65918,1.16602-.23438,1.59082-.65918l9.5498-9.5498c.4248-.4248.65918-.99023.65918-1.59082ZM3.78027,17.28027c-.2832.2832-.77734.2832-1.06055,0-.1416-.1416-.21973-.33008-.21973-.53027s.07812-.38867.21973-.53027l7.2002-7.2002,1.06543,1.05566-7.20508,7.20508ZM13.33008,7.73047l-1.28418,1.28418-1.06543-1.05566,1.28906-1.28906c.2832-.2832.77734-.28418,1.06055.00098.1416.14062.21973.3291.21973.5293s-.07812.38867-.21973.53027Z"
      fill="currentColor"
    />
    <path
      d="m18.70605,10.83154l-1.26123-.49854-.20312-1.34204c-.06519-.42798-.75806-.50513-.91577-.10425l-.49878,1.26221-1.34204.20166c-.21289.03198-.37891.20361-.40332.41797-.02441.2146.0979.41821.29907.49805l1.26221.49976.2019,1.34106c.03174.21289.20337.37891.41797.40332.21436.02441.41797-.0979.49805-.29907l.49927-1.26099,1.34131-.20312c.21411-.03271.37891-.20361.40332-.41797s-.09863-.41919-.29883-.49805Z"
      fill="currentColor"
    />
    <path
      d="m14.33618,3.64233l1.26221.49976.2019,1.34094c.03174.21301.20361.37903.41797.40344.2146.02441.41821-.0979.49805-.29907l.49951-1.26111,1.34131-.203c.21387-.03259.37891-.20361.40332-.41797s-.09863-.41919-.29907-.49805l-1.26123-.49854-.20288-1.34204c-.06519-.4281-.7583-.50513-.91602-.10437l-.49854,1.26221-1.34204.2019c-.21313.03186-.37915.20349-.40356.41797s.0979.41809.29907.49792Z"
      fill="currentColor"
    />
    <path
      d="m5.7793,4.69019l1.02417.4054.16382,1.08826c.02588.17273.16528.3075.33936.32727.17383.0199.33911-.07935.40405-.24268l.40527-1.02332,1.08813-.16479c.17383-.02637.30762-.16504.32764-.33911.01978-.17407-.08008-.34009-.24268-.40405l-1.02344-.40454-.16479-1.08911c-.05298-.34741-.61523-.40991-.74316-.08472l-.40454,1.02429-1.08911.16382c-.17285.02576-.30762.16516-.32739.33923-.01978.17395.07935.33911.24268.40405Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/MagicWand.js
var MagicWandIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: l16 = false, title: e36 = "Magic Wand" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <rect
      height="4"
      rx="1"
      ry="1"
      transform="rotate(-45 12.249 21.751)"
      width="30.118"
      x="-2.811"
      y="19.752"
    />
    <path
      d="m31.506 13.559.078 2.156a1.756 1.756 0 0 0 .9 1.47l1.882 1.054-2.156.078a1.756 1.756 0 0 0-1.47.9L29.684 21.1l-.078-2.156a1.756 1.756 0 0 0-.9-1.47l-1.882-1.054 2.156-.078a1.759 1.759 0 0 0 1.47-.9ZM29.732.1l.108 2.99a2.437 2.437 0 0 0 1.245 2.038L33.7 6.589l-2.99.108a2.434 2.434 0 0 0-2.039 1.245l-1.462 2.61-.109-2.99a2.44 2.44 0 0 0-1.245-2.039l-2.614-1.462 2.99-.108a2.439 2.439 0 0 0 2.039-1.245ZM12.7 1.68l.139 3.851a3.138 3.138 0 0 0 1.6 2.625L17.8 10.04l-3.851.139a3.139 3.139 0 0 0-2.626 1.6l-1.88 3.365-.143-3.851a3.139 3.139 0 0 0-1.6-2.626L4.339 6.784l3.851-.139a3.141 3.141 0 0 0 2.626-1.6Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconMagicWand.js
var IconMagicWand = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? MagicWandIcon({ hidden: !this.label, title: this.label }) : MagicWandIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-magic-wand.js
init_define_element();
defineElement("sp-icon-magic-wand", IconMagicWand);

// src/features/toolbar/ee-toolbar.js
var SUMMARY_INTERACTIVE_TAGS = [
  "sp-action-button",
  "sp-action-menu",
  "sp-button",
  "sp-icon-button",
  "sp-close-button",
  "sp-number-field",
  "sp-textfield",
  "sp-picker",
  "sp-checkbox",
  "sp-radio",
  "sp-switch",
  "sp-tags",
  "sp-tag"
];
var SUMMARY_INTERACTIVE_TAG_SET = new Set(
  SUMMARY_INTERACTIVE_TAGS.map((tag3) => tag3.toUpperCase())
);
var SUMMARY_LABEL_ATTR = "data-ee-summary-label";
var INLINE_TEXT_TAGS = /* @__PURE__ */ new Set(["span", "div", "p"]);
var INLINE_CONTAINER_ATTR = "data-ee-inline-container";
var INLINE_EDITOR_ATTR = "data-ee-inline-editor";
var SHOW_ALL_FIELDS_TITLE = "Show all fields";
var SHOW_ALL_FIELDS_POPOVER_ID = "show-all-fields-popover";
var EEToolbar = class extends i4 {
  static get styles() {
    return eeToolbarStyles;
  }
  static get properties() {
    return {
      editorStore: { type: Object, observe: true, throttle: 20 },
      commentStore: { type: Object, observe: true },
      agentStore: { type: Object, observe: true },
      visible: { type: Boolean, converter: booleanConverter },
      static: { type: Boolean, reflect: true, attribute: "static", converter: booleanConverter },
      showAllOpen: { type: Boolean, attribute: false },
      rteNodeShowAllOpen: { type: Boolean, attribute: false },
      clipboardHasTextOrHtml: { state: true }
    };
  }
  #logEnabled = TOOLBAR_DEBUG === true;
  #checkingClipboard = false;
  #lastEditingElement = null;
  #lastEditingTagName = null;
  #inlineAttrNames = [];
  #shouldReopenPopover = false;
  #dragHandlers = null;
  #rteButtonRegistry = /* @__PURE__ */ new Map();
  #renderRteInvocation = 0;
  #focusInHandler = () => {
    this.editorStore?.setLastAction?.("toolbar:focus");
  };
  #focusOutHandler = () => {
  };
  #pointerDownHandler = () => {
    this.editorStore?.setLastAction?.("toolbar:interact");
  };
  #attributeTarget() {
    return this.editorStore?.editingElement || null;
  }
  #getDomStore() {
    return this.editorStore?.domStore || this.editorStore?.store?.domStore || null;
  }
  #withFrozenPosition(fn2) {
    if (!fn2) {
      return;
    }
    const toolbarStore = this.editorStore?.toolbar;
    if (toolbarStore) {
      toolbarStore.freezePositionDuring(fn2);
      return;
    }
    fn2();
  }
  #normalizeSlotEntry(entry) {
    if (typeof entry === "string") {
      const trimmed = entry.trim();
      return trimmed || null;
    }
    if (entry && typeof entry === "object") {
      const name = typeof entry.name === "string" ? entry.name : typeof entry.slot === "string" ? entry.slot : typeof entry.id === "string" ? entry.id : "";
      const trimmed = typeof name === "string" ? name.trim() : "";
      return trimmed || null;
    }
    return null;
  }
  #hasDefaultSlot(actions) {
    const slotsApi = actions?.slots;
    if (!slotsApi || slotsApi.enabled !== true) {
      return false;
    }
    return this.#checkDefaultSlotExists(slotsApi);
  }
  #checkDefaultSlotExists(slotsApi) {
    if (!slotsApi) return false;
    const available = slotsApi.available;
    if (Array.isArray(available)) {
      const normalized2 = available.map((entry) => this.#normalizeSlotEntry(entry)).filter(Boolean);
      return normalized2.includes("default");
    }
    const normalized = this.#normalizeSlotEntry(available);
    if (normalized === "default") {
      return true;
    }
    const defaultConfig = slotsApi.getConfig?.("default");
    return defaultConfig && typeof defaultConfig === "object";
  }
  renderRteControls(context) {
    const actions = context?.actions ?? null;
    const formatting = actions?.textFormatting || null;
    const slotConfig = context?.slotConfig || null;
    const slotInfo = context?.slotInfo || null;
    const callId = ++this.#renderRteInvocation;
    const inlineEditorActive = !!(formatting?.activeRte || this.editorStore?.richText?.activeRte);
    if (this.#logEnabled) {
      this.#log("debug", "renderRteControls entry", {
        callId,
        slotName: context?.slotName ?? formatting?.slotName ?? null,
        inlineEditorActive,
        formattingHasActive: !!formatting?.activeRte,
        storeActive: !!this.editorStore?.richText?.activeRte,
        isSlotSelection: !!formatting?.isSlotSelection,
        hasFormatting: !!formatting
      });
    }
    if (formatting?.isSlotSelection && slotInfo?.hasContent && slotConfig?.multiline === false && (!formatting?.allowedMarks?.length && !formatting?.allowedAlignments?.length && !formatting?.allowedLists?.length && !formatting?.allowLink)) {
      if (this.#logEnabled) {
        this.#log("debug", "renderRteControls skipped (single-line slot gate)", {
          callId
        });
      }
      return E;
    }
    if (!inlineEditorActive) {
      if (this.#logEnabled) {
        this.#log("debug", "renderRteControls skipped (inactive editor)", {
          callId
        });
      }
      return E;
    }
    const { buttonConfigs, activeRte } = this.#getRteButtonConfigs(formatting);
    if (!buttonConfigs.length) {
      if (this.#logEnabled) {
        this.#log("debug", "renderRteControls skipped (no configs)", {
          callId
        });
      }
      return E;
    }
    if (!activeRte) {
      if (this.#logEnabled) {
        this.#log("debug", "renderRteControls skipped (missing activeRte)", {
          callId
        });
      }
      return E;
    }
    const shadowRoot = this.shadowRoot;
    const activeEl = shadowRoot?.activeElement;
    const isRteControlFocused = activeEl && (activeEl.closest('.group[aria-label="RTE"]') || activeEl.closest('.group[aria-label="RTE Node"]'));
    const editorHasFocus = activeRte.isEditorFocused?.() === true || activeRte.hasEditorFocus?.() === true || !!isRteControlFocused;
    if (!editorHasFocus) {
      if (this.#logEnabled) {
        this.#log("debug", "renderRteControls skipped (editor not focused)", {
          callId
        });
      }
      return E;
    }
    if (this.#logEnabled) {
      this.#log("debug", "renderRteControls render", {
        callId,
        buttonCount: buttonConfigs.length
      });
    }
    const invoke = (fn2) => {
      if (!activeRte || !fn2) return;
      fn2(activeRte);
      activeRte.focusEditor?.();
    };
    return x`<span class="group" aria-label="RTE"
      >${c5(
      buttonConfigs,
      (config) => config.key,
      (config) => this.#createActionButton({
        id: `ee-toolbar-rte-${config.key}`,
        dataCommand: config.key,
        title: config.label,
        icon: config.icon(),
        onClick: () => invoke(config.action),
        disabled: config.disabled,
        toggles: config.toggles,
        selected: config.selected
      })
    )}</span
    >`;
  }
  renderRteNodeControls(context) {
    const actions = context?.actions ?? null;
    const formatting = actions?.textFormatting || null;
    const richTextContext = this.editorStore?.richText?.context || null;
    const liveCommands = richTextContext?.commands || formatting?.commands || null;
    const liveSelection = richTextContext?.selection || formatting?.selection || null;
    let node = formatting?.node || null;
    if (!node && liveSelection && liveCommands) {
      const toolbarStore = this.editorStore?.toolbar;
      if (toolbarStore?.buildRteNodeConfig) {
        node = toolbarStore.buildRteNodeConfig({
          selectionDetail: liveSelection,
          commands: liveCommands,
          activeRte: formatting?.activeRte || actions?.activeRte || this.editorStore?.richText?.activeRte || null
        });
      }
    }
    if (!node || !node.attributes) {
      return E;
    }
    const activeRte = formatting?.activeRte || actions?.activeRte || this.editorStore?.richText?.activeRte || null;
    if (activeRte) {
      const shadowRoot = this.shadowRoot;
      const activeEl = shadowRoot?.activeElement;
      const isRteControlFocused = activeEl && (activeEl.closest('.group[aria-label="RTE"]') || activeEl.closest('.group[aria-label="RTE Node"]'));
      const editorHasFocus = activeRte.isEditorFocused?.() === true || activeRte.hasEditorFocus?.() === true || !!isRteControlFocused;
      if (!editorHasFocus) {
        return E;
      }
    }
    const externalizedLink = node?.type === "link" && this.actions?.attributes?.node === node;
    const attributeEntries = Object.entries(node.attributes);
    const inlineEntries = [];
    const popoverEntries = [];
    for (const entry of attributeEntries) {
      if (externalizedLink) {
        break;
      }
      const [, def] = entry;
      if (!def) {
        continue;
      }
      if (inlineEntries.length < 2 && def?.type !== "popover") {
        inlineEntries.push(entry);
        continue;
      }
      popoverEntries.push(entry);
    }
    if (!popoverEntries.length && this.rteNodeShowAllOpen) {
      this.rteNodeShowAllOpen = false;
    }
    const inlineControls = inlineEntries.map(
      ([name, def]) => this.renderAttributeField(name, def, {
        nodeConfig: node,
        wrapperClass: "rte-node-field",
        summaryLabel: this.#getAttributeSummaryLabel(def, name)
      })
    ).filter((field) => field !== E);
    const popoverControls = popoverEntries.length > 0 ? this.#renderRteNodePopover(node, popoverEntries) : E;
    const toolbarActions = Array.isArray(node.toolbarActions) ? node.toolbarActions : [];
    const canRemove = node.removeEnabled && node.remove;
    const removeButton = canRemove ? this.#createActionButton({
      title: "Remove link",
      icon: x`<sp-icon-link-off slot="icon"></sp-icon-link-off>`,
      onClick: () => this.#withFrozenPosition(() => node.remove?.()),
      disabled: false
    }) : E;
    const headerLabel = node.label || "";
    return x`<span class="group rte-node-group" aria-label="RTE Node">
      ${headerLabel ? x`<span
            class="rte-node-group__label"
            data-ee-summary-label=${headerLabel}
          >
            ${headerLabel}
          </span>` : E}
      ${removeButton}
      ${inlineControls.length ? x`<div class="rte-node-group__fields">
            ${inlineControls}
          </div>` : E}
      ${popoverControls}
      ${toolbarActions.length ? x`<sp-action-group quiet selects="none">
            ${toolbarActions}
          </sp-action-group>` : E}
    </span>`;
  }
  #getAttributeSummaryLabel(def, name) {
    const base2 = def?.summaryLabel || def?.label || name || "";
    return typeof base2 === "string" ? base2.trim().replace(/\s+/g, " ") : "";
  }
  #getNodeAttributeValue(nodeConfig, name, def) {
    const values = nodeConfig?.values || {};
    const raw = values[name];
    if (def?.type === "boolean") {
      if (raw === void 0 || raw === null) {
        return def?.default === true;
      }
      return raw === true;
    }
    if (def?.type === "number") {
      if (raw === void 0 || raw === null || raw === "") {
        return def?.default ?? null;
      }
      return Number(raw);
    }
    if (raw === void 0 || raw === null) {
      if (def && Object.prototype.hasOwnProperty.call(def, "default")) {
        return def.default;
      }
      return "";
    }
    return raw;
  }
  #renderRteNodePopover(nodeConfig, entries) {
    if (!Array.isArray(entries) || !entries.length) {
      return E;
    }
    const label = (nodeConfig?.label || "Node").trim() || "Node";
    const typeSlug = (nodeConfig?.type || "node").toString().toLowerCase();
    const triggerId = `rte-node-fields-trigger-${typeSlug}`;
    const popoverId = `rte-node-fields-popover-${typeSlug}`;
    const fields = entries.map(
      ([name, def]) => this.renderAttributeField(name, def, {
        nodeConfig,
        wrapperClass: "rte-node-field",
        summaryLabel: this.#getAttributeSummaryLabel(def, name)
      })
    ).filter((field) => field !== E);
    if (!fields.length) {
      return E;
    }
    const title = entries.length === 1 ? `Show ${label} field` : `Show all ${label} fields`;
    return x`<overlay-trigger
      triggered-by="click hover"
      placement="bottom-start"
      offset="6"
    >
      <sp-action-button
        slot="trigger"
        quiet
        id=${triggerId}
        title=${title}
        @click=${() => {
      this.#withFrozenPosition(() => {
        this.rteNodeShowAllOpen = true;
      });
    }}
      >
        <sp-icon-table slot="icon"></sp-icon-table>
      </sp-action-button>
      <sp-popover
        slot="click-content"
        id=${popoverId}
        data-rte-node-popover="true"
        .open=${this.rteNodeShowAllOpen}
      >
        <div class="popover-content">
          <div class="attributes">
            ${fields}
          </div>
        </div>
      </sp-popover>
    </overlay-trigger>`;
  }
  #getRteButtonConfigs(formatting) {
    if (!formatting?.inlineEditable) {
      if (this.#logEnabled) {
        this.#log("debug", "#getRteButtonConfigs bail: slot not inlineEditable", {
          slotName: formatting?.slotName ?? null
        });
      }
      return { buttonConfigs: [], activeRte: null };
    }
    if (formatting.slotName === "body-xs") {
      console.log("[EEToolbar] formatting snapshot", {
        allowedMarks: formatting.allowedMarks,
        allowedAlignments: formatting.allowedAlignments,
        allowedLists: formatting.allowedLists,
        allowLink: formatting.allowLink,
        inlineEditable: formatting.inlineEditable
      });
    }
    const activeRte = formatting.activeRte || this.editorStore?.richText?.activeRte || null;
    if (!activeRte) {
      if (this.#logEnabled) {
        this.#log("debug", "#getRteButtonConfigs bail: missing activeRte", {
          slotName: formatting?.slotName ?? null,
          formattingHasActive: !!formatting?.activeRte,
          storeActive: !!this.editorStore?.richText?.activeRte
        });
      }
      return { buttonConfigs: [], activeRte: null };
    }
    const commands = this.editorStore?.richText?.context?.commands || formatting.commands || {};
    const selectionDetail = this.editorStore?.richText?.context?.selection || formatting.selection || null;
    const markStates = commands.formats || {};
    const alignmentStates = commands.blocks || {};
    const listStates2 = commands.lists || {};
    const buttonConfigs = [];
    if (this.#logEnabled) {
      this.#log("debug", "#getRteButtonConfigs building buttons", {
        slotName: formatting?.slotName ?? null,
        hasCommands: !!commands,
        hasSelection: !!selectionDetail
      });
    }
    const addButton = ({
      key,
      label,
      icon,
      toggles = true,
      enabled,
      active,
      action
    }) => {
      const disabled = enabled === false;
      buttonConfigs.push({
        key,
        label,
        icon,
        toggles,
        disabled,
        selected: toggles && !disabled && active === true,
        action
      });
    };
    const markConfigs = {
      bold: {
        label: "Bold",
        icon: () => x`<sp-icon-text-bold slot="icon"></sp-icon-text-bold>`,
        action: (rte) => rte.toggleBold?.()
      },
      italic: {
        label: "Italic",
        icon: () => x`<sp-icon-text-italic slot="icon"></sp-icon-text-italic>`,
        action: (rte) => rte.toggleItalic?.()
      },
      underline: {
        label: "Underline",
        icon: () => x`<sp-icon-text-underline slot="icon"></sp-icon-text-underline>`,
        action: (rte) => rte.toggleUnderline?.()
      },
      strikethrough: {
        label: "Strikethrough",
        icon: () => x`<sp-icon-text-strikethrough slot="icon"></sp-icon-text-strikethrough>`,
        action: (rte) => rte.toggleStrikethrough?.()
      }
    };
    formatting.allowedMarks?.forEach((mark) => {
      const config = markConfigs[mark];
      if (!config) return;
      const state = markStates[mark] || {};
      addButton({
        key: mark,
        label: config.label,
        icon: config.icon,
        enabled: state.enabled,
        active: state.active === true,
        action: config.action
      });
    });
    const alignmentConfigs = {
      "align-left": {
        label: "Align left",
        icon: () => x`<sp-icon-text-align-left slot="icon"></sp-icon-text-align-left>`,
        action: (rte) => rte.setAlignment?.("left")
      },
      "align-center": {
        label: "Align center",
        icon: () => x`<sp-icon-text-align-center slot="icon"></sp-icon-text-align-center>`,
        action: (rte) => rte.setAlignment?.("center")
      },
      "align-right": {
        label: "Align right",
        icon: () => x`<sp-icon-text-align-right slot="icon"></sp-icon-text-align-right>`,
        action: (rte) => rte.setAlignment?.("right")
      },
      "align-justify": {
        label: "Justify",
        icon: () => x`<sp-icon-text-align-justify slot="icon"></sp-icon-text-align-justify>`,
        action: (rte) => rte.setAlignment?.("justify")
      }
    };
    formatting.allowedAlignments?.forEach((key) => {
      const config = alignmentConfigs[key];
      if (!config) return;
      const state = alignmentStates[key] || {};
      addButton({
        key,
        label: config.label,
        icon: config.icon,
        enabled: state.enabled,
        active: state.active === true,
        action: config.action
      });
    });
    const listConfigs = {
      "unordered-list": {
        label: "Bulleted list",
        icon: () => x`<sp-icon-list-bulleted slot="icon"></sp-icon-list-bulleted>`,
        action: (rte) => rte.toggleBulletList?.()
      },
      "ordered-list": {
        label: "Numbered list",
        icon: () => x`<sp-icon-list-numbered slot="icon"></sp-icon-list-numbered>`,
        action: (rte) => rte.toggleOrderedList?.()
      }
    };
    formatting.allowedLists?.forEach((key) => {
      const config = listConfigs[key];
      if (!config) return;
      const state = listStates2[key] || {};
      addButton({
        key,
        label: config.label,
        icon: config.icon,
        enabled: state.enabled,
        active: state.active === true,
        action: config.action
      });
    });
    if (formatting.allowLink) {
      const linkState = commands.link || {};
      const linkActive = linkState.active === true;
      const selectionIsEditable = selectionDetail && selectionDetail.empty === false && !selectionDetail.reference;
      const enabled = linkActive || selectionIsEditable;
      addButton({
        key: "link",
        label: linkActive ? "Remove link" : "Add link",
        icon: () => x`<sp-icon-link slot="icon"></sp-icon-link>`,
        enabled,
        active: linkActive,
        action: (rte) => {
          const liveCommands = this.editorStore?.richText?.context?.commands || commands;
          const liveSelection = this.editorStore?.richText?.context?.selection || selectionDetail;
          const isActive = liveCommands?.link?.active === true;
          if (isActive) {
            rte.removeLink?.();
            return;
          }
          const canApply = liveSelection && liveSelection.empty === false && !liveSelection.reference;
          if (!canApply) {
            return;
          }
          rte.applyLink?.({});
        }
      });
    }
    return { buttonConfigs, activeRte };
  }
  applyRteState(formatting) {
    const { buttonConfigs } = this.#getRteButtonConfigs(formatting);
    if (!buttonConfigs.length) {
      return;
    }
    this.#synchronizeRteButtons(buttonConfigs);
  }
  #synchronizeRteButtons(buttonConfigs) {
    if (!Array.isArray(buttonConfigs) || buttonConfigs.length === 0) {
      return;
    }
    const buttonStateByKey = new Map(
      buttonConfigs.map((config) => [config.key, config])
    );
    for (const [key, nodes2] of this.#rteButtonRegistry) {
      const config = buttonStateByKey.get(key);
      if (!config) {
        continue;
      }
      for (const node of Array.from(nodes2)) {
        node.disabled = config.disabled;
        if (config.disabled) {
          node.setAttribute("disabled", "");
        } else {
          node.removeAttribute("disabled");
        }
        if (config.toggles) {
          node.selected = !!config.selected;
          if (config.selected) {
            node.setAttribute("selected", "");
          } else {
            node.removeAttribute("selected");
          }
        }
        if (!node.isConnected) {
          nodes2.delete(node);
        }
      }
      if (nodes2.size === 0) {
        this.#rteButtonRegistry.delete(key);
      }
    }
    queueMicrotask(() => {
      const root = this.shadowRoot;
      if (!root) {
        return;
      }
      const buttons = Array.from(
        root.querySelectorAll(
          '.group[aria-label="RTE"] sp-action-button[data-command]'
        )
      );
      buttons.forEach((button) => {
        const key = button.dataset.command;
        if (!key) return;
        if (!this.#rteButtonRegistry.has(key)) {
          this.#rteButtonRegistry.set(key, /* @__PURE__ */ new Set());
        }
        const nodes2 = this.#rteButtonRegistry.get(key);
        nodes2.add(button);
        const config = buttonStateByKey.get(key);
        if (config) {
          button.disabled = config.disabled;
          if (config.disabled) {
            button.setAttribute("disabled", "");
          } else {
            button.removeAttribute("disabled");
          }
          if (config.toggles) {
            button.selected = !!config.selected;
            if (config.selected) {
              button.setAttribute("selected", "");
            } else {
              button.removeAttribute("selected");
            }
          }
        }
      });
      for (const [key, nodes2] of this.#rteButtonRegistry) {
        if (nodes2.size === 0) {
          this.#rteButtonRegistry.delete(key);
        }
      }
    });
  }
  constructor() {
    super();
    this.editorStore = null;
    this.commentStore = null;
    this.visible = false;
    this.static = false;
    this.showAllOpen = false;
    this.rteNodeShowAllOpen = false;
    this.clipboardHasTextOrHtml = false;
    this.handleOverlayOpen = this.handleOverlayOpen.bind(this);
    this.handleOverlayClose = this.handleOverlayClose.bind(this);
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("sp-opened", this.handleOverlayOpen);
    this.addEventListener("sp-closed", this.handleOverlayClose);
    this.addEventListener("focusin", this.#focusInHandler);
    this.addEventListener("focusout", this.#focusOutHandler);
    this.addEventListener("pointerdown", this.#pointerDownHandler, true);
    if (this.#dragHandlers?.cleanup) {
      this.#dragHandlers.cleanup();
    }
    const toolbarStore = this.editorStore?.toolbar;
    if (toolbarStore) {
      this.#dragHandlers = toolbarStore.createDragHandlers(this);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("sp-opened", this.handleOverlayOpen);
    this.removeEventListener("sp-closed", this.handleOverlayClose);
    this.removeEventListener("focusin", this.#focusInHandler);
    this.removeEventListener("focusout", this.#focusOutHandler);
    this.removeEventListener("pointerdown", this.#pointerDownHandler, true);
    if (this.#dragHandlers?.cleanup) {
      this.#dragHandlers.cleanup();
      this.#dragHandlers = null;
    }
  }
  #log(level, message, data = {}) {
    if (!this.#logEnabled) return;
    const logger = console[level] || console.log;
    logger.call(console, `[EEToolbar] ${message}`, data);
  }
  #openPopoverProgrammatically() {
    this.#shouldReopenPopover = false;
    const trigger = this.shadowRoot?.querySelector(
      'overlay-trigger > [slot="trigger"]'
    );
    if (trigger) {
      this.showAllOpen = true;
      trigger.click();
      this.#log("debug", "programmatic trigger click for reopen");
      return;
    }
    const popover = this.shadowRoot?.querySelector(
      'sp-popover[slot="click-content"]'
    );
    if (popover) {
      this.showAllOpen = true;
      popover.open = true;
      this.#log("debug", "fallback popover.open=true for reopen");
    }
  }
  // Button factory for consistent action buttons
  #createActionButton({
    title,
    icon,
    onClick,
    disabled = false,
    id = void 0,
    className = void 0,
    toggles = false,
    selected = false,
    dataCommand = void 0,
    onPointerDown = void 0
  }) {
    return x`<sp-action-button
      quiet
      id=${o9(id)}
      class=${o9(className)}
      data-command=${o9(dataCommand)}
      title="${title}"
      .disabled=${disabled}
      ?disabled=${disabled}
      .toggles=${toggles}
      ?toggles=${toggles}
      .selected=${toggles && selected}
      ?selected=${toggles && selected}
      @click=${() => {
      if (!onClick) {
        return;
      }
      const toolbarStore = this.editorStore?.toolbar;
      if (toolbarStore) {
        toolbarStore.freezePositionDuring(onClick);
        return;
      }
      onClick();
    }}
      @pointerdown=${onPointerDown}
    >
      ${icon}
    </sp-action-button>`;
  }
  // Reordering button getters
  get moveUpButton() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { actions, element } = state;
    const canUp = !!actions?.reordering?.canMoveUp;
    return this.#createActionButton({
      title: "Move up",
      icon: x`<sp-icon-chevron-up slot="icon"></sp-icon-chevron-up>`,
      onClick: () => this.editorStore?.toolbar?.moveElementBefore(element),
      disabled: !canUp
    });
  }
  get moveDownButton() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { actions, element } = state;
    const canDown = !!actions?.reordering?.canMoveDown;
    return this.#createActionButton({
      title: "Move down",
      icon: x`<sp-icon-chevron-down slot="icon"></sp-icon-chevron-down>`,
      onClick: () => this.editorStore?.toolbar?.moveElementAfter(element),
      disabled: !canDown
    });
  }
  get duplicateButton() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { element: el, slotSelected, duplicationAllowed } = state;
    if (!el) return E;
    if (!duplicationAllowed || slotSelected) {
      return E;
    }
    const lockable = this.hasAuthoringSchema(el);
    if (lockable && this.isAuthoringLocked(el)) {
      return E;
    }
    return this.#createActionButton({
      title: "Duplicate",
      icon: x`<sp-icon-duplicate slot="icon"></sp-icon-duplicate>`,
      onClick: () => this.editorStore?.toolbar?.duplicateElement(el)
    });
  }
  get deleteButton() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { element: el } = state;
    return this.#createActionButton({
      title: "Delete",
      icon: x`<sp-icon-delete slot="icon"></sp-icon-delete>`,
      onClick: () => this.editorStore?.toolbar?.deleteElement(el)
    });
  }
  get copyButton() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { element: el } = state;
    return this.#createActionButton({
      title: "Copy",
      icon: x`<sp-icon-copy slot="icon"></sp-icon-copy>`,
      onClick: async () => {
        const editorElement = this.editorStore?.editorElement;
        if (!editorElement || !el) return;
        const clone = el.cloneNode(true);
        const html = clone.outerHTML;
        if (navigator.clipboard?.write) {
          const clipboardItem = new ClipboardItem({
            "text/html": new Blob([html], { type: "text/html" }),
            "text/plain": new Blob([html], { type: "text/plain" })
          });
          await navigator.clipboard.write([clipboardItem]);
          editorElement.showToast("Element copied to clipboard");
        } else if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(html);
          editorElement.showToast("Element copied to clipboard");
        }
      }
    });
  }
  get aiButton() {
    if (!this.agentStore) return E;
    const state = this.#toolbarState;
    if (!state) return E;
    return this.#createActionButton({
      title: "AI Assistant",
      icon: x`<sp-icon-magic-wand slot="icon"></sp-icon-magic-wand>`,
      onClick: () => {
        this.agentStore?.togglePanel?.();
      },
      id: "ai-assistant-button"
    });
  }
  get selectParentButton() {
    const can = !!this.editorStore?.canSelectParent;
    if (!can) return E;
    return this.#createActionButton({
      title: "Select parent",
      icon: x`<span slot="icon" id="select-parent-button-icon">
        <sp-icon-chevron-double-left></sp-icon-chevron-double-left>
      </span>`,
      onClick: () => this.editorStore.selection.selectParent(),
      id: "select-parent-button"
    });
  }
  #resetElementGroups() {
  }
  #resetSlotGroups() {
  }
  get lockButton() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { element } = state;
    if (!element || !this.hasAuthoringSchema(element)) return E;
    const locked = this.isAuthoringLocked(element);
    const title = locked ? "Unlock element" : "Lock element";
    const icon = locked ? x`<sp-icon-lock-open slot="icon"></sp-icon-lock-open>` : x`<sp-icon-lock-closed slot="icon"></sp-icon-lock-closed>`;
    return this.#createActionButton({
      title,
      icon,
      onClick: () => this.toggleAuthoringLock(element)
    });
  }
  // Helper method for getting element labels
  #labelForTag(tag3) {
    if (typeof tag3 !== "string") return tag3;
    const normalizedTag = tag3.trim();
    if (!normalizedTag) return tag3;
    const ctor = customElements.get(normalizedTag);
    const eeApi = ctor?.ee || null;
    let label = eeApi?.getElementLabel?.() || "";
    if (typeof label === "string") {
      label = label.trim();
    }
    if (!label && typeof eeApi?.getSchema === "function") {
      const contextElement = this.editorStore?.editingElement ?? null;
      const schema2 = getElementSchema(eeApi, contextElement);
      const schemaLabel = typeof schema2?.element?.label === "string" ? schema2.element.label.trim() : "";
      if (schemaLabel) {
        label = schemaLabel;
      }
    }
    if (!label) {
      return normalizedTag;
    }
    return label;
  }
  #renderSlotAddButtons({ allowedTags, remaining, slotName, slotLabel }) {
    if (!Array.isArray(allowedTags) || !allowedTags.length) {
      return E;
    }
    const tags = allowedTags.map((tag3) => typeof tag3 === "string" ? tag3.trim() : "").filter((tag3) => !!tag3 && !INLINE_TEXT_TAGS.has(tag3.toLowerCase()));
    if (!tags.length) {
      return E;
    }
    const disabled = !(remaining > 0);
    if (tags.length === 1) {
      const tag3 = tags[0];
      const label = this.#labelForTag(tag3);
      return this.#createActionButton({
        id: `add-slot-${slotName || "default"}-${tag3}`,
        title: label,
        icon: x`<sp-icon-add slot="icon"></sp-icon-add> ${label}`,
        onClick: () => this.addElementToSlot(tag3, slotName),
        disabled
      });
    }
    const menuLabelBase = typeof slotLabel === "string" && slotLabel.trim() ? slotLabel.trim() : slotName || "default";
    const menuId = `add-slot-${slotName || "default"}-menu`;
    return x`
      <sp-action-menu
        id=${menuId}
        quiet
        selects="single"
        placement="bottom-start"
        label=${`Add element to ${menuLabelBase}`}
        ?disabled=${disabled}
        @change=${(event) => {
      const rawValue = event?.detail?.value || event?.target?.value && event.target.value || "";
      const value = typeof rawValue === "string" ? rawValue.trim() : "";
      if (!value) {
        return;
      }
      this.#withFrozenPosition(() => {
        this.addElementToSlot(value, slotName);
      });
      if (event?.target) {
        event.target.value = "";
      }
    }}
      >
        <sp-icon-add slot="icon"></sp-icon-add>
        <span slot="label">Add to ${menuLabelBase}</span>
        ${tags.map(
      (tag3) => x`<sp-menu-item value=${tag3}
              >${this.#labelForTag(tag3)}</sp-menu-item
            >`
    )}
      </sp-action-menu>
    `;
  }
  // Only attributes are included in the compact "Fields" group
  #primaryFields(options) {
    const includeAttrs = options?.includeAttrs;
    const renders = [];
    const state = this.#toolbarState;
    if (!state) return E;
    const { actions } = state;
    if (includeAttrs) {
      const schema2 = actions?.attributes?.schema || {};
      const nodeConfig = actions?.attributes?.node || null;
      for (const [name, def] of Object.entries(schema2)) {
        if (def?.type === "popover") continue;
        renders.push(
          this.renderAttributeField(name, def, {
            nodeConfig
          })
        );
        this.#inlineAttrNames.push(name);
        if (renders.length >= 2) break;
      }
    }
    if (!renders.length) return E;
    return x`${renders}`;
  }
  // Render popover-type attributes (e.g., icon, color, size) in their own group
  #popoverAttributes() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { actions } = state;
    const schema2 = actions?.attributes?.schema || {};
    const nodeConfig = actions?.attributes?.node || null;
    const entries = Object.entries(schema2).filter(
      ([, def]) => def?.type === "popover"
    );
    if (!entries.length) return E;
    const controls = entries.map(
      ([name, def]) => this.renderAttributeField(name, def, { nodeConfig })
    );
    return x`${controls}`;
  }
  get toolbarVisible() {
    if (this.static) {
      return !!this.visible;
    }
    return !!this.editorStore?.toolbar?.isEEToolbarVisible;
  }
  get positionStyle() {
    if (!this.editorStore?.toolbar) return "";
    const pos = this.editorStore.toolbar.eeToolbarPosition || { x: 0, y: 0 };
    const x5 = Math.round(pos.x);
    const y5 = Math.round(pos.y);
    return `transform: translate(${x5}px, ${y5}px);`;
  }
  get toolbarStructure() {
    const root = this.shadowRoot?.getElementById("ee-toolbar");
    if (!root) return "";
    const lines = this.#collectToolbarSummaryLines(root);
    return lines.join("\n").trim();
  }
  #collectToolbarSummaryLines(container) {
    const lines = [];
    const children = Array.from(container.children || []);
    for (const child of children) {
      if (!child || child.nodeType !== Node.ELEMENT_NODE) continue;
      if (child.classList?.contains("group")) {
        const label = child.getAttribute("aria-label") || "Group";
        const items = this.#collectGroupSummary(child);
        const formatted = items.length ? items.join(", ") : "(empty)";
        lines.push(`[${label}] ${formatted}`);
        continue;
      }
      const tag3 = child.tagName?.toUpperCase?.() || "";
      if (tag3 === "SP-DIVIDER") {
        lines.push("--- divider ---");
        continue;
      }
      if (SUMMARY_INTERACTIVE_TAG_SET.has(tag3)) {
        lines.push(`Button: ${this.#describeSummaryControl(child)}`);
      }
    }
    return lines;
  }
  #collectGroupSummary(group) {
    const labels = [];
    const seen = /* @__PURE__ */ new Set();
    const nodes2 = Array.from(group.querySelectorAll("*"));
    for (const node of nodes2) {
      if (!node || node.nodeType !== Node.ELEMENT_NODE) continue;
      if (node.closest("sp-popover")) continue;
      const ownerGroup = node.closest(".group");
      if (ownerGroup !== group) continue;
      if (node.classList?.contains("rte-node-field")) {
        const label = node.getAttribute(SUMMARY_LABEL_ATTR);
        const trimmed = typeof label === "string" ? label.trim() : "";
        if (trimmed && !seen.has(trimmed)) {
          labels.push(trimmed);
          seen.add(trimmed);
        }
        continue;
      }
      if (node.closest(".rte-node-field")) {
        continue;
      }
      const tag3 = node.tagName?.toUpperCase?.() || "";
      if (SUMMARY_INTERACTIVE_TAG_SET.has(tag3)) {
        const controlLabel = this.#describeSummaryControl(node);
        if (controlLabel && !seen.has(controlLabel)) {
          labels.push(controlLabel);
          seen.add(controlLabel);
        }
      }
      const attr = node.getAttribute?.(SUMMARY_LABEL_ATTR);
      if (attr) {
        const trimmed = attr.trim();
        if (trimmed && !seen.has(trimmed)) {
          labels.push(trimmed);
          seen.add(trimmed);
        }
      }
    }
    return labels;
  }
  #describeSummaryControl(element) {
    if (!element) return "";
    const getAttr = (name) => {
      const value = element.getAttribute?.(name);
      return typeof value === "string" ? value.trim() : "";
    };
    const title = getAttr("title");
    const aria = getAttr("aria-label");
    const labelAttr = getAttr("label");
    const nameAttr = getAttr("name");
    const text = (element.textContent || "").trim().replace(/\s+/g, " ");
    const baseLabel = title || aria || labelAttr || (typeof element.label === "string" ? element.label.trim() : "") || nameAttr || text || element.tagName?.toLowerCase?.() || "control";
    const disabled = element.hasAttribute?.("disabled") || element.getAttribute?.("aria-disabled") === "true" || element.disabled === true;
    return disabled ? `${baseLabel} [disabled]` : baseLabel;
  }
  async updated(changed) {
    if (super.updated) {
      super.updated(changed);
    }
    if (this.editorStore) {
      const currentEditing = this.editorStore.editingElement;
      if (currentEditing !== this.#lastEditingElement) {
        const currentTag = currentEditing?.tagName?.toLowerCase?.() || null;
        const prevTag = this.#lastEditingTagName;
        const wasOpen = this.showAllOpen;
        this.#lastEditingElement = currentEditing;
        this.#lastEditingTagName = currentTag;
        if (currentTag !== prevTag) {
          const willReopen = !!wasOpen;
          this.showAllOpen = false;
          this.#shouldReopenPopover = willReopen;
          this.#log(
            "debug",
            willReopen ? "element type changed; scheduling reopen" : "element type changed, closing popover",
            { prevTag, currentTag }
          );
        } else if (wasOpen) {
          this.#shouldReopenPopover = true;
          this.#log("debug", "same type selection; scheduling reopen", {
            tag: currentTag
          });
        }
      }
    }
    const actionsForTools = this.actions;
    const toolsForInit = actionsForTools?.tools;
    if (toolsForInit?.enabled && Array.isArray(toolsForInit?.available)) {
      for (const tool of toolsForInit.available) {
        const toolId = tool.id || tool.tag || "tool";
        const toolElementId = `tool-element-${toolId}`;
        const toolEl = this.shadowRoot?.getElementById(toolElementId);
        if (toolEl && toolEl.setAccessToken && !toolEl.hasAttribute("data-token-set")) {
          const documentStore = this.editorStore?.documentStore;
          if (documentStore) {
            const token = await documentStore.getAccessToken();
            if (token) {
              toolEl.setAccessToken(token);
              toolEl.setAttribute("data-token-set", "");
            }
          }
        }
      }
    }
    await this.updateComplete;
    if (this.toolbarVisible) {
      this.editorStore?.toolbar?.updateToolbarPosition();
      this.editorStore?.toolbar?.checkAndAdjustOverflow();
    }
    if (this.toolbarVisible && this.clipboardHasTextOrHtml === void 0 && !this.#checkingClipboard) {
      this.checkClipboardForPaste();
    }
  }
  get updateComplete() {
    return super.updateComplete;
  }
  get actions() {
    const store = this.editorStore || null;
    if (!store) return null;
    const toolbar = store.toolbar || null;
    return toolbar?.toolbarActions ?? store.toolbarActions ?? null;
  }
  get toolbarContext() {
    return this.editorStore?.context ?? null;
  }
  // Unified state getter that combines context + actions with common properties extracted
  get #toolbarState() {
    const context = this.toolbarContext;
    if (!context) return null;
    const actions = context.actions;
    if (!actions) return null;
    return {
      context,
      actions,
      // Extract commonly used properties once
      slotSelected: context.slotSelected,
      isLocked: context.isLocked,
      element: context.element,
      slotName: context.slotName,
      parentElement: context.parentElement,
      slotConfig: context.slotConfig,
      slotInfo: context.slotInfo,
      duplicationAllowed: context.duplicationAllowed,
      deletionAllowed: context.deletionAllowed,
      // Derived values
      hasAttributes: !!actions.attributes?.enabled,
      isSlotContent: !!actions.isSlotContent,
      attrEntries: Object.entries(actions.attributes?.schema || {})
    };
  }
  render() {
    if (!this.editorStore) {
      return E;
    }
    const context = this.toolbarContext;
    if (!context) {
      return E;
    }
    const view = x`
      <div
        id="ee-toolbar"
        style="${this.positionStyle}"
        @mousedown=${this.#dragHandlers?.onDragStart}
      >
        ${this.compactControls}
      </div>
    `;
    return view;
  }
  /**
   * Debug snapshot of toolbar UI state
  */
  get debugState() {
    if (!TOOLBAR_DEBUG) return null;
    const describeElement = (el) => {
      if (!el || !el.tagName) return null;
      const tag3 = el.tagName.toLowerCase();
      const ctor = customElements.get(tag3);
      return {
        tag: tag3,
        id: el.id || null,
        slot: el.getAttribute ? el.getAttribute("slot") : null,
        isCustom: tag3.includes("-"),
        hasEE: !!ctor?.ee,
        text: (el.textContent || "").trim().slice(0, 60)
      };
    };
    const toolbarStore = this.editorStore?.toolbar || null;
    const actions = toolbarStore?.toolbarActions || null;
    const pos = toolbarStore?.eeToolbarPosition || { x: 0, y: 0 };
    const root = this.shadowRoot;
    const buttonLabels = root ? Array.from(
      root.querySelectorAll(
        "sp-button, sp-action-button, sp-close-button, sp-icon-button, button"
      )
    ).map((btn) => {
      const textContent = (btn.textContent || "").trim().replace(/\s+/g, " ");
      const aria = btn.getAttribute?.("aria-label") || "";
      const title = btn.getAttribute?.("title") || "";
      const id = btn.id || "";
      let base2 = textContent;
      if (!base2) {
        base2 = aria || (id ? `#${id}` : btn.tagName.toLowerCase());
      }
      if (title) {
        return `${base2} [title="${title}"]`;
      }
      return base2;
    }) : [];
    const reorderingSnapshot = actions?.reordering ? {
      enabled: !!actions.reordering.enabled,
      canMoveUp: !!actions.reordering.canMoveUp,
      canMoveDown: !!actions.reordering.canMoveDown,
      canMoveFirst: !!actions.reordering.canMoveFirst,
      canMoveLast: !!actions.reordering.canMoveLast
    } : null;
    return {
      toolbarVisible: this.toolbarVisible,
      static: !!this.static,
      position: { x: Math.round(pos.x || 0), y: Math.round(pos.y || 0) },
      showAllOpen: !!this.showAllOpen,
      shouldReopenPopover: !!this.#shouldReopenPopover,
      lastEditingTagName: this.#lastEditingTagName || null,
      storeCanReorder: !!toolbarStore?.canReorder,
      actions: actions ? {
        element: describeElement(actions.element),
        isSlotContent: !!actions.isSlotContent,
        slotName: actions.slotName || null,
        attributes: {
          enabled: !!actions.attributes?.enabled,
          count: Object.keys(actions.attributes?.schema || {}).length
        },
        slots: {
          enabled: !!actions.slots?.enabled,
          current: actions.slots?.current || null,
          available: Array.isArray(actions.slots?.available) ? [...actions.slots.available] : null
        },
        reordering: reorderingSnapshot,
        duplicationAllowed: actions.duplicationAllowed !== false
      } : null,
      buttons: buttonLabels
    };
  }
  #appendAiButton(pieces) {
    const aiBtn = this.aiButton;
    if (aiBtn !== E) {
      pieces.push(
        x`<span class="group" aria-label="AI Assistant">${aiBtn}</span>`
      );
    }
    return pieces;
  }
  get compactControls() {
    const state = this.#toolbarState;
    if (!state) return E;
    this.#resetElementGroups();
    this.#resetSlotGroups();
    const { context, actions, slotSelected, isLocked, element, hasAttributes, isSlotContent, attrEntries } = state;
    const attributesEnabled = actions.attributes?.enabled === true;
    const slotContextActive = slotSelected;
    const rteControls = this.renderRteControls(context);
    const rteNodeControls = this.renderRteNodeControls(context);
    const editingActive = false;
    const selectParentBtn = this.renderSelectParentButton();
    if (!slotContextActive && isSlotContent && !hasAttributes && !editingActive) {
      if (isLocked) {
        return selectParentBtn !== E ? selectParentBtn : E;
      }
      const pieces = [];
      if (selectParentBtn !== E) pieces.push(selectParentBtn);
      if (rteControls !== E) pieces.push(rteControls);
      if (rteNodeControls !== E) pieces.push(rteNodeControls);
      if (!editingActive) {
        pieces.push(
          x`<span class="group" aria-label="Element Controls"></span>`
        );
        const lockBtn = this.renderLockButton(actions);
        const duplicateBtn = this.renderDuplicateButton();
        const deleteBtn = this.renderDeleteButton();
        const buttons = [
          lockBtn !== E ? lockBtn : E,
          duplicateBtn !== E ? duplicateBtn : E,
          deleteBtn !== E ? deleteBtn : E
        ].filter((x5) => x5 !== E);
        if (buttons.length) {
          pieces.push(
            x`<span class="group" aria-label="Element Actions"
              >${buttons}</span
            >`
          );
        }
      }
      return x`${this.#appendAiButton(pieces)}`;
    }
    if (slotContextActive && !hasAttributes) {
      if (isLocked) {
        return selectParentBtn !== E ? selectParentBtn : E;
      }
      const pieces = [];
      if (selectParentBtn !== E) pieces.push(selectParentBtn);
      if (rteControls !== E) pieces.push(rteControls);
      if (rteNodeControls !== E) pieces.push(rteNodeControls);
      const slotControlsOnly = this.renderSlotControls({
        selectParentOverride: selectParentBtn !== E ? E : void 0,
        includeSlotContentActions: true
      });
      if (slotControlsOnly !== E) pieces.push(slotControlsOnly);
      return x`${this.#appendAiButton(pieces)}`;
    }
    const elementToCheck = element;
    const showStructuralControlsBase = !slotSelected && (!isSlotContent || this.#isCustomElement(elementToCheck));
    if (isLocked) {
      const lockBtn = this.renderLockButton(actions);
      const duplicateBtn = this.renderDuplicateButton();
      const deleteBtn = this.renderDeleteButton();
      const buttons = [
        lockBtn !== E ? lockBtn : E,
        duplicateBtn !== E ? duplicateBtn : E,
        deleteBtn !== E ? deleteBtn : E
      ].filter((x5) => x5 !== E);
      return x`${selectParentBtn}
        <span class="group" aria-label="Element Actions"
          >${buttons}</span
        >`;
    }
    const fieldCount = attrEntries.filter(
      ([, def]) => def?.type !== "popover"
    ).length;
    this.#inlineAttrNames = [];
    const fieldsTemplate = this.#primaryFields({
      includeAttrs: attributesEnabled
    });
    const editingElementActive = false;
    const fieldsParts = [];
    if (fieldsTemplate !== E) fieldsParts.push(fieldsTemplate);
    const fieldsFormButton = fieldCount > 2 ? this.renderFieldsPopover(actions) : E;
    const popoverControls = attributesEnabled ? this.#popoverAttributes() : E;
    const elementControlsParts = [];
    if (!editingElementActive && !slotContextActive && fieldsParts.length) {
      elementControlsParts.push(
        x`<div class="attributes" aria-label="Fields">${fieldsParts}</div>`
      );
    }
    if (!editingElementActive && !slotContextActive && popoverControls !== E) {
      elementControlsParts.push(
        x`<div class="attributes" aria-label="Popover Controls">
          ${popoverControls}
        </div>`
      );
    }
    if (!editingElementActive && !slotContextActive && fieldsFormButton !== E) {
      elementControlsParts.push(fieldsFormButton);
    }
    const chunks = [];
    if (selectParentBtn !== E) {
      chunks.push(selectParentBtn);
    }
    if (rteControls !== E) {
      chunks.push(rteControls);
    }
    if (rteNodeControls !== E) {
      chunks.push(rteNodeControls);
    }
    const clipboardGroup = this.renderClipboardGroup();
    if (clipboardGroup !== E) {
      chunks.push(clipboardGroup);
    }
    const toolsGroup = this.renderToolsGroup();
    if (toolsGroup !== E) {
      chunks.push(toolsGroup);
    }
    const hasDefaultSlot = slotContextActive ? false : this.#hasDefaultSlot(actions);
    const defaultSlotConfig = hasDefaultSlot && !slotContextActive && state?.element ? this.editorStore?.selection?.getNormalizedSlotConfig?.(state.element, "default") : null;
    const isDefaultSlotInlineEditable = defaultSlotConfig?.inlineEditable === true;
    const shouldUseSlotControls = slotContextActive || hasDefaultSlot && !isDefaultSlotInlineEditable;
    const slotControlsView = shouldUseSlotControls ? this.renderSlotControls({
      selectParentOverride: selectParentBtn !== E ? E : void 0,
      elementControlsParts: slotContextActive ? elementControlsParts : [],
      showElementControls: slotContextActive && elementControlsParts.length > 0,
      forcedSlotName: slotContextActive ? void 0 : hasDefaultSlot ? "default" : null,
      includeSlotContentActions: isSlotContent
    }) : E;
    const hasSlotControls = slotControlsView !== E;
    const showStructuralControls = showStructuralControlsBase && !(isSlotContent && hasSlotControls);
    if (hasSlotControls) {
      chunks.push(slotControlsView);
      if (slotContextActive) {
        return x`${this.#appendAiButton(chunks)}`;
      }
    }
    if (!editingElementActive && elementControlsParts.length && rteControls === E) {
      chunks.push(
        x`<span class="group" aria-label="Element Controls">
          ${elementControlsParts}
        </span>`
      );
    }
    if (showStructuralControls && !editingElementActive) {
      const actionPieces = [];
      if (actions.reordering?.enabled) {
        const reorder = this.renderReorderGroup();
        if (reorder !== E) actionPieces.push(reorder);
      }
      const duplicateBtn = this.renderDuplicateButton();
      if (duplicateBtn !== E) actionPieces.push(duplicateBtn);
      const copyBtn = this.renderCopyButton();
      if (copyBtn !== E) actionPieces.push(copyBtn);
      const deleteBtn = this.renderDeleteButton();
      if (deleteBtn !== E) actionPieces.push(deleteBtn);
      const custom = this.#customActions();
      if (custom !== E) actionPieces.push(custom);
      if (!slotContextActive && actionPieces.length) {
        chunks.push(
          x`<span class="group" aria-label="Element Actions">
            ${actionPieces}
          </span>`
        );
      }
    }
    return x`${this.#appendAiButton(chunks)}`;
  }
  #isCustomElement(element) {
    const tag3 = element?.tagName?.toLowerCase?.() || "";
    return tag3.includes("-");
  }
  isAuthoringLocked(element) {
    return this.editorStore?.isAuthoringLocked(element) ?? false;
  }
  hasAuthoringSchema(element) {
    return this.editorStore?.hasAuthoringSchema(element) ?? false;
  }
  renderLockButton(actions) {
    return this.lockButton;
  }
  toggleAuthoringLock(element) {
    if (!element) return;
    const willLock = !this.isAuthoringLocked(element);
    if (willLock) {
      element.setAttribute("data-ee-locked", "");
    } else {
      element.removeAttribute("data-ee-locked");
    }
    this.editorStore?.history.scheduleSnapshot();
    this.editorStore?.history.scheduleAutoSave();
  }
  #customActions() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { actions } = state;
    const items = Array.isArray(actions.customActions) ? actions.customActions : [];
    if (!items.length) return E;
    return x`${items}`;
  }
  // Slot editing UI removed from toolbar
  // Popover that shows all fields (attributes + slot selectors)
  renderFieldsPopover(actions) {
    return x`
      <overlay-trigger
        triggered-by="click hover"
        placement="bottom-start"
        offset="6"
      >
        <sp-action-button
          slot="trigger"
          quiet
          title=${SHOW_ALL_FIELDS_TITLE}
          @click=${() => {
      this.#withFrozenPosition(() => {
        this.#log("debug", "popover trigger clicked");
        this.showAllOpen = true;
      });
    }}
        >
          <sp-icon-table slot="icon"></sp-icon-table>
        </sp-action-button>
        <sp-popover slot="click-content" .open=${this.showAllOpen} id=${SHOW_ALL_FIELDS_POPOVER_ID}>
          <div class="popover-content">
            ${this.renderRemainingFormPanel(actions)}
          </div>
        </sp-popover>
      </overlay-trigger>
    `;
  }
  // renderActionsPopover removed
  #buildSlotContext({ requestedSlotName = null, fallbackToDefault = false } = {}) {
    const state = this.#toolbarState;
    if (!state) {
      return null;
    }
    const { context, actions } = state;
    const slotsApi = actions.slots || null;
    const slotOnlySelection = this.editorStore?.slotOnlySelection || false;
    const explicitSlot = this.editorStore?.currentSlot || null;
    let selectedSlot = requestedSlotName ?? explicitSlot;
    if (!selectedSlot && slotOnlySelection) {
      selectedSlot = context.slotName || slotsApi?.current || null;
    }
    if (!selectedSlot && fallbackToDefault) {
      const hasDefault = this.#checkDefaultSlotExists(slotsApi);
      selectedSlot = slotsApi?.current || context.slotName || (hasDefault ? "default" : null);
    }
    if (!selectedSlot) {
      return null;
    }
    const normalizedSlot = typeof selectedSlot === "string" && selectedSlot.trim() ? selectedSlot.trim() : "default";
    const parentElement = context.parentElement || (actions.isSlotContent ? actions.element : this.editorStore?.editingElement);
    const slotConfig = context.slotName === normalizedSlot && context.slotConfig || slotsApi?.getConfig?.(normalizedSlot) || (parentElement ? this.editorStore?.getNormalizedSlotConfig?.(parentElement, normalizedSlot) : null) || {};
    const slotInfo = context.slotName === normalizedSlot && context.slotInfo || slotsApi?.slotInfo?.[normalizedSlot] || {};
    const labelFromGetter = slotsApi?.getLabel?.(normalizedSlot) ?? null;
    const slotLabel = typeof labelFromGetter === "string" && labelFromGetter.trim() || typeof slotInfo.label === "string" && slotInfo.label.trim() || typeof slotConfig.label === "string" && slotConfig.label.trim() || normalizedSlot;
    const supportsTextEditing = !!parentElement && this.editorStore?.slotSupportsTextEditing?.(parentElement, normalizedSlot) === true;
    const maxItems = slotConfig.maxLength === void 0 || slotConfig.maxLength === null ? Infinity : slotConfig.maxLength;
    const remaining = Math.max(0, maxItems - (slotInfo.count ?? 0));
    const inlineEditable = slotConfig.inlineEditable === true || supportsTextEditing === true;
    return {
      slotName: normalizedSlot,
      parentElement,
      slotConfig,
      slotInfo,
      slotLabel,
      supportsTextEditing: supportsTextEditing === true,
      inlineEditable,
      remaining,
      slotsApi
    };
  }
  // Slot controls: add allowed elements, type text (inline), clear content if any
  renderSlotControls(options = {}) {
    const {
      selectParentOverride = void 0,
      elementControlsParts = [],
      showElementControls = false,
      includeSlotContentActions = true,
      forcedSlotName = null
    } = options;
    const state = this.#toolbarState;
    if (!state) return E;
    this.#resetSlotGroups();
    const { actions, duplicationAllowed, slotSelected, element } = state;
    const slotDuplicationAllowed = duplicationAllowed ?? actions.duplicationAllowed ?? true;
    const slotState = this.#buildSlotContext({
      requestedSlotName: forcedSlotName ?? null
    });
    if (!slotState) return E;
    const { slotName: resolvedSlot, slotConfig, slotLabel, remaining } = slotState;
    const addButtons = this.#renderSlotAddButtons({
      allowedTags: slotConfig.allowedTags,
      remaining,
      slotName: resolvedSlot,
      slotLabel
    });
    const pasteButton = this.#renderPasteButton(slotState);
    const slotActionParts = [];
    if (addButtons !== E) {
      slotActionParts.push(addButtons);
    }
    if (pasteButton !== E) {
      slotActionParts.push(pasteButton);
    }
    if (slotSelected) {
      const deleteBtn = this.renderDeleteButton();
      if (deleteBtn !== E) {
        slotActionParts.push(deleteBtn);
      }
    }
    if (actions.isSlotContent && includeSlotContentActions) {
      const editingEl = this.editorStore?.editingElement;
      const elementToCheck = editingEl || element || actions.element;
      if (this.#isCustomElement(elementToCheck)) {
        const lockBtn = this.lockButton;
        if (lockBtn !== E) slotActionParts.push(lockBtn);
      }
      if (actions.reordering?.enabled) {
        const reorder = this.renderReorderGroup();
        if (reorder !== E) slotActionParts.push(reorder);
      }
      const allowDuplicate = slotDuplicationAllowed !== false;
      if (allowDuplicate) {
        const duplicateBtn = this.duplicateButton;
        if (duplicateBtn !== E) slotActionParts.push(duplicateBtn);
      }
      if (!slotSelected) {
        const copyBtn = this.renderCopyButton();
        if (copyBtn !== E) {
          slotActionParts.push(copyBtn);
        }
      }
      if (!slotSelected) {
        const deleteBtn = this.renderDeleteButton();
        if (deleteBtn !== E) {
          slotActionParts.push(deleteBtn);
        }
      }
    }
    if (!slotActionParts.length && !showElementControls) {
      return E;
    }
    const selectParentButton = selectParentOverride === void 0 ? this.renderSelectParentButton() : selectParentOverride;
    const blocks = [];
    if (selectParentButton !== E) {
      blocks.push(selectParentButton);
    }
    if (showElementControls && elementControlsParts.length) {
      blocks.push(
        x`<span class="group" aria-label="Element Controls">
          ${elementControlsParts}
        </span>`
      );
    }
    if (slotActionParts.length) {
      blocks.push(
        x`<span class="group" aria-label="Slot Actions">
          ${slotActionParts}
        </span>`
      );
    }
    return blocks.length ? x`${blocks}` : E;
  }
  renderClipboardGroup() {
    return E;
  }
  renderToolsGroup() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { actions } = state;
    const tools = actions.tools;
    if (!tools?.enabled || !Array.isArray(tools?.available) || !tools.available.length) {
      return E;
    }
    const editingElement = this.editorStore?.editingElement;
    if (!editingElement) return E;
    const renderIcon = (iconName) => {
      if (typeof iconName === "function") {
        return iconName(x);
      }
      if (typeof iconName !== "string") {
        return x`<sp-icon-table slot="icon"></sp-icon-table>`;
      }
      const iconTag = iconName.toLowerCase();
      const iconHtml = `<${iconTag} slot="icon"></${iconTag}>`;
      return o12(iconHtml);
    };
    const toolControls = tools.available.map((tool) => {
      const toolId = tool.id || tool.tag || "tool";
      const toolLabel = tool.label || tool.tag || "Tool";
      const toolTag = tool.tag || "";
      const toolIcon = tool.icon || "sp-icon-table";
      if (!toolTag) return E;
      const isOpen = this.editorStore?.toolbar?.openTool && (this.editorStore.toolbar.openTool.id === tool.id || this.editorStore.toolbar.openTool.tag === tool.tag);
      return x`
        <sp-action-button
          quiet
          id=${`tool-trigger-${toolId}`}
          title=${toolLabel}
          ?selected=${isOpen}
          @click=${() => {
        const toolbar = this.editorStore?.toolbar;
        if (toolbar) {
          console.log("[EEToolbar] Tool button clicked", { tool, isOpen, toolbar });
          if (isOpen) {
            toolbar.setOpenTool(null);
          } else {
            toolbar.setOpenTool(tool);
            console.log("[EEToolbar] Tool opened", { tool, openTool: toolbar.openTool });
          }
        }
      }}
        >
          ${renderIcon(toolIcon)}
        </sp-action-button>
      `;
    }).filter((control) => control !== E);
    if (!toolControls.length) return E;
    return x`
      <span class="group" aria-label="Tools">
        ${toolControls}
      </span>
    `;
  }
  #renderPasteButton(slotState) {
    if (!slotState) return E;
    if (!this.#canPasteContext(slotState)) {
      return E;
    }
    const { slotName } = slotState;
    if (this.clipboardHasTextOrHtml === void 0 || this.clipboardHasTextOrHtml === null) {
      this.clipboardHasTextOrHtml = false;
    }
    const enabled = this.clipboardHasTextOrHtml === true;
    if (!enabled) {
      this.checkClipboardForPaste();
    }
    return this.#createActionButton({
      title: "Paste",
      icon: x`<sp-icon-paste slot="icon"></sp-icon-paste>`,
      onClick: () => this.pasteFromClipboard({ slotName }),
      disabled: !enabled,
      onPointerDown: (e36) => e36.preventDefault()
    });
  }
  #canPasteContext(slotState) {
    return slotState?.slotConfig?.allowPaste === true;
  }
  async checkClipboardForPaste() {
    if (this.#checkingClipboard) return;
    this.#checkingClipboard = true;
    let hasTextOrHtml = false;
    if (navigator.clipboard && navigator.clipboard.read) {
      const items = await navigator.clipboard.read().catch(() => []);
      for (const item of items) {
        const types = Array.isArray(item?.types) ? item.types : [];
        if (types.includes("text/html") || types.includes("text/plain")) {
          hasTextOrHtml = true;
          break;
        }
      }
    }
    if (!hasTextOrHtml && navigator.clipboard && navigator.clipboard.readText) {
      const text = await navigator.clipboard.readText().catch(() => "");
      if (text && text.trim()) {
        hasTextOrHtml = true;
      }
    }
    this.clipboardHasTextOrHtml = hasTextOrHtml;
    this.#checkingClipboard = false;
  }
  async pasteFromClipboard({ slotName } = {}) {
    const activeRte = this.editorStore?.richText?.activeRte;
    if (activeRte?.insertHtml) {
      const { html: html2 } = await this.#readClipboardContent();
      if (!html2) return;
      activeRte.insertHtml(html2);
      return;
    }
    const { html, text } = await this.#readClipboardContent();
    const raw = html || text;
    if (!raw) return;
    const editorStore = this.editorStore;
    const domStore = editorStore?.domStore;
    if (!domStore) return;
    const slotState = this.#buildSlotContext({
      requestedSlotName: slotName ?? null,
      fallbackToDefault: true
    });
    if (!slotState || !this.#canPasteContext(slotState)) {
      return;
    }
    const { slotName: resolvedSlot, remaining, parentElement } = slotState;
    if (!parentElement) return;
    const fragmentNodes = this.#parseClipboardMarkup(raw, {
      slotName: resolvedSlot
    });
    if (!fragmentNodes.length) return;
    const limit = Number.isFinite(remaining) ? remaining : fragmentNodes.length;
    const nodesToInsert = fragmentNodes.slice(0, limit);
    const insertedElements = [];
    nodesToInsert.forEach((nodeData) => {
      const inserted = domStore.insertElement(
        nodeData,
        parentElement,
        Infinity
      );
      if (inserted) {
        insertedElements.push(inserted);
      }
    });
    if (!insertedElements.length) {
      return;
    }
    editorStore.history.scheduleSnapshot();
    editorStore.history.scheduleAutoSave?.();
    const lastInserted = insertedElements[insertedElements.length - 1];
    if (lastInserted?.isConnected) {
      editorStore.selection?.selectElement?.(lastInserted, resolvedSlot, {
        recordAction: false
      });
    }
  }
  async #readClipboardContent() {
    let html = "";
    let text = "";
    if (navigator.clipboard?.read) {
      try {
        const items = await navigator.clipboard.read();
        for (const item of items) {
          if (item.types?.includes("text/html") && !html) {
            const blob = await item.getType("text/html");
            html = await blob.text();
          }
          if (item.types?.includes("text/plain") && !text) {
            const blob = await item.getType("text/plain");
            text = await blob.text();
          }
          if (html && text) {
            break;
          }
        }
      } catch (error) {
        console.warn("[EEToolbar] clipboard.read failed", error);
      }
    }
    if (!html && navigator.clipboard?.readText) {
      try {
        const fallback = await navigator.clipboard.readText();
        if (fallback && fallback.trim()) {
          text = fallback;
        }
      } catch (error) {
        console.warn("[EEToolbar] clipboard.readText failed", error);
      }
    }
    const sanitizedHtml = html ? html.trim() : "";
    const sanitizedText = text ? text.trim() : "";
    return {
      html: sanitizedHtml,
      text: sanitizedText
    };
  }
  #parseClipboardMarkup(raw, { slotName }) {
    const doc3 = this.editorStore?.editorElement?.ownerDocument || window.document;
    if (!doc3) return [];
    const template = doc3.createElement("template");
    template.innerHTML = raw && raw.includes("<") ? raw : (() => {
      const span = doc3.createElement("span");
      span.textContent = raw;
      return span.innerHTML;
    })();
    const nodes2 = [];
    const isDefaultSlot = !slotName || slotName === "default" || slotName === "";
    Array.from(template.content.childNodes || []).forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE && node.tagName?.toLowerCase() === "meta") {
        console.log("[EEToolbar] #parseClipboardMarkup skipping browser-injected <meta> tag");
        return;
      }
      const data = this.#nodeToDomStoreData(node, {
        slotName: isDefaultSlot ? null : slotName,
        isRoot: true
      });
      if (data) {
        nodes2.push(data);
      }
    });
    return nodes2;
  }
  #nodeToDomStoreData(node, { slotName, isRoot }) {
    if (!node) return null;
    const ELEMENT_NODE = typeof Node !== "undefined" ? Node.ELEMENT_NODE : 1;
    const TEXT_NODE = typeof Node !== "undefined" ? Node.TEXT_NODE : 3;
    if (node.nodeType === TEXT_NODE) {
      const textContent = node.textContent ?? "";
      if (!textContent.trim()) {
        return null;
      }
      const attrs2 = {};
      const data2 = {
        tag: "span",
        html: textContent
      };
      if (slotName) {
        data2.slotName = slotName;
      }
      if (Object.keys(attrs2).length) {
        data2.attrs = attrs2;
      }
      return data2;
    }
    if (node.nodeType !== ELEMENT_NODE) {
      return null;
    }
    const element = (
      /** @type {Element} */
      node
    );
    const attrs = {};
    Array.from(element.attributes || []).forEach((attr) => {
      const name = attr.name;
      const value = attr.value;
      attrs[name] = value === "" ? "" : value;
    });
    const tag3 = element.tagName?.toLowerCase?.() || "div";
    const data = {
      tag: tag3
    };
    if (Object.keys(attrs).length) {
      data.attrs = attrs;
    }
    const inner = element.innerHTML;
    data.html = inner ?? "";
    if (isRoot && slotName) {
      if (attrs.slot) {
        delete attrs.slot;
        if (Object.keys(attrs).length) {
          data.attrs = attrs;
        } else {
          delete data.attrs;
        }
      }
      data.slotName = slotName;
    }
    return data;
  }
  renderPrimaryAttributes(actions) {
    const schema2 = actions.attributes?.schema || {};
    const entries = Object.entries(schema2).slice(0, 3);
    if (!entries.length) return E;
    return x`${entries.map(
      ([name, def]) => this.renderAttributeField(name, def)
    )}`;
  }
  // Slot field renderer removed
  // Quick slot actions removed
  // Attribute + slot form panel
  renderFormPanel(actions) {
    const schema2 = actions.attributes?.schema || {};
    return x`
      ${Object.keys(schema2).length ? x`
            <div class="attributes">
              ${Object.entries(schema2).map(
      ([name, def]) => this.renderAttributeField(name, def)
    )}
            </div>
          ` : E}
    `;
  }
  // Remaining attributes only (exclude those shown inline); vertical form
  renderRemainingFormPanel(actions) {
    if (!this.showAllOpen) return E;
    const schema2 = actions.attributes?.schema || {};
    const rest = Object.entries(schema2).filter(
      ([name, def]) => !this.#inlineAttrNames.includes(name) && def?.type !== "popover"
    );
    if (!rest.length) return E;
    return x`
      <div class="attributes">
        ${rest.map(([name, def]) => this.renderAttributeField(name, def))}
      </div>
    `;
  }
  // Inline edit starter (pen icon)
  // Slot helpers
  #slotNodeHasContent(node) {
    if (!node) return false;
    if (node.nodeType === Node.TEXT_NODE) {
      return !!node.textContent && !!node.textContent.trim();
    }
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    const element = node;
    if (element.hasAttribute?.(INLINE_EDITOR_ATTR)) {
      return Array.from(element.childNodes || []).some(
        (child) => this.#slotNodeHasContent(child)
      );
    }
    const tagName = element.tagName?.toLowerCase?.() || "";
    if (tagName === "ee-rte") {
      const value = typeof element.getValue === "function" ? element.getValue() : element.textContent || "";
      if (typeof value === "string" && value.trim()) {
        return true;
      }
      return Array.from(element.childNodes || []).some(
        (child) => this.#slotNodeHasContent(child)
      );
    }
    if (element.hasAttribute?.(INLINE_CONTAINER_ATTR)) {
      return Array.from(element.childNodes || []).some(
        (child) => this.#slotNodeHasContent(child)
      );
    }
    if (element.childNodes && element.childNodes.length > 0) {
      return Array.from(element.childNodes).some(
        (child) => this.#slotNodeHasContent(child)
      );
    }
    return true;
  }
  #slotHasAnyContent(parent, slotName, inShadow) {
    if (!parent) return false;
    if (inShadow) {
      const selector = slotName === "default" ? "slot:not([name])" : `slot[name="${slotName}"]`;
      const slotEl = parent.shadowRoot?.querySelector(selector);
      const assigned = slotEl ? slotEl.assignedNodes() : [];
      return assigned.some((n25) => this.#slotNodeHasContent(n25));
    }
    if (slotName === "default") {
      return Array.from(parent.childNodes || []).some(
        (node) => this.#slotNodeHasContent(node)
      );
    }
    return Array.from(parent.children || []).some((child) => {
      if (child.getAttribute?.("slot") !== slotName) {
        return false;
      }
      return this.#slotNodeHasContent(child);
    });
  }
  clearSlot(slotName) {
    const parent = this.editorStore?.editingElement;
    if (!parent) return;
    this.#withFrozenPosition(() => {
      const domStore = this.#getDomStore();
      if (!domStore) {
        console.warn("clearSlot() requires dom store state");
        return;
      }
      const normalizedSlot = domStore.normalizeSlotName(slotName);
      const candidates = domStore.getAuthorableChildren(parent).filter(
        (child) => domStore.getElementSlotName(child) === normalizedSlot
      );
      candidates.forEach((child) => domStore.deleteElement(child));
      const selectionSlot = slotName ?? normalizedSlot ?? domStore.defaultSlotName;
      this.editorStore?.selection.selectSlot(parent, selectionSlot);
      this.editorStore?.history.scheduleSnapshot();
    });
  }
  addElementToSlot(tagName, slotName = "default") {
    const parent = this.editorStore?.editingElement;
    if (!parent || !tagName) return;
    this.#withFrozenPosition(() => {
      const normalizedTag = typeof tagName === "string" ? tagName.trim() : "";
      if (!normalizedTag) return;
      const domStore = this.#getDomStore();
      if (!domStore) {
        console.warn("addElementToSlot() requires dom store state");
        return;
      }
      const desiredSlot = slotName === "default" ? "default" : slotName;
      const siblings = domStore.getAuthorableChildren(parent);
      let insertPosition = siblings.length;
      for (let i21 = siblings.length - 1; i21 >= 0; i21 -= 1) {
        const child = siblings[i21];
        if (child.hasAttribute("data-ee-inline-editor")) continue;
        const childSlot = child.getAttribute("slot");
        const normalizedChildSlot = !childSlot || childSlot === "" ? "default" : childSlot;
        if (normalizedChildSlot === desiredSlot) {
          insertPosition = i21 + 1;
          break;
        }
      }
      const slotState = this.#buildSlotContext({
        requestedSlotName: desiredSlot
      });
      const slotCreate = slotState?.slotConfig?.create;
      let createdElement = null;
      if (typeof slotCreate === "function") {
        const result = slotCreate(normalizedTag, desiredSlot);
        if (result instanceof HTMLElement) {
          createdElement = result;
        }
      }
      let newElement = null;
      if (createdElement) {
        const attrs = {};
        if (createdElement.attributes) {
          for (const attr of createdElement.attributes) {
            attrs[attr.name] = attr.value;
          }
        }
        if (desiredSlot !== "default") {
          attrs.slot = desiredSlot;
        }
        const nodeData = {
          tag: normalizedTag,
          attrs,
          slotName: desiredSlot === "default" ? null : desiredSlot,
          html: createdElement.innerHTML
        };
        newElement = domStore.insertElement(nodeData, parent, insertPosition);
      } else if (normalizedTag.includes("-")) {
        const ctor = customElements.get(normalizedTag);
        if (ctor?.ee?.create) {
          const elementCreated = ctor.ee.create();
          const attrs = {};
          if (elementCreated.attributes) {
            for (const attr of elementCreated.attributes) {
              attrs[attr.name] = attr.value;
            }
          }
          if (desiredSlot !== "default") {
            attrs.slot = desiredSlot;
          }
          const nodeData = {
            tag: normalizedTag,
            attrs,
            slotName: desiredSlot === "default" ? null : desiredSlot,
            html: elementCreated.innerHTML
          };
          newElement = domStore.insertElement(nodeData, parent, insertPosition);
        }
      }
      if (!newElement) {
        const elementSchema2 = normalizedTag.includes("-") ? getElementSchema(customElements.get(normalizedTag)?.ee, null) : null;
        const attrs = {};
        if (elementSchema2?.attributes) {
          Object.entries(elementSchema2.attributes).forEach(([name, attr]) => {
            if (attr?.default !== void 0) {
              attrs[name] = attr.default;
            }
          });
        }
        if (desiredSlot !== "default") {
          attrs.slot = desiredSlot;
        }
        if (normalizedTag.toLowerCase() === "a" && !attrs.href) {
          attrs.href = "#";
        }
        const nodeData = {
          tag: normalizedTag,
          attrs,
          slotName: desiredSlot === "default" ? null : desiredSlot
        };
        newElement = domStore.insertElement(nodeData, parent, insertPosition);
      }
      if (!newElement) {
        return;
      }
      requestAnimationFrame(() => {
        if (newElement && normalizedTag.toLowerCase() === "a" && !newElement.textContent?.trim()) {
          newElement.textContent = "Link";
          newElement.eePlaceholder = true;
        }
        if (newElement) {
          this.editorStore?.selection.selectElement(newElement);
        }
      });
      this.editorStore?.history.scheduleSnapshot?.();
    });
  }
  renderAttributeField(name, def, options = {}) {
    if (!def) {
      return E;
    }
    const nodeConfig = options.nodeConfig || null;
    const wrapperClass = options.wrapperClass || "";
    let summaryLabelAttr = typeof options.summaryLabel === "string" && options.summaryLabel.trim() ? options.summaryLabel.trim() : null;
    if (!summaryLabelAttr) {
      const fallbackSummary = this.#getAttributeSummaryLabel(def, name);
      if (fallbackSummary) {
        summaryLabelAttr = fallbackSummary;
      }
    }
    const element = nodeConfig ? null : this.editorStore?.editingElement || null;
    const renderElement = nodeConfig?.element || (nodeConfig ? null : element);
    if (!nodeConfig) {
      const evaluateResult = def?.evaluate?.({
        element,
        name,
        def,
        read: (attrName, fallbackDef = { default: "" }) => this.getAttributeValue(element, attrName, fallbackDef)
      }) || null;
      if (evaluateResult && evaluateResult.render === false) {
        return E;
      }
    }
    const currentValue = nodeConfig ? this.#getNodeAttributeValue(nodeConfig, name, def) : this.getAttributeValue(element, name, def);
    const readValue = (attrName, fallbackDef = { default: "" }) => {
      if (nodeConfig) {
        return this.#getNodeAttributeValue(nodeConfig, attrName, fallbackDef);
      }
      const currentElement = this.editorStore?.editingElement || null;
      return this.getAttributeValue(currentElement, attrName, fallbackDef);
    };
    const applyValue = (attrName, value) => {
      if (nodeConfig?.apply) {
        nodeConfig.apply({ [attrName]: value });
        return;
      }
      const actions = this.actions;
      const schema2 = actions?.attributes?.schema || {};
      const attrDef = schema2[attrName];
      if (attrDef?.type === "boolean" && (value === true || value === false)) {
        const trueValue = attrDef?.booleanTrueValue;
        if (value === false) {
          this.updateBooleanAttribute(attrName, false);
          return;
        }
        if (value === true && trueValue !== void 0) {
          this.updateAttribute(attrName, trueValue);
          return;
        }
        this.updateBooleanAttribute(attrName, value);
        return;
      }
      this.updateAttribute(attrName, value);
    };
    const applyBoolean = (attrName, checked, attrDef = null) => {
      if (nodeConfig?.apply) {
        nodeConfig.apply({ [attrName]: checked });
        return;
      }
      const trueValue = attrDef?.booleanTrueValue;
      if (checked === false) {
        this.updateBooleanAttribute(attrName, false);
        return;
      }
      if (checked === true && trueValue !== void 0) {
        this.updateAttribute(attrName, trueValue);
        return;
      }
      this.updateBooleanAttribute(attrName, checked);
    };
    const wrapField = (body, helpText = E) => x`<div
        class=${o9(wrapperClass || void 0)}
        data-ee-summary-label=${o9(summaryLabelAttr || void 0)}
      >
        ${body}${helpText}
      </div>`;
    const helpTemplate = def.description ? x`<sp-help-text>${def.description}</sp-help-text>` : E;
    const labelValue = typeof def?.label === "string" && def.label.trim() ? def.label.trim() : typeof name === "string" ? name : "";
    const showFieldLabel = def?.showFieldLabel !== false && labelValue.length > 0;
    const labelTemplate = showFieldLabel ? x`<sp-field-label>${labelValue}</sp-field-label>` : E;
    if ((def.type === "custom" || def.type === "popover" || def.type === "transient") && def.render) {
      const control = def.render({
        html: x,
        value: currentValue,
        onChange: (v6) => applyValue(name, v6),
        updateAttribute: (attrName, v6) => applyValue(attrName, v6),
        read: (attrName, fallback = { default: "" }) => readValue(attrName, fallback),
        element: renderElement
      });
      return wrapField(x`${labelTemplate}${control}`, helpTemplate);
    }
    if (def.type === "enum" && Array.isArray(def.options)) {
      const pickerId = `picker-${name}`;
      const emptyOption = def.allowEmpty ? x`<sp-menu-item value=""></sp-menu-item>` : E;
      const picker = x`<sp-picker
        id=${pickerId}
        .value=${o9(
        currentValue === void 0 || currentValue === null || currentValue === "" ? "" : String(currentValue)
      )}
        placeholder=${o9(def.placeholder || def.description || "")}
        aria-label=${o9(def.label || name || void 0)}
        @change=${(event) => {
        const newValue = event.detail?.value ?? event.target?.value ?? null;
        if (def.allowEmpty && (newValue === "" || newValue === null)) {
          applyValue(name, null);
        } else {
          applyValue(name, newValue);
        }
      }}
      >
        ${emptyOption}
        ${def.options.map((opt) => {
        const val = String(opt);
        const content = def.optionRenderer?.(val);
        if (content != null) {
          return x`<sp-menu-item value=${val}
              >${o12(content)}</sp-menu-item
            >`;
        }
        return x`<sp-menu-item value=${val}>${val}</sp-menu-item>`;
      })}
      </sp-picker>`;
      return wrapField(
        x`${labelTemplate}${picker}`,
        helpTemplate
      );
    }
    if (def.type === "boolean") {
      const checkbox = x`<sp-checkbox
        ?checked=${!!currentValue}
        aria-label=${o9(def.label || name || void 0)}
        @change=${(event) => applyBoolean(name, event.target.checked === true, def)}
      >
        ${def.label || name}
      </sp-checkbox>`;
      return wrapField(checkbox, helpTemplate);
    }
    if (def.type === "number") {
      const numberField = x`<sp-number-field
        .value=${Number(currentValue) || 0}
        min=${o9(def.min ?? void 0)}
        max=${o9(def.max ?? void 0)}
        step=${o9(def.step ?? 1)}
        placeholder=${o9(def.placeholder || def.description || "")}
        aria-label=${o9(def.label || name || void 0)}
        @change=${(event) => applyValue(name, event.target.valueAsNumber)}
      ></sp-number-field>`;
      return wrapField(
        x`${labelTemplate}${numberField}`,
        helpTemplate
      );
    }
    const textField = x`<sp-textfield
      .value=${String(currentValue ?? "")}
      placeholder=${o9(def.placeholder || def.description || "")}
      aria-label=${o9(def.label || name || void 0)}
      @change=${(event) => applyValue(name, event.target.value)}
    ></sp-textfield>`;
    return wrapField(
      x`${labelTemplate}${textField}`,
      helpTemplate
    );
  }
  getAttributeValue(element, name, def) {
    if (!element) return def?.default ?? "";
    if (def?.type === "boolean") {
      const attrValue = element.getAttribute(name);
      if (attrValue === null) {
        return def?.default === true;
      }
      return attrValue !== "false";
    }
    return element.getAttribute(name) ?? def?.default ?? "";
  }
  getAttributeValues() {
    const actions = this.actions;
    const element = this.#attributeTarget();
    const schema2 = actions?.attributes?.schema || {};
    if (!element)
      return Object.fromEntries(
        Object.keys(schema2).map((k2) => [k2, schema2[k2]?.default ?? null])
      );
    const values = {};
    for (const [attrName, def] of Object.entries(schema2)) {
      if (def.type === "boolean") {
        values[attrName] = this.getAttributeValue(element, attrName, def);
      } else if (def.type === "number") {
        const v6 = element.getAttribute(attrName);
        values[attrName] = v6 !== null && v6 !== void 0 ? Number(v6) : def.default ?? null;
      } else {
        values[attrName] = element.getAttribute(attrName) ?? def.default ?? "";
      }
    }
    return values;
  }
  #isTransientAttribute(name) {
    const actions = this.actions;
    const schema2 = actions?.attributes?.schema || {};
    const attrDef = schema2[name];
    return attrDef?.type === "transient";
  }
  updateBooleanAttribute(name, checked) {
    if (this.#isTransientAttribute(name)) {
      return;
    }
    this.#withFrozenPosition(() => {
      const element = this.editorStore?.editingElement || null;
      if (!element || !element.isConnected) return;
      const domStore = this.#getDomStore();
      if (!domStore) {
        console.warn("updateBooleanAttribute() requires dom store state");
        return;
      }
      const normalizedValue = checked ? "true" : "false";
      const attrs = { [name]: normalizedValue };
      domStore.updateElementAttributes(element, attrs);
      this.editorStore?.history.scheduleSnapshot();
    });
  }
  handleBooleanAttributeChange(name, checked) {
    this.updateBooleanAttribute(name, checked);
  }
  updateAttribute(name, value) {
    if (this.#isTransientAttribute(name)) {
      return;
    }
    this.#withFrozenPosition(() => {
      const element = this.editorStore?.editingElement || null;
      if (!element || !element.isConnected) return;
      const domStore = this.#getDomStore();
      if (!domStore) {
        console.warn("updateAttribute() requires dom store state");
        return;
      }
      const actions = this.actions;
      const schema2 = actions?.attributes?.schema || {};
      const attrDef = schema2[name];
      let normalizedValue;
      if (attrDef?.type === "boolean") {
        if (value === true || value === "true") {
          normalizedValue = "true";
        } else if (value === false || value === "false") {
          normalizedValue = "false";
        } else if (value === void 0 || value === null) {
          normalizedValue = null;
        } else {
          normalizedValue = value ? "true" : "false";
        }
      } else {
        normalizedValue = value === void 0 || value === null ? null : String(value);
      }
      const attrs = { [name]: normalizedValue };
      domStore.updateElementAttributes(element, attrs);
      this.editorStore?.history.scheduleSnapshot();
    });
  }
  handleOverlayOpen(e36) {
    this.editorStore?.setToolbarOverlayOpen?.(true);
    this.editorStore?.setLastAction?.("toolbar:overlay");
    this.#log("debug", "overlay opened", {
      showAllOpen: this.showAllOpen,
      target: e36?.target?.tagName
    });
    this.#shouldReopenPopover = false;
  }
  handleOverlayClose(e36) {
    this.editorStore?.setToolbarOverlayOpen?.(false);
    this.#log("debug", "overlay closed", {
      showAllOpen: this.showAllOpen,
      target: e36?.target?.tagName
    });
    const closedPopover = e36?.target;
    if (closedPopover && closedPopover.tagName === "SP-POPOVER") {
      if (closedPopover.hasAttribute("data-rte-node-popover")) {
        this.rteNodeShowAllOpen = false;
      } else if (closedPopover.id === SHOW_ALL_FIELDS_POPOVER_ID) {
        this.showAllOpen = false;
      }
    } else {
      const shadowRoot = this.shadowRoot;
      if (shadowRoot) {
        if (this.rteNodeShowAllOpen) {
          const rteNodePopover = shadowRoot.querySelector('sp-popover[data-rte-node-popover="true"]');
          if (rteNodePopover && !rteNodePopover.open) {
            this.rteNodeShowAllOpen = false;
          }
        }
        if (this.showAllOpen) {
          const showAllPopover = shadowRoot.getElementById(SHOW_ALL_FIELDS_POPOVER_ID);
          if (showAllPopover && !showAllPopover.open) {
            this.showAllOpen = false;
          }
        }
      }
    }
    if (this.#shouldReopenPopover) {
      this.#log("debug", "overlay closed; attempting reopen");
      setTimeout(() => this.#openPopoverProgrammatically(), 50);
    }
  }
  // All slot selection/editing helpers removed
  renderReorderGroup() {
    const state = this.#toolbarState;
    if (!state) {
      return E;
    }
    const { actions } = state;
    const canUp = !!actions.reordering?.canMoveUp;
    const canDown = !!actions.reordering?.canMoveDown;
    if (!canUp && !canDown) {
      return E;
    }
    const buttons = [
      canUp ? this.moveUpButton : E,
      canDown ? this.moveDownButton : E
    ].filter((x5) => x5 !== E);
    return x`<sp-action-group quiet selects="none"
      >${buttons}</sp-action-group
    >`;
  }
  renderSelectParentButton() {
    return this.selectParentButton;
  }
  renderDuplicateButton() {
    const button = this.duplicateButton;
    if (button === E) return E;
    return x`<sp-action-group quiet selects="none"
      >${button}</sp-action-group
    >`;
  }
  renderDeleteButton() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { actions, element: el, slotSelected, slotName, parentElement, deletionAllowed } = state;
    if (slotSelected) {
      const slotContext = this.#buildSlotContext({
        requestedSlotName: slotName ?? null,
        fallbackToDefault: true
      }) || null;
      const parent = parentElement || slotContext?.parentElement || el || this.editorStore?.editingElement;
      const hasDefault = this.#hasDefaultSlot(actions);
      const resolvedSlotName = slotContext?.slotName || slotName || this.editorStore?.currentSlot || actions.slots?.current || (hasDefault ? "default" : null);
      if (!parent || !resolvedSlotName) return E;
      const hasContent = this.#slotHasAnyContent(
        parent,
        resolvedSlotName,
        !!parent?.shadowRoot
      );
      if (!hasContent) return E;
      const clearButton = this.#createActionButton({
        title: "Clear slot content",
        icon: x`<sp-icon-delete slot="icon"></sp-icon-delete>`,
        onClick: () => this.clearSlot(resolvedSlotName)
      });
      return x`<sp-action-group quiet selects="none">
        ${clearButton}
      </sp-action-group>`;
    }
    const deletionAllowedFlag = deletionAllowed ?? actions.deletionAllowed ?? true;
    if (!deletionAllowedFlag) return E;
    const lockable = el ? this.hasAuthoringSchema(el) : false;
    const locked = lockable && this.isAuthoringLocked(el);
    if (!el || locked) return E;
    const button = this.deleteButton;
    if (button === E) {
      return E;
    }
    return x`<sp-action-group quiet selects="none"
      >${button}</sp-action-group
    >`;
  }
  renderCopyButton() {
    const state = this.#toolbarState;
    if (!state) return E;
    const { element: el, slotSelected } = state;
    if (slotSelected || !el) return E;
    return x`<sp-action-group quiet selects="none"
      >${this.copyButton}</sp-action-group
    >`;
  }
};
customElements.define("ee-toolbar", makeLitObserver(EEToolbar));

// src/experience-elements-editor.css.js
init_lit();
var experienceElementsEditorStyles = i`

  :host {
    --ee-canvas-max: 1440px;
    display: none;
    grid-template-rows: var(--ee-toolbar-height, 60px) 1fr;
    /* Toolbar row + main content row */
    justify-content: stretch;
    height: 100vh;
    overflow: hidden;
    font-family: var(--spectrum-global-font-family-base);
    background: var(--spectrum-alias-background-color-default);
    position: relative;
    box-sizing: border-box;
  }


  :host([open]) {
    display: grid;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: border-box;
  }

  :host ::part(editor) {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    width: 100%;
  }

  .loading-spinner {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  /* Center only modal dialogs; fullscreen manages its own layout */
  sp-dialog-wrapper[open][mode="modal"] {
    display: flex;
    align-items: center;
    justify-content: center; /* center middle group between flexible sides */
    justify-content: center;
  }

  #editor-toolbar {
    grid-row: 1;
    grid-column: 1 / 4;
    background: var(--spectrum-alias-component-background-color);
    padding: var(--spectrum-global-dimension-size-200)
      var(--spectrum-global-dimension-size-400);
    border-bottom: 1px solid var(--spectrum-alias-border-color);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-300);
    backdrop-filter: blur(10px);
    background: color-mix(in srgb, var(--spectrum-alias-component-background-color) 95%, transparent);
  }

  #editor-toolbar sp-textfield {
    --mod-textfield-border-width: 0;
  }

  #toolbar-left {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-200);
    flex: 1 1 0;
  }

  #toolbar-center {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-200);
    /* Center area should size to its content */
    flex: 0 0 auto;
    width: -moz-fit-content;
    width: fit-content;
    --mod-textfield-spacing-block-start: 0;
  }

  /* Ensure Spectrum controls align perfectly on the center line */
  #toolbar-center sp-action-button,
  #toolbar-center sp-textfield {
    align-self: center;
  }

  /* Keep file name inline, even when space is tight */
  #name-actions {
    display: inline-flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-150);
  }

  /* Ensure buttons align with the textfield vertically */
  /* Removed custom top offset to keep center alignment consistent */

  /* Make the name field feel inline while staying Spectrum */
  #fragment-name {
    flex: 1;
    align-items: center;
    display: inline-flex;
    font-size: var(--spectrum-global-dimension-font-size-200);
    font-weight: 600;
    color: var(--spectrum-gray-1000);
    max-width: 300px;
    text-align: center;
    cursor: pointer;
  }

  #fragment-name:active {
    min-width: 220px;
  }

  #toolbar-right {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: var(--spectrum-global-dimension-size-200);
    flex: 1 1 0;
  }

  .toolbar-icon-wrap {
    position: relative;
    display: inline-flex;
    align-items: center;
  }
  .toolbar-icon-wrap .count-badge {
    position: absolute;
    top: -6px;
    right: -6px;
    pointer-events: none;
  }

  /* Main grid row holds left sidebar, canvas, right sidebar */
  #editor-main {
    grid-row: 2;
    grid-column: 1 / 4;
    display: grid;
    grid-template-columns: auto 1fr auto; /* left | center | right */
    column-gap: var(--spectrum-global-dimension-size-200);
    align-items: stretch;
    height: 100%;
    overflow: hidden;
    padding: 0 var(--spectrum-global-dimension-size-200);
  }
  /* Consistent column gap; sidebar width collapses via [open] on content-tree-nav */

  /* Place content-tree-nav directly in the first column */
  #editor-main > .left-sidebar-container {
    grid-column: 1;
    position: relative;
    height: 100%;
    box-sizing: border-box;
    overflow: hidden;
    min-width: 0; /* allow grid to collapse this track */
    width: var(--ee-left-sidebar-width, 360px);
    opacity: 1;
    transition: width 200ms ease, opacity 140ms ease;
  }
  
  #editor-main > .left-sidebar-container:not(:has(content-tree-nav[open])) {
    width: 0;
    opacity: 0;
  }
  
  /* Fallback for browsers without :has() support */
  #editor-main > .left-sidebar-container content-tree-nav:not([open]) ~ * {
    display: none;
  }

  #editor-main > .left-sidebar-container > content-tree-nav {
    width: 100%;
    height: 100%;
  }

  /* Larger desktop: widen tree to 480px at >= 1920px */
  @media (min-width: 1920px) {
    #editor-main > .left-sidebar-container:has(content-tree-nav[open]) {
      width: 480px;
    }
  }

  /* #editor-pane wrapper removed; canvas-container is placed directly in column 2 */

  #right-sidebar {
    grid-column: 3;
    position: relative;
    height: 100%;
    transition: width 180ms ease;
    padding: var(--spectrum-global-dimension-size-200)
      var(--spectrum-global-dimension-size-200);
    background: transparent;
    width: 360px;
    overflow: hidden;
  }
  #right-sidebar.closed { width: 0; padding-left: 0; padding-right: 0; }
  #right-sidebar.open { width: 360px; }

  /* Shared card styling for sidebars */
  /* left/right sidebar cards removed; components style themselves */

  #comments-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
  }

  /* Leave dialog layout */
  .leave-dialog-body {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-200);
    padding: var(--spectrum-global-dimension-size-100) 0;
  }
  .leave-dialog-text {
    color: var(--spectrum-alias-text-color);
  }
  /* scroll inside the panel if needed */

  /* Resizer removed: fixed-width sidebar */

  /* Canvas column */

  #canvas-container {
    grid-column: 2; /* center column inside #editor-main */
    position: relative;
    min-width: 0;   /* allow shrink without overflow */
    height: 100%;
    display: flex;
    justify-content: flex-start; /* stick to tree-nav */
    align-items: flex-start;
    /* Align with tree-nav vertical rhythm: top=200, right/bottom=400, left=0 */
    padding: var(--spectrum-global-dimension-size-200)
      0
      var(--spectrum-global-dimension-size-200)
      0;
    overflow: auto;
    /* keep scroll chaining from propagating to ancestors so the container stays put */
    overscroll-behavior: contain;
    /* ensure transformed children never paint outside the container */
    contain: paint;
  }

  #surface-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    max-width: 1440px;
    /* Align top with tree-nav using container padding only */
    margin: 0;
    background: var(--spectrum-alias-component-background-color);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
    border-radius: var(--spectrum-global-dimension-size-100);
    border: 1px dashed var(--spectrum-alias-border-color);
    padding: 4px;
    overflow-x: hidden; /* clip zoomed content inside */
  }

  /* Centered spinner overlay over the surface wrapper while loading */
  #surface-spinner {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    pointer-events: none;
  }

  /* Inner content that receives zoom/pan transforms */
  #surface-content {
    position: relative;
    width: 100%;
    min-height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    will-change: transform;
    transform-origin: 0 0;
    /* Improve rendering quality during zoom */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }

  /* Visual outline for the currently selected (editing) element.
     Elements are provided to the editor via a <slot>, so style the
     slotted node with ::slotted to cross the shadow boundary. */
  ::slotted([data-ee-selected]) {
    outline: 2px solid var(--spectrum-alias-focus-color);
    outline-offset: 2px;
    border-radius: var(--spectrum-global-dimension-size-50);
  }

  /* Hovered-by-comment outline: light blue, does not affect toolbar */
  ::slotted([data-ee-comment-hovered]) {
    outline: 2px solid var(--spectrum-global-color-blue-400);
    outline-offset: 2px;
    border-radius: var(--spectrum-global-dimension-size-50);
  }

  /* Slot selection is styled directly on the <slot> element within open shadow DOM. */
  #reset-zoom {
    min-width: 60px;
`;

// src/experience-elements-editor.js
init_sp_progress_circle();

// node_modules/@spectrum-web-components/toast/src/Toast.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/button/sp-close-button.js
init_define_element();
defineElement("sp-close-button", CloseButton);

// node_modules/@spectrum-web-components/toast/src/Toast.js
init_focus_visible();

// node_modules/@spectrum-web-components/toast/src/toast.css.js
init_src();
var o39 = i`
    :host{--spectrum-toast-font-weight:var(--spectrum-regular-font-weight);--spectrum-toast-font-size:var(--spectrum-font-size-100);--spectrum-toast-corner-radius:var(--spectrum-corner-radius-100);--spectrum-toast-block-size:var(--spectrum-toast-height);--spectrum-toast-max-inline-size:var(--spectrum-toast-maximum-width);--spectrum-toast-border-width:var(--spectrum-border-width-100);--spectrum-toast-line-height:var(--spectrum-line-height-100);--spectrum-toast-line-height-cjk:var(--spectrum-cjk-line-height-100);--spectrum-toast-spacing-icon-to-text:var(--spectrum-text-to-visual-100);--spectrum-toast-spacing-start-edge-to-text-and-icon:var(--spectrum-spacing-300);--spectrum-toast-spacing-text-and-action-button-to-divider:var(--spectrum-spacing-300);--spectrum-toast-spacing-top-edge-to-divider:var(--spectrum-spacing-100);--spectrum-toast-spacing-bottom-edge-to-divider:var(--spectrum-spacing-100);--spectrum-toast-spacing-top-edge-to-icon:var(--spectrum-toast-top-to-workflow-icon);--spectrum-toast-spacing-text-to-action-button-horizontal:var(--spectrum-spacing-300);--spectrum-toast-spacing-close-button:var(--spectrum-spacing-100);--spectrum-toast-spacing-block-start:var(--spectrum-spacing-100);--spectrum-toast-spacing-block-end:var(--spectrum-spacing-100);--spectrum-toast-spacing-top-edge-to-text:var(--spectrum-toast-top-to-text);--spectrum-toast-spacing-bottom-edge-to-text:var(--spectrum-toast-bottom-to-text);--spectrum-toast-negative-background-color-default:var(--spectrum-negative-background-color-default);--spectrum-toast-positive-background-color-default:var(--spectrum-positive-background-color-default);--spectrum-toast-informative-background-color-default:var(--spectrum-informative-background-color-default);--spectrum-toast-text-and-icon-color:var(--spectrum-white)}@media (forced-colors:active){:host{--highcontrast-toast-border-color:ButtonText;border:var(--mod-toast-border-width,var(--spectrum-toast-border-width))solid var(--highcontrast-toast-border-color,transparent)}}:host{box-sizing:border-box;min-block-size:var(--mod-toast-block-size,var(--spectrum-toast-block-size));max-inline-size:var(--mod-toast-max-inline-size,var(--spectrum-toast-max-inline-size));border-radius:var(--mod-toast-corner-radius,var(--spectrum-toast-corner-radius));font-size:var(--mod-toast-font-size,var(--spectrum-toast-font-size));font-weight:var(--mod-toast-font-weight,var(--spectrum-toast-font-weight));-webkit-font-smoothing:antialiased;background-color:var(--mod-toast-background-color-default,var(--spectrum-toast-background-color-default));color:var(--mod-toast-background-color-default,var(--spectrum-toast-background-color-default));overflow-wrap:anywhere;flex-direction:row;align-items:stretch;padding-inline-start:var(--mod-toast-spacing-start-edge-to-text-and-icon,var(--spectrum-toast-spacing-start-edge-to-text-and-icon));display:inline-flex}:host([variant=negative]){background-color:var(--mod-toast-negative-background-color-default,var(--spectrum-toast-negative-background-color-default))}:host([variant=negative]),:host([variant=negative]) .closeButton:focus-visible:not(:active){color:var(--mod-toast-negative-background-color-default,var(--spectrum-toast-negative-background-color-default))}:host([variant=info]){background-color:var(--mod-toast-informative-background-color-default,var(--spectrum-toast-informative-background-color-default))}:host([variant=info]),:host([variant=info]) .closeButton:focus-visible:not(:active){color:var(--mod-toast-informative-background-color-default,var(--spectrum-toast-informative-background-color-default))}:host([variant=positive]){background-color:var(--mod-toast-positive-background-color-default,var(--spectrum-toast-positive-background-color-default))}:host([variant=positive]),:host([variant=positive]) .closeButton:focus-visible:not(:active){color:var(--mod-toast-positive-background-color-default,var(--spectrum-toast-positive-background-color-default))}.type{flex-grow:0;flex-shrink:0;margin-block-start:var(--mod-toast-spacing-top-edge-to-icon,var(--spectrum-toast-spacing-top-edge-to-icon));margin-inline-start:0;margin-inline-end:var(--mod-toast-spacing-icon-to-text,var(--spectrum-toast-spacing-icon-to-text))}.content,.type{color:var(--mod-toast-text-and-icon-color,var(--spectrum-toast-text-and-icon-color))}.content{box-sizing:border-box;line-height:var(--mod-toast-line-height,var(--spectrum-toast-line-height));text-align:start;flex:auto;padding-block-start:calc(var(--mod-toast-spacing-top-edge-to-text,var(--spectrum-toast-spacing-top-edge-to-text)) - var(--mod-toast-spacing-block-start,var(--spectrum-toast-spacing-block-start)));padding-block-end:calc(var(--mod-toast-spacing-bottom-edge-to-text,var(--spectrum-toast-spacing-bottom-edge-to-text)) - var(--mod-toast-spacing-block-end,var(--spectrum-toast-spacing-block-end)));padding-inline-start:0;padding-inline-end:var(--mod-toast-spacing-text-to-action-button-horizontal,var(--spectrum-toast-spacing-text-to-action-button-horizontal));display:inline-block}.content:lang(ja),.content:lang(ko),.content:lang(zh){line-height:var(--mod-toast-line-height-cjk,var(--spectrum-toast-line-height-cjk))}.buttons{border-inline-start-color:var(--mod-toast-divider-color,var(--spectrum-toast-divider-color));flex:none;align-items:flex-start;margin-block-start:var(--mod-toast-spacing-top-edge-to-divider,var(--spectrum-toast-spacing-top-edge-to-divider));margin-block-end:var(--mod-toast-spacing-bottom-edge-to-divider,var(--spectrum-toast-spacing-bottom-edge-to-divider));padding-inline-end:var(--mod-toast-spacing-close-button,var(--spectrum-toast-spacing-close-button));display:flex}.buttons .spectrum-CloseButton{align-self:flex-start}.body{flex-wrap:wrap;flex:auto;align-self:center;align-items:center;padding-block-start:var(--mod-toast-spacing-block-start,var(--spectrum-toast-spacing-block-start));padding-block-end:var(--mod-toast-spacing-block-end,var(--spectrum-toast-spacing-block-end));display:flex}.body ::slotted([slot=action]){margin-inline-start:auto;margin-inline-end:var(--mod-toast-spacing-text-and-action-button-to-divider,var(--spectrum-toast-spacing-text-and-action-button-to-divider))}.body ::slotted([slot=action]:dir(rtl)),:host([dir=rtl]) .body ::slotted([slot=action]){margin-inline-end:var(--mod-toast-spacing-text-and-action-button-to-divider,var(--spectrum-toast-spacing-text-and-action-button-to-divider))}.body+.buttons{border-inline-start-style:solid;border-inline-start-width:1px;padding-inline-start:var(--mod-toast-spacing-close-button,var(--spectrum-toast-spacing-close-button))}:host{--spectrum-toast-background-color-default:var(--system-toast-background-color-default);--spectrum-toast-divider-color:var(--system-toast-divider-color)}:host{--spectrum-overlay-animation-distance:var(--spectrum-spacing-100);--spectrum-overlay-animation-duration:var(--spectrum-animation-duration-100);opacity:0;pointer-events:none;transition:transform var(--spectrum-overlay-animation-duration)ease-in-out,opacity var(--spectrum-overlay-animation-duration)ease-in-out,visibility 0s linear var(--spectrum-overlay-animation-duration);visibility:hidden}:host([open]){opacity:1;pointer-events:auto;visibility:visible;transition-delay:0s}:host([variant=error]),:host([variant=warning]){background-color:var(--highcontrast-toast-negative-background-color-default,var(--mod-toast-negative-background-color-default,var(--spectrum-toast-negative-background-color-default)))}:host([variant=negative]),:host([variant=negative]) .closeButton:focus-visible:not(:active),:host([variant=warning]),:host([variant=warning]) .closeButton:focus-visible:not(:active){color:var(--highcontrast-toast-negative-background-color-default,var(--mod-toast-negative-background-color-default,var(--spectrum-toast-negative-background-color-default)))}
`;
var toast_css_default = o39;

// node_modules/@spectrum-web-components/toast/src/Toast.js
var c26 = Object.defineProperty;
var p18 = Object.getOwnPropertyDescriptor;
var r16 = (u36, n25, t34, e36) => {
  for (var o52 = e36 > 1 ? void 0 : e36 ? p18(n25, t34) : n25, s19 = u36.length - 1, l16; s19 >= 0; s19--) (l16 = u36[s19]) && (o52 = (e36 ? l16(n25, t34, o52) : l16(o52)) || o52);
  return e36 && o52 && c26(n25, t34, o52), o52;
};
var toastVariants = ["negative", "positive", "info", "error", "warning"];
var Toast = class extends FocusVisiblePolyfillMixin(SpectrumElement) {
  constructor() {
    super(...arguments);
    this.open = false;
    this._timeout = null;
    this._variant = "";
    this.countdownStart = 0;
    this.nextCount = -1;
    this.doCountdown = (t34) => {
      this.countdownStart || (this.countdownStart = performance.now()), t34 - this.countdownStart > this._timeout ? (this.shouldClose(), this.countdownStart = 0) : this.countdown();
    };
    this.countdown = () => {
      cancelAnimationFrame(this.nextCount), this.nextCount = requestAnimationFrame(this.doCountdown);
    };
    this.holdCountdown = () => {
      this.stopCountdown(), this.addEventListener("focusout", this.resumeCountdown);
    };
    this.resumeCountdown = () => {
      this.removeEventListener("focusout", this.holdCountdown), this.countdown();
    };
  }
  static get styles() {
    return [toast_css_default];
  }
  set timeout(t34) {
    const o52 = typeof t34 !== null && t34 > 0 ? Math.max(6e3, t34) : null, s19 = this.timeout;
    o52 && this.countdownStart && (this.countdownStart = performance.now()), this._timeout = o52, this.requestUpdate("timeout", s19);
  }
  get timeout() {
    return this._timeout;
  }
  set variant(t34) {
    if (t34 === this.variant) return;
    const e36 = this.variant;
    toastVariants.includes(t34) ? (this.setAttribute("variant", t34), this._variant = t34) : (this.removeAttribute("variant"), this._variant = ""), this.requestUpdate("variant", e36);
  }
  get variant() {
    return this._variant;
  }
  renderIcon(t34, e36) {
    switch (t34) {
      case "info":
        return x`
                    <sp-icon-info
                        label=${e36 || "Information"}
                        class="type"
                    ></sp-icon-info>
                `;
      case "negative":
      case "error":
        return x`
                    <sp-icon-alert
                        label=${e36 || "Error"}
                        class="type"
                    ></sp-icon-alert>
                `;
      case "warning":
        return x`
                    <sp-icon-alert
                        label=${e36 || "Warning"}
                        class="type"
                    ></sp-icon-alert>
                `;
      case "positive":
        return x`
                    <sp-icon-checkmark-circle
                        label=${e36 || "Success"}
                        class="type"
                    ></sp-icon-checkmark-circle>
                `;
      default:
        return x``;
    }
  }
  startCountdown() {
    this.countdown(), this.addEventListener("focusin", this.holdCountdown);
  }
  stopCountdown() {
    cancelAnimationFrame(this.nextCount), this.countdownStart = 0;
  }
  shouldClose() {
    this.dispatchEvent(new CustomEvent("close", { composed: true, bubbles: true, cancelable: true })) && this.close();
  }
  close() {
    this.open = false;
  }
  render() {
    return x`
            ${this.renderIcon(this.variant, this.iconLabel)}
            <div class="body" role="alert">
                <div class="content">
                    <slot></slot>
                </div>
                <slot name="action"></slot>
            </div>
            <div class="buttons">
                <sp-close-button
                    @click=${this.shouldClose}
                    label="Close"
                    static-color="white"
                ></sp-close-button>
            </div>
        `;
  }
  updated(t34) {
    super.updated(t34), t34.has("open") && (this.open ? this.timeout && this.startCountdown() : this.timeout && this.stopCountdown()), t34.has("timeout") && (this.timeout !== null && this.open ? this.startCountdown() : this.stopCountdown());
  }
};
r16([n4({ type: Boolean, reflect: true })], Toast.prototype, "open", 2), r16([n4({ type: Number })], Toast.prototype, "timeout", 1), r16([n4({ type: String })], Toast.prototype, "variant", 1), r16([n4({ type: String, attribute: "icon-label" })], Toast.prototype, "iconLabel", 2);

// node_modules/@spectrum-web-components/toast/sp-toast.js
init_define_element();
defineElement("sp-toast", Toast);

// node_modules/@spectrum-web-components/dialog/src/Dialog.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/button-group/src/ButtonGroup.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/button-group/src/button-group.css.js
init_src();
var o40 = i`
    :host{--spectrum-buttongroup-spacing:var(--mod-buttongroup-spacing,var(--mod-buttongroup-spacing-horizontal,var(--spectrum-spacing-300)));--spectrum-buttongroup-display:flex;--spectrum-buttongroup-flex-direction:row;--spectrum-buttongroup-justify-content:var(--mod-buttongroup-justify-content,normal)}:host([size=s]){--spectrum-buttongroup-spacing:var(--mod-buttongroup-spacing,var(--mod-buttongroup-spacing-horizontal,var(--spectrum-spacing-200)))}:host([vertical]){--mod-buttongroup-spacing:var(--mod-buttongroup-spacing-vertical);--spectrum-buttongroup-display:inline-flex;--spectrum-buttongroup-flex-direction:column}:host{display:var(--spectrum-buttongroup-display);flex-direction:var(--spectrum-buttongroup-flex-direction);gap:var(--spectrum-buttongroup-spacing);justify-content:var(--spectrum-buttongroup-justify-content);flex-wrap:wrap}::slotted(*){flex-shrink:0}:host([vertical]) ::slotted(sp-action-button){--spectrum-actionbutton-label-flex-grow:1}:host([dir=ltr][vertical]) ::slotted(sp-action-button){--spectrum-actionbutton-label-text-align:left}:host([dir=rtl][vertical]) ::slotted(sp-action-button){--spectrum-actionbutton-label-text-align:right}
`;
var button_group_css_default = o40;

// node_modules/@spectrum-web-components/button-group/src/ButtonGroup.js
var a12 = Object.defineProperty;
var m15 = Object.getOwnPropertyDescriptor;
var n20 = (s19, r25, e36, l16) => {
  for (var t34 = l16 > 1 ? void 0 : l16 ? m15(r25, e36) : r25, o52 = s19.length - 1, i21; o52 >= 0; o52--) (i21 = s19[o52]) && (t34 = (l16 ? i21(r25, e36, t34) : i21(t34)) || t34);
  return l16 && t34 && a12(r25, e36, t34), t34;
};
var ButtonGroup = class extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.vertical = false;
  }
  static get styles() {
    return [button_group_css_default];
  }
  updated(e36) {
    super.updated(e36), e36.has("size") && this.manageChildrenSize(this.slotElement);
  }
  handleSlotchange({ target: e36 }) {
    this.manageChildrenSize(e36);
  }
  manageChildrenSize(e36) {
    e36.assignedElements().forEach((t34) => {
      t34.size = this.size;
    });
  }
  render() {
    return x`
            <slot @slotchange=${this.handleSlotchange}></slot>
        `;
  }
};
n20([n4({ type: Boolean, reflect: true })], ButtonGroup.prototype, "vertical", 2), n20([e5("slot")], ButtonGroup.prototype, "slotElement", 2);

// node_modules/@spectrum-web-components/button-group/sp-button-group.js
init_define_element();
defineElement("sp-button-group", ButtonGroup);

// node_modules/@spectrum-web-components/dialog/src/Dialog.js
init_src2();

// node_modules/@spectrum-web-components/alert-dialog/src/AlertDialog.js
init_src();
init_decorators2();
init_focus_visible();
init_random_id();
init_condition_attribute_with_id();

// node_modules/@lit-labs/observers/resize-controller.js
var s12 = class {
  constructor(s19, { target: t34, config: i21, callback: h16, skipInitial: e36 }) {
    this.t = /* @__PURE__ */ new Set(), this.o = false, this.i = false, this.h = s19, null !== t34 && this.t.add(t34 ?? s19), this.l = i21, this.o = e36 ?? this.o, this.callback = h16, window.ResizeObserver ? (this.u = new ResizeObserver((s20) => {
      this.handleChanges(s20), this.h.requestUpdate();
    }), s19.addController(this)) : console.warn("ResizeController error: browser does not support ResizeObserver.");
  }
  handleChanges(s19) {
    this.value = this.callback?.(s19, this.u);
  }
  hostConnected() {
    for (const s19 of this.t) this.observe(s19);
  }
  hostDisconnected() {
    this.disconnect();
  }
  async hostUpdated() {
    !this.o && this.i && this.handleChanges([]), this.i = false;
  }
  observe(s19) {
    this.t.add(s19), this.u.observe(s19, this.l), this.i = true, this.h.requestUpdate();
  }
  unobserve(s19) {
    this.t.delete(s19), this.u.unobserve(s19);
  }
  disconnect() {
    this.u.disconnect();
  }
};

// node_modules/@spectrum-web-components/alert-dialog/src/alert-dialog.css.js
init_src();
var r17 = i`
    :host{--spectrum-alert-dialog-min-width:var(--spectrum-alert-dialog-minimum-width);--spectrum-alert-dialog-max-width:var(--spectrum-alert-dialog-maximum-width);--spectrum-alert-dialog-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-alert-dialog-warning-icon-color:var(--spectrum-notice-visual-color);--spectrum-alert-dialog-error-icon-color:var(--spectrum-negative-visual-color);--spectrum-alert-dialog-title-font-family:var(--spectrum-sans-font-family-stack);--spectrum-alert-dialog-title-font-weight:var(--spectrum-heading-sans-serif-font-weight);--spectrum-alert-dialog-title-font-style:var(--spectrum-heading-sans-serif-font-style);--spectrum-alert-dialog-title-font-size:var(--spectrum-alert-dialog-title-size);--spectrum-alert-dialog-title-line-height:var(--spectrum-heading-line-height);--spectrum-alert-dialog-title-color:var(--spectrum-heading-color);--spectrum-alert-dialog-body-font-family:var(--spectrum-sans-font-family-stack);--spectrum-alert-dialog-body-font-weight:var(--spectrum-body-sans-serif-font-weight);--spectrum-alert-dialog-body-font-style:var(--spectrum-body-sans-serif-font-style);--spectrum-alert-dialog-body-font-size:var(--spectrum-alert-dialog-description-size);--spectrum-alert-dialog-body-line-height:var(--spectrum-line-height-100);--spectrum-alert-dialog-body-color:var(--spectrum-body-color);--spectrum-alert-dialog-title-to-divider:var(--spectrum-spacing-200);--spectrum-alert-dialog-divider-to-description:var(--spectrum-spacing-300);--spectrum-alert-dialog-title-to-icon:var(--spectrum-spacing-300);--mod-buttongroup-justify-content:flex-end;box-sizing:border-box;inline-size:fit-content;min-inline-size:var(--mod-alert-dialog-min-width,var(--spectrum-alert-dialog-min-width));max-inline-size:var(--mod-alert-dialog-max-width,var(--spectrum-alert-dialog-max-width));max-block-size:inherit;padding:var(--mod-alert-dialog-padding,var(--spectrum-alert-dialog-padding));outline:none;display:flex}.icon{inline-size:var(--mod-alert-dialog-icon-size,var(--spectrum-alert-dialog-icon-size));block-size:var(--mod-alert-dialog-icon-size,var(--spectrum-alert-dialog-icon-size));flex-shrink:0;margin-inline-start:var(--mod-alert-dialog-title-to-icon,var(--spectrum-alert-dialog-title-to-icon))}:host([variant=warning]){--mod-icon-color:var(--mod-alert-dialog-warning-icon-color,var(--spectrum-alert-dialog-warning-icon-color))}:host([variant=error]){--mod-icon-color:var(--mod-alert-dialog-error-icon-color,var(--spectrum-alert-dialog-error-icon-color))}.grid{display:grid}.header{justify-content:space-between;align-items:baseline;display:flex}::slotted([slot=heading]){font-family:var(--mod-alert-dialog-title-font-family,var(--spectrum-alert-dialog-title-font-family));font-weight:var(--mod-alert-dialog-title-font-weight,var(--spectrum-alert-dialog-title-font-weight));font-style:var(--mod-alert-dialog-title-font-style,var(--spectrum-alert-dialog-title-font-style));font-size:var(--mod-alert-dialog-title-font-size,var(--spectrum-alert-dialog-title-font-size));line-height:var(--mod-alert-dialog-title-line-height,var(--spectrum-alert-dialog-title-line-height));color:var(--mod-alert-dialog-title-color,var(--spectrum-alert-dialog-title-color));margin:0;margin-block-end:var(--mod-alert-dialog-title-to-divider,var(--spectrum-alert-dialog-title-to-divider))}.content{font-family:var(--mod-alert-dialog-body-font-family,var(--spectrum-alert-dialog-body-font-family));font-weight:var(--mod-alert-dialog-body-font-weight,var(--spectrum-alert-dialog-body-font-weight));font-style:var(--mod-alert-dialog-body-font-style,var(--spectrum-alert-dialog-body-font-style));font-size:var(--mod-alert-dialog-body-font-size,var(--spectrum-alert-dialog-body-font-size));line-height:var(--mod-alert-dialog-body-line-height,var(--spectrum-alert-dialog-body-line-height));color:var(--mod-alert-dialog-body-color,var(--spectrum-alert-dialog-body-color));-webkit-overflow-scrolling:touch;margin:0;margin-block-start:var(--mod-alert-dialog-divider-to-description,var(--spectrum-alert-dialog-divider-to-description));margin-block-end:var(--mod-alert-dialog-description-to-buttons,var(--spectrum-alert-dialog-description-to-buttons));overflow-y:auto}@media (forced-colors:active){:host{border:solid}}.divider{--spectrum-divider-background-color:var(--system-alert-dialog-divider-background-color);--spectrum-divider-background-color-static-white:var(--spectrum-alert-dialog-divider-background-color-static-white);--spectrum-divider-background-color-static-black:var(--spectrum-alert-dialog-divider-background-color-static-black)}
`;
var alert_dialog_css_default = r17;

// node_modules/@spectrum-web-components/alert-dialog/src/AlertDialog.js
var b8 = Object.defineProperty;
var p19 = Object.getOwnPropertyDescriptor;
var l12 = (a23, r25, e36, t34) => {
  for (var i21 = t34 > 1 ? void 0 : t34 ? p19(r25, e36) : r25, n25 = a23.length - 1, d22; n25 >= 0; n25--) (d22 = a23[n25]) && (i21 = (t34 ? d22(r25, e36, i21) : d22(i21)) || i21);
  return t34 && i21 && b8(r25, e36, i21), i21;
};
var alertDialogVariants = ["confirmation", "information", "warning", "error", "destructive", "secondary"];
function h12(a23, r25) {
  const e36 = a23.assignedElements(), t34 = [];
  return e36.forEach((i21) => {
    if (i21.id) t34.push(i21.id);
    else {
      const n25 = r25 + `-${randomID()}`;
      i21.id = n25, t34.push(n25);
    }
  }), t34;
}
var o41 = class o42 extends FocusVisiblePolyfillMixin(SpectrumElement) {
  constructor() {
    super(...arguments);
    this.resizeController = new s12(this, { callback: () => {
      this.shouldManageTabOrderForScrolling();
    } });
    this._variant = "";
    this.labelledbyId = `sp-dialog-label-${o42.instanceCount++}`;
    this.shouldManageTabOrderForScrolling = () => {
      if (!this.contentElement) return;
      const { offsetHeight: e36, scrollHeight: t34 } = this.contentElement;
      e36 < t34 ? this.contentElement.tabIndex = 0 : this.contentElement.removeAttribute("tabindex");
    };
    this.describedbyId = `sp-dialog-description-${o42.instanceCount++}`;
  }
  static get styles() {
    return [alert_dialog_css_default];
  }
  set variant(e36) {
    if (e36 === this.variant) return;
    const t34 = this.variant;
    alertDialogVariants.includes(e36) ? (this.setAttribute("variant", e36), this._variant = e36) : (this.removeAttribute("variant"), this._variant = ""), this.requestUpdate("variant", t34);
  }
  get variant() {
    return this._variant;
  }
  renderIcon() {
    switch (this.variant) {
      case "warning":
      case "error":
        return x`
                    <sp-icon-alert class="icon"></sp-icon-alert>
                `;
      default:
        return x``;
    }
  }
  renderHeading() {
    return x`
            <slot name="heading" @slotchange=${this.onHeadingSlotchange}></slot>
        `;
  }
  renderContent() {
    return x`
            <div class="content">
                <slot @slotchange=${this.onContentSlotChange}></slot>
            </div>
        `;
  }
  onHeadingSlotchange({ target: e36 }) {
    this.conditionLabelledby && (this.conditionLabelledby(), delete this.conditionLabelledby);
    const t34 = h12(e36, this.labelledbyId);
    t34.length && (this.conditionLabelledby = conditionAttributeWithId(this, "aria-labelledby", t34));
  }
  onContentSlotChange({ target: e36 }) {
    requestAnimationFrame(() => {
      this.resizeController.unobserve(this.contentElement), this.resizeController.observe(this.contentElement);
    }), this.conditionDescribedby && (this.conditionDescribedby(), delete this.conditionDescribedby);
    const t34 = h12(e36, this.describedbyId);
    if (t34.length && t34.length < 4) this.conditionDescribedby = conditionAttributeWithId(this, "aria-describedby", t34);
    else if (!t34.length) {
      const i21 = !!this.id;
      i21 || (this.id = this.describedbyId);
      const n25 = conditionAttributeWithId(this, "aria-describedby", this.id);
      this.conditionDescribedby = () => {
        n25(), i21 || this.removeAttribute("id");
      };
    }
  }
  renderButtons() {
    return x`
            <sp-button-group class="button-group">
                <slot name="button"></slot>
            </sp-button-group>
        `;
  }
  render() {
    return x`
            <div class="grid">
                <div class="header">
                    ${this.renderHeading()} ${this.renderIcon()}
                </div>
                <sp-divider size="m" class="divider"></sp-divider>
                ${this.renderContent()} ${this.renderButtons()}
            </div>
        `;
  }
};
o41.instanceCount = 0, l12([e5(".content")], o41.prototype, "contentElement", 2), l12([n4({ type: String, reflect: true })], o41.prototype, "variant", 1);
var AlertDialog = o41;

// node_modules/@spectrum-web-components/dialog/src/Dialog.js
init_directives();

// node_modules/@spectrum-web-components/dialog/src/dialog.css.js
init_src();
var i17 = i`
    :host{box-sizing:border-box;inline-size:fit-content;min-inline-size:var(--mod-dialog-min-inline-size,var(--spectrum-dialog-min-inline-size));max-inline-size:100%;max-block-size:inherit;outline:none;display:flex}:host([size=s]){inline-size:var(--mod-dialog-confirm-small-width,var(--spectrum-dialog-confirm-small-width))}:host([size=m]){inline-size:var(--mod-dialog-confirm-medium-width,var(--spectrum-dialog-confirm-medium-width))}:host([size=l]){inline-size:var(--mod-dialog-confirm-large-width,var(--spectrum-dialog-confirm-large-width))}::slotted([slot=hero]){block-size:var(--mod-dialog-confirm-hero-height,var(--spectrum-dialog-confirm-hero-height));background-position:50%;background-size:cover;border-start-start-radius:var(--mod-dialog-confirm-border-radius,var(--spectrum-dialog-confirm-border-radius));border-start-end-radius:var(--mod-dialog-confirm-border-radius,var(--spectrum-dialog-confirm-border-radius));grid-area:hero;overflow:hidden}.grid{grid-template-columns:var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto 1fr auto minmax(0,auto)var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));grid-template-areas:"hero hero hero hero hero hero"". . . . . ."".heading header header header."".divider divider divider divider."".content content content content."".footer footer buttonGroup buttonGroup."". . . . . .";grid-template-rows:auto var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto auto 1fr auto var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));inline-size:100%;display:grid}::slotted([slot=heading]){font-size:var(--mod-dialog-confirm-title-text-size,var(--spectrum-dialog-confirm-title-text-size));font-weight:var(--mod-dialog-heading-font-weight,var(--spectrum-dialog-heading-font-weight));line-height:var(--mod-dialog-confirm-title-text-line-height,var(--spectrum-dialog-confirm-title-text-line-height));color:var(--mod-dialog-confirm-title-text-color,var(--spectrum-dialog-confirm-title-text-color));outline:none;grid-area:heading;margin:0;padding-inline-end:var(--mod-dialog-confirm-gap-size,var(--spectrum-dialog-confirm-gap-size))}.no-header::slotted([slot=heading]){grid-area:heading-start/heading-start/header-end/header-end;padding-inline-end:0}.header{box-sizing:border-box;outline:none;grid-area:header;justify-content:flex-end;align-items:center;display:flex}.divider{inline-size:100%;grid-area:divider;margin-block-start:var(--mod-dialog-confirm-divider-block-spacing-end,var(--spectrum-dialog-confirm-divider-block-spacing-end));margin-block-end:var(--mod-dialog-confirm-divider-block-spacing-start,var(--spectrum-dialog-confirm-divider-block-spacing-start))}:host([mode=fullscreen]) [name=heading]+.divider{margin-block-end:calc(var(--mod-dialog-confirm-divider-block-spacing-start,var(--spectrum-dialog-confirm-divider-block-spacing-start)) - var(--mod-dialog-confirm-description-padding,var(--spectrum-dialog-confirm-description-padding))*2)}:host([no-divider]) .divider{display:none}:host([no-divider]) ::slotted([slot=heading]){padding-block-end:calc(var(--mod-dialog-confirm-divider-block-spacing-end,var(--spectrum-dialog-confirm-divider-block-spacing-end)) + var(--mod-dialog-confirm-divider-block-spacing-start,var(--spectrum-dialog-confirm-divider-block-spacing-start)) + var(--mod-dialog-confirm-divider-height,var(--spectrum-dialog-confirm-divider-height)))}.content{box-sizing:border-box;-webkit-overflow-scrolling:touch;font-size:var(--mod-dialog-confirm-description-text-size,var(--spectrum-dialog-confirm-description-text-size));font-weight:var(--mod-dialog-confirm-description-font-weight,var(--spectrum-regular-font-weight));line-height:var(--mod-dialog-confirm-description-text-line-height,var(--spectrum-dialog-confirm-description-text-line-height));color:var(--mod-dialog-confirm-description-text-color,var(--spectrum-dialog-confirm-description-text-color));padding:calc(var(--mod-dialog-confirm-description-padding,var(--spectrum-dialog-confirm-description-padding))*2);margin:0 var(--mod-dialog-confirm-description-margin,var(--spectrum-dialog-confirm-description-margin));outline:none;grid-area:content;overflow-y:auto}.footer{outline:none;flex-wrap:wrap;grid-area:footer;padding-block-start:var(--mod-dialog-confirm-footer-padding-top,var(--spectrum-dialog-confirm-footer-padding-top));display:flex}.footer>*,.footer>.spectrum-Button+.spectrum-Button{margin-block-end:0}.button-group{grid-area:buttonGroup;justify-content:flex-end;padding-block-start:var(--mod-dialog-confirm-buttongroup-padding-top,var(--spectrum-dialog-confirm-buttongroup-padding-top));padding-inline-start:var(--mod-dialog-confirm-gap-size,var(--spectrum-dialog-confirm-gap-size));display:flex}.button-group.button-group--noFooter{grid-area:footer-start/footer-start/buttonGroup-end/buttonGroup-end}:host([dismissable]) .grid{grid-template-columns:var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto 1fr auto minmax(0,auto)minmax(0,var(--mod-dialog-confirm-close-button-size,var(--spectrum-dialog-confirm-close-button-size)))var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));grid-template-areas:"hero hero hero hero hero hero hero"". . . . .closeButton closeButton"".heading header header typeIcon closeButton closeButton"".divider divider divider divider divider."".content content content content content."".footer footer buttonGroup buttonGroup buttonGroup."". . . . . . .";grid-template-rows:auto var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto auto 1fr auto var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))}:host([dismissable]) .grid .button-group{display:none}:host([dismissable]) .grid .footer{color:var(--mod-dialog-confirm-description-text-color,var(--spectrum-dialog-confirm-description-text-color));grid-area:footer/footer/buttonGroup/buttonGroup}.close-button{grid-area:closeButton;place-self:start end;margin-block-start:var(--mod-dialog-confirm-close-button-padding,var(--spectrum-dialog-confirm-close-button-padding));margin-inline-end:var(--mod-dialog-confirm-close-button-padding,var(--spectrum-dialog-confirm-close-button-padding))}:host([mode=fullscreen]){block-size:100%;inline-size:100%}:host([mode=fullscreenTakeover]){border-radius:0;block-size:100%;inline-size:100%}:host([mode=fullscreen]),:host([mode=fullscreenTakeover]){max-block-size:none;max-inline-size:none}:host([mode=fullscreen]) .grid,:host([mode=fullscreenTakeover]) .grid{grid-template-columns:var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))1fr auto auto var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));grid-template-rows:var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto auto 1fr var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));grid-template-areas:". . . . ."".heading header buttonGroup."".divider divider divider."".content content content."". . . . .";display:grid}:host([mode=fullscreen]) ::slotted([slot=heading]),:host([mode=fullscreenTakeover]) ::slotted([slot=heading]){font-size:var(--mod-dialog-fullscreen-header-text-size,var(--spectrum-dialog-fullscreen-header-text-size))}:host([mode=fullscreen]) .content,:host([mode=fullscreenTakeover]) .content{max-block-size:none}:host([mode=fullscreen]) .button-group,:host([mode=fullscreen]) .footer,:host([mode=fullscreenTakeover]) .button-group,:host([mode=fullscreenTakeover]) .footer{padding-block-start:0}:host([mode=fullscreen]) .footer,:host([mode=fullscreenTakeover]) .footer{display:none}:host([mode=fullscreen]) .button-group,:host([mode=fullscreenTakeover]) .button-group{grid-area:buttonGroup;align-self:start}@media screen and (width<=700px){.grid{grid-template-columns:var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto 1fr auto minmax(0,auto)var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));grid-template-areas:"hero hero hero hero hero hero"". . . . . ."".heading heading heading heading."".header header header header."".divider divider divider divider."".content content content content."".footer footer buttonGroup buttonGroup."". . . . . ."}.grid,:host([dismissable]) .grid{grid-template-rows:auto var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto auto auto 1fr auto var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))}:host([dismissable]) .grid{grid-template-columns:var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto 1fr auto minmax(0,auto)minmax(0,var(--mod-dialog-confirm-close-button-size,var(--spectrum-dialog-confirm-close-button-size)))var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));grid-template-areas:"hero hero hero hero hero hero hero"". . . . .closeButton closeButton"".heading heading heading heading closeButton closeButton"".header header header header header."".divider divider divider divider divider."".content content content content content."".footer footer buttonGroup buttonGroup buttonGroup."". . . . . . ."}.header{justify-content:flex-start}:host([mode=fullscreen]) .grid,:host([mode=fullscreenTakeover]) .grid{grid-template-columns:var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))1fr var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));grid-template-rows:var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid))auto auto auto 1fr auto var(--mod-dialog-confirm-padding-grid,var(--spectrum-dialog-confirm-padding-grid));grid-template-areas:". . ."".heading."".header."".divider."".content."".buttonGroup."". . .";display:grid}:host([mode=fullscreen]) .button-group,:host([mode=fullscreenTakeover]) .button-group{padding-block-start:var(--mod-dialog-confirm-buttongroup-padding-top,var(--spectrum-dialog-confirm-buttongroup-padding-top))}:host([mode=fullscreen]) ::slotted([slot=heading]),:host([mode=fullscreenTakeover]) ::slotted([slot=heading]){font-size:var(--mod-dialog-confirm-title-text-size,var(--spectrum-dialog-confirm-title-text-size))}}@media (forced-colors:active){:host{border:solid}}:host{--spectrum-dialog-fullscreen-header-text-size:var(--system-dialog-fullscreen-header-text-size);--spectrum-dialog-min-inline-size:var(--system-dialog-min-inline-size);--spectrum-dialog-confirm-small-width:var(--system-dialog-confirm-small-width);--spectrum-dialog-confirm-medium-width:var(--system-dialog-confirm-medium-width);--spectrum-dialog-confirm-large-width:var(--system-dialog-confirm-large-width);--spectrum-dialog-confirm-divider-block-spacing-start:var(--system-dialog-confirm-divider-block-spacing-start);--spectrum-dialog-confirm-divider-block-spacing-end:var(--system-dialog-confirm-divider-block-spacing-end);--spectrum-dialog-confirm-description-text-color:var(--system-dialog-confirm-description-text-color);--spectrum-dialog-confirm-title-text-color:var(--system-dialog-confirm-title-text-color);--spectrum-dialog-confirm-description-text-line-height:var(--system-dialog-confirm-description-text-line-height);--spectrum-dialog-confirm-title-text-line-height:var(--system-dialog-confirm-title-text-line-height);--spectrum-dialog-heading-font-weight:var(--system-dialog-heading-font-weight);--spectrum-dialog-confirm-description-padding:var(--system-dialog-confirm-description-padding);--spectrum-dialog-confirm-description-margin:var(--system-dialog-confirm-description-margin);--spectrum-dialog-confirm-footer-padding-top:var(--system-dialog-confirm-footer-padding-top);--spectrum-dialog-confirm-gap-size:var(--system-dialog-confirm-gap-size);--spectrum-dialog-confirm-buttongroup-padding-top:var(--system-dialog-confirm-buttongroup-padding-top);--spectrum-dialog-confirm-close-button-size:var(--system-dialog-confirm-close-button-size);--spectrum-dialog-confirm-close-button-padding:var(--system-dialog-confirm-close-button-padding);--spectrum-dialog-confirm-divider-height:var(--system-dialog-confirm-divider-height)}:host{--swc-alert-dialog-error-icon-color:var(--spectrum-negative-visual-color)}.content{overflow:hidden}.footer{color:var(--spectrum-dialog-confirm-description-text-color,var(--spectrum-gray-800))}.type-icon{color:var(--mod-alert-dialog-error-icon-color,var(--swc-alert-dialog-error-icon-color));grid-area:typeIcon}.content[tabindex]{overflow:auto}::slotted(img[slot=hero]){width:100%;height:auto}.grid{grid-template-areas:"hero hero hero hero hero hero"". . . . . ."".heading heading heading typeIcon."".divider divider divider divider."".content content content content."".footer footer buttonGroup buttonGroup."". . . . . .";inline-size:100%;display:grid}:host(:not([error],[dismissable],[mode])) .grid{grid-template-areas:"hero hero hero hero hero hero"". . . . . ."".heading heading heading heading."".divider divider divider divider."".content content content content."".footer footer buttonGroup buttonGroup."". . . . . .";inline-size:100%;display:grid}
`;
var dialog_css_default = i17;

// node_modules/@spectrum-web-components/dialog/src/Dialog.js
var a13 = Object.defineProperty;
var c27 = Object.getOwnPropertyDescriptor;
var t25 = (u36, i21, e36, n25) => {
  for (var r25 = n25 > 1 ? void 0 : n25 ? c27(i21, e36) : i21, p30 = u36.length - 1, d22; p30 >= 0; p30--) (d22 = u36[p30]) && (r25 = (n25 ? d22(i21, e36, r25) : d22(r25)) || r25);
  return n25 && r25 && a13(i21, e36, r25), r25;
};
var Dialog = class extends ObserveSlotPresence(AlertDialog, ['[slot="hero"]', '[slot="footer"]', '[slot="button"]']) {
  constructor() {
    super(...arguments);
    this.error = false;
    this.dismissable = false;
    this.dismissLabel = "Close";
    this.noDivider = false;
  }
  static get styles() {
    return [dialog_css_default];
  }
  get hasFooter() {
    return this.getSlotContentPresence('[slot="footer"]');
  }
  get hasButtons() {
    return this.getSlotContentPresence('[slot="button"]');
  }
  get hasHero() {
    return this.getSlotContentPresence('[slot="hero"]');
  }
  close() {
    this.dispatchEvent(new Event("close", { bubbles: true, composed: true, cancelable: true }));
  }
  renderHero() {
    return x`
            <slot name="hero"></slot>
        `;
  }
  renderFooter() {
    return x`
            <div class="footer">
                <slot name="footer"></slot>
            </div>
        `;
  }
  renderButtons() {
    const e36 = { "button-group": true, "button-group--noFooter": !this.hasFooter };
    return x`
            <sp-button-group class=${e10(e36)}>
                <slot name="button"></slot>
            </sp-button-group>
        `;
  }
  renderDismiss() {
    return x`
            <sp-close-button
                class="close-button"
                label=${this.dismissLabel}
                quiet
                size="m"
                @click=${this.close}
            ></sp-close-button>
        `;
  }
  render() {
    return x`
            <div class="grid">
                ${this.renderHero()} ${this.renderHeading()}
                ${this.error ? x`
                          <sp-icon-alert class="type-icon"></sp-icon-alert>
                      ` : E}
                ${this.noDivider ? E : x`
                          <sp-divider size="m" class="divider"></sp-divider>
                      `}
                ${this.renderContent()}
                ${this.hasFooter ? this.renderFooter() : E}
                ${this.hasButtons ? this.renderButtons() : E}
                ${this.dismissable ? this.renderDismiss() : E}
            </div>
        `;
  }
  shouldUpdate(e36) {
    return e36.has("mode") && this.mode && (this.dismissable = false), e36.has("dismissable") && this.dismissable && (this.dismissable = !this.mode), super.shouldUpdate(e36);
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.setAttribute("role", "dialog");
  }
  updated(e36) {
    super.updated(e36);
  }
};
t25([e5(".close-button")], Dialog.prototype, "closeButton", 2), t25([n4({ type: Boolean, reflect: true })], Dialog.prototype, "error", 2), t25([n4({ type: Boolean, reflect: true })], Dialog.prototype, "dismissable", 2), t25([n4({ type: String, reflect: true, attribute: "dismiss-label" })], Dialog.prototype, "dismissLabel", 2), t25([n4({ type: Boolean, reflect: true, attribute: "no-divider" })], Dialog.prototype, "noDivider", 2), t25([n4({ type: String, reflect: true })], Dialog.prototype, "mode", 2), t25([n4({ type: String, reflect: true })], Dialog.prototype, "size", 2);

// node_modules/@spectrum-web-components/dialog/sp-dialog.js
init_define_element();
defineElement("sp-dialog", Dialog);

// node_modules/@spectrum-web-components/dialog/src/DialogWrapper.js
init_src();
init_decorators2();
init_directives();
init_sp_underlay();

// node_modules/@spectrum-web-components/dialog/src/DialogBase.js
init_src();
init_decorators2();
init_sp_underlay();

// node_modules/@spectrum-web-components/modal/src/modal-wrapper.css.js
init_src();
var e25 = i`
    :host{box-sizing:border-box;visibility:hidden;pointer-events:none;z-index:1;block-size:stretch;inline-size:100vw;transition:visibility 0s linear var(--mod-modal-transition-animation-duration,var(--spectrum-animation-duration-100));justify-content:center;align-items:center;display:flex;position:fixed;inset-block-start:0;inset-inline-start:0}:host([open]){visibility:visible}@media only screen and (device-height<=350px),only screen and (device-width<=400px){:host([responsive]){border-radius:0;block-size:100%;max-block-size:100%;inline-size:100%;max-inline-size:100%;margin-block-start:0}}
`;
var modal_wrapper_css_default = e25;

// node_modules/@spectrum-web-components/dialog/src/DialogBase.js
init_modal_css();
init_src2();
init_first_focusable_in();
var p20 = Object.defineProperty;
var u22 = Object.getOwnPropertyDescriptor;
var s13 = (l16, n25, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? u22(n25, e36) : n25, o52 = l16.length - 1, r25; o52 >= 0; o52--) (r25 = l16[o52]) && (t34 = (i21 ? r25(n25, e36, t34) : r25(t34)) || t34);
  return i21 && t34 && p20(n25, e36, t34), t34;
};
var DialogBase = class extends FocusVisiblePolyfillMixin(SpectrumElement) {
  constructor() {
    super(...arguments);
    this.dismissable = false;
    this.open = false;
    this.responsive = false;
    this.transitionPromise = Promise.resolve();
    this.resolveTransitionPromise = () => {
    };
    this.underlay = false;
    this.animating = false;
  }
  static get styles() {
    return [modal_wrapper_css_default, modal_css_default];
  }
  get dialog() {
    return this.shadowRoot.querySelector("slot").assignedElements()[0] || this;
  }
  async focus() {
    if (this.shadowRoot) {
      const e36 = firstFocusableIn(this.dialog);
      e36 ? (e36.updateComplete && await e36.updateComplete, e36.focus()) : this.dialog.focus();
    } else super.focus();
  }
  overlayWillCloseCallback() {
    return this.open ? (this.close(), true) : this.animating;
  }
  dismiss() {
    this.dismissable && this.close();
  }
  handleClose(e36) {
    e36.stopPropagation(), this.close();
  }
  close() {
    this.open = false;
  }
  dispatchClosed() {
    this.dispatchEvent(new Event("close", { bubbles: true }));
  }
  handleTransitionEvent(e36) {
    this.dispatchEvent(new TransitionEvent(e36.type, { bubbles: true, composed: true, propertyName: e36.propertyName }));
  }
  handleUnderlayTransitionend(e36) {
    !this.open && e36.propertyName === "visibility" && this.resolveTransitionPromise(), this.handleTransitionEvent(e36);
  }
  handleModalTransitionend(e36) {
    (this.open || !this.underlay) && this.resolveTransitionPromise(), this.handleTransitionEvent(e36);
  }
  get hasTransitionDuration() {
    const e36 = this.shadowRoot.querySelector(".modal"), i21 = window.getComputedStyle(e36).transitionDuration;
    for (const o52 of i21.split(",")) if (parseFloat(o52) > 0) return true;
    const t34 = this.shadowRoot.querySelector("sp-underlay");
    if (t34) {
      const o52 = window.getComputedStyle(t34).transitionDuration;
      for (const r25 of o52.split(",")) if (parseFloat(r25) > 0) return true;
    }
    return false;
  }
  update(e36) {
    if (e36.has("open") && e36.get("open") !== void 0) {
      const i21 = this.hasTransitionDuration;
      this.animating = true, this.transitionPromise = new Promise((t34) => {
        this.resolveTransitionPromise = () => {
          this.animating = false, !this.open && i21 && this.dispatchClosed(), t34();
        };
      }), !this.open && !i21 && this.dispatchClosed();
    }
    super.update(e36);
  }
  renderDialog() {
    return x`
            <slot></slot>
        `;
  }
  render() {
    return x`
            ${this.underlay ? x`
                      <sp-underlay
                          ?open=${this.open}
                          @close=${this.dismiss}
                          @transitionrun=${this.handleTransitionEvent}
                          @transitionend=${this.handleUnderlayTransitionend}
                          @transitioncancel=${this.handleTransitionEvent}
                      ></sp-underlay>
                  ` : E}
            <div
                class="modal ${this.mode}"
                @transitionrun=${this.handleTransitionEvent}
                @transitionend=${this.handleModalTransitionend}
                @transitioncancel=${this.handleTransitionEvent}
                @close=${this.handleClose}
            >
                ${this.renderDialog()}
            </div>
        `;
  }
  updated(e36) {
    e36.has("open") && this.open && "updateComplete" in this.dialog && "shouldManageTabOrderForScrolling" in this.dialog && this.dialog.updateComplete.then(() => {
      this.dialog.shouldManageTabOrderForScrolling();
    });
  }
  async getUpdateComplete() {
    const e36 = await super.getUpdateComplete();
    return await this.transitionPromise, e36;
  }
};
s13([n4({ type: Boolean, reflect: true })], DialogBase.prototype, "dismissable", 2), s13([n4({ type: Boolean, reflect: true })], DialogBase.prototype, "open", 2), s13([n4({ type: String, reflect: true })], DialogBase.prototype, "mode", 2), s13([n4({ type: Boolean })], DialogBase.prototype, "responsive", 2), s13([n4({ type: Boolean })], DialogBase.prototype, "underlay", 2);

// node_modules/@spectrum-web-components/dialog/src/DialogWrapper.js
var h13 = Object.defineProperty;
var u23 = Object.getOwnPropertyDescriptor;
var e26 = (c33, o52, r25, n25) => {
  for (var i21 = n25 > 1 ? void 0 : n25 ? u23(o52, r25) : o52, b12 = c33.length - 1, d22; b12 >= 0; b12--) (d22 = c33[b12]) && (i21 = (n25 ? d22(o52, r25, i21) : d22(i21)) || i21);
  return n25 && i21 && h13(o52, r25, i21), i21;
};
var DialogWrapper = class extends DialogBase {
  constructor() {
    super(...arguments);
    this.error = false;
    this.cancelLabel = "";
    this.confirmLabel = "";
    this.dismissLabel = "Close";
    this.footer = "";
    this.hero = "";
    this.heroLabel = "";
    this.noDivider = false;
    this.secondaryLabel = "";
    this.headline = "";
  }
  static get styles() {
    return [...super.styles];
  }
  get dialog() {
    return this.shadowRoot.querySelector("sp-dialog");
  }
  clickSecondary() {
    this.dispatchEvent(new Event("secondary", { bubbles: true }));
  }
  clickCancel() {
    this.dispatchEvent(new Event("cancel", { bubbles: true }));
  }
  clickConfirm() {
    this.dispatchEvent(new Event("confirm", { bubbles: true }));
  }
  renderDialog() {
    const r25 = this.noDivider || !this.headline || this.headlineVisibility === "none";
    return x`
            <sp-dialog
                ?dismissable=${this.dismissable}
                dismiss-label=${this.dismissLabel}
                ?no-divider=${r25}
                ?error=${this.error}
                mode=${o9(this.mode)}
                size=${o9(this.size)}
            >
                ${this.hero ? x`
                          <img
                              src="${this.hero}"
                              slot="hero"
                              aria-hidden=${o9(this.heroLabel ? void 0 : "true")}
                              alt=${o9(this.heroLabel ? this.heroLabel : void 0)}
                          />
                      ` : E}
                ${this.headline ? x`
                          <h2
                              slot="heading"
                              ?hidden=${this.headlineVisibility === "none"}
                          >
                              ${this.headline}
                          </h2>
                      ` : E}
                <slot></slot>
                ${this.footer ? x`
                          <div slot="footer">${this.footer}</div>
                      ` : E}
                ${this.cancelLabel ? x`
                          <sp-button
                              variant="secondary"
                              treatment="outline"
                              slot="button"
                              @click=${this.clickCancel}
                          >
                              ${this.cancelLabel}
                          </sp-button>
                      ` : E}
                ${this.secondaryLabel ? x`
                          <sp-button
                              variant="primary"
                              treatment="outline"
                              slot="button"
                              @click=${this.clickSecondary}
                          >
                              ${this.secondaryLabel}
                          </sp-button>
                      ` : E}
                ${this.confirmLabel ? x`
                          <sp-button
                              variant="accent"
                              slot="button"
                              @click=${this.clickConfirm}
                          >
                              ${this.confirmLabel}
                          </sp-button>
                      ` : E}
            </sp-dialog>
        `;
  }
};
e26([n4({ type: Boolean, reflect: true })], DialogWrapper.prototype, "error", 2), e26([n4({ attribute: "cancel-label" })], DialogWrapper.prototype, "cancelLabel", 2), e26([n4({ attribute: "confirm-label" })], DialogWrapper.prototype, "confirmLabel", 2), e26([n4({ attribute: "dismiss-label" })], DialogWrapper.prototype, "dismissLabel", 2), e26([n4()], DialogWrapper.prototype, "footer", 2), e26([n4()], DialogWrapper.prototype, "hero", 2), e26([n4({ attribute: "hero-label" })], DialogWrapper.prototype, "heroLabel", 2), e26([n4({ type: Boolean, reflect: true, attribute: "no-divider" })], DialogWrapper.prototype, "noDivider", 2), e26([n4({ type: String, reflect: true })], DialogWrapper.prototype, "size", 2), e26([n4({ attribute: "secondary-label" })], DialogWrapper.prototype, "secondaryLabel", 2), e26([n4()], DialogWrapper.prototype, "headline", 2), e26([n4({ type: String, attribute: "headline-visibility" })], DialogWrapper.prototype, "headlineVisibility", 2);

// node_modules/@spectrum-web-components/dialog/sp-dialog-wrapper.js
init_define_element();
defineElement("sp-dialog-wrapper", DialogWrapper);

// src/experience-elements-editor.js
init_sp_underlay();

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconViewList.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ViewList.js
var ViewListIcon = ({ width: t34 = 24, height: r25 = 24, hidden: l16 = false, title: e36 = "View List" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="m17.25,4.49811H7.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h9.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m17.25,10.49811H7.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h9.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m17.25,16.49811H7.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h9.5c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m4.75,4.49811h-2c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h2c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m4.75,10.49811h-2c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h2c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m4.75,16.49811h-2c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h2c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ViewList.js
var ViewListIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: i21 = "View List" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${i21}"
  >
    <rect height="8" rx="1" ry="1" width="8" x="2" y="2" />
    <rect height="4" rx=".5" ry=".5" width="22" x="12" y="4" />
    <rect height="4" rx=".5" ry=".5" width="22" x="12" y="16" />
    <rect height="4" rx=".5" ry=".5" width="22" x="12" y="28" />
    <rect height="8" rx="1" ry="1" width="8" x="2" y="14" />
    <rect height="8" rx="1" ry="1" width="8" x="2" y="26" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconViewList.js
var IconViewList = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ViewListIcon({ hidden: !this.label, title: this.label }) : ViewListIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-view-list.js
init_define_element();
defineElement("sp-icon-view-list", IconViewList);

// src/features/content-tree/tree-nav.js
init_lit();

// src/features/content-tree/tree-nav.css.js
init_lit();
var treeNavStyles = i`
  :host {
    display: block;
    height: 100%;
    color: var(--spectrum-alias-text-color);
  }

  /* Honor the hidden attribute on the host even with component styles */
  :host([hidden]) {
    display: none !important;
  }

  .nav-root {
    /* Apply sidebar card styling directly to the tree */
    height: calc(100% - var(--spectrum-global-dimension-size-400));
    margin: var(--spectrum-global-dimension-size-200) 0 0 0;
    background: var(--spectrum-alias-component-background-color);
    border: 1px solid var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-global-dimension-size-100);
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    padding: var(--spectrum-global-dimension-size-100);
  }

  .controls {
    display: flex;
    gap: var(--spectrum-global-dimension-size-100);
    align-items: center;
    padding: var(--spectrum-global-dimension-size-100)
      var(--spectrum-global-dimension-size-0);
  }

  .tree {
    position: relative;
    flex: 1 1 auto;
    min-height: 0;
    overflow: auto;           /* enable both vertical & horizontal */
    overflow-x: auto;
    overflow-y: auto;
    padding: var(--spectrum-global-dimension-size-100) 0;
  }

  .node {
    --indent: 0px;
    padding-left: calc(var(--indent));
    /* ensure deep indentation contributes to overall content width for horizontal scrolling */
    width: max-content;
  }

  .node-row {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-125);
    padding: var(--spectrum-global-dimension-size-65)
      var(--spectrum-global-dimension-size-100);
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    transition: background 120ms ease, transform 120ms ease;
    outline: none;
    /* avoid wrapping so long labels/indent create horizontal overflow */
    white-space: nowrap;
    /* ensure row contributes its intrinsic width (indent + icons + capped label) */
    width: max-content;
    /* scroll margin for smooth navigation */
    scroll-margin-top: 20px;
    scroll-margin-bottom: 20px;
  }

  .node-row:hover {
    background: var(--spectrum-menu-item-background-color-hover);
  }

  /* Drag & drop source/target cues */
  .node-row[drag-source] {
    opacity: 0.8;
  }
  .node-row[data-drop-allowed] {
    outline: 2px dashed var(--spectrum-alias-focus-color);
    outline-offset: -2px;
    background: color-mix(in srgb, var(--spectrum-global-color-blue-400) 16%, transparent);
  }
  .node-row[data-drop-pos="before"] {
    box-shadow: inset 0 2px 0 var(--spectrum-alias-focus-color);
  }
  .node-row[data-drop-pos="after"] {
    box-shadow: inset 0 -2px 0 var(--spectrum-alias-focus-color);
  }
  .node-row[data-drop-denied] {
    cursor: not-allowed;
  }

  /* Dedicated placeholder line for precise insertion feedback */
  .drop-placeholder {
    height: 8px;
    position: relative;
  }
  .drop-placeholder::before {
    content: "";
    position: absolute;
    left: 0;
    right: 0;
    top: 50%;
    height: 2px;
    background: var(--spectrum-alias-focus-color);
    transform: translateY(-50%);
    border-radius: 1px;
  }

  .node-row[selected] {
    background: var(--spectrum-menu-item-background-color-hover);
    border-left: 2px solid var(--spectrum-alias-focus-color);
  }

  /* Browser focus ring inside the tree */
  .node-row:focus {
    box-shadow: 0 0 0 2px var(--spectrum-alias-focus-color) inset;
  }

  /* Persist visual focus only when nav is active (keyboard or recent interaction) */
  :host([data-nav-active]) .node-row[focused]:not([selected]) {
    box-shadow: 0 0 0 1px var(--spectrum-alias-focus-color) inset;
  }

  .caret {
    width: 16px;
    height: 16px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transform: none;
    transition: transform 160ms ease;
    color: var(--spectrum-alias-icon-color);
  }

  .caret[expanded] {
    transform: rotate(90deg);
  }

  .caret[placeholder] {
    opacity: 0;
    pointer-events: none;
  }

  .label {
    flex: 1 1 auto;
    font-size: var(--spectrum-global-dimension-size-175);
    line-height: 1.3;
    /* allow label to shrink and ellipsize within available space */
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: min(100%, var(--ee-tree-label-max, 480px));
  }

  .node-row[data-node-kind="slot"] .label {
    color: var(--spectrum-indigo-900);
  }

  .icon-slot {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    color: var(--spectrum-alias-icon-color);
  }

  .children {
    overflow: hidden;
    will-change: height, opacity;
    transition: height 140ms ease, opacity 140ms ease;
    opacity: 1;
    /* allow descendant widths to contribute to horizontal scroll calculations */
  }

  .children[collapsed] {
    height: 0 !important;
    opacity: 0;
  }
`;

// src/features/content-tree/tree-nav-actions.js
function handleDropOnSlot(context) {
  const { store, domStore, dragged, slotNode } = context;
  if (!dragged || !slotNode || slotNode.kind !== "slot") {
    return false;
  }
  if (!domStore) {
    console.error("Dom store required for drop handling");
    return false;
  }
  const parent = slotNode.parentElement;
  const slotName = domStore.normalizeSlotName(slotNode.slotName) || domStore.defaultSlotName;
  store?.richText?.disposeInlineEditing?.();
  store?.editorStore?.richText?.disposeInlineEditing?.();
  if (!parent) {
    return false;
  }
  if (dragged.contains(parent)) {
    return false;
  }
  domStore.setElementSlot(dragged, slotName);
  domStore.moveElement(dragged, parent, Infinity);
  store?.toolbar?.elementMoved?.(dragged);
  store?.history?.scheduleSnapshot?.();
  store?.setLastAction?.("tree:drop", {
    slot: slotName,
    tag: dragged.tagName?.toLowerCase?.()
  });
  store?.selection?.selectElement?.(dragged);
  return true;
}
function handleReorderDrop(context) {
  const { store, domStore, dragged, targetEl, before } = context;
  if (!dragged || !targetEl) {
    return false;
  }
  if (!domStore) {
    console.error("Dom store required for reorder handling");
    return false;
  }
  const parent = targetEl.parentElement;
  if (!parent) {
    return false;
  }
  store?.richText?.disposeInlineEditing?.();
  store?.editorStore?.richText?.disposeInlineEditing?.();
  const siblings = domStore.getAuthorableChildren(parent);
  const targetIndex = siblings.indexOf(targetEl);
  if (targetIndex === -1) {
    console.warn("Target element missing from authorable list");
    return false;
  }
  const position = before ? targetIndex : targetIndex + 1;
  domStore.moveElement(dragged, parent, position);
  store?.toolbar?.elementMoved?.(dragged);
  store?.history?.scheduleSnapshot?.();
  store?.setLastAction?.("tree:reorder-drop", {
    tag: dragged.tagName?.toLowerCase?.()
  });
  store?.selection?.selectElement?.(dragged);
  return true;
}
function handleDropIntoDefault(context) {
  const { store, domStore, dragged, targetEl } = context;
  if (!dragged || !targetEl) {
    return false;
  }
  if (!domStore) {
    console.error("Dom store required for default drop");
    return false;
  }
  if (dragged.contains(targetEl)) {
    return false;
  }
  store?.richText?.disposeInlineEditing?.();
  store?.editorStore?.richText?.disposeInlineEditing?.();
  domStore.setElementSlot(dragged, null);
  domStore.moveElement(dragged, targetEl, Infinity);
  store?.toolbar?.elementMoved?.(dragged);
  store?.history?.scheduleSnapshot?.();
  store?.setLastAction?.("tree:drop-default", {
    parent: targetEl.tagName?.toLowerCase?.(),
    tag: dragged.tagName?.toLowerCase?.()
  });
  store?.selection?.selectElement?.(dragged);
  return true;
}

// src/features/content-tree/tree-nav.js
init_sp_popover();

// node_modules/@spectrum-web-components/search/src/Search.js
init_src();
init_decorators2();
init_directives();

// node_modules/@spectrum-web-components/search/src/search.css.js
init_src();
var e27 = i`
    #textfield{--spectrum-search-inline-size:var(--spectrum-field-width);--spectrum-search-block-size:var(--spectrum-component-height-100);--spectrum-search-button-inline-size:var(--spectrum-search-block-size);--spectrum-search-min-inline-size:calc(var(--spectrum-search-field-minimum-width-multiplier)*var(--spectrum-search-block-size));--spectrum-search-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-search-text-to-icon:var(--spectrum-text-to-visual-100);--spectrum-search-to-help-text:var(--spectrum-help-text-to-component);--spectrum-search-top-to-text:var(--spectrum-component-top-to-text-100);--spectrum-search-bottom-to-text:var(--spectrum-component-bottom-to-text-100);--spectrum-search-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-search-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--spectrum-search-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-search-font-family:var(--spectrum-sans-font-family-stack);--spectrum-search-font-weight:var(--spectrum-regular-font-weight);--spectrum-search-font-style:var(--spectrum-default-font-style);--spectrum-search-line-height:var(--spectrum-line-height-100);--spectrum-search-color-default:var(--spectrum-neutral-content-color-default);--spectrum-search-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-search-color-focus:var(--spectrum-neutral-content-color-focus);--spectrum-search-color-focus-hover:var(--spectrum-neutral-content-color-focus-hover);--spectrum-search-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-search-border-width:var(--spectrum-border-width-100);--spectrum-search-color-disabled:var(--spectrum-disabled-content-color);--mod-textfield-font-family:var(--mod-search-font-family,var(--spectrum-search-font-family));--mod-textfield-font-weight:var(--mod-search-font-weight,var(--spectrum-search-font-weight));--mod-textfield-corner-radius:var(--mod-search-border-radius,var(--spectrum-search-border-radius));--mod-textfield-border-width:var(--mod-search-border-width,var(--spectrum-search-border-width));--mod-textfield-focus-indicator-gap:var(--mod-search-focus-indicator-gap,var(--spectrum-search-focus-indicator-gap));--mod-textfield-focus-indicator-width:var(--mod-search-focus-indicator-thickness,var(--spectrum-search-focus-indicator-thickness));--mod-textfield-focus-indicator-color:var(--mod-search-focus-indicator-color,var(--spectrum-search-focus-indicator-color));--mod-textfield-text-color-default:var(--mod-search-color-default,var(--spectrum-search-color-default));--mod-textfield-text-color-hover:var(--mod-search-color-hover,var(--spectrum-search-color-hover));--mod-textfield-text-color-focus:var(--mod-search-color-focus,var(--spectrum-search-color-focus));--mod-textfield-text-color-focus-hover:var(--mod-search-color-focus-hover,var(--spectrum-search-color-focus-hover));--mod-textfield-text-color-keyboard-focus:var(--mod-search-color-key-focus,var(--spectrum-search-color-key-focus));--mod-textfield-text-color-disabled:var(--mod-search-color-disabled,var(--spectrum-search-color-disabled));--mod-textfield-border-color:var(--mod-search-border-color-default,var(--spectrum-search-border-color-default));--mod-textfield-border-color-hover:var(--mod-search-border-color-hover,var(--spectrum-search-border-color-hover));--mod-textfield-border-color-focus:var(--mod-search-border-color-focus,var(--spectrum-search-border-color-focus));--mod-textfield-border-color-focus-hover:var(--mod-search-border-color-focus-hover,var(--spectrum-search-border-color-focus-hover));--mod-textfield-border-color-keyboard-focus:var(--mod-search-border-color-key-focus,var(--spectrum-search-border-color-key-focus));--mod-textfield-border-color-disabled:var(--mod-search-border-color-disabled,var(--spectrum-search-border-color-disabled));--mod-textfield-background-color:var(--mod-search-background-color,var(--spectrum-search-background-color));--mod-textfield-background-color-disabled:var(--mod-search-background-color-disabled,var(--spectrum-search-background-color-disabled));inline-size:var(--mod-search-inline-size,var(--spectrum-search-inline-size));min-inline-size:var(--mod-search-min-inline-size,var(--spectrum-search-min-inline-size));display:inline-block;position:relative}#textfield .spectrum-HelpText{margin-block-start:var(--mod-search-to-help-text,var(--spectrum-search-to-help-text))}:host([size=s]) #textfield{--spectrum-search-block-size:var(--spectrum-component-height-75);--spectrum-search-icon-size:var(--spectrum-workflow-icon-size-75);--spectrum-search-text-to-icon:var(--spectrum-text-to-visual-75)}:host([size=l]) #textfield{--spectrum-search-block-size:var(--spectrum-component-height-200);--spectrum-search-icon-size:var(--spectrum-workflow-icon-size-200);--spectrum-search-text-to-icon:var(--spectrum-text-to-visual-200)}:host([size=xl]) #textfield{--spectrum-search-block-size:var(--spectrum-component-height-300);--spectrum-search-icon-size:var(--spectrum-workflow-icon-size-300);--spectrum-search-text-to-icon:var(--spectrum-text-to-visual-300)}@media (forced-colors:active){#textfield #textfield,#textfield #textfield .input{--highcontrast-search-color-default:CanvasText;--highcontrast-search-color-hover:CanvasText;--highcontrast-search-color-focus:CanvasText;--highcontrast-search-color-disabled:GrayText}#textfield #button .spectrum-ClearButton-fill{forced-color-adjust:none;background-color:initial}}#button{position:absolute;inset-block-start:0;inset-inline-end:0}#button,#button .spectrum-ClearButton-fill{border-radius:var(--mod-search-border-radius,var(--spectrum-search-border-radius))}#textfield.is-disabled #button{display:none}#textfield{inline-size:100%}.icon-search{--spectrum-search-color:var(--highcontrast-search-color-default,var(--mod-search-color-default,var(--spectrum-search-color-default)));color:var(--spectrum-search-color);margin-block:auto;display:block;position:absolute;inset-block:0}#textfield.is-focused .icon-search{--spectrum-search-color:var(--highcontrast-search-color-focus,var(--mod-search-color-focus,var(--spectrum-search-color-focus)))}#textfield.is-keyboardFocused .icon-search{--spectrum-search-color:var(--highcontrast-search-color-focus,var(--mod-search-color-key-focus,var(--spectrum-search-color-key-focus)))}#textfield.is-disabled .icon-search{--spectrum-search-color:var(--highcontrast-search-color-disabled,var(--mod-search-color-disabled,var(--spectrum-search-color-disabled)))}@media (hover:hover){#textfield:hover .icon-search{--spectrum-search-color:var(--highcontrast-search-color-hover,var(--mod-search-color-hover,var(--spectrum-search-color-hover)))}#textfield.is-focused:hover .icon-search{--spectrum-search-color:var(--highcontrast-search-color-focus,var(--mod-search-color-focus-hover,var(--spectrum-search-color-focus-hover)))}#textfield.is-disabled:hover .icon-search{--spectrum-search-color:var(--highcontrast-search-color-disabled,var(--mod-search-color-disabled,var(--spectrum-search-color-disabled)))}}.input{appearance:none;block-size:var(--mod-search-block-size,var(--spectrum-search-block-size));font-style:var(--mod-search-font-style,var(--spectrum-search-font-style));line-height:var(--mod-search-line-height,var(--spectrum-search-line-height));padding-block-start:calc(var(--mod-search-top-to-text,var(--spectrum-search-top-to-text)) - var(--mod-search-border-width,var(--spectrum-search-border-width)));padding-block-end:calc(var(--mod-search-bottom-to-text,var(--spectrum-search-bottom-to-text)) - var(--mod-search-border-width,var(--spectrum-search-border-width)))}.input::-webkit-search-cancel-button,.input::-webkit-search-decoration{appearance:none}:host(:not([quiet])) #textfield .icon-search{inset-inline-start:var(--mod-search-edge-to-visual,var(--spectrum-search-edge-to-visual))}:host(:not([quiet])) #textfield .input{padding-inline-start:calc(var(--mod-search-edge-to-visual,var(--spectrum-search-edge-to-visual)) - var(--mod-search-border-width,var(--spectrum-search-border-width)) + var(--mod-search-icon-size,var(--spectrum-search-icon-size)) + var(--mod-search-text-to-icon,var(--spectrum-search-text-to-icon)));padding-inline-end:var(--mod-search-button-inline-size,var(--spectrum-search-button-inline-size))}:host([quiet]){--spectrum-search-background-color:transparent;--spectrum-search-background-color-disabled:transparent;--spectrum-search-border-color-disabled:var(--spectrum-disabled-border-color);--mod-search-border-radius:0;--mod-search-edge-to-visual:var(--spectrum-field-edge-to-visual-quiet)}:host([quiet]) .input{border-radius:var(--mod-search-border-radius,var(--spectrum-search-border-radius));padding-block-start:var(--mod-search-top-to-text,var(--spectrum-search-top-to-text));padding-inline-start:calc(var(--mod-search-edge-to-visual,var(--spectrum-search-edge-to-visual)) + var(--mod-search-icon-size,var(--spectrum-search-icon-size)) + var(--mod-search-text-to-icon,var(--spectrum-search-text-to-icon)));padding-inline-end:var(--mod-search-button-inline-size,var(--spectrum-search-button-inline-size))}:host{--spectrum-search-border-color-default:var(--system-search-border-color-default);--spectrum-search-border-color-hover:var(--system-search-border-color-hover);--spectrum-search-border-color-focus:var(--system-search-border-color-focus);--spectrum-search-border-color-focus-hover:var(--system-search-border-color-focus-hover);--spectrum-search-border-color-key-focus:var(--system-search-border-color-key-focus);--spectrum-search-background-color:var(--system-search-background-color);--spectrum-search-background-color-disabled:var(--system-search-background-color-disabled);--spectrum-search-border-color-disabled:var(--system-search-border-color-disabled);--spectrum-search-border-radius:var(--system-search-border-radius);--spectrum-search-edge-to-visual:var(--system-search-edge-to-visual)}:host([size=m]) #textfield{--spectrum-search-border-radius:var(--system-search-size-m-border-radius);--spectrum-search-edge-to-visual:var(--system-search-size-m-edge-to-visual)}:host([quiet]){--spectrum-search-background-color-disabled:var(--system-search-quiet-background-color-disabled);--spectrum-search-border-color-disabled:var(--system-search-quiet-border-color-disabled)}:host{--mod-textfield-spacing-inline:var(--spectrum-alias-infieldbutton-full-height-m)}input::-webkit-search-cancel-button{display:none}:host([size=s]) #textfield{--spectrum-search-border-radius:var(--system-search-size-s-border-radius);--spectrum-search-edge-to-visual:var(--system-search-size-s-edge-to-visual)}:host([size=l]) #textfield{--spectrum-search-border-radius:var(--system-search-size-l-border-radius);--spectrum-search-edge-to-visual:var(--system-search-size-l-edge-to-visual)}:host([size=xl]) #textfield{--spectrum-search-border-radius:var(--system-search-size-xl-border-radius);--spectrum-search-edge-to-visual:var(--system-search-size-xl-edge-to-visual)}@media (forced-colors:active){sp-clear-button{--spectrum-clearbutton-fill-background-color:transparent;--spectrum-clearbutton-fill-background-color-disabled:transparent;--spectrum-clearbutton-fill-background-color-down:transparent;--spectrum-clearbutton-fill-background-color-hover:transparent;--spectrum-clearbutton-fill-background-color-key-focus:transparent}}
`;
var search_css_default = e27;

// node_modules/@spectrum-web-components/search/src/Search.js
var d13 = Object.defineProperty;
var c28 = Object.getOwnPropertyDescriptor;
var s14 = (r25, o52, e36, t34) => {
  for (var i21 = t34 > 1 ? void 0 : t34 ? c28(o52, e36) : o52, a23 = r25.length - 1, n25; a23 >= 0; a23--) (n25 = r25[a23]) && (i21 = (t34 ? n25(o52, e36, i21) : n25(i21)) || i21);
  return t34 && i21 && d13(o52, e36, i21), i21;
};
var v5 = (r25) => r25.stopPropagation();
var Search = class extends Textfield {
  constructor() {
    super(...arguments);
    this.action = "";
    this.label = "Search";
    this.placeholder = "Search";
  }
  static get styles() {
    return [...super.styles, search_css_default];
  }
  handleSubmit(e36) {
    this.dispatchEvent(new Event("submit", { cancelable: true, bubbles: true })) || e36.preventDefault();
  }
  handleKeydown(e36) {
    const { code: t34 } = e36;
    t34 === "Escape" && this.holdValueOnEscape || !this.value || t34 !== "Escape" || this.reset();
  }
  async reset() {
    this.value = "", await this.updateComplete, this.focusElement.dispatchEvent(new InputEvent("input", { bubbles: true, composed: true })), this.focusElement.dispatchEvent(new InputEvent("change", { bubbles: true }));
  }
  renderField() {
    return x`
            <form
                action=${this.action}
                id="form"
                method=${o9(this.method)}
                @submit=${this.handleSubmit}
                @reset=${this.reset}
                @keydown=${this.handleKeydown}
            >
                <sp-icon-search
                    size=${this.size}
                    class="icon magnifier icon-workflow icon-search"
                ></sp-icon-search>
                ${super.renderField()}
                ${this.value ? x`
                          <sp-clear-button
                              id="button"
                              label="Reset"
                              tabindex="-1"
                              type="reset"
                              size=${o9(this.size)}
                              @keydown=${v5}
                          ></sp-clear-button>
                      ` : E}
            </form>
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.hasAttribute("holdValueOnEscape") || this.inputElement.setAttribute("type", "search");
  }
  willUpdate() {
    this.multiline = false;
  }
};
s14([n4()], Search.prototype, "action", 2), s14([n4()], Search.prototype, "label", 2), s14([n4()], Search.prototype, "method", 2), s14([n4()], Search.prototype, "placeholder", 2), s14([n4({ type: Boolean })], Search.prototype, "holdValueOnEscape", 2), s14([e5("#form")], Search.prototype, "form", 2);

// node_modules/@spectrum-web-components/search/sp-search.js
init_define_element();
defineElement("sp-search", Search);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronRight.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ChevronRight.js
var ChevronRightIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Chevron Right" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m7.75,16.46484c-.1875,0-.37402-.06934-.51953-.20996-.29883-.28711-.30859-.76172-.02051-1.05957l4.99902-5.19727-4.98633-5.18359c-.28809-.29785-.27832-.77246.02051-1.05957.2959-.28711.77344-.2793,1.05957.02051l5.4873,5.70312c.28027.29004.28027.74902,0,1.03906l-5.5,5.7168c-.14648.15332-.34375.23047-.54004.23047Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ChevronRight.js
var ChevronRightIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Chevron Right" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M24 18a1.988 1.988 0 0 1-.585 1.409l-7.983 7.98a2 2 0 1 1-2.871-2.772l.049-.049L19.181 18l-6.572-6.57a2 2 0 0 1 2.773-2.87l.049.049 7.983 7.98A1.988 1.988 0 0 1 24 18Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronRight.js
var IconChevronRight = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ChevronRightIcon({ hidden: !this.label, title: this.label }) : ChevronRightIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-chevron-right.js
init_define_element();
defineElement("sp-icon-chevron-right", IconChevronRight);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLayout.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Layout.js
var LayoutIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: l16 = "Layout" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m15.75,2H4.25c-1.24023,0-2.25,1.00977-2.25,2.25v11.5c0,1.24023,1.00977,2.25,2.25,2.25h11.5c1.24023,0,2.25-1.00977,2.25-2.25V4.25c0-1.24023-1.00977-2.25-2.25-2.25ZM3.5,4.25c0-.41309.33691-.75.75-.75h11.5c.41309,0,.75.33691.75.75v3.75H3.5v-3.75Zm0,11.5v-6.25h4.5v7h-3.75c-.41309,0-.75-.33691-.75-.75Zm12.25.75h-6.25v-7h7v6.25c0,.41309-.33691.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconLayout.js
var IconLayout = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? LayoutIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-layout.js
init_define_element();
defineElement("sp-icon-layout", IconLayout);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTreeCollapseAll.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/TreeCollapseAll.js
var TreeCollapseAllIcon = ({ width: a23 = 24, height: e36 = 24, hidden: l16 = false, title: t34 = "Tree Collapse All" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path d="M9 8h17V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5V9a1 1 0 0 1 1-1Z" />
    <path
      d="M10 11v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1Zm4.5 13a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTreeCollapseAll.js
var IconTreeCollapseAll = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? TreeCollapseAllIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-tree-collapse-all.js
init_define_element();
defineElement("sp-icon-tree-collapse-all", IconTreeCollapseAll);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronDoubleRight.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ChevronDoubleRight.js
var ChevronDoubleRightIcon = ({ width: l16 = 24, height: e36 = 24, hidden: t34 = false, title: r25 = "Chevron Double Right" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M9.61805,16.24512c-.29883-.28711-.3086-.76172-.02051-1.05957l4.98633-5.18359-4.99902-5.19727c-.28808-.29785-.27832-.77246.02051-1.05957.29687-.28711.77246-.27832,1.05957.02051l5.5,5.7168c.28027.29004.28027.74902,0,1.03906l-5.4873,5.70312c-.14649.15332-.34375.23047-.54004.23047-.18751,0-.37501-.06934-.51954-.20996Z"
      fill="currentColor"
    />
    <path
      d="M3.86805,16.24512c-.29883-.28711-.3086-.76172-.02051-1.05957l4.98633-5.18359L3.83485,4.80469c-.28808-.29785-.27832-.77246.02051-1.05957.29687-.28711.77246-.27832,1.05957.02051l5.5,5.7168c.28027.29004.28027.74902,0,1.03906l-5.4873,5.70312c-.14649.15332-.34375.23047-.54004.23047-.18751,0-.37501-.06934-.51954-.20996Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ChevronDoubleRight.js
var ChevronDoubleRightIcon2 = ({ width: e36 = 24, height: l16 = 24, hidden: t34 = false, title: a23 = "Chevron Double Right" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${l16}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M30 18a1.988 1.988 0 0 1-.585 1.409l-7.983 7.98a2 2 0 1 1-2.871-2.772l.049-.049L25.181 18l-6.572-6.57a2 2 0 0 1 2.773-2.87l.049.049 7.983 7.98A1.988 1.988 0 0 1 30 18Z"
    />
    <path
      d="M18 18a1.988 1.988 0 0 1-.585 1.409l-7.983 7.98a2 2 0 1 1-2.872-2.77l.049-.049L13.181 18l-6.572-6.57a2 2 0 0 1 2.774-2.87l.049.049 7.983 7.98A1.988 1.988 0 0 1 18 18Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconChevronDoubleRight.js
var IconChevronDoubleRight = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ChevronDoubleRightIcon({ hidden: !this.label, title: this.label }) : ChevronDoubleRightIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-chevron-double-right.js
init_define_element();
defineElement("sp-icon-chevron-double-right", IconChevronDoubleRight);

// src/features/content-tree/tree-nav.js
var TreeNav = class _TreeNav extends i4 {
  static get styles() {
    return treeNavStyles;
  }
  static get properties() {
    return {
      store: { type: Object, throttle: 20, observe: true },
      tree: { type: Object },
      searchQuery: { type: String },
      centerOn: { type: Object },
      focusedKey: { type: String }
    };
  }
  #expanded;
  #elKeyMap;
  #elKeySeq;
  #typeahead;
  #typeaheadTimer;
  #dropIndicator;
  #expandHoverTimer;
  #expandHoverKey;
  #autoScrollRAF;
  #autoScrollVelocity;
  #dragElement;
  #navActive;
  #navActiveTimer;
  #onDocKeyDown;
  #lastSelectionKey;
  // Static utility methods for tree building and manipulation
  static getElementLabel(editor, el) {
    const tag3 = el.tagName?.toLowerCase?.() || "element";
    const ctor = customElements.get(tag3);
    const schema2 = getElementSchema(ctor?.ee, el);
    const lbl = schema2?.element?.label;
    if (lbl) return lbl;
    return tag3;
  }
  static getElementIconTemplate(editor, el) {
    const tag3 = el?.tagName?.toLowerCase?.();
    if (!tag3) return void 0;
    const ctor = customElements.get(tag3);
    const result = ctor?.ee?.getElementIcon?.(x);
    if (result === void 0) return void 0;
    if (typeof result === "string") {
      const iconTag = result.trim();
      if (!iconTag) return null;
      const defined = !!customElements.get(iconTag);
      if (!defined) return null;
      return x`<${iconTag}></${iconTag}>`;
    }
    return result;
  }
  static renderItemIcon(editor, el) {
    const tpl = _TreeNav.getElementIconTemplate(editor, el);
    if (tpl === void 0) return E;
    if (tpl === null) {
      return x`<span slot="icon" class="node-icon" title="Icon error"
        ><sp-icon-alert-circle></sp-icon-alert-circle
      ></span>`;
    }
    return x`<span slot="icon" class="node-icon">${tpl}</span>`;
  }
  static buildTreeNode(editor, domStore, el) {
    const label = _TreeNav.getElementLabel(editor, el);
    const tag3 = el.tagName?.toLowerCase?.();
    const ctor = tag3 ? customElements.get(tag3) : null;
    const rawSchema = getElementSchema(ctor?.ee, el);
    let directChildren = domStore ? domStore.getAuthorableChildren(el) : Array.from(el.children).filter((c33) => editor.isAuthorableElement(c33));
    if (tag3 === "ee-reference") {
      directChildren = directChildren.filter(
        (c33) => c33.getAttribute && c33.getAttribute("slot") === "trigger"
      );
    }
    const declaredSlots = Array.isArray(rawSchema?.slots?.order) ? rawSchema.slots.order : [];
    const declaredNamed = new Set(
      (declaredSlots || []).filter((s19) => s19 && s19 !== "default")
    );
    const slotNodeMap = {};
    const editorStore = editor?.editorStore || null;
    const selectionStore = editorStore?.selection || null;
    const inlineDescendants = (elements) => {
      if (!elements || elements.length === 0) return [];
      const results = [];
      const visited = /* @__PURE__ */ new Set();
      const visit = (node) => {
        if (!node || node.nodeType !== Node.ELEMENT_NODE) return;
        const tag4 = node.tagName?.toLowerCase?.() || "";
        if (tag4 === "script" || tag4 === "style" || tag4 === "ee-rte") return;
        if (visited.has(node)) return;
        visited.add(node);
        const isCustom = tag4.includes("-");
        if (isCustom) {
          results.push(_TreeNav.buildTreeNode(editor, domStore, node));
          return;
        }
        const children2 = Array.from(node.children || []);
        for (const child of children2) {
          visit(child);
        }
      };
      for (const element of elements) {
        visit(element);
      }
      return results;
    };
    for (const slotName of declaredNamed) {
      const shadowRoot = el.shadowRoot;
      if (shadowRoot) {
        const selector = `slot[name="${slotName}"]`;
        const slotElement = shadowRoot.querySelector(selector);
        if (!slotElement) {
          continue;
        }
      } else {
        continue;
      }
      const childEls = directChildren.filter(
        (c33) => c33.getAttribute("slot") === slotName
      );
      const slotConfig = rawSchema?.slots?.configs?.[slotName] || null;
      const inlineEditable = slotConfig?.inlineEditable === true;
      const isTextSlot = selectionStore?.slotSupportsTextEditing(el, slotName) === true;
      const inlineText = inlineEditable || isTextSlot;
      const inlineChildren = inlineText ? inlineDescendants(childEls) : null;
      const hasInlineChildren = inlineText && Array.isArray(inlineChildren) && inlineChildren.length > 0;
      const hasDirectChildren = childEls.length > 0;
      const hideChildren = inlineText ? !hasInlineChildren : !hasDirectChildren;
      slotNodeMap[slotName] = {
        kind: "slot",
        slotName,
        parentElement: el,
        label: rawSchema?.slots?.configs?.[slotName]?.label || slotName,
        inlineText,
        children: hideChildren ? [] : inlineText ? inlineChildren : childEls.map((c33) => _TreeNav.buildTreeNode(editor, domStore, c33))
      };
    }
    let defaultChildren = [];
    const defaultSlotConfig = rawSchema?.slots?.configs?.default || null;
    const defaultInlineEditable = defaultSlotConfig?.inlineEditable === true;
    const defaultChildEls = directChildren.filter(
      (c33) => !c33.hasAttribute("slot")
    );
    const defaultIsInline = defaultInlineEditable || selectionStore?.slotSupportsTextEditing(el, "default") === true;
    if (defaultIsInline) {
      const inlineChildren = inlineDescendants(defaultChildEls);
      if (inlineChildren.length) {
        defaultChildren = inlineChildren;
      }
    } else {
      defaultChildren = defaultChildEls.map(
        (c33) => _TreeNav.buildTreeNode(editor, domStore, c33)
      );
    }
    const orphanChildren = directChildren.filter((c33) => {
      const name = c33.getAttribute && c33.getAttribute("slot");
      return !!name && name !== "default" && !declaredNamed.has(name);
    }).map((c33) => _TreeNav.buildTreeNode(editor, domStore, c33));
    const children = [];
    for (const s19 of declaredSlots) {
      if (s19 === "default") {
        children.push(...defaultChildren);
      } else if (slotNodeMap[s19]) {
        children.push(slotNodeMap[s19]);
      }
    }
    if (declaredSlots.length === 0 && defaultChildren.length > 0) {
      children.push(...defaultChildren);
    }
    children.push(...orphanChildren);
    return { element: el, label, children };
  }
  static getAuthorableTree(editor) {
    const domStore = editor?.editorStore?.domStore || editor?.store?.domStore || null;
    const roots = domStore ? domStore.getRootElements() : Array.from(editor.children).filter((c33) => editor.isAuthorableElement(c33));
    if (!roots.length) return null;
    return roots.map((root) => _TreeNav.buildTreeNode(editor, domStore, root));
  }
  static containsSelected(node, selectedEl) {
    if (!selectedEl) return false;
    if (node.element === selectedEl) return true;
    return (node.children || []).some(
      (c33) => _TreeNav.containsSelected(c33, selectedEl)
    );
  }
  static getCanvasRoot(editor) {
    const domStore = editor?.editorStore?.domStore || editor?.store?.domStore || null;
    const roots = domStore ? domStore.getRootElements() : Array.from(editor.children).filter((c33) => editor.isAuthorableElement(c33));
    return roots.length ? roots[0] : null;
  }
  static expandAllSidebarItems(editor) {
    const host = editor.shadowRoot;
    if (!host) return;
    const nav2 = host.querySelector("content-tree-nav");
    nav2?.expandAll?.(true);
  }
  constructor() {
    super();
    this.store = null;
    this.tree = null;
    this.searchQuery = "";
    this.#expanded = /* @__PURE__ */ new Set();
    this.#elKeyMap = /* @__PURE__ */ new WeakMap();
    this.#elKeySeq = 1;
    this.focusedKey = null;
    this.#typeahead = "";
    this.#typeaheadTimer = null;
    this.#navActive = false;
    this.#navActiveTimer = null;
    this.#dropIndicator = null;
    this.#expandHoverTimer = null;
    this.#expandHoverKey = null;
    this.#autoScrollRAF = null;
    this.#autoScrollVelocity = 0;
    this.#dragElement = null;
  }
  #getInputType(event) {
    if (!event) return null;
    const type = event.type ? String(event.type).toLowerCase() : "";
    if (type.startsWith("key")) return "keyboard";
    if (typeof event.pointerType === "string" && event.pointerType) {
      return event.pointerType;
    }
    if (type.startsWith("pointer")) {
      return event.pointerType || "pointer";
    }
    if (type.startsWith("mouse") || type === "click" || type === "dblclick") {
      return "mouse";
    }
    if (type.startsWith("touch")) return "touch";
    return null;
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("keydown", this.onHostKeyDown, true);
    this.addEventListener("click", this.onHostClick, true);
    this.#onDocKeyDown = (e36) => this.onDocumentKeyDown(e36);
    document.addEventListener("keydown", this.#onDocKeyDown, true);
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    const currentSelectionKey = this.selectionKey;
    if (currentSelectionKey !== this.#lastSelectionKey) {
      this.#lastSelectionKey = currentSelectionKey;
      const selectedNode = this.findSelectedNode();
      if (selectedNode) {
        this.expandAncestorsForNode(selectedNode);
        this.updateComplete.then(() => {
          const key = this.getKeyFor(selectedNode);
          if (key) {
            this.focusRowByKey(key, { focus: false, scroll: true });
          }
        });
      }
    }
  }
  // Debug snapshot of tree state and nodes
  get debugState() {
    if (!TREE_DEBUG) return null;
    const root = this.filteredTree || this.tree || null;
    const selectionKey = this.selectionKey;
    const focusedKey = this.focusedKey || null;
    const expandedKeys = Array.from(this.#expanded || []);
    let total = 0;
    const countAll = (n25) => {
      if (!n25) return;
      total += 1;
      (n25.children || []).forEach(countAll);
    };
    if (root) countAll(root);
    const visible = [];
    const walkVisible = (n25, depth = 0) => {
      if (!n25) return;
      visible.push({ key: this.getKeyFor(n25), depth });
      const hasChildren = Array.isArray(n25.children) && n25.children.length > 0;
      if (hasChildren && this.isExpanded(n25)) {
        n25.children.forEach((c33) => walkVisible(c33, depth + 1));
      }
    };
    if (root) walkVisible(root, 0);
    const keyMap = this.getKeyNodeMap();
    const summarizeNode = (n25) => {
      if (!n25) return { kind: "unknown", label: "", tag: null, id: null, slotName: null, childCount: 0 };
      const isSlot = n25.kind === "slot";
      const el = isSlot ? n25.parentElement : n25.element;
      const tag3 = el?.tagName?.toLowerCase?.() || null;
      const id = el?.id || null;
      const slotName = isSlot ? n25.slotName : null;
      return {
        kind: isSlot ? "slot" : "element",
        label: n25.label || "",
        tag: tag3,
        id,
        slotName,
        childCount: Array.isArray(n25.children) ? n25.children.length : 0
      };
    };
    const visibleNodes = TREE_DEBUG ? visible.map(({ key, depth }) => ({
      key,
      depth,
      ...summarizeNode(keyMap.get(key))
    })) : null;
    return {
      totals: {
        totalNodes: total,
        visibleNodes: visible.length,
        expanded: expandedKeys.length
      },
      selectionKey,
      focusedKey,
      expandedKeys,
      // Only include full per-node details when debug is enabled
      nodes: visibleNodes
    };
  }
  clearTreeFocus() {
    this.focusedKey = null;
    this.#navActive = false;
    this.removeAttribute("data-nav-active");
    const active = this.shadowRoot?.activeElement;
    if (active && active.classList && active.classList.contains("node-row")) {
      active.blur();
    }
    this.requestUpdate();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("keydown", this.onHostKeyDown, true);
    this.removeEventListener("click", this.onHostClick, true);
    document.removeEventListener("keydown", this.#onDocKeyDown, true);
    this.#onDocKeyDown = null;
    this.clearExpandHoverTimer();
    this.#dropIndicator = null;
    this.stopAutoScroll();
  }
  // Ensure we react to selection changes even if store is provided post-connect
  // Compute a unique selection key so exactly one row is selected at a time
  get selectionKey() {
    const el = this.store?.editingElement ?? null;
    const slot = this.store?.currentSlot ?? null;
    if (el && slot) {
      const key = this.getElementKey(el);
      return key ? `slot:${key}:${slot}` : null;
    }
    if (el) {
      const key = this.getElementKey(el);
      return key ? `el:${key}` : null;
    }
    return null;
  }
  // Compute effective expanded keys: user's manual expansions + auto-expand selection ancestors
  get effectiveExpandedKeys() {
    const expanded = new Set(this.#expanded);
    const el = this.store?.editingElement ?? null;
    const slotName = this.store?.currentSlot ?? null;
    if (!el) return expanded;
    const targetNode = slotName ? this.findSlotNode(el, slotName) : this.findNodeForElement(el);
    if (!targetNode) return expanded;
    const findPath = (node, target, path = []) => {
      if (!node) return null;
      if (node === target) return path;
      const hasChildren = Array.isArray(node.children) && node.children.length > 0;
      if (hasChildren) {
        for (const child of node.children) {
          const childPath = findPath(child, target, [...path, node]);
          if (childPath) return childPath;
        }
      }
      return null;
    };
    let ancestorPath = null;
    const root = this.filteredTree || this.tree;
    if (Array.isArray(root)) {
      for (const r25 of root) {
        ancestorPath = findPath(r25, targetNode, []);
        if (ancestorPath) break;
      }
    } else if (root) {
      ancestorPath = findPath(root, targetNode, []);
    }
    if (ancestorPath && ancestorPath.length > 0) {
      ancestorPath.forEach((ancestor) => {
        const key = this.getKeyFor(ancestor);
        if (key) expanded.add(key);
      });
    }
    return expanded;
  }
  // Compute the filtered tree (based on query)
  get filteredTree() {
    return this.filterTree(this.tree, this.searchQuery);
  }
  // Flatten visible nodes according to current expansion state
  getVisibleKeys() {
    const expanded = this.effectiveExpandedKeys;
    const out = [];
    const walk = (n25) => {
      if (!n25) return;
      const key = this.getKeyFor(n25);
      out.push(key);
      const hasChildren = n25.children && n25.children.length > 0;
      if (hasChildren && expanded.has(key)) {
        n25.children.forEach(walk);
      }
    };
    const root = this.filteredTree;
    if (Array.isArray(root)) root.forEach((r25) => walk(r25));
    else if (root) walk(root);
    return out;
  }
  getParentMap() {
    const map2 = /* @__PURE__ */ new Map();
    const walk = (n25, parentKey = null) => {
      if (!n25) return;
      const key = this.getKeyFor(n25);
      if (parentKey) map2.set(key, parentKey);
      (n25.children || []).forEach((c33) => walk(c33, key));
    };
    const root = this.filteredTree;
    if (Array.isArray(root)) root.forEach((r25) => walk(r25, null));
    else if (root) walk(root, null);
    return map2;
  }
  getKeyNodeMap() {
    const map2 = /* @__PURE__ */ new Map();
    const walk = (n25) => {
      if (!n25) return;
      const key = this.getKeyFor(n25);
      map2.set(key, n25);
      (n25.children || []).forEach(walk);
    };
    const root = this.filteredTree;
    if (Array.isArray(root)) root.forEach((r25) => walk(r25));
    else if (root) walk(root);
    return map2;
  }
  focusRowByKey(key, { focus = true, scroll = true } = {}) {
    if (!key) return;
    this.focusedKey = key;
    const tryFocus = () => {
      const row = this.renderRoot?.querySelector?.(
        `[data-node-key="${key}"] > .node-row`
      );
      if (!row) return false;
      if (focus) row.focus();
      if (scroll) row.scrollIntoView({ block: "nearest", inline: "nearest" });
      return true;
    };
    if (!tryFocus()) {
      this.updateComplete.then(() => {
        tryFocus();
      });
    }
  }
  getKeyFor(node) {
    if (!node) return null;
    if (node.kind === "slot") {
      const pKey = this.getElementKey(node.parentElement);
      return `slot:${pKey}:${node.slotName}`;
    }
    return `el:${this.getElementKey(node.element)}`;
  }
  getElementKey(el) {
    if (!el || typeof el !== "object") return null;
    let key = this.#elKeyMap.get(el);
    if (!key) {
      key = this.#elKeySeq++;
      this.#elKeyMap.set(el, key);
    }
    return key;
  }
  isExpanded(node) {
    return this.effectiveExpandedKeys.has(this.getKeyFor(node));
  }
  setExpanded(node, expanded) {
    const key = this.getKeyFor(node);
    if (!key) return;
    const was = this.#expanded.has(key);
    if (expanded && !was) this.#expanded.add(key);
    if (!expanded && was) this.#expanded.delete(key);
    this.animateNodeChildren(node, !!expanded);
    this.requestUpdate();
  }
  toggleExpanded(node) {
    this.setExpanded(node, !this.isExpanded(node));
  }
  animateNodeChildren(node, expanded) {
    const key = this.getKeyFor(node);
    const el = this.renderRoot?.querySelector?.(
      `[data-node-key="${key}"] > .children`
    );
    if (!el) return;
    if (el._eeOnHeightEnd) {
      el.removeEventListener("transitionend", el._eeOnHeightEnd);
      el._eeOnHeightEnd = null;
    }
    const endHandler = (ev) => {
      if (!ev || ev.propertyName === "height") {
        if (expanded) {
          el.style.height = "auto";
        }
        el.removeEventListener("transitionend", endHandler);
        el._eeOnHeightEnd = null;
      }
    };
    if (expanded) {
      el.style.height = "0px";
      el.removeAttribute("collapsed");
      requestAnimationFrame(() => {
        el.style.height = `${el.scrollHeight}px`;
      });
      el.addEventListener("transitionend", endHandler);
      el._eeOnHeightEnd = endHandler;
    } else {
      const currentH = el.scrollHeight || el.getBoundingClientRect().height || 0;
      el.style.height = `${currentH}px`;
      el.offsetHeight;
      el.style.height = "0px";
      el.setAttribute("collapsed", "");
      el.addEventListener("transitionend", endHandler);
      el._eeOnHeightEnd = endHandler;
    }
  }
  expandAll(expanded, anchorNode = null) {
    const anchor = anchorNode || this.findSelectedNode() || this.findNodeForElement(this.store?.editingElement) || this.tree;
    const keys2 = [];
    const walk = (n25) => {
      if (!n25) return;
      keys2.push(this.getKeyFor(n25));
      (n25.children || []).forEach(walk);
    };
    if (Array.isArray(anchor)) anchor.forEach((r25) => walk(r25));
    else walk(anchor);
    if (expanded) keys2.forEach((k2) => this.#expanded.add(k2));
    else keys2.forEach((k2) => this.#expanded.delete(k2));
    this.updateComplete.then(() => {
      keys2.forEach((k2) => {
        const host = this.renderRoot?.querySelector?.(
          `[data-node-key="${k2}"] > .children`
        );
        if (host) {
          if (expanded) {
            host.style.height = "auto";
            host.removeAttribute("collapsed");
          } else {
            host.style.height = "0px";
            host.setAttribute("collapsed", "");
          }
        }
      });
    });
    this.requestUpdate();
  }
  // Determine if an anchor subtree is fully expanded
  isSubtreeFullyExpanded(anchorNode = null) {
    const anchor = anchorNode || this.findSelectedNode() || this.findNodeForElement(this.store?.editingElement) || this.tree;
    const expanded = this.effectiveExpandedKeys;
    const allExpanded = (n25) => {
      if (!n25) return true;
      const key = this.getKeyFor(n25);
      const hasChildren = n25.children && n25.children.length > 0;
      if (hasChildren && !expanded.has(key)) return false;
      for (const c33 of n25.children || []) {
        if (!allExpanded(c33)) return false;
      }
      return true;
    };
    if (Array.isArray(anchor)) return anchor.every((r25) => allExpanded(r25));
    return allExpanded(anchor);
  }
  toggleExpandSelected() {
    const node = this.findSelectedNode() || this.findNodeForElement(this.store?.editingElement) || this.tree;
    const fullyExpanded = this.isSubtreeFullyExpanded(node);
    this.expandAll(!fullyExpanded, node);
  }
  onItemClick(e36, node) {
    e36.stopPropagation();
    this.markNavActive();
    const input = this.#getInputType(e36);
    const isSlot = node && node.kind === "slot";
    if (isSlot) {
      if (node.parentElement && this.store) {
        const p30 = node.parentElement;
        const meta = {
          slot: node.slotName,
          parentTag: p30?.tagName?.toLowerCase?.() || null,
          parentId: p30?.id || null
        };
        if (input) {
          meta.input = input;
        }
        this.store.setUserAction && this.store.setUserAction("tree:slot-click", meta);
        this.store.selection.selectSlot(node.parentElement, node.slotName, {
          inputType: input,
          fromTree: true
        });
      }
    } else if (node.element && this.store) {
      let el = node.element;
      const computedDisplay = getComputedStyle(el).display;
      if (computedDisplay === "contents" && el.firstElementChild) {
        el = el.firstElementChild;
      }
      const meta = {
        tag: el?.tagName?.toLowerCase?.() || null,
        id: el?.id || null
      };
      if (input) {
        meta.input = input;
      }
      this.store.setUserAction && this.store.setUserAction("tree:element-click", meta);
      this.store.selection.selectElement(el, null, {
        inputType: input,
        fromTree: true
      });
    }
    const k2 = this.getKeyFor(node);
    if (k2) this.focusedKey = k2;
    if (k2) this.focusRowByKey(k2, { focus: true, scroll: false });
  }
  onItemDblClick(e36, node) {
    e36.stopPropagation();
    const input = this.#getInputType(e36);
    this.store.setUserAction && this.store.setUserAction("tree:dblclick", {
      key: this.getKeyFor(node),
      ...input ? { input } : {}
    });
    const hasChildren = node.children && node.children.length > 0;
    if (hasChildren) this.toggleExpanded(node);
  }
  onKeyDown(e36, node) {
    const key = e36.key;
    const item = e36.currentTarget?.closest?.(".node-row");
    if (!item) return;
    const currentKey = this.getKeyFor(node);
    const visible = this.getVisibleKeys();
    const idx = visible.indexOf(currentKey);
    const parentMap = this.getParentMap();
    const moveIndex = (nextIndex) => {
      const safeIndex = Math.max(0, Math.min(visible.length - 1, nextIndex));
      const keyToFocus = visible[safeIndex];
      if (keyToFocus) {
        e36.preventDefault();
        this.focusRowByKey(keyToFocus);
      }
    };
    if (key === "Escape") {
      e36.preventDefault();
      this.hideSidebar();
      return;
    }
    if (key === "ArrowDown") {
      moveIndex(idx + 1);
      return;
    }
    if (key === "ArrowUp") {
      moveIndex(idx - 1);
      return;
    }
    if (key === "Home") {
      moveIndex(0);
      return;
    }
    if (key === "End") {
      moveIndex(visible.length - 1);
      return;
    }
    if (key === "ArrowRight") {
      const hasChildren = Array.isArray(node.children) && node.children.length > 0;
      if (!hasChildren) return;
      e36.preventDefault();
      if (!this.isExpanded(node)) {
        this.setExpanded(node, true);
        return;
      }
      const firstChild = node.children[0];
      if (firstChild) {
        const childKey = this.getKeyFor(firstChild);
        this.focusRowByKey(childKey);
      }
      return;
    }
    if (key === "ArrowLeft") {
      const hasChildren = node.children && node.children.length > 0;
      if (hasChildren && this.isExpanded(node)) {
        e36.preventDefault();
        this.setExpanded(node, false);
        return;
      }
      const parentKey = parentMap.get(currentKey);
      if (parentKey) {
        e36.preventDefault();
        this.focusRowByKey(parentKey);
      }
      return;
    }
    if (key === "Enter" || key === " ") {
      e36.preventDefault();
      this.onItemClick(e36, node);
      return;
    }
    if (key.length === 1 && !e36.metaKey && !e36.ctrlKey && !e36.altKey) {
      if (!this.#typeaheadTimer) {
        this.#typeahead = "";
      }
      this.#typeahead += key.toLowerCase();
      clearTimeout(this.#typeaheadTimer);
      this.#typeaheadTimer = setTimeout(() => {
        this.#typeahead = "";
        this.#typeaheadTimer = null;
      }, 600);
      const keyMap = this.getKeyNodeMap();
      const start = Math.max(0, idx + 1);
      const keys2 = visible;
      const matchIndex = (() => {
        const hay = [...keys2.slice(start), ...keys2.slice(0, start)];
        let offset4 = 0;
        for (const k2 of hay) {
          const n25 = keyMap.get(k2);
          const label = (n25?.label || "").toLowerCase();
          if (label.startsWith(this.#typeahead)) {
            return (start + offset4) % keys2.length;
          }
          offset4 += 1;
        }
        return -1;
      })();
      if (matchIndex >= 0) {
        moveIndex(matchIndex);
      }
      return;
    }
  }
  onHostKeyDown(e36) {
    if (e36.key === "Escape") {
      e36.preventDefault();
      e36.stopPropagation();
      this.hideSidebar();
    }
  }
  hideSidebar() {
    this.store.setSidebarOpen(false);
  }
  onHostClick(e36) {
    const tree = this.renderRoot?.querySelector?.(".tree");
    if (!tree) return;
    const target = e36.composedPath ? e36.composedPath()[0] : e36.target;
    if (!tree.contains(target)) return;
    this.markNavActive();
    const row = target?.closest?.(".node-row");
    if (row) return;
    const visible = this.getVisibleKeys();
    const keyToFocus = this.focusedKey && visible.includes(this.focusedKey) ? this.focusedKey : visible[0] || null;
    if (keyToFocus) {
      this.focusRowByKey(keyToFocus);
    }
  }
  markNavActive() {
    this.#navActive = true;
    if (this.#navActiveTimer) clearTimeout(this.#navActiveTimer);
    this.setAttribute("data-nav-active", "");
    this.#navActiveTimer = setTimeout(() => {
      this.#navActive = false;
      this.removeAttribute("data-nav-active");
    }, 3e3);
  }
  onDocumentKeyDown(e36) {
    const path = e36.composedPath?.() ?? [];
    const typingTarget = path.find(
      (node2) => node2 && node2.nodeType === Node.ELEMENT_NODE && (node2.isContentEditable || node2.getAttribute?.("contenteditable") === "true")
    );
    if (typingTarget) {
      return;
    }
    if (!this.#navActive) return;
    if (e36.metaKey || e36.ctrlKey || e36.altKey) return;
    const k2 = e36.key;
    const managed = [
      "ArrowDown",
      "ArrowUp",
      "ArrowLeft",
      "ArrowRight",
      "Home",
      "End",
      "Enter",
      " "
    ];
    if (!managed.includes(k2)) return;
    const visible = this.getVisibleKeys();
    if (!visible.length) return;
    let current = this.focusedKey;
    if (!current || !visible.includes(current)) {
      const selected = this.selectionKey;
      current = selected && visible.includes(selected) ? selected : visible[0];
      this.focusedKey = current;
    }
    const keyMap = this.getKeyNodeMap();
    const node = keyMap.get(current);
    if (!node) return;
    const idx = visible.indexOf(current);
    const parentMap = this.getParentMap();
    const moveIndex = (nextIndex) => {
      const safeIndex = Math.max(0, Math.min(visible.length - 1, nextIndex));
      const keyToFocus = visible[safeIndex];
      if (keyToFocus) this.focusRowByKey(keyToFocus);
    };
    if (k2 === "ArrowDown") {
      e36.preventDefault();
      e36.stopPropagation();
      this.markNavActive();
      moveIndex(idx + 1);
      return;
    }
    if (k2 === "ArrowUp") {
      e36.preventDefault();
      e36.stopPropagation();
      this.markNavActive();
      moveIndex(idx - 1);
      return;
    }
    if (k2 === "Home") {
      e36.preventDefault();
      e36.stopPropagation();
      this.markNavActive();
      moveIndex(0);
      return;
    }
    if (k2 === "End") {
      e36.preventDefault();
      e36.stopPropagation();
      this.markNavActive();
      moveIndex(visible.length - 1);
      return;
    }
    const hasChildren = Array.isArray(node.children) && node.children.length > 0;
    if (k2 === "ArrowRight") {
      e36.preventDefault();
      e36.stopPropagation();
      this.markNavActive();
      if (hasChildren && !this.isExpanded(node)) {
        this.setExpanded(node, true);
        return;
      }
      const firstChild = hasChildren ? node.children[0] : null;
      if (firstChild) {
        const childKey = this.getKeyFor(firstChild);
        this.focusRowByKey(childKey);
      }
      return;
    }
    if (k2 === "ArrowLeft") {
      e36.preventDefault();
      e36.stopPropagation();
      this.markNavActive();
      if (hasChildren && this.isExpanded(node)) {
        this.setExpanded(node, false);
        return;
      }
      const parentKey = parentMap.get(current);
      if (parentKey) this.focusRowByKey(parentKey);
      return;
    }
    if (k2 === "Enter" || k2 === " ") {
      e36.preventDefault();
      e36.stopPropagation();
      this.markNavActive();
      this.onItemClick(e36, node);
      return;
    }
  }
  isSelected(node) {
    const isSlot = node && node.kind === "slot";
    const el = this.store?.editingElement ?? null;
    const slot = this.store?.currentSlot ?? null;
    const slotOnlySelection = this.store?.slotOnlySelection ?? false;
    if (isSlot) {
      if (slot !== node.slotName) return false;
      if (slotOnlySelection) {
        return el === node.parentElement;
      }
      if (!el) return true;
      const walk = (n25) => {
        if (!n25) return false;
        if (n25.element === el) return true;
        for (const c33 of n25.children || []) {
          if (walk(c33)) return true;
        }
        return false;
      };
      return walk(node);
    }
    return el === node.element && !slotOnlySelection;
  }
  onSearch(e36) {
    this.searchQuery = e36.target?.value || "";
    this.requestUpdate();
  }
  onSearchKeydown(e36) {
    if (e36 && e36.key === "Enter") {
      e36.preventDefault();
      e36.stopPropagation();
      return false;
    }
  }
  filterTree(node, query) {
    if (!query) return node;
    const q3 = query.toLowerCase();
    const contains = (n25) => (n25.label || "").toLowerCase().includes(q3);
    const dive = (n25) => {
      const kids = (n25.children || []).map((c33) => dive(c33)).filter(Boolean);
      if (contains(n25) || kids.length) {
        return { ...n25, children: kids };
      }
      return null;
    };
    if (Array.isArray(node)) return node.map((n25) => dive(n25)).filter(Boolean);
    return dive(node);
  }
  renderControls() {
    const selected = this.findSelectedNode() || this.findNodeForElement(this.store?.editingElement) || this.tree;
    const willExpand = !this.isSubtreeFullyExpanded(selected);
    return x`
      <div class="controls">
        <sp-action-group quiet selects="none">
          <sp-action-button
            quiet
            size="l"
            title=${willExpand ? "Expand subtree" : "Collapse subtree"}
            @click=${() => this.toggleExpandSelected()}
          >
            ${willExpand ? x`<sp-icon-chevron-double-right
                  slot="icon"
                ></sp-icon-chevron-double-right>` : x`<sp-icon-chevron-double-right
                  slot="icon"
                  style="transform: rotate(90deg);"
                ></sp-icon-chevron-double-right>`}
          </sp-action-button>

          <overlay-trigger placement="bottom-start" offset="6">
            <sp-action-button slot="trigger" quiet size="l" title="Search tree">
              <sp-icon-search slot="icon"></sp-icon-search>
            </sp-action-button>
            <sp-popover slot="click-content" open>
              <div style="width: 300px; padding: 8px;">
                <sp-search
                  quiet
                  placeholder="Filter elements..."
                  .value=${this.searchQuery}
                  @input=${(e36) => this.onSearch(e36)}
                  @keydown=${(e36) => this.onSearchKeydown(e36)}
                ></sp-search>
              </div>
            </sp-popover>
          </overlay-trigger>
        </sp-action-group>
      </div>
    `;
  }
  // Find the tree node corresponding to a given element
  findNodeForElement(el) {
    if (!el || !this.tree) return null;
    const walk = (n25) => {
      if (!n25) return null;
      if (Array.isArray(n25)) {
        for (const child of n25) {
          const r25 = walk(child);
          if (r25) return r25;
        }
        return null;
      }
      if (n25.element === el) return n25;
      for (const c33 of n25.children || []) {
        const r25 = walk(c33);
        if (r25) return r25;
      }
      return null;
    };
    return walk(this.tree);
  }
  // Find currently selected node (slot node if a slot is active, otherwise the element node)
  findSelectedNode() {
    if (!this.tree) return null;
    const el = this.store?.editingElement ?? null;
    const slotName = this.store?.currentSlot ?? null;
    const elementNode = this.findNodeForElement(el);
    if (elementNode && slotName) {
      const slotContainsElement = (slotNode2, targetElement) => {
        if (!slotNode2 || slotNode2.kind !== "slot") return false;
        const walk = (n25) => {
          if (!n25) return false;
          if (n25.element === targetElement) return true;
          for (const c33 of n25.children || []) {
            if (walk(c33)) return true;
          }
          return false;
        };
        return walk(slotNode2);
      };
      const findSlot = (node) => {
        if (!node) return null;
        for (const c33 of node.children || []) {
          if (c33.kind === "slot" && c33.slotName === slotName && slotContainsElement(c33, el))
            return c33;
        }
        for (const c33 of node.children || []) {
          const r25 = findSlot(c33);
          if (r25) return r25;
        }
        return null;
      };
      const slotNode = findSlot(this.tree);
      return slotNode || elementNode;
    }
    if (elementNode) return elementNode;
    if (Array.isArray(this.tree)) return this.tree[0] || null;
    return this.tree;
  }
  // Find a slot node in the tree for a given parent element and slot name
  findSlotNode(parentElement, slotName) {
    if (!parentElement || !slotName || !this.tree) return null;
    const elementNode = this.findNodeForElement(parentElement);
    if (!elementNode) return null;
    for (const c33 of elementNode.children || []) {
      if (c33.kind === "slot" && c33.slotName === slotName && c33.parentElement === parentElement) {
        return c33;
      }
    }
    return null;
  }
  // Expand all ancestors of a node to make it visible
  expandAncestorsForNode(targetNode) {
    if (!targetNode) return;
    const findPath = (node, target, path = []) => {
      if (!node) return null;
      if (node === target) return path;
      const hasChildren = Array.isArray(node.children) && node.children.length > 0;
      if (hasChildren) {
        for (const child of node.children) {
          const childPath = findPath(child, target, [...path, node]);
          if (childPath) return childPath;
        }
      }
      return null;
    };
    let ancestorPath = null;
    const root = this.filteredTree || this.tree;
    if (Array.isArray(root)) {
      for (const r25 of root) {
        ancestorPath = findPath(r25, targetNode, []);
        if (ancestorPath) break;
      }
    } else if (root) {
      ancestorPath = findPath(root, targetNode, []);
    }
    if (ancestorPath) {
      for (const ancestor of ancestorPath) {
        const key = this.getKeyFor(ancestor);
        if (key) this.#expanded.add(key);
      }
    }
  }
  renderTree(node, depth = 0, pos = 1, setsize = 1) {
    if (!node) return E;
    const isSlotNode = node.kind === "slot";
    const key = this.getKeyFor(node);
    const isSelected = this.isSelected(node);
    const activeElement = this.store?.editingElement ?? null;
    const activeSlot = this.store?.currentSlot ?? null;
    const isEditingElementRow = !isSlotNode && !activeSlot && activeElement === node.element;
    const hasChildren = node.children && node.children.length > 0;
    const elKey = !isSlotNode && node.element ? this.getElementKey(node.element) : null;
    const parentKey = isSlotNode && node.parentElement ? this.getElementKey(node.parentElement) : null;
    const expanded = this.isExpanded(node);
    const caretTagName = this.getCaretIconTag(depth);
    const CaretTag = s9(caretTagName);
    const showBefore = !!(this.#dropIndicator && this.#dropIndicator.key === key && this.#dropIndicator.pos === "before");
    const showAfter = !!(this.#dropIndicator && this.#dropIndicator.key === key && this.#dropIndicator.pos === "after");
    return x`
      <div
        class="node"
        data-node-key=${key}
        style=${`--indent: ${depth * 12}px`}
      >
        ${showBefore ? x`<div
              class="drop-placeholder"
              data-pos="before"
              aria-hidden="true"
            ></div>` : E}
        <div
          class="node-row"
          role="treeitem"
          aria-level=${depth + 1}
          aria-posinset=${pos}
          aria-setsize=${setsize}
          aria-selected=${String(!!isSelected)}
          aria-expanded=${hasChildren ? String(expanded) : E}
          tabindex=${this.focusedKey === key ? 0 : -1}
          ?selected=${isSelected}
          ?focused=${this.focusedKey === key}
          ?editing=${isEditingElementRow}
          data-el-key=${elKey !== null ? String(elKey) : E}
          data-slot-parent-key=${isSlotNode && parentKey !== null ? String(parentKey) : E}
          data-slot-name=${isSlotNode ? node.slotName : E}
          data-node-kind=${isSlotNode ? "slot" : "element"}
          draggable=${!isSlotNode}
          @dragstart=${!isSlotNode ? (e36) => this.onDragStart(e36, node) : E}
          @dragend=${!isSlotNode ? (e36) => this.onDragEnd(e36, node) : E}
          @dragover=${isSlotNode ? (e36) => this.onDragOverSlot(e36, node) : (e36) => this.onDragOverElement(e36, node)}
          @dragenter=${isSlotNode ? (e36) => this.onDragOverSlot(e36, node) : (e36) => this.onDragOverElement(e36, node)}
          @dragleave=${isSlotNode ? (e36) => this.onDragLeaveSlot(e36, node) : (e36) => this.onDragLeaveElement(e36, node)}
          @drop=${isSlotNode ? (e36) => this.onDropOnSlot(e36, node) : (e36) => this.onDropOnElement(e36, node)}
          @click=${(e36) => this.onItemClick(e36, node)}
          @dblclick=${(e36) => this.onItemDblClick(e36, node)}
          @keydown=${(e36) => this.onKeyDown(e36, node)}
        >
          <span
            class="caret"
            ?expanded=${expanded}
            ?placeholder=${!hasChildren}
            @click=${hasChildren ? (e36) => {
      e36.stopPropagation();
      this.toggleExpanded(node);
    } : null}
          >
            ${hasChildren ? u16`<${CaretTag}></${CaretTag}>` : E}
          </span>
          ${isSlotNode ? x`<span class="icon-slot" title="Slot"
                ><sp-icon-layout></sp-icon-layout
              ></span>` : this.renderElementIconIfAvailable(node.element)}
          <span class="label">${node.label}</span>
        </div>
        ${showAfter ? x`<div
              class="drop-placeholder"
              data-pos="after"
              aria-hidden="true"
            ></div>` : E}
        ${hasChildren ? x`<div
              class="children"
              role="group"
              ?collapsed=${!expanded}
              aria-hidden=${String(!expanded)}
              ?inert=${!expanded}
            >
              ${node.children.map(
      (c33, i21, arr) => this.renderTree(c33, depth + 1, i21 + 1, arr.length)
    )}
            </div>` : E}
      </div>
    `;
  }
  // ----- Drag & Drop -----
  onDragStart(e36, node) {
    this.#dragElement = node?.element || null;
    if (e36?.dataTransfer) {
      e36.dataTransfer.effectAllowed = "move";
      e36.dataTransfer.setData("text/plain", "ee/element");
    }
    e36.currentTarget?.setAttribute?.("drag-source", "");
  }
  onDragEnd(e36, node) {
    e36.currentTarget?.removeAttribute?.("drag-source");
    this.#dragElement = null;
    this.renderRoot?.querySelectorAll?.(".node-row[data-drop-allowed]").forEach((el) => el.removeAttribute("data-drop-allowed"));
    this.#dropIndicator = null;
    this.requestUpdate();
    this.clearExpandHoverTimer();
  }
  onDragOverSlot(e36, slotNode) {
    const row = e36.currentTarget;
    const dragged = this.#dragElement;
    if (!dragged || !slotNode || slotNode.kind !== "slot") return;
    const allowed = this.canAcceptDrop(dragged, slotNode);
    if (allowed) {
      this.ensureExpandOnHover(slotNode);
      this.ensureAutoScrollFromEvent(e36);
      row.setAttribute("data-drop-allowed", "");
      e36.preventDefault();
      if (e36.dataTransfer) e36.dataTransfer.dropEffect = "move";
      row.removeAttribute("data-drop-denied");
      row.removeAttribute("title");
    } else {
      row.removeAttribute("data-drop-allowed");
      if (e36.dataTransfer) e36.dataTransfer.dropEffect = "none";
      const reason = this.getSlotDropDenyReason(this.#dragElement, slotNode) || "Drop not allowed";
      row.setAttribute("data-drop-denied", "");
      row.setAttribute("title", reason);
      this.ensureAutoScrollFromEvent(e36);
    }
  }
  onDragLeaveSlot(e36, slotNode) {
    e36.currentTarget?.removeAttribute?.("data-drop-allowed");
    e36.currentTarget?.removeAttribute?.("data-drop-denied");
    e36.currentTarget?.removeAttribute?.("title");
  }
  onDropOnSlot(e36, slotNode) {
    e36.preventDefault();
    const row = e36.currentTarget;
    row.removeAttribute("data-drop-allowed");
    const el = this.#dragElement;
    this.#dragElement = null;
    this.#dropIndicator = null;
    this.clearExpandHoverTimer();
    this.stopAutoScroll();
    if (!el || !slotNode || slotNode.kind !== "slot") return;
    if (!this.canAcceptDrop(el, slotNode)) return;
    const parent = slotNode.parentElement;
    if (el.contains(parent)) return;
    const domStore = this.store?.domStore;
    const success = handleDropOnSlot({
      store: this.store,
      domStore,
      dragged: el,
      slotNode
    });
    if (success) {
      this.markNavActive();
    }
  }
  // Dragging over an element row: allow reorder within same slot, or drop into default slot of this element when allowed
  onDragOverElement(e36, elementNode) {
    const row = e36.currentTarget;
    const dragged = this.#dragElement;
    const targetEl = elementNode?.element;
    if (!dragged || !targetEl) return;
    const canReorder = this.canReorderWithinSlot(dragged, targetEl);
    const canIntoDefault = this.canAcceptDropIntoDefault(dragged, targetEl);
    if (!canReorder && !canIntoDefault) {
      row.removeAttribute("data-drop-allowed");
      row.removeAttribute("data-drop-pos");
      this.#dropIndicator = null;
      this.requestUpdate();
      if (e36.dataTransfer) e36.dataTransfer.dropEffect = "none";
      const reason = this.getElementDropDenyReason(dragged, elementNode) || "Drop not allowed";
      row.setAttribute("data-drop-denied", "");
      row.setAttribute("title", reason);
      this.ensureAutoScrollFromEvent(e36);
      return;
    }
    e36.preventDefault();
    if (e36.dataTransfer) e36.dataTransfer.dropEffect = "move";
    row.setAttribute("data-drop-allowed", "");
    row.removeAttribute("data-drop-denied");
    row.removeAttribute("title");
    if (canReorder) {
      const rect = row.getBoundingClientRect();
      const before = e36.clientY - rect.top < rect.height / 2;
      row.setAttribute("data-drop-pos", before ? "before" : "after");
      this.#dropIndicator = {
        key: this.getKeyFor(elementNode),
        pos: before ? "before" : "after"
      };
      this.requestUpdate();
    } else {
      row.removeAttribute("data-drop-pos");
      this.#dropIndicator = null;
      this.requestUpdate();
      this.ensureExpandOnHover(elementNode);
    }
    this.ensureAutoScrollFromEvent(e36);
  }
  onDragLeaveElement(e36, elementNode) {
    e36.currentTarget?.removeAttribute("data-drop-allowed");
    e36.currentTarget?.removeAttribute("data-drop-pos");
    this.#dropIndicator = null;
    this.requestUpdate();
    e36.currentTarget?.removeAttribute("data-drop-denied");
    e36.currentTarget?.removeAttribute("title");
  }
  onDropOnElement(e36, elementNode) {
    e36.preventDefault();
    const row = e36.currentTarget;
    row.removeAttribute("data-drop-allowed");
    row.removeAttribute("data-drop-pos");
    const dragged = this.#dragElement;
    this.#dragElement = null;
    const targetEl = elementNode?.element;
    if (!dragged || !targetEl) return;
    const domStore = this.store?.domStore;
    if (this.canReorderWithinSlot(dragged, targetEl)) {
      const parent = targetEl.parentElement;
      if (!parent) return;
      const rect = row.getBoundingClientRect();
      const before = e36.clientY - rect.top < rect.height / 2;
      const success = handleReorderDrop({
        store: this.store,
        domStore,
        dragged,
        targetEl,
        before
      });
      if (success) {
        this.markNavActive();
      }
      this.#dropIndicator = null;
      this.requestUpdate();
      this.clearExpandHoverTimer();
      this.stopAutoScroll();
      return;
    }
    if (this.canAcceptDropIntoDefault(dragged, targetEl)) {
      if (dragged.contains(targetEl)) return;
      const success = handleDropIntoDefault({
        store: this.store,
        domStore,
        dragged,
        targetEl
      });
      if (success) {
        this.markNavActive();
      }
      this.#dropIndicator = null;
      this.requestUpdate();
      this.clearExpandHoverTimer();
      this.stopAutoScroll();
      return;
    }
    this.#dropIndicator = null;
    this.requestUpdate();
    this.clearExpandHoverTimer();
    this.stopAutoScroll();
  }
  canReorderWithinSlot(dragged, target) {
    if (!dragged || !target) return false;
    if (dragged === target) return false;
    const p1 = dragged.parentElement;
    const p210 = target.parentElement;
    if (!p1 || !p210 || p1 !== p210) return false;
    const s1 = dragged.getAttribute("slot") || "default";
    const s22 = target.getAttribute("slot") || "default";
    return s1 === s22;
  }
  ensureExpandOnHover(node) {
    const key = this.getKeyFor(node);
    if (!key) return;
    const hasChildren = Array.isArray(node.children) && node.children.length > 0;
    if (!hasChildren) return;
    if (this.isExpanded(node)) return;
    if (this.#expandHoverKey === key && this.#expandHoverTimer) return;
    this.clearExpandHoverTimer();
    this.#expandHoverKey = key;
    this.#expandHoverTimer = setTimeout(() => {
      this.setExpanded(node, true);
      this.clearExpandHoverTimer();
    }, 600);
  }
  clearExpandHoverTimer() {
    if (this.#expandHoverTimer) {
      clearTimeout(this.#expandHoverTimer);
    }
    this.#expandHoverTimer = null;
    this.#expandHoverKey = null;
  }
  // ----- Auto-scroll support while dragging -----
  ensureAutoScrollFromEvent(e36) {
    const tree = this.renderRoot?.querySelector?.(".tree");
    if (!tree) return this.stopAutoScroll();
    const rect = tree.getBoundingClientRect();
    const y5 = e36.clientY;
    const threshold = Math.max(24, rect.height * 0.08);
    let v6 = 0;
    if (y5 < rect.top + threshold) {
      const d22 = Math.max(1, rect.top + threshold - y5);
      v6 = -Math.min(16, Math.ceil(d22 / 4));
    } else if (y5 > rect.bottom - threshold) {
      const d22 = Math.max(1, y5 - (rect.bottom - threshold));
      v6 = Math.min(16, Math.ceil(d22 / 4));
    }
    this.#autoScrollVelocity = v6;
    if (!this.#autoScrollRAF)
      this.#autoScrollRAF = requestAnimationFrame(() => this.autoScrollStep());
  }
  autoScrollStep() {
    this.#autoScrollRAF = null;
    const tree = this.renderRoot?.querySelector?.(".tree");
    if (!tree) return;
    if (this.#autoScrollVelocity) {
      tree.scrollTop = Math.max(
        0,
        Math.min(tree.scrollHeight, tree.scrollTop + this.#autoScrollVelocity)
      );
    }
    if (this.#autoScrollVelocity)
      this.#autoScrollRAF = requestAnimationFrame(() => this.autoScrollStep());
  }
  stopAutoScroll() {
    if (this.#autoScrollRAF) cancelAnimationFrame(this.#autoScrollRAF);
    this.#autoScrollRAF = null;
    this.#autoScrollVelocity = 0;
  }
  // ----- Deny reason helpers -----
  getSlotDropDenyReason(dragged, slotNode) {
    if (!dragged || !slotNode || slotNode.kind !== "slot")
      return "Invalid target";
    const parent = slotNode.parentElement;
    if (!parent) return "No parent element";
    if (dragged.contains(parent)) return "Cannot move into its own descendant";
    const parentCtor = customElements.get(parent.tagName.toLowerCase());
    let cfg = null;
    const slotName = slotNode.slotName || "default";
    const parentSchema = getElementSchema(parentCtor?.ee, parent);
    if (parentSchema) {
      cfg = parentSchema.slots?.configs?.[slotName] || null;
    }
    if (!cfg && parentCtor?.ee?.getSlotConfig) {
      cfg = parentCtor.ee.getSlotConfig(slotName);
    }
    if (!cfg) return "Slot not available";
    if (cfg.inlineEditable === true) return "Slot accepts text content only";
    const currentParent = dragged.parentElement;
    const currentSlot = dragged.getAttribute("slot") || "default";
    if (currentParent !== parent || currentSlot !== slotName) {
      const maxLen = cfg.maxLength == null ? Infinity : Number(cfg.maxLength);
      let count = 0;
      for (const c33 of Array.from(parent.children || [])) {
        const s19 = c33.getAttribute && (c33.getAttribute("slot") || "default");
        if (s19 === slotName) count += 1;
      }
      if (!(count < maxLen)) return "Slot is full";
    }
    return "";
  }
  getElementDropDenyReason(dragged, elementNode) {
    const targetEl = elementNode?.element;
    if (!dragged || !targetEl) return "Invalid target";
    if (!this.canReorderWithinSlot(dragged, targetEl)) {
      const okDefault = this.canAcceptDropIntoDefault(dragged, targetEl);
      if (!okDefault) {
        const ctor = customElements.get(targetEl.tagName?.toLowerCase?.());
        let cfg = null;
        const targetSchema = getElementSchema(ctor?.ee, targetEl);
        if (targetSchema) {
          cfg = targetSchema.slots?.configs?.["default"] || null;
        }
        if (!cfg && ctor?.ee?.getSlotConfig) {
          cfg = ctor.ee.getSlotConfig("default");
        }
        if (!cfg) return "Default slot not available";
        if (cfg.inlineEditable === true) return "Default slot accepts text content only";
        const currentParent = dragged.parentElement;
        const currentSlot = dragged.getAttribute("slot") || "default";
        if (currentParent !== targetEl || currentSlot !== "default") {
          const maxLen = cfg.maxLength == null ? Infinity : Number(cfg.maxLength);
          let count = 0;
          for (const c33 of Array.from(targetEl.children || [])) {
            const s19 = c33.getAttribute && (c33.getAttribute("slot") || "default");
            if (s19 === "default") count += 1;
          }
          if (!(count < maxLen)) return "Default slot is full";
        }
        return "Drop not allowed here";
      }
    }
    return "";
  }
  canAcceptDropIntoDefault(draggedElement, targetElement) {
    if (!draggedElement || !targetElement) return false;
    const parent = targetElement;
    const ctor = customElements.get(parent.tagName?.toLowerCase?.());
    let cfg = null;
    const parentSchema = getElementSchema(ctor?.ee, parent);
    if (parentSchema) {
      cfg = parentSchema.slots?.configs?.["default"] || null;
    }
    if (!cfg && ctor?.ee?.getSlotConfig) {
      cfg = ctor.ee.getSlotConfig("default");
    }
    if (!cfg) return false;
    if (cfg.inlineEditable === true) return false;
    const currentParent = draggedElement.parentElement;
    const currentSlot = draggedElement.getAttribute("slot") || "default";
    if (currentParent !== parent || currentSlot !== "default") {
      const maxLen = cfg.maxLength == null ? Infinity : Number(cfg.maxLength);
      let count = 0;
      const kids = Array.from(parent.children || []);
      for (const c33 of kids) {
        if (!(c33 && c33.nodeType === Node.ELEMENT_NODE)) continue;
        const s19 = c33.getAttribute && (c33.getAttribute("slot") || "default");
        if (s19 === "default") count += 1;
      }
      if (!(count < maxLen)) return false;
    }
    return true;
  }
  canAcceptDrop(draggedElement, slotNode) {
    if (!draggedElement || !slotNode || slotNode.kind !== "slot") return false;
    const parent = slotNode.parentElement;
    if (!parent || !parent.tagName?.includes?.("-")) return false;
    if (draggedElement.contains(parent)) return false;
    const parentCtor = customElements.get(parent.tagName.toLowerCase());
    let cfg = null;
    const slotName = slotNode.slotName || "default";
    const parentSchema = getElementSchema(parentCtor?.ee, parent);
    if (parentSchema) {
      cfg = parentSchema.slots?.configs?.[slotName] || null;
    }
    if (!cfg && parentCtor?.ee?.getSlotConfig) {
      cfg = parentCtor.ee.getSlotConfig(slotName);
    }
    if (!cfg) return false;
    if (cfg.inlineEditable === true) return false;
    const currentParent = draggedElement.parentElement;
    const currentSlot = draggedElement.getAttribute("slot") || "default";
    if (currentParent !== parent || currentSlot !== slotName) {
      const maxLen = cfg.maxLength == null ? Infinity : Number(cfg.maxLength);
      let count = 0;
      const kids = Array.from(parent.children || []);
      for (const c33 of kids) {
        if (!(c33 && c33.nodeType === Node.ELEMENT_NODE)) continue;
        const s19 = c33.getAttribute && (c33.getAttribute("slot") || "default");
        if (s19 === slotName) count += 1;
      }
      if (!(count < maxLen)) return false;
    }
    return true;
  }
  // Render an element-provided icon if available via ee.getElementIcon()
  renderElementIcon(el) {
    const tpl = this.getElementIconTemplate(el);
    if (tpl === void 0) return x``;
    if (tpl === null) return x``;
    return tpl;
  }
  // Render icon-slot span only if an icon is available
  renderElementIconIfAvailable(el) {
    const tpl = this.getElementIconTemplate(el);
    if (tpl === void 0 || tpl === null) return E;
    return x`<span class="icon-slot">${tpl}</span>`;
  }
  getElementIconTemplate(el) {
    const tag3 = el?.tagName?.toLowerCase?.();
    if (!tag3) return void 0;
    const ctor = customElements.get(tag3);
    const iconProvider = ctor?.ee?.getElementIcon;
    if (iconProvider) {
      const result = iconProvider(x);
      if (typeof result === "string") {
        const iconTag = result.trim();
        if (!iconTag) return null;
        const defined = !!customElements.get(iconTag);
        if (!defined) return null;
        return u16`<${s9(iconTag)}></${s9(
          iconTag
        )}>`;
      }
      return result;
    }
    return void 0;
  }
  getCaretIconTag(_depth) {
    return "sp-icon-chevron-double-right";
  }
  render() {
    const filtered = this.filterTree(this.tree, this.searchQuery);
    const hasAny = Array.isArray(filtered) ? filtered.length > 0 : !!filtered;
    return x`
      <div class="nav-root">
        ${this.renderControls()}
        <div
          class="tree"
          role="tree"
          aria-multiselectable="false"
          tabindex="0"
          @focus=${this.onTreeFocus}
        >
          ${hasAny ? Array.isArray(filtered) ? filtered.map(
      (n25, i21, arr) => this.renderTree(n25, 0, i21 + 1, arr.length)
    ) : this.renderTree(filtered, 0) : x`
                <sp-illustrated-message heading="No results">
                  <div slot="description">Try a different search term.</div>
                </sp-illustrated-message>
              `}
        </div>
      </div>
    `;
  }
  onTreeFocus = (e36) => {
    this.markNavActive();
    const visible = this.getVisibleKeys();
    if (!visible.length) return;
    const targetKey = this.focusedKey && visible.includes(this.focusedKey) ? this.focusedKey : visible[0];
    if (targetKey)
      this.focusRowByKey(targetKey, { focus: true, scroll: false });
  };
};
customElements.define("content-tree-nav", makeLitObserver(TreeNav));

// src/features/toolbar/tool-panel.js
init_lit();

// src/features/toolbar/tool-panel.css.js
init_lit();
var toolPanelStyles = i`
  :host {
    position: absolute;
    top: 0;
    left: 0;
    display: block;
    height: 100%;
    width: 100%;
    color: var(--spectrum-alias-text-color);
    z-index: 1000;
    pointer-events: none;
  }

  /* Honor the hidden attribute on the host even with component styles */
  :host([hidden]) {
    display: none !important;
  }

  :host(:not([data-open])) {
    display: none;
  }

  :host([data-open]) {
    pointer-events: auto;
  }

  .panel-root {
    /* Apply sidebar card styling directly to the panel - matching tree-nav */
    height: calc(100% - var(--spectrum-global-dimension-size-400));
    margin: var(--spectrum-global-dimension-size-200) 0 0 0;
    background: var(--spectrum-alias-component-background-color);
    border: 1px solid var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-global-dimension-size-100);
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    padding: var(--spectrum-global-dimension-size-100);
    position: relative;
  }

  .close-button {
    position: absolute;
    top: var(--spectrum-global-dimension-size-200);
    right: var(--spectrum-global-dimension-size-200);
    z-index: 1;
  }

  .panel-content {
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
  }
`;

// src/features/toolbar/tool-panel.js
var ToolPanel = class extends i4 {
  static styles = toolPanelStyles;
  static properties = {
    editorStore: { type: Object, observe: true },
    toolbarStore: { type: Object, observe: true }
  };
  constructor() {
    super();
    this.editorStore = null;
    this.toolbarStore = null;
    this.#accessToken = null;
    this.#toolElement = null;
  }
  #accessToken;
  #toolElement;
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("keydown", this.#handleEscapeKey);
    document.addEventListener("click", this.#handleClickOutside, true);
    this.addEventListener("click", this.#handleClickBubble, false);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("keydown", this.#handleEscapeKey);
    document.removeEventListener("click", this.#handleClickOutside, true);
    this.removeEventListener("click", this.#handleClickBubble, false);
  }
  #handleClickBubble = (event) => {
    const path = event.composedPath();
    const isClickInside = path.includes(this) || this.#toolElement && path.includes(this.#toolElement);
    if (isClickInside) {
      console.log("[ToolPanel] Click bubble handler - stopping propagation after tool handled it");
      event.stopPropagation();
    }
  };
  #handleEscapeKey = (event) => {
    if (event.key === "Escape" && this.openTool) {
      event.stopPropagation();
      this.#handleToolClose();
    }
  };
  #handleClickOutside = (event) => {
    if (!this.openTool) return;
    const path = event.composedPath();
    const isClickInside = path.includes(this) || this.#toolElement && path.includes(this.#toolElement);
    console.log("[ToolPanel] Click outside handler", {
      hasOpenTool: !!this.openTool,
      hasToolElement: !!this.#toolElement,
      toolElementTag: this.#toolElement?.tagName,
      pathLength: path.length,
      pathIncludesPanel: path.includes(this),
      pathIncludesToolElement: this.#toolElement ? path.includes(this.#toolElement) : false,
      isClickInside,
      pathElements: path.filter((node) => node?.nodeType === Node.ELEMENT_NODE).map((node) => ({
        tagName: node.tagName,
        id: node.id,
        className: node.className
      }))
    });
    if (isClickInside) {
      console.log("[ToolPanel] Click inside panel - NOT stopping propagation, letting tool element handle it");
      return;
    }
    console.log("[ToolPanel] Closing panel - click outside detected");
    this.#handleToolClose();
  };
  get openTool() {
    return this.toolbarStore?.openTool || null;
  }
  get editingElement() {
    return this.editorStore?.editingElement || null;
  }
  render() {
    const openTool = this.openTool;
    const editingElement = this.editingElement;
    console.log("[ToolPanel] render called", {
      hasEditorStore: !!this.editorStore,
      hasToolbarStore: !!this.toolbarStore,
      openTool,
      editingElement: editingElement?.tagName
    });
    if (openTool && editingElement) {
      this.setAttribute("data-open", "");
    } else {
      this.removeAttribute("data-open");
    }
    if (!openTool || !editingElement) {
      return x``;
    }
    return x`
      <div class="panel-root">
        <sp-action-button
          class="close-button"
          quiet
          size="s"
          title="Close"
          @click=${this.#handleToolClose}
        >
          <sp-icon-close slot="icon"></sp-icon-close>
        </sp-action-button>
        <div class="panel-content"></div>
      </div>
    `;
  }
  updated(changed) {
    if (changed.has("editorStore")) {
      this.toolbarStore = this.editorStore?.toolbar || null;
    }
    const openTool = this.openTool;
    const editingElement = this.editingElement;
    console.log("[ToolPanel] updated called", {
      changed: Array.from(changed.keys()),
      openTool,
      editingElement: editingElement?.tagName
    });
    if (!editingElement && openTool) {
      console.log("[ToolPanel] Closing tool - element unselected");
      if (this.toolbarStore) {
        this.toolbarStore.setOpenTool(null);
      }
      this.#cleanupTool();
      return;
    }
    if (openTool && editingElement) {
      const currentToolTag = openTool.tag || "";
      const existingToolTag = this.#toolElement?.tagName?.toLowerCase() || "";
      if (currentToolTag !== existingToolTag || this.#toolElement?.target !== editingElement) {
        console.log("[ToolPanel] Initializing tool", { currentToolTag, existingToolTag, editingElement });
        this.#initializeTool(openTool, editingElement);
      }
    } else if (!openTool && this.#toolElement) {
      console.log("[ToolPanel] Cleaning up tool");
      this.#cleanupTool();
    }
  }
  #cleanupTool() {
    if (this.#toolElement && this.#toolElement.parentNode) {
      this.#toolElement.remove();
      this.#toolElement = null;
    }
  }
  async #initializeTool(openTool, editingElement) {
    if (!openTool || !editingElement) {
      this.#cleanupTool();
      return;
    }
    const toolTag = openTool.tag || "";
    if (!toolTag) {
      this.#cleanupTool();
      return;
    }
    await this.updateComplete;
    const container = this.shadowRoot?.querySelector(".panel-content");
    if (!container) return;
    this.#cleanupTool();
    const toolEl = document.createElement(toolTag);
    toolEl.target = editingElement;
    toolEl.addEventListener("tool-close", () => this.#handleToolClose());
    container.appendChild(toolEl);
    this.#toolElement = toolEl;
    if (toolEl.setAccessToken && this.#accessToken) {
      toolEl.setAccessToken(this.#accessToken);
    } else if (toolEl.setAccessToken && this.editorStore?.documentStore) {
      const token = await this.editorStore.documentStore.getAccessToken();
      if (token) {
        this.#accessToken = token;
        toolEl.setAccessToken(token);
      }
    }
  }
  #handleToolClose() {
    if (this.toolbarStore) {
      this.toolbarStore.setOpenTool(null);
    }
  }
  setAccessToken(token) {
    this.#accessToken = token;
    if (this.#toolElement && this.#toolElement.setAccessToken) {
      this.#toolElement.setAccessToken(token);
    }
  }
};
customElements.define("tool-panel", makeLitObserver(ToolPanel));

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconAlertCircle.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/AlertCircle.js
var AlertCircleIcon = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Alert Circle" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <g>
      <path
        d="M18.1 2.2A15.9 15.9 0 1 0 34 18.1 15.9 15.9 0 0 0 18.1 2.2Zm0 29.812A13.912 13.912 0 1 1 32.012 18.1 13.912 13.912 0 0 1 18.1 32.012Z"
      />
      <path
        d="M15.691 25.772a2.268 2.268 0 0 1 2.232-2.304q.084 0 .168.004a2.232 2.232 0 0 1 2.4 2.3 2.181 2.181 0 0 1-2.4 2.234 2.182 2.182 0 0 1-2.4-2.234Zm4.434-16.977a.416.416 0 0 1 .2.367v2.082c0 2.8-.567 7.96-.667 8.962 0 .1-.033.199-.234.199h-2.666a.221.221 0 0 1-.234-.2c-.066-.933-.6-6.06-.6-8.861V9.26a.355.355 0 0 1 .167-.366 5.766 5.766 0 0 1 2-.4 6.55 6.55 0 0 1 2.034.3Z"
      />
    </g>
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/AlertDiamond.js
var AlertDiamondIcon = ({ width: t34 = 24, height: l16 = 24, hidden: r25 = false, title: e36 = "Alert Diamond" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="M10,18.79492c-.60107,0-1.1665-.23438-1.59131-.65918L1.86426,11.59082c-.87646-.87695-.87646-2.30469-.00049-3.18164L8.40918,1.86426c.84863-.84961,2.33252-.84961,3.18213,0l6.54443,6.54492c.87646.87695.87646,2.30469.00049,3.18164h-.00049l-6.54492,6.54492c-.42432.4248-.98975.65918-1.59082.65918ZM10,2.70508c-.2002,0-.38867.07812-.52979.21973l-6.54541,6.54492c-.29199.29199-.29199.76855.00049,1.06055l6.54443,6.54492c.2832.2832.77783.2832,1.06006,0l6.54492-6.54492c.29248-.29199.29248-.76855,0-1.06055l-6.54443-6.54492c-.1416-.1416-.33008-.21973-.53027-.21973Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="M9.99936,14.99834c-.23065.00812-.45538-.07378-.62661-.22835-.33033-.36462-.33033-.91993,0-1.28455.16935-.15832.39483-.24279.62664-.23476.23635-.00947.46589.08026.63302.24745.16207.1677.24916.39386.24137.62681.01238.23469-.06959.4646-.2277.63864-.17358.16455-.40786.24959-.64671.23475Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="M10,11.625c-.41406,0-.75-.33594-.75-.75v-5c0-.41406.33594-.75.75-.75s.75.33594.75.75v5c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconAlertCircle.js
var IconAlertCircle = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? AlertCircleIcon({ hidden: !this.label, title: this.label }) : AlertDiamondIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-alert-circle.js
init_define_element();
defineElement("sp-icon-alert-circle", IconAlertCircle);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFileText.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/FileText.js
var FileTextIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "File Text" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m16.34082,5.2959l-3.62109-3.62207c-.41895-.41895-.99902-.65918-1.59082-.65918h-5.87891c-1.24023,0-2.25,1.00977-2.25,2.25v12.4834c0,1.24023,1.00977,2.25,2.25,2.25h9.5c1.24023,0,2.25-1.00977,2.25-2.25V6.88672c0-.60059-.23438-1.16602-.65918-1.59082Zm-1.06055,1.06055c.04614.04614.07397.10352.10596.1582h-3.13623c-.41309,0-.75-.33691-.75-.75v-3.13623c.05542.03223.11353.0603.15918.10596l3.62109,3.62207Zm-.53027,10.1416H5.25c-.41309,0-.75-.33691-.75-.75V3.26465c0-.41309.33691-.75.75-.75h4.75v3.25c0,1.24023,1.00977,2.25,2.25,2.25h3.25v7.7334c0,.41309-.33691.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m13,11.49805h-6c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h6c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m13,14.49805h-6c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h6c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/FileTxt.js
var FileTxtIcon = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "File Txt" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path d="M20 2v10h10L20 2z" />
    <path
      d="M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14Zm7 15.5a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5Zm0-4a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5Zm0-4a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFileText.js
var IconFileText = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? FileTextIcon({ hidden: !this.label, title: this.label }) : FileTxtIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-file-text.js
init_define_element();
defineElement("sp-icon-file-text", IconFileText);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconZoomIn.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ZoomIn.js
var ZoomInIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Zoom In" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m10.7998,7.25h-2.0498v-2.0498c0-.41406-.33594-.75-.75-.75s-.75.33594-.75.75v2.0498h-2.0498c-.41406,0-.75.33594-.75.75s.33594.75.75.75h2.0498v2.0498c0,.41406.33594.75.75.75s.75-.33594.75-.75v-2.0498h2.0498c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75Z"
      fill="currentColor"
    />
    <path
      d="m18.78027,17.71973l-5.33301-5.33301c-.00006,0-.00024,0-.00031-.00024.96942-1.20142,1.55304-2.72632,1.55304-4.38647,0-3.85938-3.14014-7-7-7S1,4.14062,1,8s3.14014,7,7,7c1.66022,0,3.18524-.5835,4.38654-1.55298.00006,0,.00012.00024.00018.00024l5.33301,5.33301c.14648.14648.33838.21973.53027.21973s.38379-.07324.53027-.21973c.29297-.29297.29297-.76758,0-1.06055Zm-10.78027-4.21973c-3.03271,0-5.5-2.46777-5.5-5.5s2.46729-5.5,5.5-5.5,5.5,2.46777,5.5,5.5-2.46729,5.5-5.5,5.5Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ZoomIn.js
var ZoomInIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "Zoom In" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M21.5 14H18v-3.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5V14h-3.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5H14v3.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V18h3.5a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5Z"
    />
    <path
      d="M35.173 32.215 27.256 24.3a14.031 14.031 0 1 0-2.956 2.957l7.916 7.916a2.1 2.1 0 0 0 2.958-2.958ZM6 16a10 10 0 1 1 10 10A10 10 0 0 1 6 16Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconZoomIn.js
var IconZoomIn = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ZoomInIcon({ hidden: !this.label, title: this.label }) : ZoomInIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-zoom-in.js
init_define_element();
defineElement("sp-icon-zoom-in", IconZoomIn);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconZoomOut.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ZoomOut.js
var ZoomOutIcon = ({ width: t34 = 24, height: l16 = 24, hidden: r25 = false, title: e36 = "Zoom Out" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="m10.7998,8.75h-5.59961c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h5.59961c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m8,15c-3.85986,0-7-3.14062-7-7S4.14014,1,8,1s7,3.14062,7,7-3.14014,7-7,7Zm0-12.5c-3.03271,0-5.5,2.46777-5.5,5.5s2.46729,5.5,5.5,5.5,5.5-2.46777,5.5-5.5-2.46729-5.5-5.5-5.5Z"
      fill="currentColor"
    />
    <path
      d="m18.25,19c-.19189,0-.38379-.07324-.53027-.21973l-5.33301-5.33301c-.29297-.29297-.29297-.76758,0-1.06055s.76758-.29297,1.06055,0l5.33301,5.33301c.29297.29297.29297.76758,0,1.06055-.14648.14648-.33838.21973-.53027.21973Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ZoomOut.js
var ZoomOutIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Zoom Out" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <rect height="4" rx=".5" ry=".5" width="12" x="10" y="14" />
    <path
      d="M35.173 32.215 27.256 24.3a14.031 14.031 0 1 0-2.956 2.957l7.916 7.916a2.1 2.1 0 0 0 2.958-2.958ZM6 16a10 10 0 1 1 10 10A10 10 0 0 1 6 16Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconZoomOut.js
var IconZoomOut = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ZoomOutIcon({ hidden: !this.label, title: this.label }) : ZoomOutIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-zoom-out.js
init_define_element();
defineElement("sp-icon-zoom-out", IconZoomOut);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUndo.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Undo.js
var UndoIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Undo" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m12.25732,5H3.80811l1.71973-1.71973c.29297-.29297.29297-.76758,0-1.06055s-.76758-.29297-1.06055,0l-2.99756,2.99756c-.29297.29248-.29297.76709-.00049,1.06006l2.99756,3.00244c.14648.14697.33838.22021.53076.22021.19189,0,.3833-.07324.52979-.21924.29346-.29248.29346-.76758.00098-1.06055l-1.71747-1.72021h8.44647c2.48145,0,4.50049,2.01855,4.50049,4.5s-2.01904,4.5-4.50049,4.5h-3.73779c-.41406,0-.75.33594-.75.75s.33594.75.75.75h3.73779c3.30859,0,6.00049-2.69141,6.00049-6s-2.69189-6-6.00049-6Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Undo.js
var UndoIcon2 = ({ width: t34 = 24, height: a23 = 24, hidden: e36 = false, title: l16 = "Undo" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${a23}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M30.663 12.542A10.391 10.391 0 0 0 23.671 10H11V4.8a.8.8 0 0 0-.8-.8.787.787 0 0 0-.527.2l-7.529 7.449a.5.5 0 0 0 0 .7L9.668 19.8a.787.787 0 0 0 .527.2.8.8 0 0 0 .8-.8V14h12.882a6.139 6.139 0 0 1 6.223 5.8A5.889 5.889 0 0 1 24 26h-7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6.526a10.335 10.335 0 0 0 10.426-9.013 9.947 9.947 0 0 0-3.289-8.445Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUndo.js
var IconUndo = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? UndoIcon({ hidden: !this.label, title: this.label }) : UndoIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-undo.js
init_define_element();
defineElement("sp-icon-undo", IconUndo);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconRedo.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Redo.js
var RedoIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Redo" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m7.74268,5h8.44922s-1.71973-1.71973-1.71973-1.71973c-.29297-.29297-.29297-.76758,0-1.06055s.76758-.29297,1.06055,0l2.99756,2.99756c.29297.29248.29297.76709.00049,1.06006l-2.99756,3.00244c-.14648.14697-.33838.22021-.53076.22021-.19189,0-.3833-.07324-.52979-.21924-.29346-.29248-.29346-.76758-.00098-1.06055l1.71747-1.72021H7.74268c-2.48145,0-4.50049,2.01855-4.50049,4.5s2.01904,4.5,4.50049,4.5h3.73779c.41406,0,.75.33594.75.75,0,.41406-.33594.75-.75.75h-3.73779c-3.30859,0-6.00049-2.69141-6.00049-6s2.69189-6,6.00049-6Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Redo.js
var RedoIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: l16 = "Redo" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M5.337 12.542A10.391 10.391 0 0 1 12.329 10H25V4.8a.8.8 0 0 1 .8-.8.787.787 0 0 1 .527.2l7.524 7.445a.5.5 0 0 1 0 .7L26.332 19.8a.787.787 0 0 1-.527.2.8.8 0 0 1-.8-.8V14H12.123A6.139 6.139 0 0 0 5.9 19.8 5.889 5.889 0 0 0 12 26h7a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6.526a10.335 10.335 0 0 1-10.426-9.013 9.947 9.947 0 0 1 3.289-8.445Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconRedo.js
var IconRedo = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? RedoIcon({ hidden: !this.label, title: this.label }) : RedoIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-redo.js
init_define_element();
defineElement("sp-icon-redo", IconRedo);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconWebPage.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/WebPage.js
var WebPageIcon = ({ width: e36 = 24, height: r25 = 24, hidden: t34 = false, title: l16 = "Web Page" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <circle cx="4.125" cy="6" r=".75" fill="currentColor" />
    <path
      d="m16.75,3H3.25c-1.24023,0-2.25,1.00977-2.25,2.25v9.5c0,1.24023,1.00977,2.25,2.25,2.25h13.5c1.24023,0,2.25-1.00977,2.25-2.25V5.25c0-1.24023-1.00977-2.25-2.25-2.25ZM2.5,5.25c0-.41309.33691-.75.75-.75h13.5c.41309,0,.75.33691.75.75v2.25H2.5v-2.25Zm14.25,10.25H3.25c-.41309,0-.75-.33691-.75-.75v-5.75h15v5.75c0,.41309-.33691.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Homepage.js
var HomepageIcon = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Homepage" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path d="M6 22h12v4H6zM20 22h4v4h-4zM26 22h4v4h-4zM6 14h24v6H6z" />
    <path
      d="M33 4H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1ZM4 28V10h28v18Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconWebPage.js
var IconWebPage = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? WebPageIcon({ hidden: !this.label, title: this.label }) : HomepageIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-web-page.js
init_define_element();
defineElement("sp-icon-web-page", IconWebPage);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconGearsEdit.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/GearsEdit.js
var GearsEditIcon = ({ width: a23 = 24, height: l16 = 24, hidden: t34 = false, title: e36 = "Gears Edit" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${l16}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="M17.193 25.786h-2.125a6.142 6.142 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858 0l-1.511 1.514a6.145 6.145 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607H8.393a.607.607 0 0 0-.607.607v2.125a6.145 6.145 0 0 0-2.178.9l-1.513-1.516a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.513 1.514a6.142 6.142 0 0 0-.9 2.179H.807a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.516 1.512a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.514-1.514a6.145 6.145 0 0 0 2.178.9v2.125a.607.607 0 0 0 .607.607h1.214a.607.607 0 0 0 .607-.607v-2.127a6.145 6.145 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858 0l.92-.92a.607.607 0 0 0 0-.858l-1.513-1.511a6.142 6.142 0 0 0 .9-2.179h2.125a.607.607 0 0 0 .607-.607v-1.213a.607.607 0 0 0-.609-.607ZM9 30.164A3.164 3.164 0 1 1 12.164 27 3.164 3.164 0 0 1 9 30.164ZM19.967 24.036a.865.865 0 0 0 1.127-.474l1.144-2.8a8.691 8.691 0 0 0 3 .025l4.188-4.188a3.221 3.221 0 0 1 2.187-.949h.1a3.119 3.119 0 0 1 2.224.918l1.182 1.181a.806.806 0 0 0 .072-.108l.653-1.6a.865.865 0 0 0-.474-1.127l-2.8-1.143a8.749 8.749 0 0 0-.012-3.357l2.811-1.182a.865.865 0 0 0 .462-1.132L35.1 6.383a.865.865 0 0 0-1.132-.462L31.157 7.1a8.762 8.762 0 0 0-2.392-2.356l1.143-2.8a.864.864 0 0 0-.473-1.127l-1.6-.653a.865.865 0 0 0-1.127.474l-1.143 2.8a8.763 8.763 0 0 0-3.357.012L21.024.644a.865.865 0 0 0-1.132-.462L18.183.9a.865.865 0 0 0-.462 1.132L18.9 4.843a8.756 8.756 0 0 0-2.356 2.392l-2.8-1.143a.864.864 0 0 0-1.127.474l-.653 1.6a.865.865 0 0 0 .474 1.127l2.8 1.143a8.761 8.761 0 0 0 .012 3.357l-2.811 1.182a.865.865 0 0 0-.461 1.132l.719 1.708a.864.864 0 0 0 1.132.462l2.81-1.182a8.758 8.758 0 0 0 2.392 2.356l-1.143 2.8a.865.865 0 0 0 .474 1.127ZM23.9 7.912a4.188 4.188 0 1 1-4.188 4.188A4.188 4.188 0 0 1 23.9 7.912Z"
    />
    <path
      d="m35.738 21.764-3.506-3.506a.739.739 0 0 0-.527-.215h-.023a.834.834 0 0 0-.564.247L20.3 29.113a.611.611 0 0 0-.153.256l-2.027 6c-.069.229.279.517.477.517a.284.284 0 0 0 .037 0c.168-.039 5.123-1.764 6-2.028a.591.591 0 0 0 .252-.152l10.82-10.828a.834.834 0 0 0 .246-.537.742.742 0 0 0-.214-.577ZM19.7 34.3l1.56-4.431 2.871 2.863c-1.309.391-3.29 1.225-4.431 1.568Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconGearsEdit.js
var IconGearsEdit = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? GearsEditIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-gears-edit.js
init_define_element();
defineElement("sp-icon-gears-edit", IconGearsEdit);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconComment.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Comment.js
var CommentIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Comment" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m6.25,19c-.09912,0-.19873-.01953-.29346-.05957-.27686-.11816-.45654-.38965-.45654-.69043v-3.25h-.75c-2.06787,0-3.75-1.68262-3.75-3.75v-5.5c0-2.06738,1.68213-3.75,3.75-3.75h10.5c2.06787,0,3.75,1.68262,3.75,3.75v5.5c0,2.06738-1.68213,3.75-3.75,3.75h-4.54297l-3.93701,3.79004c-.14258.1377-.32959.20996-.52002.20996Zm-1.5-15.5c-1.24072,0-2.25,1.00977-2.25,2.25v5.5c0,1.24023,1.00928,2.25,2.25,2.25h1.5c.41406,0,.75.33594.75.75v2.2373l2.88477-2.77734c.13965-.13477.32617-.20996.52002-.20996h4.84521c1.24072,0,2.25-1.00977,2.25-2.25v-5.5c0-1.24023-1.00928-2.25-2.25-2.25H4.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Comment.js
var CommentIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: r25 = "Comment" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M6 4a4 4 0 0 0-4 4v14a4 4 0 0 0 4 4h2v8.793a.5.5 0 0 0 .854.353L18 26h12a4 4 0 0 0 4-4V8a4 4 0 0 0-4-4Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconComment.js
var IconComment = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? CommentIcon({ hidden: !this.label, title: this.label }) : CommentIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-comment.js
init_define_element();
defineElement("sp-icon-comment", IconComment);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconHistory.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/History.js
var HistoryIcon = ({ width: l16 = 24, height: t34 = 24, hidden: r25 = false, title: e36 = "History" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="M13.21973,12.65674c-.12891,0-.25977-.0332-.37891-.10352l-3.2207-1.89502c-.22949-.13477-.37012-.38086-.37012-.64648v-5c0-.41406.33594-.75.75-.75s.75.33594.75.75v4.57129l2.85059,1.67725c.35742.20996.47656.66992.2666,1.02686-.13965.2373-.39062.36963-.64746.36963Z"
      fill="currentColor"
    />
    <path
      d="M10,1.25c-2.78918,0-5.39026,1.36719-7.02332,3.56567l-.24426-1.48462c-.06738-.40918-.46289-.68359-.8623-.61816-.4082.06738-.68555.45361-.61816.8623l.55371,3.36279c.06055.36719.37891.62793.73926.62793.04004,0,.08105-.00293.12207-.00977l3.36621-.55127c.40918-.06689.68555-.45264.61914-.86133-.06738-.4082-.44727-.68359-.86133-.61914l-1.68457.27588c1.34741-1.87939,3.54175-3.05029,5.89355-3.05029,3.99805,0,7.25,3.25244,7.25,7.25s-3.25195,7.25-7.25,7.25c-2.98047,0-5.62305-1.78662-6.73145-4.55225-.1543-.38477-.59082-.57178-.97559-.41699-.38477.1543-.57129.59082-.41699.97559,1.33887,3.3374,4.52734,5.49365,8.12402,5.49365,4.8252,0,8.75-3.92529,8.75-8.75S14.8252,1.25,10,1.25Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/History.js
var HistoryIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "History" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M19 6h-2a1 1 0 0 0-1 1v10.586a1 1 0 0 0 .293.707L21.9 23.9a1 1 0 0 0 1.414 0l1.336-1.336a1 1 0 0 0 0-1.414L20 16.5V7a1 1 0 0 0-1-1Z"
    />
    <path
      d="M18 2A15.946 15.946 0 0 0 6.856 6.519 13.124 13.124 0 0 0 2.847 14H.5a.5.5 0 0 0-.5.5.49.49 0 0 0 .147.35l3.537 4.033a.5.5 0 0 0 .632 0l3.537-4.033A.49.49 0 0 0 8 14.5a.5.5 0 0 0-.5-.5H4.969a11.708 11.708 0 0 1 3.489-6.245 14 14 0 1 1-.009 20.481.5.5 0 0 0-.691.006l-.707.707a.506.506 0 0 0 0 .723A16 16 0 1 0 18 2Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconHistory.js
var IconHistory = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? HistoryIcon({ hidden: !this.label, title: this.label }) : HistoryIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-history.js
init_define_element();
defineElement("sp-icon-history", IconHistory);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconOpenIn.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/OpenIn.js
var OpenInIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Open In" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m18,15.75V4.25c0-1.24072-1.00928-2.25-2.25-2.25H4.25c-1.24072,0-2.25,1.00928-2.25,2.25v3.71777c0,.41406.33594.75.75.75s.75-.33594.75-.75v-3.71777c0-.41357.33643-.75.75-.75h11.5c.41357,0,.75.33643.75.75v11.5c0,.41357-.33643.75-.75.75h-3.81104c-.41406,0-.75.33594-.75.75s.33594.75.75.75h3.81104c1.24072,0,2.25-1.00928,2.25-2.25Z"
      fill="currentColor"
    />
    <path
      d="m11,9.75v4.24268c0,.41406-.33594.75-.75.75s-.75-.33594-.75-.75v-2.43213l-6.46973,6.46973c-.14648.14648-.33838.21973-.53027.21973s-.38379-.07324-.53027-.21973c-.29297-.29297-.29297-.76758,0-1.06055l6.46973-6.46973h-2.43213c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h4.24268c.41406,0,.75.33594.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/OpenIn.js
var OpenInIcon2 = ({ width: a23 = 24, height: e36 = 24, hidden: t34 = false, title: l16 = "Open In" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${a23}"
    height="${e36}"
    viewBox="0 0 36 36"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M33 2H3a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V6h24v24H19a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1Z"
    />
    <path
      d="M18.636 27.764a.784.784 0 0 0 .56.236.803.803 0 0 0 .804-.754v-10.75a.497.497 0 0 0-.496-.496H8.754a.803.803 0 0 0-.754.804.785.785 0 0 0 .235.56l3.786 3.786-9.042 9.042a1 1 0 0 0 0 1.415l1.414 1.414a1 1 0 0 0 1.414 0l9.043-9.042Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconOpenIn.js
var IconOpenIn = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? OpenInIcon({ hidden: !this.label, title: this.label }) : OpenInIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-open-in.js
init_define_element();
defineElement("sp-icon-open-in", IconOpenIn);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconRevert.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Revert.js
var RevertIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Revert" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m18,15.5H3c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h15c.41406,0,.75.33594.75.75s-.33594.75-.75.75ZM11,3.25c-3.77661,0-6.92633,2.81616-7.6087,6.52832l-.85858-1.43994c-.21143-.35596-.67236-.47119-1.02832-.25977-.35547.21191-.47217.67236-.25977,1.02832l1.79541,3.01172c.10352.17383.27344.29834.47021.34521.05762.01367.11572.02051.17383.02051.14111,0,.28076-.04004.40186-.1167l2.91943-1.85254c.34961-.22217.45312-.68555.23145-1.03516-.22217-.3501-.68604-.45312-1.03516-.23145l-1.34387.85291c.53448-3.03955,3.0827-5.35144,6.14221-5.35144,3.44629,0,6.25,2.93115,6.25,6.53418,0,.41406.33594.75.75.75s.75-.33594.75-.75c0-4.43018-3.47656-8.03418-7.75-8.03418Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Revert.js
var RevertIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Revert" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <rect height="4" rx="1" ry="1" width="32" x="2" y="26" />
    <path
      d="M2.5 20h10.75a.8.8 0 0 0 .75-.8.784.784 0 0 0-.235-.56L9.81 14.681l.692-.693a11.447 11.447 0 0 1 19.116 5.074A1.215 1.215 0 0 0 30.78 20h1.894a1 1 0 0 0 .991-1.17A15.43 15.43 0 0 0 14.621 7.165 16.181 16.181 0 0 0 7.337 11.5l-.356.357-3.617-3.621A.781.781 0 0 0 2.8 8a.8.8 0 0 0-.8.754V19.5a.5.5 0 0 0 .5.5Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconRevert.js
var IconRevert = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? RevertIcon({ hidden: !this.label, title: this.label }) : RevertIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-revert.js
init_define_element();
defineElement("sp-icon-revert", IconRevert);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUploadToCloud.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/UploadToCloud.js
var UploadToCloudIcon = ({ width: l16 = 24, height: t34 = 24, hidden: e36 = false, title: o52 = "Upload To Cloud" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${o52}"
  >
    <path
      d="m19.73877,11.66797c0,1.15771-.45068,2.24561-1.26904,3.06348s-1.90625,1.26855-3.06348,1.26855h-.65723c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h.65723c.75635,0,1.46777-.29443,2.00293-.82959.53516-.53467.82959-1.24561.82959-2.00244,0-.72754-.27686-1.41748-.7793-1.94189-.50146-.52393-1.17676-.8335-1.90234-.87207-.25439-.01367-.48486-.15576-.61133-.37695-.12646-.22168-.13184-.49219-.01367-.71826.12549-.24121.22217-.48975.28711-.73877.06836-.25977.10303-.52588.10303-.7915,0-.89355-.34766-1.7334-.979-2.36523-1.20801-1.20703-3.29639-1.27393-4.56787-.14062-.60059.53662-.98975,1.27246-1.09424,2.07275-.03076.23584-.17188.44336-.37988.55859-.20752.11572-.45752.12549-.6748.02686-.16846-.07666-.3418-.13574-.5166-.17529-.86035-.1958-1.7417.06934-2.34863.66211-.47461.46289-.73584,1.07666-.73584,1.72803,0,.16748.01807.33496.05322.49854.03467.1582.08643.31543.15283.46582.09961.22412.08301.48291-.04395.69287-.12744.20996-.34912.34424-.59375.35986-.49609.03174-.95654.24707-1.29785.60596-.34131.36035-.52979.83252-.52979,1.32959,0,.52148.20312,1.01172.57178,1.38037.36865.36816.8584.57129,1.37988.57129h2.09961c.41406,0,.75.33594.75.75s-.33594.75-.75.75h-2.09961c-.92188,0-1.78857-.35889-2.44043-1.01074-.65234-.65186-1.01123-1.51904-1.01123-2.44092,0-.88281.33447-1.72119.94141-2.36182.38721-.40771.86084-.71045,1.38232-.88965-.04297-.23145-.06445-.46631-.06445-.70117,0-1.05908.42188-2.0542,1.18848-2.80176.95605-.93408,2.3335-1.3501,3.67627-1.0625.26416-.81494.74072-1.55127,1.38672-2.12793.88184-.78613,2.01855-1.21924,3.20166-1.21924,1.29346,0,2.51025.50391,3.42529,1.41846.91455.91504,1.41846,2.13184,1.41846,3.42578,0,.39453-.05127.78906-.15234,1.17236-.01074.04199-.02246.08398-.03467.12549.72119.21191,1.37793.60889,1.90771,1.16211.771.80518,1.1958,1.86328,1.1958,2.97949Z"
      fill="currentColor"
    />
    <path
      d="m13.85352,10.82373l-3.00293-2.99756c-.29297-.29199-.76709-.29248-1.06006.00049l-2.99707,2.99756c-.29297.29297-.29297.76758,0,1.06055.14648.14648.33838.21973.53027.21973s.38379-.07324.53027-.21973l1.72217-1.72253v8.18347c0,.41406.33594.75.75.75s.75-.33594.75-.75v-8.17517l1.71777,1.71472c.29248.29199.76709.29199,1.06055-.00098.29248-.29297.29248-.76807-.00098-1.06055Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/UploadToCloud.js
var UploadToCloudIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "Upload To Cloud" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M16 33a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-9h-4ZM29.572 11.143a6.449 6.449 0 0 0-.726.041 8.144 8.144 0 1 0-15.922-3.236 6.862 6.862 0 0 0-8.407 8.394A3.857 3.857 0 1 0 3.857 24H16v-6h-4.3a.7.7 0 0 1-.7-.7.685.685 0 0 1 .207-.49l6.468-5.685a.5.5 0 0 1 .65 0l6.468 5.685a.685.685 0 0 1 .207.49.7.7 0 0 1-.7.7H20v6h9.572a6.429 6.429 0 0 0 0-12.857Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUploadToCloud.js
var IconUploadToCloud = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? UploadToCloudIcon({ hidden: !this.label, title: this.label }) : UploadToCloudIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-upload-to-cloud.js
init_define_element();
defineElement("sp-icon-upload-to-cloud", IconUploadToCloud);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTarget.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Target.js
var TargetIcon = ({ width: t34 = 24, height: r25 = 24, hidden: e36 = false, title: l16 = "Target" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <circle cx="10" cy="10" r="1.5" fill="currentColor" stroke-width="0" />
    <path
      d="M10,18.75c-4.82471,0-8.75-3.9248-8.75-8.75S5.17529,1.25,10,1.25s8.75,3.9248,8.75,8.75-3.92529,8.75-8.75,8.75ZM10,2.75c-3.99756,0-7.25,3.25195-7.25,7.25s3.25244,7.25,7.25,7.25,7.25-3.25195,7.25-7.25-3.25244-7.25-7.25-7.25Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="M10,15c-2.75684,0-5-2.24316-5-5s2.24316-5,5-5,5,2.24316,5,5-2.24316,5-5,5ZM10,6.5c-1.92969,0-3.5,1.57031-3.5,3.5s1.57031,3.5,3.5,3.5,3.5-1.57031,3.5-3.5-1.57031-3.5-3.5-3.5Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Target.js
var TargetIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Target" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2Zm0 26.2A10.2 10.2 0 1 1 28.2 18 10.2 10.2 0 0 1 18 28.2Z"
    />
    <circle cx="18" cy="18" r="4" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTarget.js
var IconTarget = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TargetIcon({ hidden: !this.label, title: this.label }) : TargetIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-target.js
init_define_element();
defineElement("sp-icon-target", IconTarget);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPreview.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Preview.js
var PreviewIcon = ({ width: e36 = 24, height: l16 = 24, hidden: t34 = false, title: r25 = "Preview" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m19.28027,18.22168l-1.97339-1.97339c.43652-.64087.69312-1.41382.69312-2.24634,0-2.20605-1.79395-4-4-4s-4,1.79395-4,4,1.79395,4,4,4c.83252,0,1.60547-.25659,2.24634-.69312l1.97339,1.97339c.14648.14648.33789.21973.53027.21973s.38379-.07324.53027-.21973c.29297-.29297.29297-.76758,0-1.06055Zm-7.78027-4.21973c0-1.37891,1.12109-2.5,2.5-2.5s2.5,1.12109,2.5,2.5-1.12109,2.5-2.5,2.5-2.5-1.12109-2.5-2.5Z"
      fill="currentColor"
    />
    <path
      d="m16.34082,5.28027l-3.62109-3.62012c-.41797-.41992-.99805-.66016-1.59082-.66016h-5.87891c-1.24023,0-2.25,1.00977-2.25,2.25v12.5c0,1.24023,1.00977,2.25,2.25,2.25h3.75c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75h-3.75c-.41309,0-.75-.33691-.75-.75V3.25c0-.41309.33691-.75.75-.75h4.75v3.25c0,1.24023,1.00977,2.25,2.25,2.25h3.25v.5c0,.41406.33594.75.75.75s.75-.33594.75-.75v-1.62891c0-.5918-.24023-1.17188-.65918-1.59082Zm-4.84082.46973v-3.13574c.05493.03198.11279.06006.1582.10547l3.62207,3.62109c.04565.04565.07373.10376.10596.15918h-3.13623c-.41309,0-.75-.33691-.75-.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Preview.js
var PreviewIcon2 = ({ width: e36 = 24, height: a23 = 24, hidden: t34 = false, title: r25 = "Preview" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${a23}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M33.191 32.143 28.646 27.6a9.065 9.065 0 1 0-3.046 3.046l4.546 4.545a2.044 2.044 0 0 0 3.048 0A2.133 2.133 0 0 0 33.781 34a2.163 2.163 0 0 0-.59-1.857ZM15.412 22.98a5.568 5.568 0 1 1 5.568 5.568 5.568 5.568 0 0 1-5.568-5.568Z"
    />
    <path
      d="M33 4H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h11.232a11.322 11.322 0 0 1-2.068-2H4V10h28v17.777l2 1.99V5a1 1 0 0 0-1-1Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPreview.js
var IconPreview = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? PreviewIcon({ hidden: !this.label, title: this.label }) : PreviewIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-preview.js
init_define_element();
defineElement("sp-icon-preview", IconPreview);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCloud.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Cloud.js
var CloudIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Cloud" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m15.40674,17H3.71777c-1.90332,0-3.45166-1.54883-3.45166-3.45215,0-1.49316.9668-2.78027,2.32373-3.25-.04297-.23047-.06445-.46484-.06445-.70215,0-2.17969,1.80957-3.95312,4.03369-3.95312.27979,0,.55762.0293.83105.08789.63721-1.95801,2.47607-3.34668,4.58838-3.34668,2.6709,0,4.84424,2.17285,4.84424,4.84375,0,.43848-.0625.87305-.18701,1.29883,1.80225.53125,3.10303,2.19141,3.10303,4.1416,0,2.38867-1.94336,4.33203-4.33203,4.33203ZM6.55908,7.14258c-1.39697,0-2.53369,1.10059-2.53369,2.45312,0,.33203.06934.65625.20605.96484.09961.22363.08301.48242-.04395.69238-.12744.20996-.34912.34375-.59375.35938-1.0249.06543-1.82764.91602-1.82764,1.93555,0,1.07617.87549,1.95215,1.95166,1.95215h11.68896c1.56152,0,2.83203-1.27051,2.83203-2.83203,0-1.49707-1.17822-2.7334-2.68213-2.81445-.25439-.01367-.48438-.15625-.61084-.37695-.12646-.22168-.13184-.49219-.01416-.71777.25977-.49902.39111-1.01465.39111-1.53125,0-1.84375-1.5-3.34375-3.34424-3.34375-1.6626,0-3.08008,1.25195-3.29736,2.91211-.03076.23535-.17188.44238-.37988.55762-.20752.11719-.45898.12598-.67432.02734-.34766-.1582-.70654-.23828-1.06787-.23828Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/CloudOutline.js
var CloudOutlineIcon = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: l16 = "Cloud Outline" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M20.5 6.714a6.788 6.788 0 0 1 6.538 8.606 5.492 5.492 0 0 1 .605-.034 5.357 5.357 0 0 1 0 10.714H6.214a3.215 3.215 0 0 1 0-6.429h.359v-1.428a5.718 5.718 0 0 1 7.2-5.519 6.788 6.788 0 0 1 6.727-5.91Zm0-2a8.811 8.811 0 0 0-8.233 5.715 7.724 7.724 0 0 0-7.69 7.406A5.214 5.214 0 0 0 6.214 28h21.429a7.357 7.357 0 0 0 1.643-14.529A8.8 8.8 0 0 0 20.5 4.714Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCloud.js
var IconCloud = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? CloudIcon({ hidden: !this.label, title: this.label }) : CloudOutlineIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-cloud.js
init_define_element();
defineElement("sp-icon-cloud", IconCloud);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPublish.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Publish.js
var PublishIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: r25 = "Publish" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M18.7793,1.21875c-.21191-.21094-.52734-.27539-.80469-.16602L1.47461,7.56152c-.26953.10547-.45312.3584-.47266.64746s.12891.56348.38184.7041l6.25488,3.49512,3.52148,6.21191c.13379.23535.38379.37988.65234.37988.01758,0,.03613-.00098.05371-.00195.28906-.02051.54004-.20605.64453-.47559L18.94824,2.02246c.1084-.27734.04199-.59375-.16895-.80371ZM15.16907,3.77148l-7.11292,7.15161-4.55908-2.54712L15.16907,3.77148ZM11.6875,16.50781l-2.56641-4.52661,7.12842-7.16724-4.56201,11.69385Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPublish.js
var IconPublish = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? PublishIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-publish.js
init_define_element();
defineElement("sp-icon-publish", IconPublish);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconReviewLink.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ReviewLink.js
var ReviewLinkIcon = ({ width: l16 = 24, height: c33 = 24, hidden: r25 = false, title: e36 = "Review Link" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${c33}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <circle cx="4.125" cy="6" r=".75" fill="currentColor" />
    <path
      d="m16.75,3H3.25c-1.24072,0-2.25,1.00977-2.25,2.25v9.5c0,1.24023,1.00928,2.25,2.25,2.25h3.75c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75h-3.75c-.41357,0-.75-.33691-.75-.75v-5.75h8.5c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75H2.5v-2.25c0-.41309.33643-.75.75-.75h13.5c.41357,0,.75.33691.75.75v.97852c0,.41406.33594.75.75.75s.75-.33594.75-.75v-.97852c0-1.24023-1.00928-2.25-2.25-2.25Z"
      fill="currentColor"
    />
    <path
      d="m12.19971,18.25c-.92139,0-1.7876-.35938-2.43896-1.01074-.65186-.65137-1.01074-1.51758-1.01074-2.43945,0-.9209.35889-1.78809,1.01074-2.43945l.10986-.10938c.29346-.29199.76758-.29199,1.06104.00195.29199.29395.29102.76855-.00244,1.06055l-.10889.1084c-.36719.36719-.57031.85742-.57031,1.37793,0,.52148.20264,1.01074.57129,1.37891.73633.73633,2.02051.73535,2.75732,0l.11182-.11035c.29346-.29199.76904-.29004,1.06055.00391.2915.29492.28955.76953-.00488,1.06055l-.10938.1084c-.64893.64941-1.51514,1.00879-2.43701,1.00879Z"
      fill="currentColor"
    />
    <path
      d="m17.6001,13.96777c-.19238,0-.38477-.07324-.53174-.2207-.29199-.29395-.29102-.76855.00244-1.06055l.10889-.1084c.36719-.36719.57031-.85742.57031-1.37793,0-.52148-.20264-1.01074-.57129-1.37891-.7373-.7373-2.02197-.73633-2.75732,0l-.11182.11035c-.29346.29297-.76904.28906-1.06055-.00391-.2915-.29492-.28955-.76953.00488-1.06055l.10938-.1084c1.29736-1.29883,3.57275-1.30078,4.87598.00195.65186.65137,1.01074,1.51758,1.01074,2.43945,0,.9209-.35889,1.78809-1.01074,2.43945l-.10986.10938c-.14648.14551-.33789.21875-.5293.21875Z"
      fill="currentColor"
    />
    <path
      d="m12.7998,14.9502c-.19189,0-.38379-.07324-.53027-.21973-.29297-.29297-.29297-.76758,0-1.06055l2.40039-2.40039c.29297-.29297.76758-.29297,1.06055,0s.29297.76758,0,1.06055l-2.40039,2.40039c-.14648.14648-.33838.21973-.53027.21973Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconReviewLink.js
var IconReviewLink = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ReviewLinkIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-review-link.js
init_define_element();
defineElement("sp-icon-review-link", IconReviewLink);

// node_modules/@spectrum-web-components/switch/src/Switch.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/checkbox/src/CheckboxBase.js
init_focusable();
var CheckboxBase = class extends CheckboxMixin(Focusable) {
  get focusElement() {
    return this.inputElement;
  }
};

// node_modules/@spectrum-web-components/switch/src/switch.css.js
init_src();
var t26 = i`
    :host{--spectrum-switch-label-color-default:var(--spectrum-neutral-content-color-default);--spectrum-switch-label-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-switch-label-color-down:var(--spectrum-neutral-content-color-down);--spectrum-switch-label-color-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-switch-label-color-disabled:var(--spectrum-disabled-content-color);--spectrum-switch-background-color-selected-default:var(--spectrum-neutral-background-color-selected-default);--spectrum-switch-background-color-selected-hover:var(--spectrum-neutral-background-color-selected-hover);--spectrum-switch-background-color-selected-down:var(--spectrum-neutral-background-color-selected-down);--spectrum-switch-background-color-selected-focus:var(--spectrum-neutral-background-color-selected-key-focus);--spectrum-switch-background-color-selected-disabled:var(--spectrum-disabled-content-color);--spectrum-switch-focus-indicator-thickness:var(--mod-focus-indicator-thickness,var(--spectrum-focus-indicator-thickness));--spectrum-switch-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-switch-handle-border-color-disabled:var(--spectrum-disabled-content-color)}:host([disabled]){--spectrum-switch-label-color-default:var(--spectrum-disabled-content-color)}:host([emphasized]){--spectrum-switch-background-color-selected-default:var(--spectrum-accent-color-900);--spectrum-switch-background-color-selected-hover:var(--spectrum-accent-color-1000);--spectrum-switch-background-color-selected-down:var(--spectrum-accent-color-1100);--spectrum-switch-background-color-selected-focus:var(--spectrum-accent-color-1000);--spectrum-switch-handle-border-color-selected-default:var(--spectrum-accent-color-900);--spectrum-switch-handle-border-color-selected-hover:var(--spectrum-accent-color-1000);--spectrum-switch-handle-border-color-selected-down:var(--spectrum-accent-color-1100);--spectrum-switch-handle-border-color-selected-focus:var(--spectrum-accent-color-1000)}:host,:host{--spectrum-switch-min-height:var(--spectrum-component-height-100);--spectrum-switch-control-width:var(--spectrum-switch-control-width-medium);--spectrum-switch-control-height:var(--spectrum-switch-control-height-medium);--spectrum-switch-control-label-spacing:var(--spectrum-text-to-control-100);--spectrum-switch-spacing-top-to-control:var(--spectrum-switch-top-to-control-medium);--spectrum-switch-spacing-top-to-label:var(--spectrum-component-top-to-text-100);--spectrum-switch-font-size:var(--spectrum-font-size-100)}:host([size=s]){--spectrum-switch-min-height:var(--spectrum-component-height-75);--spectrum-switch-control-width:var(--spectrum-switch-control-width-small);--spectrum-switch-control-height:var(--spectrum-switch-control-height-small);--spectrum-switch-control-label-spacing:var(--spectrum-text-to-control-75);--spectrum-switch-spacing-top-to-control:var(--spectrum-switch-top-to-control-small);--spectrum-switch-spacing-top-to-label:var(--spectrum-component-top-to-text-75);--spectrum-switch-font-size:var(--spectrum-font-size-75)}:host([size=l]){--spectrum-switch-min-height:var(--spectrum-component-height-200);--spectrum-switch-control-width:var(--spectrum-switch-control-width-large);--spectrum-switch-control-height:var(--spectrum-switch-control-height-large);--spectrum-switch-control-label-spacing:var(--spectrum-text-to-control-200);--spectrum-switch-spacing-top-to-control:var(--spectrum-switch-top-to-control-large);--spectrum-switch-spacing-top-to-label:var(--spectrum-component-top-to-text-200);--spectrum-switch-font-size:var(--spectrum-font-size-200)}:host([size=xl]){--spectrum-switch-min-height:var(--spectrum-component-height-300);--spectrum-switch-control-width:var(--spectrum-switch-control-width-extra-large);--spectrum-switch-control-height:var(--spectrum-switch-control-height-extra-large);--spectrum-switch-control-label-spacing:var(--spectrum-text-to-control-300);--spectrum-switch-spacing-top-to-control:var(--spectrum-switch-top-to-control-extra-large);--spectrum-switch-spacing-top-to-label:var(--spectrum-component-top-to-text-300);--spectrum-switch-font-size:var(--spectrum-font-size-300)}:host{min-block-size:var(--mod-switch-height,var(--spectrum-switch-min-height));vertical-align:top;align-items:flex-start;max-inline-size:100%;display:inline-flex;position:relative}#input{box-sizing:border-box;opacity:0;z-index:1;cursor:pointer;block-size:100%;inline-size:100%;margin:0;padding:0;position:absolute;inset-block-start:0;inset-inline-start:0}:host([checked]) #input+#switch:before{transform:translateX(calc(var(--mod-switch-control-width,var(--spectrum-switch-control-width)) - 100%))}:host([checked]) #input+#switch:dir(rtl):before,:host([dir=rtl][checked]) #input+#switch:before{transform:translateX(calc((var(--mod-switch-control-width,var(--spectrum-switch-control-width)) - 100%)*-1))}:host([disabled]) #input,:host([disabled]) #input{cursor:default}#input:focus-visible+#switch:after{margin:calc(var(--mod-focus-indicator-gap,var(--spectrum-focus-indicator-gap))*-1)}#label{color:var(--highcontrast-switch-label-color-default,var(--mod-switch-label-color-default,var(--spectrum-switch-label-color-default)));margin-inline:var(--mod-switch-control-label-spacing,var(--spectrum-switch-control-label-spacing));font-size:var(--mod-switch-font-size,var(--spectrum-switch-font-size));line-height:var(--mod-line-height-100,var(--spectrum-line-height-100));transition:color var(--mod-animation-duration-200,var(--spectrum-animation-duration-200))ease-in-out;margin-block-start:var(--mod-switch-spacing-top-to-label,var(--spectrum-switch-spacing-top-to-label));margin-block-end:0}#switch{box-sizing:border-box;inline-size:var(--mod-switch-control-width,var(--spectrum-switch-control-width));margin-block:calc(var(--mod-switch-height,var(--spectrum-switch-min-height)) - var(--mod-switch-control-height,var(--spectrum-switch-control-height)) - var(--mod-switch-spacing-top-to-control,var(--spectrum-switch-spacing-top-to-control)));vertical-align:middle;transition:background var(--mod-animation-duration-100,var(--spectrum-animation-duration-100))ease-in-out,border var(--mod-animation-duration-100,var(--spectrum-animation-duration-100))ease-in-out;block-size:var(--mod-switch-control-height,var(--spectrum-switch-control-height));border-radius:calc(var(--mod-switch-control-height,var(--spectrum-switch-control-height))/2);flex-grow:0;flex-shrink:0;margin-inline:0;display:inline-block;position:relative;inset-inline:0}#switch:before{box-sizing:border-box;transition:background var(--mod-animation-duration-100,var(--spectrum-animation-duration-100))ease-in-out,border var(--mod-animation-duration-100,var(--spectrum-animation-duration-100))ease-in-out,transform var(--mod-animation-duration-100,var(--spectrum-animation-duration-100))ease-in-out,box-shadow var(--mod-animation-duration-100,var(--spectrum-animation-duration-100))ease-in-out;inline-size:var(--mod-switch-control-height,var(--spectrum-switch-control-height));block-size:var(--mod-switch-control-height,var(--spectrum-switch-control-height));border-width:var(--mod-border-width-200,var(--spectrum-border-width-200));border-radius:calc(var(--mod-switch-control-height,var(--spectrum-switch-control-height))/2);border-style:solid}#switch:after,#switch:before{content:"";display:block;position:absolute;inset-block-start:0;inset-inline-start:0}#switch:after{border-radius:calc(var(--mod-switch-control-height,var(--spectrum-switch-control-height))/2 + var(--mod-focus-indicator-gap,var(--spectrum-focus-indicator-gap))*2);transition:opacity var(--mod-animation-duration-100,var(--spectrum-animation-duration-100))ease-out,margin var(--spectrum-animation-duration-100,var(--spectrum-animation-duration-100))ease-out;margin:0;inset-block-end:0;inset-inline-end:0}#switch{background-color:var(--highcontrast-switch-background-color,var(--mod-switch-background-color,var(--spectrum-switch-background-color)))}#switch:before{background-color:var(--highcontrast-switch-handle-background-color,var(--mod-switch-handle-background-color,var(--spectrum-switch-handle-background-color)));border-color:var(--highcontrast-switch-handle-border-color-default,var(--mod-switch-handle-border-color-default,var(--spectrum-switch-handle-border-color-default)))}:host(:active) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-down,var(--mod-switch-handle-border-color-down,var(--spectrum-switch-handle-border-color-down)))}:host(:active) #input~#label{color:var(--highcontrast-switch-label-color-down,var(--mod-switch-label-color-down,var(--spectrum-switch-label-color-down)))}#input:focus-visible+#switch:after{box-shadow:0 0 0 var(--mod-switch-focus-indicator-thickness,var(--spectrum-switch-focus-indicator-thickness))var(--highcontrast-switch-focus-indicator-color,var(--mod-switch-focus-indicator-color,var(--spectrum-switch-focus-indicator-color)))}#input:focus-visible+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-focus,var(--mod-switch-handle-border-color-focus,var(--spectrum-switch-handle-border-color-focus)))}:host([checked]) #input:focus-visible+#switch{background-color:var(--highcontrast-switch-background-color-selected-focus,var(--mod-switch-background-color-selected-focus,var(--spectrum-switch-background-color-selected-focus)))}:host([checked]) #input:focus-visible+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-selected-focus,var(--mod-switch-handle-border-color-selected-focus,var(--spectrum-switch-handle-border-color-selected-focus)))}#input:focus-visible~#label{color:var(--highcontrast-switch-label-color-focus,var(--mod-switch-label-color-focus,var(--spectrum-switch-label-color-focus)))}@media (hover:hover){:host(:hover) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-hover,var(--mod-switch-handle-border-color-hover,var(--spectrum-switch-handle-border-color-hover)));box-shadow:none}:host(:hover) #input~#label{color:var(--highcontrast-switch-label-color-hover,var(--mod-switch-label-color-hover,var(--spectrum-switch-label-color-hover)))}:host([checked]:hover) #input:enabled+#switch{background-color:var(--highcontrast-switch-background-color-selected-hover,var(--mod-switch-background-color-selected-hover,var(--spectrum-switch-background-color-selected-hover)))}:host([checked]:hover) #input:enabled+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-selected-hover,var(--mod-switch-handle-border-color-selected-hover,var(--spectrum-switch-handle-border-color-selected-hover)))}:host([disabled]:hover) #input+#switch,:host([disabled]:hover) #input+#switch{background-color:var(--mod-switch-background-color-disabled,var(--spectrum-switch-background-color-disabled))}:host([disabled]:hover) #input+#switch:before,:host([disabled]:hover) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-disabled,var(--mod-switch-handle-border-color-disabled,var(--spectrum-switch-handle-border-color-disabled)))}:host([disabled]:hover) #input~#label,:host([disabled]:hover) #input~#label{color:var(--highcontrast-switch-label-color-disabled,var(--mod-switch-label-color-disabled,var(--spectrum-switch-label-color-disabled)))}:host([disabled][checked]:hover) #input+#switch,:host([disabled][checked]:hover) #input+#switch{background-color:var(--highcontrast-switch-background-color-selected-disabled,var(--mod-switch-background-color-selected-disabled,var(--spectrum-switch-background-color-selected-disabled)))}:host([disabled][checked]:hover) #input+#switch:before,:host([disabled][checked]:hover) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-disabled,var(--mod-switch-handle-border-color-disabled,var(--spectrum-switch-handle-border-color-disabled)))}:host([disabled][checked]:hover) #input~#label,:host([disabled][checked]:hover) #input~#label{color:var(--highcontrast-switch-label-color-disabled,var(--mod-switch-label-color-disabled,var(--spectrum-switch-label-color-disabled)))}:host(:hover) #input:focus-visible+#switch:after{box-shadow:0 0 0 var(--mod-switch-focus-indicator-thickness,var(--spectrum-switch-focus-indicator-thickness))var(--highcontrast-switch-focus-indicator-color,var(--mod-switch-focus-indicator-color,var(--spectrum-switch-focus-indicator-color)))}:host(:hover) #input:focus-visible+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-focus,var(--mod-switch-handle-border-color-focus,var(--spectrum-switch-handle-border-color-focus)))}:host([checked]:hover) #input:focus-visible+#switch{background-color:var(--highcontrast-switch-background-color-selected-focus,var(--mod-switch-background-color-selected-focus,var(--spectrum-switch-background-color-selected-focus)))}:host([checked]:hover) #input:focus-visible+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-selected-focus,var(--mod-switch-handle-border-color-selected-focus,var(--spectrum-switch-handle-border-color-selected-focus)))}:host(:hover) #input:focus-visible~#label{color:var(--highcontrast-switch-label-color-focus,var(--mod-switch-label-color-focus,var(--spectrum-switch-label-color-focus)))}}:host([checked]) #input+#switch{background-color:var(--highcontrast-switch-background-color-selected-default,var(--mod-switch-background-color-selected-default,var(--spectrum-switch-background-color-selected-default)))}:host([checked]) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-selected-default,var(--mod-switch-handle-border-color-selected-default,var(--spectrum-switch-handle-border-color-selected-default)))}:host([disabled]) #input+#switch,:host([disabled]) #input+#switch{background-color:var(--mod-switch-background-color-disabled,var(--spectrum-switch-background-color-disabled))}:host([disabled]) #input+#switch:before,:host([disabled]) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-disabled,var(--mod-switch-handle-border-color-disabled,var(--spectrum-switch-handle-border-color-disabled)))}:host([disabled][checked]) #input+#switch,:host([disabled][checked]) #input+#switch{background-color:var(--highcontrast-switch-background-color-selected-disabled,var(--mod-switch-background-color-selected-disabled,var(--spectrum-switch-background-color-selected-disabled)))}:host([disabled][checked]) #input+#switch:before,:host([disabled][checked]) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-disabled,var(--mod-switch-handle-border-color-disabled,var(--spectrum-switch-handle-border-color-disabled)))}:host([disabled]) #input~#label,:host([disabled]) #input~#label{color:var(--highcontrast-switch-label-color-disabled,var(--mod-switch-label-color-disabled,var(--spectrum-switch-label-color-disabled)))}@media (forced-colors:active){:host{--highcontrast-switch-label-color-default:ButtonText;--highcontrast-switch-label-color-hover:ButtonText;--highcontrast-switch-label-color-down:ButtonText;--highcontrast-switch-label-color-focus:ButtonText;--highcontrast-switch-label-color-disabled:GrayText;--highcontrast-switch-handle-background-color:ButtonFace;--highcontrast-switch-handle-border-color-default:ButtonText;--highcontrast-switch-handle-border-color-hover:Highlight;--highcontrast-switch-handle-border-color-down:Highlight;--highcontrast-switch-handle-border-color-focus:Highlight;--highcontrast-switch-handle-border-color-disabled:Highlight;--highcontrast-switch-handle-border-color-selected-default:Highlight;--highcontrast-switch-handle-border-color-selected-hover:Highlight;--highcontrast-switch-handle-border-color-selected-down:Highlight;--highcontrast-switch-handle-border-color-selected-focus:Highlight;--highcontrast-switch-background-color:ButtonFace;--highcontrast-switch-background-color-selected-default:Highlight;--highcontrast-switch-background-color-selected-hover:Highlight;--highcontrast-switch-background-color-selected-down:Highlight;--highcontrast-switch-background-color-selected-focus:Highlight;--highcontrast-switch-background-color-selected-disabled:Highlight;--highcontrast-switch-focus-indicator-color:ButtonText;forced-color-adjust:none}#input:not(:checked)+#switch{box-shadow:inset 0 0 0 1px buttontext}@media (hover:hover){:host(:hover) #input:not(:checked)+#switch{box-shadow:inset 0 0 0 1px highlight}:host([disabled][checked]:hover) #input+#switch,:host([disabled][checked]:hover) #input+#switch{background-color:graytext;box-shadow:inset 0 0 0 1px graytext}:host([disabled][checked]:hover) #input+#switch:before,:host([disabled][checked]:hover) #input+#switch:before{background-color:buttonface;border-color:graytext}}:host([disabled]) #input:not(:checked)+#switch,:host([disabled]) #input:not(:checked)+#switch{background-color:buttonface;box-shadow:inset 0 0 0 1px graytext}:host([disabled]) #input:not(:checked)+#switch:before,:host([disabled]) #input:not(:checked)+#switch:before{background-color:buttonface;border-color:graytext}:host([disabled][checked]) #input+#switch,:host([disabled][checked]) #input+#switch{background-color:graytext;box-shadow:inset 0 0 0 1px graytext}:host([disabled][checked]) #input+#switch:before,:host([disabled][checked]) #input+#switch:before{background-color:buttonface;border-color:graytext}:host([disabled]) #input~#label,:host([disabled]) #input~#label{color:graytext}}:host{--spectrum-switch-handle-border-color-default:var(--system-switch-handle-border-color-default);--spectrum-switch-handle-border-color-hover:var(--system-switch-handle-border-color-hover);--spectrum-switch-handle-border-color-down:var(--system-switch-handle-border-color-down);--spectrum-switch-handle-border-color-focus:var(--system-switch-handle-border-color-focus);--spectrum-switch-handle-border-color-selected-default:var(--system-switch-handle-border-color-selected-default);--spectrum-switch-handle-border-color-selected-hover:var(--system-switch-handle-border-color-selected-hover);--spectrum-switch-handle-border-color-selected-down:var(--system-switch-handle-border-color-selected-down);--spectrum-switch-handle-border-color-selected-focus:var(--system-switch-handle-border-color-selected-focus);--spectrum-switch-background-color:var(--system-switch-background-color);--spectrum-switch-background-color-disabled:var(--system-switch-background-color-disabled);--spectrum-switch-handle-background-color:var(--system-switch-handle-background-color)}:host([disabled]){pointer-events:none}:host(:hover:active) #input+#switch:before,:host([emphasized]:hover:active) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-down,var(--mod-switch-handle-border-color-down,var(--spectrum-switch-handle-border-color-down)))}:host(:active[checked]) #input:enabled+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-selelcted-down,var(--mod-switch-handle-border-color-selected-down,var(--spectrum-switch-handle-border-color-selected-down)))}:host(:active[checked]) #input:enabled+#switch{background-color:var(--highcontrast-switch-background-color-selected-down,var(--mod-switch-background-color-selected-down,var(--spectrum-switch-background-color-selected-down)))}:host([readonly]) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-default,var(--mod-switch-handle-border-color-default,var(--spectrum-switch-handle-border-color-default)))!important}:host([readonly][checked]) #input+#switch:before{border-color:var(--highcontrast-switch-handle-border-color-selected-default,var(--mod-switch-handle-border-color-selected-default,var(--spectrum-switch-handle-border-color-selected-default)))!important}
`;
var switch_css_default = t26;

// node_modules/@spectrum-web-components/switch/src/switch-legacy.css.js
init_src();
var a14 = i`
    #switch:before{transition:background var(--spectrum-animation-duration-100,.13s)ease-in-out,border var(--spectrum-animation-duration-100,.13s)ease-in-out,box-shadow var(--spectrum-animation-duration-100,.13s)ease-in-out}
`;
var switch_legacy_css_default = a14;

// node_modules/@spectrum-web-components/switch/src/Switch.js
var d14 = Object.defineProperty;
var u24 = Object.getOwnPropertyDescriptor;
var p21 = (s19, r25, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? u24(r25, e36) : r25, o52 = s19.length - 1, l16; o52 >= 0; o52--) (l16 = s19[o52]) && (t34 = (i21 ? l16(r25, e36, t34) : l16(t34)) || t34);
  return i21 && t34 && d14(r25, e36, t34), t34;
};
var Switch = class extends SizedMixin(CheckboxBase) {
  constructor() {
    super(...arguments);
    this.emphasized = false;
  }
  static get styles() {
    return window.hasOwnProperty("ShadyDOM") ? [switch_css_default, switch_legacy_css_default] : [switch_css_default];
  }
  render() {
    return x`
            ${super.render()}
            <span id="switch"></span>
            <label id="label" for="input"><slot></slot></label>
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.inputElement.setAttribute("role", "switch");
  }
  updated(e36) {
    e36.has("checked") && this.inputElement.setAttribute("aria-checked", this.checked ? "true" : "false");
  }
};
p21([n4({ type: Boolean, reflect: true })], Switch.prototype, "emphasized", 2);

// node_modules/@spectrum-web-components/switch/sp-switch.js
init_define_element();
defineElement("sp-switch", Switch);

// node_modules/@spectrum-web-components/field-group/sp-field-group.js
init_define_element();
defineElement("sp-field-group", FieldGroup);

// src/features/comments/ee-comments-panel.js
init_lit();

// src/features/comments/ee-comments-panel.css.js
init_lit();
var eeCommentsPanelStyles = i`
  :host,
  :host *,
  :host *::before,
  :host *::after {
    box-sizing: border-box;
  }
  :host {
    display: block;
    height: 100%;
    box-sizing: border-box;
  }

  #panel-root {
    display: grid;
    grid-template-rows: auto auto 1fr;
    height: 100%;
    padding: var(--spectrum-global-dimension-size-300);
    gap: var(--spectrum-global-dimension-size-200);
    color: var(--spectrum-alias-text-color, currentColor);
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  #header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spectrum-global-dimension-size-200);
    color: var(--spectrum-alias-text-color, inherit);
  }

  #composer {
    display: grid;
    grid-template-rows: auto auto;
    align-items: stretch;
    gap: var(--spectrum-global-dimension-size-150);
  }

  #comments-list {
    overflow: auto;
    padding-right: var(--spectrum-global-dimension-size-100);
    color: var(--spectrum-alias-text-color, currentColor);
    width: 100%;
    max-width: 100%;
  }

  sp-textfield {
    width: 100%;
  }

  .comment-item {
    display: grid;
    grid-template-rows: auto auto;
    gap: var(--spectrum-global-dimension-size-100);
    margin-bottom: var(--spectrum-global-dimension-size-150);
    padding: var(--spectrum-global-dimension-size-150);
    border-radius: var(--spectrum-global-dimension-size-75);
    border: 1px solid var(--spectrum-alias-border-color);
    background: var(--spectrum-alias-component-background-color);
    color: var(--spectrum-alias-text-color, currentColor);
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
  }

  .comment-item[data-active="true"] {
    box-shadow: inset 0 0 0 1px var(--spectrum-alias-focus-color);
  }

  .comment-item:hover {
    border-color: var(--spectrum-alias-focus-color);
  }

  .row {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-100);
    flex-wrap: wrap;
    min-width: 0;
  }

  .author {
    font-weight: 600;
    color: var(--spectrum-alias-text-color, currentColor);
  }

  .spacer {
    flex: 1 1 auto;
  }

  .comment-text {
    font-size: var(--spectrum-global-dimension-font-size-100);
    line-height: 1.4;
    color: var(--spectrum-alias-text-color, currentColor);
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  #header { min-width: 0; }
  #header h3 {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 75%;
  }

  .comment-meta {
    display: flex;
    gap: var(--spectrum-global-dimension-size-150);
    align-items: center;
    color: var(--spectrum-alias-text-color, inherit);
  }

  .timestamp {
    font-size: var(--spectrum-global-dimension-font-size-75);
    color: var(--spectrum-alias-text-color, var(--spectrum-global-color-gray-700));
  }
`;

// src/utils/date-formatters.js
var MINUTE = 6e4;
var HOUR = 36e5;
var DAY = 864e5;
var TWO_DAYS = DAY * 2;
var WEEK = DAY * 7;
var formatRelativeDate = (value) => {
  if (!value) return "";
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return "";
  const diff = Date.now() - date.getTime();
  if (diff < MINUTE) return "Just now";
  if (diff < HOUR) return `${Math.floor(diff / MINUTE)} min ago`;
  if (diff < DAY) return `${Math.floor(diff / HOUR)} hours ago`;
  if (diff < TWO_DAYS) return "Yesterday";
  if (diff < WEEK) return `${Math.floor(diff / DAY)} days ago`;
  return date.toLocaleDateString();
};

// src/features/comments/ee-comments-panel.js
var EECommentsPanel = class extends i4 {
  static get styles() {
    return eeCommentsPanelStyles;
  }
  static get properties() {
    return {
      store: { type: Object, observe: true },
      commentStore: { type: Object, observe: true }
    };
  }
  constructor() {
    super();
    this.store = null;
  }
  // Friendly date formatter (similar to experience-elements-home)
  formatFriendlyTime(dateInput) {
    return formatRelativeDate(dateInput);
  }
  // Public API for overlay positioning
  getCommentItemRect(id) {
    const el = this.renderRoot?.querySelector?.(`[data-comment-id="${id}"]`);
    return el ? el.getBoundingClientRect() : null;
  }
  get comments() {
    return Array.isArray(this.commentStore?.comments) ? this.commentStore.comments : [];
  }
  onAdd() {
    const ta = this.renderRoot?.getElementById?.("story-0");
    const val = (ta?.value || "").toString().trim();
    if (!val) return;
    this.store?.setLastAction?.("comment:add", {});
    this.commentStore?.addCommentForEditingElement?.(val);
    if (ta) ta.value = "";
  }
  onDelete(id) {
    this.store?.setLastAction?.("comment:delete", { id });
    this.commentStore?.removeComment?.(id);
  }
  onToggleResolved(id, current) {
    this.store?.setLastAction?.("comment:toggleResolved", { id, to: current === "resolved" ? "open" : "resolved" });
    this.commentStore?.updateComment?.(id, { status: current === "resolved" ? "open" : "resolved" });
  }
  onCardEnter(id) {
    this.commentStore?.setHoveredComment?.(id);
  }
  onCardLeave(id) {
    if (this.commentStore?.hoveredCommentId === id) this.commentStore?.setHoveredComment?.(null);
  }
  onCardClick(id) {
    const alreadySelected = this.commentStore?.selectedCommentId === id;
    this.commentStore?.setSelectedComment?.(id);
    const noEditing = !this.store?.editingElement;
    if (noEditing || alreadySelected) {
      const host = this.getRootNode()?.host;
      const el = host?.getElementForComment?.(id);
      if (el) {
        this.store?.setUserAction?.("comment:click", { id });
        host?.selectElement?.(el);
      }
    }
  }
  get composer() {
    const el = this.store?.editingElement;
    const slotSelected = !!this.store?.slotOnlySelection;
    const host = this.store?.editorElement || null;
    const can = !!el && !slotSelected && (!!host ? host.contains(el) : true);
    if (!can) return E;
    return x`
      <div id="composer">
        <sp-textfield id="story-0" multiline placeholder="Add a comment..." value=""></sp-textfield>
        <sp-button variant="primary" @click=${() => this.onAdd()}>Add</sp-button>
      </div>
    `;
  }
  renderComment(c33) {
    const isResolved = c33.status === "resolved";
    const activeAnchor = this.store?.editingElement?.getAttribute?.("data-ee-comment-id") || null;
    const isActive = !!activeAnchor && c33.targetId === activeAnchor;
    const host = this.getRootNode()?.host;
    const currentEmail = host?.userStore?.currentUser?.email || null;
    let author = c33.author || "";
    if (!author) {
      if (c33.authorEmail && currentEmail && c33.authorEmail === currentEmail) author = "You";
      else if (c33.authorEmail) author = c33.authorEmail;
    }
    return x`
      <div
        class="comment-item"
        data-active=${isActive ? "true" : E}
        data-comment-id=${c33.id}
        @mouseover=${() => this.onCardEnter(c33.id)}
        @focusin=${() => this.onCardEnter(c33.id)}
        @mouseout=${() => this.onCardLeave(c33.id)}
        @focusout=${() => this.onCardLeave(c33.id)}
        @click=${() => this.onCardClick(c33.id)}
      >
        <div class="row">
          ${author ? x`<span class="author">${author}</span>` : E}
          ${isResolved ? x`<sp-tag size="s" variant="positive">Resolved</sp-tag>` : x`<sp-tag size="s">Open</sp-tag>`}
          <span class="timestamp">${this.formatFriendlyTime(c33.updatedAt || c33.createdAt)}</span>
          <span class="spacer"></span>
          <sp-action-button quiet size="s" title=${isResolved ? "Reopen" : "Resolve"} @click=${(e36) => {
      e36.stopPropagation();
      this.onToggleResolved(c33.id, c33.status);
    }}>
            ${isResolved ? x`<sp-icon-revert slot="icon"></sp-icon-revert>` : x`<sp-icon-checkmark-circle slot="icon"></sp-icon-checkmark-circle>`}
          </sp-action-button>
          <sp-action-button quiet size="s" title="Delete" @click=${(e36) => {
      e36.stopPropagation();
      this.onDelete(c33.id);
    }}>
            <sp-icon-delete slot="icon"></sp-icon-delete>
          </sp-action-button>
        </div>
        <div class="comment-text">${c33.text}</div>
      </div>
    `;
  }
  render() {
    const count = this.comments.length;
    return x`
      <div id="panel-root">
        <div id="header">
          <h3 style="margin:0; font-size: 14px;">Comments (${count})</h3>
          <sp-action-button
            quiet
            title="Close comments"
            @click=${(e36) => {
      e36?.preventDefault?.();
      e36?.stopPropagation?.();
      this.store?.setLastAction?.("comment:closePanel", {});
      this.commentStore?.closeCommentsPanel?.();
      const host = this.getRootNode()?.host;
      host?.syncCommentsPanelView?.();
    }}
          >
            <sp-icon-close slot="icon"></sp-icon-close>
          </sp-action-button>
        </div>
        ${this.composer}
        <div id="comments-list">
          ${count ? this.comments.map((c33) => this.renderComment(c33)) : x`<div style="opacity:0.7; padding: 8px;">No comments yet.</div>`}
        </div>
      </div>
    `;
  }
};
customElements.define("ee-comments-panel", makeLitObserver(EECommentsPanel));

// src/features/versions/ee-versions-panel.js
init_lit();

// src/features/versions/ee-versions-panel.css.js
init_lit();
var eeVersionsPanelStyles = i`
  #panel-root {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-200);
    height: 100%;
    color: var(--spectrum-alias-text-color, var(--spectrum-global-color-gray-700));
  }
  #header {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-200);
  }
  #header h3 {
    margin: 0;
    font-size: 14px;
  }
  #list {
    overflow: auto;
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-150);
  }
  .item {
    padding: var(--spectrum-global-dimension-size-200);
    border: 1px solid var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-global-dimension-size-50);
    background: var(--spectrum-alias-component-background-color);
  }
  pre.diff {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 12px;
    line-height: 1.5;
    padding: var(--spectrum-global-dimension-size-200);
    border: 1px solid var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-global-dimension-size-50);
    background: var(--spectrum-alias-component-background-color);
    max-height: 320px;
    overflow: auto;
    white-space: pre-wrap;
  }
  .d-eq { color: inherit; opacity: 0.9; }
  .d-add { color: var(--spectrum-global-color-green-600); }
  .d-del { color: var(--spectrum-global-color-red-600); }
  .row {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-200);
  }
  .name {
    font-weight: 600;
  }
  .spacer { flex: 1; }
  .muted { opacity: 0.7; font-size: 12px; }
  #composer {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: var(--spectrum-global-dimension-size-200);
  }

  /* Compare slider layout */
  #compare-viewport {
    width: 100%;
    height: 100%;
    overflow: auto;
    border: none;
    border-radius: 0;
    background: transparent;
  }
  #compare-scene {
    position: relative;
    height: 100%;
    cursor: col-resize;
    overflow: scroll;
    --compare-divider-width: var(--spectrum-global-dimension-size-50, 4px);
  }
  .compare-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  /* Keep full-width layout; reveal with clip-path to avoid reflow/shifts */
  .compare-after-clip {
    overflow: visible;
  }
  /* Reveal selected on the right side */
  .compare-after-clip.reveal-right {
    -webkit-clip-path: inset(0 0 0 var(--divider-percent, 50%));
    clip-path: inset(0 0 0 var(--divider-percent, 50%));
  }
  /* Reveal selected on the left side */
  .compare-after-clip.reveal-left {
    -webkit-clip-path: inset(0 calc(100% - var(--divider-percent, 50%)) 0 0);
    clip-path: inset(0 calc(100% - var(--divider-percent, 50%)) 0 0);
  }
  .compare-content {
    padding: var(--spectrum-global-dimension-size-200);
    width: 100%;
    box-sizing: border-box;
  }
  /* Prevent interactions with embedded content while allowing scroll on viewport */
  .compare-layer, .compare-layer * { pointer-events: none; }
  /* Scale media to fit width */
  .compare-content img,
  .compare-content video,
  .compare-content canvas,
  .compare-content svg { max-width: 100%; height: auto; }

  /* Divider visuals now rendered via transparent canvas overlay */

  /* Transparent canvas overlay for divider glow/gradient */
  #compare-canvas {
    position: absolute;
    inset: 0;
    z-index: 1;
    pointer-events: none;
  }

  #compare-divider {
    position: absolute;
    top: 0;
    bottom: 0;
    left: var(--divider-percent, 50%);
    transform: translateX(-50%);
    width: var(--compare-divider-width);
    max-width: var(--spectrum-global-dimension-size-300);
    background: rgba(57, 57, 57, 0.65);
    background: color-mix(in srgb, var(--spectrum-global-color-gray-900) 55%, transparent);
    border-radius: var(--spectrum-global-dimension-size-50);
    box-shadow: 0 0 0 1px var(--spectrum-alias-border-color);
    opacity: 0.9;
    pointer-events: none;
    z-index: 2;
  }

  /* Remove badges to avoid layout shifts; keep layout clean */
  #compare-legend {
    position: absolute;
    top: 8px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
    z-index: 3;
    padding: 0 var(--spectrum-global-dimension-size-200);
  }
  #compare-legend .legend-left,
  #compare-legend .legend-right {
    display: inline-block;
    padding: 2px 8px;
    border-radius: var(--spectrum-global-dimension-size-50);
    font-size: 12px;
    background: color-mix(in srgb, var(--spectrum-global-color-gray-50) 70%, transparent);
    color: var(--spectrum-alias-text-color, var(--spectrum-global-color-gray-700));
    border: 1px solid var(--spectrum-alias-border-color);
  }

  /* Visual annotations for DOM nodes */
  .d-added { outline: 2px solid var(--spectrum-global-color-green-600); outline-offset: 2px; }
  .d-removed { outline: 2px solid var(--spectrum-global-color-red-600); outline-offset: 2px; }
  .d-changed { outline: 2px solid var(--spectrum-global-color-orange-600); outline-offset: 2px; }
  .d-text-changed { background: color-mix(in srgb, var(--spectrum-global-color-orange-600) 20%, transparent); }

  /* Center only modal dialogs; let fullscreen manage its own layout */
  sp-dialog-wrapper[open][mode="modal"] {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  /* Fallback to viewport centering if host isn't full height */
  :host(:not(:defined)), :host {
    contain: paint;
  }
  sp-dialog-wrapper[open][mode="modal"][underlay] {
    position: fixed;
    inset: 0;
    pointer-events: none; /* allow dialog to own interactions */
  }
  sp-dialog-wrapper[open][mode="modal"] sp-dialog {
    pointer-events: auto;
  }

  /* Fullscreen dialog wrapper to ensure it mounts above and captures ESC/underlay */
  sp-dialog-wrapper[open][mode="fullscreen"] {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }
  sp-dialog-wrapper[open][mode="fullscreen"] sp-dialog {
    pointer-events: auto;
  }
`;

// src/features/versions/ee-versions-panel.js
init_unsafe_html2();
var EEVersionsPanel = class extends i4 {
  static get styles() {
    return eeVersionsPanelStyles;
  }
  static get properties() {
    return {
      versionStore: { type: Object, observe: true },
      store: { type: Object, observe: true },
      createOpen: { type: Boolean, state: true },
      createName: { type: String, state: true },
      confirmOpen: { type: Boolean, state: true },
      confirmTarget: { type: Object, state: true },
      comparePos: { type: Number, state: true },
      revealSide: { type: String, state: true },
      renamingId: { type: String, state: true },
      renameValue: { type: String, state: true }
    };
  }
  constructor() {
    super();
    this.createOpen = false;
    this.createName = "";
    this.confirmOpen = false;
    this.confirmTarget = null;
    this.leftDiffHTML = "";
    this.rightDiffHTML = "";
    this.comparePos = 0.5;
    this.revealSide = "right";
    this.renamingId = null;
    this.renameValue = "";
  }
  sanitizeNode(node) {
    if (!node) return;
    if (node.nodeType === Node.ELEMENT_NODE) {
      const el = node;
      const tag3 = (el.tagName || "").toLowerCase();
      if (tag3 === "script") {
        el.remove();
        return;
      }
      for (const name of Array.from(el.getAttributeNames())) {
        if (name.toLowerCase().startsWith("on")) el.removeAttribute(name);
      }
      for (const child of Array.from(el.childNodes)) this.sanitizeNode(child);
    }
  }
  parseHTMLToContainer(html) {
    const parser = new DOMParser();
    const doc3 = parser.parseFromString(String(html || ""), "text/html");
    const wrapper = document.createElement("div");
    for (const child of Array.from(doc3.body.childNodes)) {
      const clone = child.cloneNode(true);
      wrapper.appendChild(clone);
    }
    this.sanitizeNode(wrapper);
    return wrapper;
  }
  onRequestRestore(v6) {
    this.store?.setUserAction?.("version:requestRestore", { id: v6?.id, name: v6?.name });
    this.confirmTarget = { ...v6, _loading: true, _snapshot: null };
    this.confirmOpen = true;
    this.comparePos = 0.5;
    this.leftDiffHTML = "";
    this.rightDiffHTML = "";
    (async () => {
      const host = this.getRootNode()?.host;
      const urn = host?.store?.editorStore?.currentElementId;
      if (!host || !urn) {
        this.confirmTarget = { ...v6, _loading: false, _snapshot: null };
        return;
      }
      const details = await this.versionStore?.documentStore?.getVersionDetails?.(urn, v6.id);
      this.confirmTarget = { ...v6, _loading: false, _snapshot: details?.snapshot_html || "" };
      let currentHtml = host?.store?.currentElement?.html || "";
      const appStore = host?.store;
      const root = host?.firstElementChild;
      if (root && appStore?.documentStore?.serializeElement) {
        const clone = root.cloneNode(true);
        sanitizeTree(clone, { currentDocumentId: urn, beforeSave: true, showToast: () => {
        } });
        currentHtml = appStore.documentStore.serializeElement(clone);
      }
      const leftRoot = this.parseHTMLToContainer(currentHtml);
      const rightRoot = this.parseHTMLToContainer(this.confirmTarget._snapshot || "");
      sanitizeTree(leftRoot, { currentDocumentId: urn, beforeSave: true, showToast: () => {
      } });
      sanitizeTree(rightRoot, { currentDocumentId: urn, beforeSave: true, showToast: () => {
      } });
      this.leftDiffHTML = leftRoot.innerHTML;
      this.rightDiffHTML = rightRoot.innerHTML;
    })().catch(() => {
      this.confirmTarget = { ...v6, _loading: false, _snapshot: null };
      this.getRootNode()?.host?.showToast?.("Failed to load version details");
    });
  }
  get versions() {
    return Array.isArray(this.versionStore?.versions) ? this.versionStore.versions : [];
  }
  connectedCallback() {
    super.connectedCallback();
    const refreshPromise = this.versionStore?.refreshVersions?.();
    if (refreshPromise && typeof refreshPromise.then === "function") {
      refreshPromise.catch(() => {
        this.getRootNode()?.host?.showToast?.("Failed to load versions");
      });
    }
  }
  formatFriendlyTime(dateInput) {
    return formatRelativeDate(dateInput);
  }
  async onCreateVersion() {
    const name = (this.createName || "").trim();
    if (!name) {
      this.getRootNode()?.host?.showToast?.("Please enter a version name");
      return;
    }
    const capped = name.length > 256 ? name.slice(0, 256) : name;
    this.store?.setUserAction?.("version:create", { name: capped });
    const createPromise = this.versionStore?.createVersion?.(capped);
    if (!createPromise || typeof createPromise.then !== "function") return;
    const success = await createPromise.then(
      () => true,
      () => false
    );
    if (!success) {
      this.getRootNode()?.host?.showToast?.("Failed to create version");
      return;
    }
    this.createOpen = false;
    this.createName = "";
    this.getRootNode()?.host?.showToast?.("Version created");
  }
  async onConfirmRestore() {
    const v6 = this.confirmTarget;
    this.confirmOpen = false;
    if (!v6) return;
    this.store?.setUserAction?.("version:restore", { id: v6.id, name: v6.name });
    const host = this.getRootNode()?.host;
    const urn = host?.store?.editorStore?.currentElementId;
    const restorePromise = this.versionStore?.documentStore?.restoreVersion?.(urn, v6.id);
    if (!restorePromise || typeof restorePromise.then !== "function") return;
    const result = await restorePromise.then(
      (value) => ({ ok: true, value }),
      () => ({ ok: false, value: null })
    );
    if (!result.ok) {
      this.getRootNode()?.host?.showToast?.("Failed to restore version");
      return;
    }
    host?.showToast?.(`Restored version "${v6.name}"`);
    const restored = result.value;
    if (restored && typeof restored === "object" && restored.html) {
      const prev = host?.store?.currentElement || {};
      host?.store?.setCurrentElement?.({ ...prev, ...restored });
      host?.loadEditorContent?.();
      const comments = Array.isArray(restored.comments) ? restored.comments : [];
      host?.commentStore?.setComments?.(comments, { silent: true });
    } else {
      await host?.store?.openElement?.(urn);
    }
    const updateComplete = host?.updateComplete;
    if (updateComplete && typeof updateComplete.then === "function") {
      await updateComplete;
    }
    host?.store?.editorStore?.scheduleAutoSave?.();
  }
  renderHeader() {
    const count = this.versions.length;
    return x`
      <div id="header">
        <h3>Versions (${count})</h3>
        <sp-action-button quiet title="Close" @click=${() => {
      this.store?.setUserAction?.("version:closePanel", {});
      this.versionStore?.closeVersionsPanel?.();
    }}>
          <sp-icon-close slot="icon"></sp-icon-close>
        </sp-action-button>
        <span class="spacer"></span>
      </div>
    `;
  }
  renderComposer() {
    if (!this.createOpen) return E;
    return x`
      <div id="composer">
        <sp-textfield
          id="version-name"
          placeholder="Version name"
          value=${this.createName}
          @input=${(e36) => this.createName = e36.target.value}
          @keydown=${(e36) => {
      if (e36.key === "Enter") this.onCreateVersion();
      if (e36.key === "Escape") {
        this.createOpen = false;
        this.createName = "";
      }
    }}
        ></sp-textfield>
        <sp-button variant="primary" @click=${() => this.onCreateVersion()}>Create</sp-button>
      </div>
    `;
  }
  renderList() {
    if (!this.versions.length) return x`<div class="muted" style="padding: 8px;">No versions yet.</div>`;
    return x`
      <div id="list">
        ${this.versions.map((v6) => x`
          <div class="item">
            <div class="row">
              ${this.renamingId === v6.id ? x`
                    <sp-textfield
                      id="rename-version-${v6.id}"
                      value=${this.renameValue}
                      @input=${(e36) => this.renameValue = e36.target.value}
                      @keydown=${(e36) => {
      if (e36.key === "Enter") this.onConfirmRename(v6);
      if (e36.key === "Escape") this.onCancelRename();
    }}
                      placeholder="Version name"
                      size="m"
                    ></sp-textfield>
                  ` : x`<span
                    class="name"
                    role="button"
                    tabindex="0"
                    title="Rename version"
                    @click=${() => this.onStartRename(v6)}
                    @keydown=${(e36) => {
      if (e36.key === "Enter" || e36.key === " ") {
        e36.preventDefault();
        this.onStartRename(v6);
      }
    }}
                  >${v6.name}</span>`}
              <span class="muted">${this.formatFriendlyTime(v6.created)}</span>
              ${this.renderAuthor(v6)}
              <span class="spacer"></span>
              ${this.renamingId === v6.id ? x`
                    <sp-action-button quiet size="s" title="Save" @click=${() => this.onConfirmRename(v6)}>
                      <sp-icon-checkmark-circle slot="icon"></sp-icon-checkmark-circle>
                    </sp-action-button>
                    <sp-action-button quiet size="s" title="Cancel" @click=${() => this.onCancelRename()}>
                      <sp-icon-close slot="icon"></sp-icon-close>
                    </sp-action-button>
                  ` : E}
              ${this.renamingId === v6.id ? E : x`<sp-action-button quiet size="s" title="Restore" @click=${() => this.onRequestRestore(v6)}>
                    <sp-icon-revert slot="icon"></sp-icon-revert>
                  </sp-action-button>`}
            </div>
          </div>
        `)}
      </div>
    `;
  }
  onStartRename(v6) {
    this.renamingId = v6?.id || null;
    this.renameValue = v6?.name || "";
    this.updateComplete.then(() => {
      const input = this.renderRoot?.querySelector?.(`#rename-version-${v6.id}`);
      if (input) input.focus();
    });
  }
  async onConfirmRename(v6) {
    const name = (this.renameValue || "").trim();
    if (!name) return;
    await this.versionStore?.renameVersion?.(v6.id, name);
    this.renamingId = null;
    this.renameValue = "";
  }
  onCancelRename() {
    this.renamingId = null;
    this.renameValue = "";
  }
  renderAuthor(v6) {
    const email = (this.getRootNode()?.host?.userStore?.currentUser?.email || "").toLowerCase();
    const vEmail = (v6.author_email || "").toLowerCase();
    const name = v6.author_name || v6.author_email || "";
    const label = email && vEmail && email === vEmail ? "You" : name;
    return label ? x`<span class="muted">by ${label}</span>` : E;
  }
  render() {
    return x`
      <div id="panel-root">
        ${this.renderHeader()}
        ${this.createOpen ? E : x`<sp-button variant="primary" size="m" @click=${() => this.createOpen = true}>
              <sp-icon-add slot="icon"></sp-icon-add>
              New version
            </sp-button>`}
        ${this.renderComposer()}
        ${this.renderList()}
        ${this.confirmDialogUI}
      </div>
    `;
  }
  get confirmDialogUI() {
    if (!this.confirmOpen) return E;
    const loading = !!this.confirmTarget?._loading;
    return x`
      <overlay-trigger
        id="restore-overlay"
        type="modal"
        triggered-by="click"
        receives-focus="auto"
        .open=${"click"}
        @sp-closed=${() => this.confirmOpen = false}
      >
        <span slot="trigger" id="compare-trigger-anchor" style="position:fixed;left:0;top:0;width:0;height:0;overflow:hidden;opacity:0"></span>
        <sp-dialog-wrapper
          id="compare-dialog"
          slot="click-content"
          dismissable
          dismiss-label="Close"
          underlay
          mode="fullscreen"
          headline="Restore version?"
          confirm-label="Restore"
          cancel-label="Cancel"
          @confirm=${() => this.onConfirmRestore()}
          @cancel=${() => this.confirmOpen = false}
          @close=${() => this.confirmOpen = false}
        >
          ${loading ? x`<div class="muted">Loading diff...</div>` : x`${this.compareUI}`}
        </sp-dialog-wrapper>
      </overlay-trigger>
    `;
  }
  get comparePercent() {
    const x5 = Number.isFinite(this.comparePos) ? this.comparePos : 0.5;
    return Math.min(100, Math.max(0, Math.round(x5 * 100)));
  }
  get compareUI() {
    const pct = this.comparePercent;
    const dividerLeft = `${pct}%`;
    const revealClass = this.revealSide === "left" ? "reveal-left" : "reveal-right";
    const revealFromRight = this.revealSide !== "left";
    const leftLegend = revealFromRight ? "Selected" : "Current";
    const rightLegend = revealFromRight ? "Current" : "Selected";
    return x`
      <div
        id="compare-viewport"
      >
        <div
          id="compare-scene"
          style=${`--divider-percent: ${dividerLeft};`}
          @pointerdown=${this.onComparePointerDown}
          @keydown=${this.onCompareKeyDown}
          role="slider"
          aria-valuemin="0"
          aria-valuemax="100"
          aria-valuenow=${pct}
          aria-label="Version compare divider"
          tabindex="0"
        >
          <div id="compare-legend" aria-hidden="true">
            <span class="legend-left">${leftLegend}</span>
            <span class="legend-right">${rightLegend}</span>
          </div>
          <div id="compare-divider" aria-hidden="true"></div>
          <div id="compare-before" class="compare-layer">
            <div class="compare-content">${o12(this.leftDiffHTML || "")}</div>
          </div>
          <div id="compare-after" class=${`compare-layer compare-after-clip ${revealClass}`}>
            <div class="compare-content">${o12(this.rightDiffHTML || "")}</div>
          </div>
          <canvas id="compare-canvas" aria-hidden="true"></canvas>
        </div>
      </div>
    `;
  }
  onCompareKeyDown = (e36) => {
    const step = e36.shiftKey ? 0.1 : 0.02;
    if (e36.key === "ArrowLeft") {
      e36.preventDefault();
      this.comparePos = Math.max(0, (this.comparePos || 0.5) - step);
    } else if (e36.key === "ArrowRight") {
      e36.preventDefault();
      this.comparePos = Math.min(1, (this.comparePos || 0.5) + step);
    }
  };
  onComparePointerDown = (e36) => {
    this.#isDraggingCompare = true;
    const move = (ev) => this.#updateCompareFromPointer(ev);
    const up = () => {
      this.#isDraggingCompare = false;
      window.removeEventListener("pointermove", move);
      window.removeEventListener("pointerup", up);
      window.removeEventListener("pointercancel", up);
    };
    window.addEventListener("pointermove", move);
    window.addEventListener("pointerup", up);
    window.addEventListener("pointercancel", up);
    this.#updateCompareFromPointer(e36);
  };
  #isDraggingCompare = false;
  #updateCompareFromPointer(e36) {
    const elements = this.#getCompareElements();
    if (!elements) return;
    const { scene } = elements;
    const rect = scene.getBoundingClientRect();
    const x5 = e36.clientX - rect.left;
    const pos = x5 / Math.max(1, rect.width);
    this.comparePos = Math.min(1, Math.max(0, pos));
  }
  updated(changed) {
    if (changed.has("leftDiffHTML") || changed.has("rightDiffHTML") || changed.has("confirmOpen")) {
      const elements = this.#getCompareElements();
      if (!elements) return;
      const { scene, before, after, viewport } = elements;
      requestAnimationFrame(() => {
        const h16 = Math.max(
          before.scrollHeight || 0,
          after.scrollHeight || 0,
          viewport ? viewport.clientHeight : 0
        );
        scene.style.height = h16 ? `${h16}px` : "";
        this.#renderCanvasOverlay();
      });
    }
    if (changed.has("confirmOpen")) {
      if (this.confirmOpen) {
        this.#onWindowResize = this.#onWindowResize || (() => {
          this.#recomputeCompareHeight();
          this.#renderCanvasOverlay();
        });
        window.addEventListener("resize", this.#onWindowResize);
        this.#ensureContentResizeObserver();
        this.#recomputeCompareHeight();
        this.#renderCanvasOverlay();
        requestAnimationFrame(() => {
          const ot2 = this.shadowRoot && this.shadowRoot.getElementById("restore-overlay");
          if (ot2) {
            ot2.open = "click";
          }
          const scene = this.#qs("#compare-scene");
          if (scene && typeof scene.focus === "function") scene.focus();
        });
      } else {
        if (this.#onWindowResize) {
          window.removeEventListener("resize", this.#onWindowResize);
        }
        this.#teardownContentResizeObserver();
      }
    }
    if (changed.has("comparePos")) {
      this.#renderCanvasOverlay();
    }
  }
  #onWindowResize;
  #resizeObserver;
  #observedNodes = [];
  #ensureContentResizeObserver() {
    if (!this.#resizeObserver) {
      this.#resizeObserver = new ResizeObserver(() => {
        this.#recomputeCompareHeight();
        this.#renderCanvasOverlay();
      });
    }
    const elements = this.#getCompareElements();
    if (!elements) return;
    const { before, after, viewport } = elements;
    const targets = [before, after, viewport].filter(Boolean);
    for (const el of targets) {
      if (!this.#observedNodes.includes(el)) {
        this.#resizeObserver.observe(el);
        this.#observedNodes.push(el);
      }
    }
  }
  #teardownContentResizeObserver() {
    if (this.#resizeObserver) {
      for (const el of this.#observedNodes) {
        this.#resizeObserver.unobserve(el);
      }
    }
    this.#observedNodes = [];
  }
  #recomputeCompareHeight() {
    const elements = this.#getCompareElements();
    if (!elements) return;
    const { scene, before, after, viewport } = elements;
    const vpH = viewport ? viewport.clientHeight : 0;
    const h16 = Math.max(before.scrollHeight || 0, after.scrollHeight || 0, vpH);
    scene.style.height = h16 ? `${h16}px` : "";
    this.#renderCanvasOverlay();
  }
  #getCompareElements() {
    const scene = this.#qs("#compare-scene");
    const before = this.#qs("#compare-before .compare-content");
    const after = this.#qs("#compare-after .compare-content");
    const viewport = this.#qs("#compare-viewport");
    if (!scene || !before || !after) return null;
    return { scene, before, after, viewport };
  }
  #renderCanvasOverlay() {
    const scene = this.#qs("#compare-scene");
    const canvas = this.#qs("#compare-canvas");
    if (!scene || !canvas) return;
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const w3 = Math.max(1, Math.floor(scene.clientWidth));
    const h16 = Math.max(1, Math.floor(scene.scrollHeight));
    canvas.style.width = w3 + "px";
    canvas.style.height = h16 + "px";
    if (canvas.width !== w3 * dpr || canvas.height !== h16 * dpr) {
      canvas.width = w3 * dpr;
      canvas.height = h16 * dpr;
    }
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const x5 = Math.round((this.comparePos || 0.5) * canvas.width);
    const band = Math.max(32 * dpr, 1);
    const left = Math.max(0, x5 - band);
    const right = Math.min(canvas.width, x5 + band);
    const borderColor = this.#getCssVarColor("--spectrum-alias-border-color") || this.#getCssVarColor("--spectrum-global-color-gray-700") || "rgb(0,0,0)";
    const grad = ctx.createLinearGradient(left, 0, right, 0);
    grad.addColorStop(0, this.#colorWithAlpha(borderColor, 0));
    grad.addColorStop(0.5, this.#colorWithAlpha(borderColor, 0.25));
    grad.addColorStop(1, this.#colorWithAlpha(borderColor, 0));
    ctx.fillStyle = grad;
    ctx.fillRect(left, 0, right - left, canvas.height);
  }
  #getCssVarColor(name) {
    const scene = this.#qs("#compare-scene");
    if (!scene) return "";
    const v6 = getComputedStyle(scene).getPropertyValue(name);
    return (v6 || "").trim();
  }
  #colorWithAlpha(color, alpha) {
    const components = this.#extractRgbComponents(color);
    if (components) {
      const [r25, g8, b12] = components;
      return `rgba(${r25}, ${g8}, ${b12}, ${alpha})`;
    }
    const c33 = (color || "").trim();
    if (c33[0] === "#" && c33.length === 7) {
      const r25 = parseInt(c33.slice(1, 3), 16) || 0;
      const g8 = parseInt(c33.slice(3, 5), 16) || 0;
      const b12 = parseInt(c33.slice(5, 7), 16) || 0;
      return `rgba(${r25}, ${g8}, ${b12}, ${alpha})`;
    }
    return `rgba(0,0,0,${alpha})`;
  }
  #extractRgbComponents(color) {
    const value = (color || "").trim();
    if (!value.startsWith("rgb")) return null;
    const start = value.indexOf("(");
    const end = value.lastIndexOf(")");
    if (start === -1 || end === -1) return null;
    const parts = value.slice(start + 1, end).split(",").map((p30) => parseInt(p30.trim(), 10)).filter((n25) => Number.isFinite(n25));
    if (parts.length < 3) return null;
    return parts.slice(0, 3);
  }
  #qs(selector) {
    const dialog = document.getElementById("compare-dialog");
    if (dialog) return dialog.querySelector(selector);
    return this.shadowRoot ? this.shadowRoot.querySelector(selector) : null;
  }
};
customElements.define("ee-versions-panel", makeLitObserver(EEVersionsPanel));

// src/features/used-in/used-in-panel.js
init_lit();

// src/features/used-in/used-in-panel.css.js
init_lit();
var usedInPanelStyles = i`
  :host {
    display: block;
    color: var(--spectrum-alias-text-color);
  }

  #panel {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-200);
    height: 100%;
  }

  #header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }

  #header-title {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-125);
    font-size: var(--spectrum-global-dimension-font-size-200);
    font-weight: 700;
    color: var(--spectrum-alias-text-color);
  }

  #list {
    flex-grow: 1;
    overflow-y: auto;
  }

  #empty {
    color: var(--spectrum-alias-label-text-color);
    padding: var(--spectrum-global-dimension-size-200) 0;
    font-style: italic;
  }

  #loading {
    display: grid;
    place-items: center;
    min-height: 120px;
  }
`;

// src/features/used-in/used-in-panel.js
init_sp_progress_circle();

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconRefresh.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Refresh.js
var RefreshIcon = ({ width: l16 = 24, height: e36 = 24, hidden: t34 = false, title: r25 = "Refresh" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M18.20654,3.89746c-.40527-.09473-.80811.15039-.90527.55371l-.38043,1.57471c-1.39771-2.43188-4.00189-4.00439-6.92084-4.00439-3.68457,0-6.87549,2.5-7.75928,6.08008-.09961.40234.146.80859.54834.9082.40137.09961.80859-.14648.90771-.54883.71826-2.9082,3.31006-4.93945,6.30322-4.93945,2.51685,0,4.73499,1.44629,5.80896,3.63232l-2.10242-.5083c-.40332-.09375-.80762.15039-.90527.55371-.09717.40234.15039.80762.55273.90527l3.24524.78418c.12476.08862.27362.14258.43152.14258.05957,0,.12012-.00684.18018-.02148.04822-.01196.08582-.04102.12921-.06104.06952-.01855.14331-.01953.20575-.05811.16943-.10352.29102-.27051.33789-.46387l.87549-3.62402c.09717-.40234-.15039-.80762-.55273-.90527Z"
      fill="currentColor"
    />
    <path
      d="M17.21094,11.03223c-.39697-.09668-.80811.14648-.90771.54883-.71826,2.90918-3.31006,4.94043-6.30322,4.94043-2.51703,0-4.73523-1.44653-5.80914-3.63354l2.1026.50854c.40283.0918.80811-.15039.90527-.55371.09717-.40234-.15039-.80762-.55273-.90527l-3.25494-.78662c-.17102-.11816-.38531-.17139-.60199-.11865-.0152.00391-.026.01465-.04071.01929-.10321.01318-.20392.04419-.29425.09985-.16943.10352-.29102.27051-.33789.46387l-.87549,3.62402c-.09717.40234.15039.80762.55273.90527.05957.01367.11865.02051.17676.02051.33838,0,.64551-.23047.72852-.57422l.38043-1.57471c1.39764,2.43213,4.00189,4.00537,6.92084,4.00537,3.68457,0,6.87549-2.50098,7.75928-6.08105.09961-.40234-.146-.80859-.54834-.9082Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Refresh.js
var RefreshIcon2 = ({ width: a23 = 24, height: e36 = 24, hidden: t34 = false, title: l16 = "Refresh" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${a23}"
    height="${e36}"
    viewBox="0 0 36 36"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M32.674 20H30.78a1.215 1.215 0 0 0-1.162.938 11.447 11.447 0 0 1-19.116 5.074l-.692-.693 3.955-3.955a.785.785 0 0 0 .235-.56.803.803 0 0 0-.754-.804H2.496a.5.5 0 0 0-.496.496v10.75a.803.803 0 0 0 .804.754.784.784 0 0 0 .56-.236l3.617-3.617.356.357a16.17 16.17 0 0 0 7.284 4.331A15.43 15.43 0 0 0 33.665 21.17a.996.996 0 0 0-.991-1.17ZM33.196 4a.784.784 0 0 0-.56.236l-3.617 3.617-.356-.357a16.17 16.17 0 0 0-7.284-4.331A15.43 15.43 0 0 0 2.335 14.83.996.996 0 0 0 3.326 16H5.22a1.216 1.216 0 0 0 1.162-.938 11.447 11.447 0 0 1 19.116-5.074l.692.693-3.955 3.955a.786.786 0 0 0-.235.56.804.804 0 0 0 .754.804h10.75a.5.5 0 0 0 .496-.496V4.754A.803.803 0 0 0 33.196 4Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconRefresh.js
var IconRefresh = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? RefreshIcon({ hidden: !this.label, title: this.label }) : RefreshIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-refresh.js
init_define_element();
defineElement("sp-icon-refresh", IconRefresh);

// node_modules/@spectrum-web-components/sidenav/src/Sidenav.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/sidenav/src/sidenav.css.js
init_src();
var t27 = i`
    @media (forced-colors:active){.spectrum-Icon{forced-color-adjust:preserve-parent-color}}:host{--spectrum-sidenav-focus-ring-size:var(--spectrum-focus-indicator-thickness);--spectrum-sidenav-focus-ring-gap:var(--spectrum-focus-indicator-gap);--spectrum-sidenav-focus-ring-color:var(--spectrum-focus-indicator-color);--spectrum-sidenav-min-height:var(--spectrum-component-height-100);--spectrum-sidenav-width:100%;--spectrum-sidenav-min-width:var(--spectrum-side-navigation-minimum-width);--spectrum-sidenav-max-width:var(--spectrum-side-navigation-maximum-width);--spectrum-sidenav-border-radius:var(--spectrum-corner-radius-100);--spectrum-sidenav-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-sidenav-icon-spacing:var(--spectrum-text-to-visual-100);--spectrum-sidenav-inline-padding:var(--spectrum-component-edge-to-text-100);--spectrum-sidenav-gap:var(--spectrum-side-navigation-item-to-item);--spectrum-sidenav-top-to-icon:var(--spectrum-component-top-to-workflow-icon-100);--spectrum-sidenav-top-to-label:var(--spectrum-component-top-to-text-100);--spectrum-sidenav-bottom-to-label:var(--spectrum-side-navigation-bottom-to-text);--spectrum-sidenav-start-to-content-second-level:var(--spectrum-side-navigation-second-level-edge-to-text);--spectrum-sidenav-start-to-content-third-level:var(--spectrum-side-navigation-third-level-edge-to-text);--spectrum-sidenav-start-to-content-with-icon-second-level:var(--spectrum-side-navigation-with-icon-second-level-edge-to-text);--spectrum-sidenav-start-to-content-with-icon-third-level:var(--spectrum-side-navigation-with-icon-third-level-edge-to-text);--spectrum-sidenav-heading-top-margin:var(--spectrum-side-navigation-item-to-header);--spectrum-sidenav-heading-bottom-margin:var(--spectrum-side-navigation-header-to-item);--spectrum-sidenav-background-disabled:transparent;--spectrum-sidenav-background-default:transparent;--spectrum-sidenav-header-color:var(--spectrum-gray-600);--spectrum-sidenav-content-disabled-color:var(--spectrum-disabled-content-color);--spectrum-sidenav-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-sidenav-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-sidenav-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-sidenav-content-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-sidenav-content-color-default-selected:var(--spectrum-neutral-content-color-default);--spectrum-sidenav-content-color-hover-selected:var(--spectrum-neutral-content-color-hover);--spectrum-sidenav-content-color-down-selected:var(--spectrum-neutral-content-color-down);--spectrum-sidenav-content-color-key-focus-selected:var(--spectrum-neutral-content-color-key-focus);--spectrum-sidenav-text-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-text-font-weight:var(--spectrum-regular-font-weight);--spectrum-sidenav-text-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-text-font-size:var(--spectrum-font-size-100);--spectrum-sidenav-text-line-height:var(--spectrum-line-height-100);--spectrum-sidenav-top-level-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-top-level-font-weight:var(--spectrum-bold-font-weight);--spectrum-sidenav-top-level-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-top-level-font-size:var(--spectrum-font-size-100);--spectrum-sidenav-top-level-line-height:var(--spectrum-line-height-100);--spectrum-sidenav-header-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-header-font-weight:var(--spectrum-medium-font-weight);--spectrum-sidenav-header-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-header-font-size:var(--spectrum-font-size-75);--spectrum-sidenav-header-line-height:var(--spectrum-line-height-100);flex-direction:column;margin:0;padding:0;list-style-type:none;display:flex}:host:lang(ja),:host:lang(ko),:host:lang(zh){--spectrum-sidenav-text-line-height:var(--spectrum-cjk-line-height-100);--spectrum-sidenav-top-level-line-height:var(--spectrum-cjk-line-height-100);--spectrum-sidenav-header-line-height:var(--spectrum-cjk-line-height-100)}:host{--spectrum-sidenav-background-hover:var(--system-side-nav-background-hover);--spectrum-sidenav-item-background-down:var(--system-side-nav-item-background-down);--spectrum-sidenav-background-key-focus:var(--system-side-nav-background-key-focus);--spectrum-sidenav-item-background-default-selected:var(--system-side-nav-item-background-default-selected);--spectrum-sidenav-background-hover-selected:var(--system-side-nav-background-hover-selected);--spectrum-sidenav-item-background-down-selected:var(--system-side-nav-item-background-down-selected);--spectrum-sidenav-background-key-focus-selected:var(--system-side-nav-background-key-focus-selected)}:host{--spectrum-web-component-sidenav-font-weight:var(--mod-sidenav-text-font-weight,var(--spectrum-sidenav-text-font-weight));width:240px;display:block}:host(:not([variant=multilevel])){--mod-sidenav-top-level-font-weight:var(--mod-sidenav-text-font-weight,var(--spectrum-sidenav-text-font-weight))}
`;
var sidenav_css_default = t27;

// node_modules/@spectrum-web-components/sidenav/src/Sidenav.js
init_src2();

// node_modules/@spectrum-web-components/sidenav/src/SidenavItem.js
init_src();
init_decorators2();
init_directives();
init_like_anchor();
init_focusable();

// node_modules/@spectrum-web-components/sidenav/src/sidenav-item.css.js
init_src();
var t28 = i`
    @media (forced-colors:active){#list ::slotted([slot=icon]){forced-color-adjust:preserve-parent-color}:host{--highcontrast-sidenav-content-disabled-color:GrayText;--highcontrast-sidenav-focus-ring-color:Highlight;--highcontrast-sidenav-content-color-default-selected:SelectedItemText;--highcontrast-sidenav-item-background-default-selected:SelectedItem;--highcontrast-sidenav-background-key-focus-selected:Highlight;--highcontrast-sidenav-background-hover-selected:Highlight;--highcontrast-sidenav-item-background-down-selected:Highlight;--highcontrast-sidenav-item-background-down:Highlight;--highcontrast-sidenav-background-hover:Highlight;--highcontrast-sidenav-content-color-hover:HighlightText;--highcontrast-sidenav-background-key-focus:Highlight;--highcontrast-sidenav-top-level-font-color:ButtonText;--highcontrast-sidenav-content-color-default:ButtonText;--highcontrast-sidenav-content-color-down:HighlightText;forced-color-adjust:none}}#list{--spectrum-sidenav-focus-ring-size:var(--spectrum-focus-indicator-thickness);--spectrum-sidenav-focus-ring-gap:var(--spectrum-focus-indicator-gap);--spectrum-sidenav-focus-ring-color:var(--spectrum-focus-indicator-color);--spectrum-sidenav-min-height:var(--spectrum-component-height-100);--spectrum-sidenav-width:100%;--spectrum-sidenav-min-width:var(--spectrum-side-navigation-minimum-width);--spectrum-sidenav-max-width:var(--spectrum-side-navigation-maximum-width);--spectrum-sidenav-border-radius:var(--spectrum-corner-radius-100);--spectrum-sidenav-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-sidenav-icon-spacing:var(--spectrum-text-to-visual-100);--spectrum-sidenav-inline-padding:var(--spectrum-component-edge-to-text-100);--spectrum-sidenav-gap:var(--spectrum-side-navigation-item-to-item);--spectrum-sidenav-top-to-icon:var(--spectrum-component-top-to-workflow-icon-100);--spectrum-sidenav-top-to-label:var(--spectrum-component-top-to-text-100);--spectrum-sidenav-bottom-to-label:var(--spectrum-side-navigation-bottom-to-text);--spectrum-sidenav-start-to-content-second-level:var(--spectrum-side-navigation-second-level-edge-to-text);--spectrum-sidenav-start-to-content-third-level:var(--spectrum-side-navigation-third-level-edge-to-text);--spectrum-sidenav-start-to-content-with-icon-second-level:var(--spectrum-side-navigation-with-icon-second-level-edge-to-text);--spectrum-sidenav-start-to-content-with-icon-third-level:var(--spectrum-side-navigation-with-icon-third-level-edge-to-text);--spectrum-sidenav-heading-top-margin:var(--spectrum-side-navigation-item-to-header);--spectrum-sidenav-heading-bottom-margin:var(--spectrum-side-navigation-header-to-item);--spectrum-sidenav-background-disabled:transparent;--spectrum-sidenav-background-default:transparent;--spectrum-sidenav-header-color:var(--spectrum-gray-600);--spectrum-sidenav-content-disabled-color:var(--spectrum-disabled-content-color);--spectrum-sidenav-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-sidenav-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-sidenav-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-sidenav-content-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-sidenav-content-color-default-selected:var(--spectrum-neutral-content-color-default);--spectrum-sidenav-content-color-hover-selected:var(--spectrum-neutral-content-color-hover);--spectrum-sidenav-content-color-down-selected:var(--spectrum-neutral-content-color-down);--spectrum-sidenav-content-color-key-focus-selected:var(--spectrum-neutral-content-color-key-focus);--spectrum-sidenav-text-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-text-font-weight:var(--spectrum-regular-font-weight);--spectrum-sidenav-text-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-text-font-size:var(--spectrum-font-size-100);--spectrum-sidenav-text-line-height:var(--spectrum-line-height-100);--spectrum-sidenav-top-level-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-top-level-font-weight:var(--spectrum-bold-font-weight);--spectrum-sidenav-top-level-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-top-level-font-size:var(--spectrum-font-size-100);--spectrum-sidenav-top-level-line-height:var(--spectrum-line-height-100);--spectrum-sidenav-header-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-header-font-weight:var(--spectrum-medium-font-weight);--spectrum-sidenav-header-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-header-font-size:var(--spectrum-font-size-75);--spectrum-sidenav-header-line-height:var(--spectrum-line-height-100);flex-direction:column;margin:0;padding:0;list-style-type:none;display:flex}#list:lang(ja),#list:lang(ko),#list:lang(zh){--spectrum-sidenav-text-line-height:var(--spectrum-cjk-line-height-100);--spectrum-sidenav-top-level-line-height:var(--spectrum-cjk-line-height-100);--spectrum-sidenav-header-line-height:var(--spectrum-cjk-line-height-100)}:host{margin-inline:0;list-style-type:none}:host([disabled]) #item-link{background-color:var(--mod-sidenav-background-disabled,var(--spectrum-sidenav-background-disabled));color:var(--highcontrast-sidenav-content-disabled-color,var(--mod-sidenav-content-disabled-color,var(--spectrum-sidenav-content-disabled-color)));cursor:default;pointer-events:none}:host([selected]) #item-link{background-color:var(--highcontrast-sidenav-item-background-default-selected,var(--mod-sidenav-item-background-default-selected,var(--spectrum-sidenav-item-background-default-selected)));color:var(--highcontrast-sidenav-content-color-default-selected,var(--mod-sidenav-content-color-default-selected,var(--spectrum-sidenav-content-color-default-selected)))}:host([selected]) #item-link:active{background-color:var(--highcontrast-sidenav-item-background-down-selected,var(--mod-sidenav-item-background-down-selected,var(--spectrum-sidenav-item-background-down-selected)));color:var(--mod-sidenav-content-color-down-selected,var(--spectrum-sidenav-content-color-down-selected))}:host([selected]) #item-link.is-keyboardFocused,:host([selected]) #item-link:focus-visible{background-color:var(--highcontrast-sidenav-background-key-focus-selected,var(--mod-sidenav-background-key-focus-selected,var(--spectrum-sidenav-background-key-focus-selected)));color:var(--mod-sidenav-content-color-key-focus-selected,var(--spectrum-sidenav-content-color-key-focus-selected))}#item-link{padding-inline:var(--mod-sidenav-inline-padding,var(--spectrum-sidenav-inline-padding));box-sizing:border-box;overflow-wrap:break-word;hyphens:auto;cursor:pointer;transition:background-color var(--spectrum-animation-duration-100)ease-out,color var(--spectrum-animation-duration-100)ease-out;border-radius:var(--mod-sidenav-border-radius,var(--spectrum-sidenav-border-radius));background-color:var(--mod-sidenav-background-default,var(--spectrum-sidenav-background-default));color:var(--highcontrast-sidenav-content-color-default,var(--mod-sidenav-content-color-default,var(--spectrum-sidenav-content-color-default)));inline-size:var(--mod-sidenav-width,var(--spectrum-sidenav-width));min-inline-size:var(--mod-sidenav-min-width,var(--spectrum-sidenav-min-width));max-inline-size:var(--mod-sidenav-max-width,var(--spectrum-sidenav-max-width));min-block-size:var(--mod-sidenav-min-height,var(--spectrum-sidenav-min-height));font-family:var(--mod-sidenav-text-font-family,var(--spectrum-sidenav-text-font-family));font-size:var(--mod-sidenav-text-font-size,var(--spectrum-sidenav-text-font-size));font-weight:var(--mod-sidenav-text-font-weight,var(--spectrum-sidenav-text-font-weight));font-style:var(--mod-sidenav-text-font-style,var(--spectrum-sidenav-text-font-style));line-height:var(--mod-sidenav-text-line-height,var(--spectrum-sidenav-text-line-height));justify-content:start;margin-block-end:var(--mod-sidenav-gap,var(--spectrum-sidenav-gap));-webkit-text-decoration:none;text-decoration:none;display:inline-flex;position:relative}#item-link #link-text{margin-block-start:var(--mod-sidenav-top-to-label,var(--spectrum-sidenav-top-to-label));margin-block-end:var(--mod-sidenav-bottom-to-label,var(--spectrum-sidenav-bottom-to-label))}#item-link ::slotted([slot=icon]){inline-size:var(--mod-sidenav-icon-size,var(--spectrum-sidenav-icon-size));block-size:var(--mod-sidenav-icon-size,var(--spectrum-sidenav-icon-size));flex-shrink:0;margin-block-start:var(--mod-sidenav-top-to-icon,var(--spectrum-sidenav-top-to-icon));margin-inline-end:var(--mod-sidenav-icon-spacing,var(--spectrum-sidenav-icon-spacing))}@media (hover:hover){:host([selected]) #item-link:hover{background-color:var(--highcontrast-sidenav-background-hover-selected,var(--mod-sidenav-background-hover-selected,var(--spectrum-sidenav-background-hover-selected)));color:var(--mod-sidenav-content-color-hover-selected,var(--spectrum-sidenav-content-color-hover-selected))}#item-link:hover{background-color:var(--highcontrast-sidenav-background-hover,var(--mod-sidenav-background-hover,var(--spectrum-sidenav-background-hover)));color:var(--highcontrast-sidenav-content-color-hover,var(--mod-sidenav-content-color-hover,var(--spectrum-sidenav-content-color-hover)))}}#item-link:active{background-color:var(--highcontrast-sidenav-item-background-down,var(--mod-sidenav-item-background-down,var(--spectrum-sidenav-item-background-down)));color:var(--highcontrast-sidenav-content-color-down,var(--mod-sidenav-content-color-down,var(--spectrum-sidenav-content-color-down)))}#item-link.is-keyboardFocused,#item-link:focus-visible{outline:var(--highcontrast-sidenav-focus-ring-color,var(--mod-sidenav-focus-ring-color,var(--spectrum-sidenav-focus-ring-color)))solid var(--mod-sidenav-focus-ring-size,var(--spectrum-sidenav-focus-ring-size));outline-offset:var(--mod-sidenav-focus-ring-gap,var(--spectrum-sidenav-focus-ring-gap));background-color:var(--highcontrast-sidenav-background-key-focus,var(--mod-sidenav-background-key-focus,var(--spectrum-sidenav-background-key-focus)));color:var(--mod-sidenav-content-color-key-focus,var(--spectrum-sidenav-content-color-key-focus))}#item-link[data-level]{color:var(--highcontrast-sidenav-top-level-font-color);font-family:var(--mod-sidenav-top-level-font-family,var(--spectrum-sidenav-top-level-font-family));font-weight:var(--mod-sidenav-top-level-font-weight,var(--spectrum-sidenav-top-level-font-weight));font-style:var(--mod-sidenav-top-level-font-style,var(--spectrum-sidenav-top-level-font-style));font-size:var(--mod-sidenav-top-level-font-size,var(--spectrum-sidenav-top-level-font-size));line-height:var(--mod-sidenav-top-level-line-height,var(--spectrum-sidenav-top-level-line-height))}#item-link:not([data-level="0"]){font-weight:var(--mod-sidenav-text-font-weight,var(--spectrum-sidenav-text-font-weight));padding-inline-start:var(--mod-sidenav-start-to-content-second-level,var(--spectrum-sidenav-start-to-content-second-level))}#item-link[data-level="2"]{padding-inline-start:var(--mod-sidenav-start-to-content-third-level,var(--spectrum-sidenav-start-to-content-third-level))}.spectrum-SideNav--hasIcon#item-link:not([data-level="0"]){padding-inline-start:var(--mod-sidenav-start-to-content-with-icon-second-level,var(--spectrum-sidenav-start-to-content-with-icon-second-level))}.spectrum-SideNav--hasIcon#item-link[data-level="2"]{padding-inline-start:var(--mod-sidenav-start-to-content-with-icon-third-level,var(--spectrum-sidenav-start-to-content-with-icon-third-level))}#list{--spectrum-sidenav-background-hover:var(--system-side-nav-background-hover);--spectrum-sidenav-item-background-down:var(--system-side-nav-item-background-down);--spectrum-sidenav-background-key-focus:var(--system-side-nav-background-key-focus);--spectrum-sidenav-item-background-default-selected:var(--system-side-nav-item-background-default-selected);--spectrum-sidenav-background-hover-selected:var(--system-side-nav-background-hover-selected);--spectrum-sidenav-item-background-down-selected:var(--system-side-nav-item-background-down-selected);--spectrum-sidenav-background-key-focus-selected:var(--system-side-nav-background-key-focus-selected)}:host{display:block}:host([disabled]){pointer-events:none}a ::slotted(sp-sidenav-item){display:none}
`;
var sidenav_item_css_default = t28;

// node_modules/@spectrum-web-components/sidenav/src/SidenavItem.js
var h14 = Object.defineProperty;
var u25 = Object.getOwnPropertyDescriptor;
var n21 = (c33, a23, e36, t34) => {
  for (var i21 = t34 > 1 ? void 0 : t34 ? u25(a23, e36) : a23, d22 = c33.length - 1, l16; d22 >= 0; d22--) (l16 = c33[d22]) && (i21 = (t34 ? l16(a23, e36, i21) : l16(i21)) || i21);
  return t34 && i21 && h14(a23, e36, i21), i21;
};
var r18 = class r19 extends LikeAnchor(Focusable) {
  constructor() {
    super(...arguments);
    this.value = void 0;
    this.selected = false;
    this.expanded = false;
  }
  static get styles() {
    return [sidenav_item_css_default];
  }
  get parentSideNav() {
    return this._parentSidenav || (this._parentSidenav = this.closest("sp-sidenav")), this._parentSidenav;
  }
  get hasChildren() {
    return !!this.querySelector("sp-sidenav-item");
  }
  get depth() {
    let e36 = 0, t34 = this.parentElement;
    for (; t34 instanceof r19; ) e36++, t34 = t34.parentElement;
    return e36;
  }
  handleSideNavSelect(e36) {
    this.selected = e36.target === this;
  }
  handleClick(e36) {
    !this.href && e36 && e36.preventDefault(), !this.disabled && (!this.href || e36 != null && e36.defaultPrevented) && (this.hasChildren ? this.expanded = !this.expanded : this.value && this.announceSelected(this.value));
  }
  announceSelected(e36) {
    const t34 = { value: e36 }, i21 = new CustomEvent("sidenav-select", { bubbles: true, composed: true, detail: t34 });
    this.dispatchEvent(i21);
  }
  click() {
    this.handleClick();
  }
  get focusElement() {
    return this.shadowRoot.querySelector("#item-link");
  }
  update(e36) {
    this.hasAttribute("slot") || (this.slot = "descendant"), super.update(e36);
  }
  render() {
    return x`
            <a
                href=${this.href || "#"}
                target=${o9(this.target)}
                download=${o9(this.download)}
                rel=${o9(this.rel)}
                data-level="${this.depth}"
                @click="${this.handleClick}"
                id="item-link"
                aria-current=${o9(this.selected && this.href ? "page" : void 0)}
                aria-expanded=${o9(this.hasChildren ? this.expanded : void 0)}
                aria-controls=${o9(this.hasChildren && this.expanded ? "list" : void 0)}
            >
                <slot name="icon"></slot>
                <span id="link-text">
                    ${this.label}
                    <slot></slot>
                </span>
            </a>
            ${this.expanded ? x`
                      <div id="list" aria-labelledby="item-link" role="list">
                          <slot name="descendant"></slot>
                      </div>
                  ` : E}
        `;
  }
  updated(e36) {
    var t34;
    this.hasChildren && this.expanded && !this.selected && ((t34 = this.parentSideNav) != null && t34.manageTabIndex) ? this.focusElement.tabIndex = -1 : this.focusElement.removeAttribute("tabindex"), super.updated(e36);
  }
  connectedCallback() {
    super.connectedCallback(), this.startTrackingSelection();
  }
  disconnectedCallback() {
    this.stopTrackingSelection(), super.disconnectedCallback();
  }
  async startTrackingSelection() {
    const e36 = this.parentSideNav;
    if (e36 && (await e36.updateComplete, e36.startTrackingSelectionForItem(this), this.selected = this.value != null && this.value === e36.value, this.selected === true && e36.variant === "multilevel")) {
      let t34 = this.parentElement;
      for (; t34 instanceof r19; ) t34.expanded = true, t34 = t34.parentElement;
    }
  }
  stopTrackingSelection() {
    const e36 = this.parentSideNav;
    e36 && e36.stopTrackingSelectionForItem(this), this._parentSidenav = void 0;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.setAttribute("role", "listitem");
  }
};
n21([n4()], r18.prototype, "value", 2), n21([n4({ type: Boolean, reflect: true })], r18.prototype, "selected", 2), n21([n4({ type: Boolean, reflect: true })], r18.prototype, "expanded", 2);
var SideNavItem = r18;

// node_modules/@spectrum-web-components/sidenav/src/SidenavHeading.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/sidenav/src/sidenav-heading.css.js
init_src();
var t29 = i`
    @media (forced-colors:active){#list .spectrum-Icon{forced-color-adjust:preserve-parent-color}}#list{--spectrum-sidenav-focus-ring-size:var(--spectrum-focus-indicator-thickness);--spectrum-sidenav-focus-ring-gap:var(--spectrum-focus-indicator-gap);--spectrum-sidenav-focus-ring-color:var(--spectrum-focus-indicator-color);--spectrum-sidenav-min-height:var(--spectrum-component-height-100);--spectrum-sidenav-width:100%;--spectrum-sidenav-min-width:var(--spectrum-side-navigation-minimum-width);--spectrum-sidenav-max-width:var(--spectrum-side-navigation-maximum-width);--spectrum-sidenav-border-radius:var(--spectrum-corner-radius-100);--spectrum-sidenav-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-sidenav-icon-spacing:var(--spectrum-text-to-visual-100);--spectrum-sidenav-inline-padding:var(--spectrum-component-edge-to-text-100);--spectrum-sidenav-gap:var(--spectrum-side-navigation-item-to-item);--spectrum-sidenav-top-to-icon:var(--spectrum-component-top-to-workflow-icon-100);--spectrum-sidenav-top-to-label:var(--spectrum-component-top-to-text-100);--spectrum-sidenav-bottom-to-label:var(--spectrum-side-navigation-bottom-to-text);--spectrum-sidenav-start-to-content-second-level:var(--spectrum-side-navigation-second-level-edge-to-text);--spectrum-sidenav-start-to-content-third-level:var(--spectrum-side-navigation-third-level-edge-to-text);--spectrum-sidenav-start-to-content-with-icon-second-level:var(--spectrum-side-navigation-with-icon-second-level-edge-to-text);--spectrum-sidenav-start-to-content-with-icon-third-level:var(--spectrum-side-navigation-with-icon-third-level-edge-to-text);--spectrum-sidenav-heading-top-margin:var(--spectrum-side-navigation-item-to-header);--spectrum-sidenav-heading-bottom-margin:var(--spectrum-side-navigation-header-to-item);--spectrum-sidenav-background-disabled:transparent;--spectrum-sidenav-background-default:transparent;--spectrum-sidenav-header-color:var(--spectrum-gray-600);--spectrum-sidenav-content-disabled-color:var(--spectrum-disabled-content-color);--spectrum-sidenav-content-color-default:var(--spectrum-neutral-content-color-default);--spectrum-sidenav-content-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-sidenav-content-color-down:var(--spectrum-neutral-content-color-down);--spectrum-sidenav-content-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-sidenav-content-color-default-selected:var(--spectrum-neutral-content-color-default);--spectrum-sidenav-content-color-hover-selected:var(--spectrum-neutral-content-color-hover);--spectrum-sidenav-content-color-down-selected:var(--spectrum-neutral-content-color-down);--spectrum-sidenav-content-color-key-focus-selected:var(--spectrum-neutral-content-color-key-focus);--spectrum-sidenav-text-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-text-font-weight:var(--spectrum-regular-font-weight);--spectrum-sidenav-text-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-text-font-size:var(--spectrum-font-size-100);--spectrum-sidenav-text-line-height:var(--spectrum-line-height-100);--spectrum-sidenav-top-level-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-top-level-font-weight:var(--spectrum-bold-font-weight);--spectrum-sidenav-top-level-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-top-level-font-size:var(--spectrum-font-size-100);--spectrum-sidenav-top-level-line-height:var(--spectrum-line-height-100);--spectrum-sidenav-header-font-family:var(--spectrum-sans-font-family-stack);--spectrum-sidenav-header-font-weight:var(--spectrum-medium-font-weight);--spectrum-sidenav-header-font-style:var(--spectrum-default-font-style);--spectrum-sidenav-header-font-size:var(--spectrum-font-size-75);--spectrum-sidenav-header-line-height:var(--spectrum-line-height-100);flex-direction:column;margin:0;padding:0;list-style-type:none;display:flex}#list:lang(ja),#list:lang(ko),#list:lang(zh){--spectrum-sidenav-text-line-height:var(--spectrum-cjk-line-height-100);--spectrum-sidenav-top-level-line-height:var(--spectrum-cjk-line-height-100);--spectrum-sidenav-header-line-height:var(--spectrum-cjk-line-height-100)}#heading{padding-inline:var(--mod-sidenav-inline-padding,var(--spectrum-sidenav-inline-padding));color:var(--mod-sidenav-header-color,var(--spectrum-sidenav-header-color));font-family:var(--spectrum-sidenav-header-font-family);font-size:var(--mod-sidenav-header-font-size,var(--spectrum-sidenav-header-font-size));font-weight:var(--mod-sidenav-header-font-weight,var(--spectrum-sidenav-header-font-weight));font-style:var(--mod-sidenav-header-font-style,var(--spectrum-sidenav-header-font-style));line-height:var(--mod-sidenav-header-line-height,var(--spectrum-sidenav-header-line-height));margin-block-start:calc(var(--mod-sidenav-heading-top-margin,var(--spectrum-sidenav-heading-top-margin)) - var(--mod-sidenav-gap,var(--spectrum-sidenav-gap)));margin-block-end:var(--mod-sidenav-heading-bottom-margin,var(--spectrum-sidenav-heading-bottom-margin))}#list{--spectrum-sidenav-background-hover:var(--system-side-nav-background-hover);--spectrum-sidenav-item-background-down:var(--system-side-nav-item-background-down);--spectrum-sidenav-background-key-focus:var(--system-side-nav-background-key-focus);--spectrum-sidenav-item-background-default-selected:var(--system-side-nav-item-background-default-selected);--spectrum-sidenav-background-hover-selected:var(--system-side-nav-background-hover-selected);--spectrum-sidenav-item-background-down-selected:var(--system-side-nav-item-background-down-selected);--spectrum-sidenav-background-key-focus-selected:var(--system-side-nav-background-key-focus-selected)}:host{display:block}
`;
var sidenav_heading_css_default = t29;

// node_modules/@spectrum-web-components/sidenav/src/SidenavHeading.js
var a15 = Object.defineProperty;
var p22 = Object.getOwnPropertyDescriptor;
var o43 = (s19, r25, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? p22(r25, e36) : r25, l16 = s19.length - 1, d22; l16 >= 0; l16--) (d22 = s19[l16]) && (t34 = (i21 ? d22(r25, e36, t34) : d22(t34)) || t34);
  return i21 && t34 && a15(r25, e36, t34), t34;
};
var SideNavHeading = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.label = "";
  }
  static get styles() {
    return [sidenav_item_css_default, sidenav_heading_css_default];
  }
  update(e36) {
    this.hasAttribute("slot") || (this.slot = "descendant"), super.update(e36);
  }
  render() {
    return x`
            <h2 id="heading">${this.label}</h2>
            <div id="list" aria-labelledby="heading" role="list">
                <slot name="descendant"></slot>
            </div>
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.setAttribute("role", "listitem");
  }
};
o43([n4({ reflect: true })], SideNavHeading.prototype, "label", 2);

// node_modules/@spectrum-web-components/sidenav/src/Sidenav.js
init_directives();
var o44 = Object.defineProperty;
var u26 = Object.getOwnPropertyDescriptor;
var r20 = (d22, l16, e36, t34) => {
  for (var a23 = t34 > 1 ? void 0 : t34 ? u26(l16, e36) : l16, i21 = d22.length - 1, s19; i21 >= 0; i21--) (s19 = d22[i21]) && (a23 = (t34 ? s19(l16, e36, a23) : s19(a23)) || a23);
  return t34 && a23 && o44(l16, e36, a23), a23;
};
var SideNav = class extends Focusable {
  constructor() {
    super(...arguments);
    this.items = /* @__PURE__ */ new Set();
    this.rovingTabindexController = new RovingTabindexController(this, { focusInIndex: (e36) => {
      let t34, a23 = e36.findIndex((i21) => (i21.value === this.value && this.isDisabledChild(i21) && (t34 = i21.closest("sp-sidenav-item:not([expanded])")), this.value ? !i21.disabled && !this.isDisabledChild(i21) && i21.value === this.value : !i21.disabled && !this.isDisabledChild(i21)));
      return a23 === -1 && t34 && (a23 = e36.findIndex((i21) => i21 === t34)), a23;
    }, direction: "vertical", elements: () => [...this.querySelectorAll("sp-sidenav-item")], isFocusableElement: (e36) => !e36.disabled && !this.isDisabledChild(e36) });
    this.manageTabIndex = false;
    this.value = void 0;
    this.variant = void 0;
    this.label = void 0;
  }
  static get styles() {
    return [sidenav_css_default];
  }
  startTrackingSelectionForItem(e36) {
    this.items.add(e36), this.rovingTabindexController.clearElementCache();
  }
  stopTrackingSelectionForItem(e36) {
    this.items.delete(e36), this.rovingTabindexController.clearElementCache();
  }
  handleSelect(e36) {
    if (e36.stopPropagation(), this.value === e36.detail.value) return;
    const t34 = this.value;
    this.value = e36.detail.value, this.dispatchEvent(new Event("change", { bubbles: true, composed: true, cancelable: true })) ? this.items.forEach((i21) => i21.handleSideNavSelect(e36)) : (this.value = t34, e36.target.selected = false, e36.preventDefault());
  }
  focus() {
    this.rovingTabindexController.focus();
  }
  blur() {
    this.focusElement !== this && super.blur();
  }
  click() {
    this.focusElement !== this && super.click();
  }
  get focusElement() {
    return this.rovingTabindexController.focusInElement || this;
  }
  isDisabledChild(e36) {
    if (e36.disabled) return true;
    let t34 = e36.parentElement;
    for (; t34 instanceof SideNavHeading || !t34.disabled && t34 instanceof SideNavItem && t34.expanded; ) t34 = t34.parentElement;
    return t34 !== this;
  }
  handleSlotchange() {
    this.manageTabIndex ? this.rovingTabindexController.manage() : this.rovingTabindexController.unmanage();
  }
  render() {
    return x`
            <nav
                @sidenav-select=${this.handleSelect}
                aria-label=${o9(this.label)}
            >
                <div role="list">
                    <slot
                        name="descendant"
                        @slotchange=${this.handleSlotchange}
                    ></slot>
                </div>
            </nav>
        `;
  }
  willUpdate() {
    if (!this.hasUpdated) {
      const e36 = this.querySelector("[selected]");
      e36 && (this.value = e36.value);
    }
  }
  updated(e36) {
    super.updated(e36), e36.has("manageTabIndex") && (this.manageTabIndex ? this.rovingTabindexController.manage() : this.rovingTabindexController.unmanage());
  }
};
r20([n4({ type: Boolean, reflect: true, attribute: "manage-tab-index" })], SideNav.prototype, "manageTabIndex", 2), r20([n4({ reflect: true })], SideNav.prototype, "value", 2), r20([n4({ reflect: true })], SideNav.prototype, "variant", 2), r20([n4({ reflect: true })], SideNav.prototype, "label", 2);

// node_modules/@spectrum-web-components/sidenav/sp-sidenav.js
init_define_element();
defineElement("sp-sidenav", SideNav);

// node_modules/@spectrum-web-components/sidenav/sp-sidenav-item.js
init_define_element();
defineElement("sp-sidenav-item", SideNavItem);

// src/features/used-in/used-in-panel.js
var UsedInPanel = class extends i4 {
  static get styles() {
    return usedInPanelStyles;
  }
  static get properties() {
    return {
      usedInStore: { type: Object, observe: true },
      store: { type: Object, observe: true }
    };
  }
  // Panel title with count when available
  get title() {
    const items = this.usedInStore && Array.isArray(this.usedInStore.items) ? this.usedInStore.items : null;
    if (items) return `Used In (${items.length})`;
    return "Used In";
  }
  renderHeader() {
    return x`
      <div id="header">
        <div id="header-title">
          <sp-icon-target size="s"></sp-icon-target>
          <span>${this.title}</span>
        </div>
        <sp-action-button
          quiet
          size="m"
          title="Refresh"
          @click=${() => this.refresh()}
        >
          <sp-icon-refresh slot="icon"></sp-icon-refresh>
        </sp-action-button>
      </div>
    `;
  }
  refresh() {
    const urn = this.getRootNode()?.host?.store?.editorStore?.currentElementId;
    if (urn) this.usedInStore?.refreshFor?.(urn);
  }
  openURN(urn) {
    if (!urn) return;
    const url = new URL(window.location.href);
    url.searchParams.set("id", String(urn || ""));
    url.searchParams.delete("new");
    url.searchParams.delete("category");
    window.location.href = url.toString();
  }
  renderList() {
    const items = Array.isArray(this.usedInStore?.items) ? this.usedInStore.items : [];
    if (this.usedInStore?.isLoading) {
      return x`<div id="loading">
        <sp-progress-circle indeterminate size="m"></sp-progress-circle>
      </div>`;
    }
    if (!items.length) {
      return x`<div id="empty">No usages yet.</div>`;
    }
    return x`
      <div id="list">
        <sp-sidenav>
          ${items.map(
      (it2) => x`
            <sp-sidenav-item
              value=${it2.urn}
              label=${it2.name || it2.urn}
              @click=${() => this.openURN(it2.urn)}
            ></sp-sidenav-item>
          `
    )}
        </sp-sidenav>
      </div>
    `;
  }
  render() {
    return x`
      <div id="panel">
        ${this.renderHeader()}
        <sp-help-text size="m" id="usage-help">Listed below are documents that use this fragment.</sp-help-text>
        ${this.renderList()}
      </div>
    `;
  }
};
makeLitObserver(UsedInPanel);
customElements.define("used-in-panel", UsedInPanel);

// src/features/agent/ee-agent-panel.js
init_lit();

// src/features/agent/ee-agent-panel.css.js
init_lit();
var eeAgentPanelStyles = i`
  :host,
  :host *,
  :host *::before,
  :host *::after {
    box-sizing: border-box;
  }

  :host {
    display: block;
    height: 100%;
    box-sizing: border-box;
  }

  #panel-root {
    display: grid;
    grid-template-rows: auto auto auto 1fr auto;
    height: 100%;
    padding: var(--spectrum-global-dimension-size-300);
    gap: var(--spectrum-global-dimension-size-200);
    color: var(--spectrum-alias-text-color, currentColor);
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  #header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spectrum-global-dimension-size-200);
    color: var(--spectrum-alias-text-color, inherit);
    min-width: 0;
  }

  #header h3 {
    margin: 0;
    font-size: 14px;
    font-weight: 600;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 75%;
  }

  #header-actions {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  #context-info {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-100);
    padding: var(--spectrum-global-dimension-size-100);
    background: var(--spectrum-alias-component-background-color);
    border-radius: var(--spectrum-global-dimension-size-75);
    border: 1px solid var(--spectrum-alias-border-color);
    font-size: var(--spectrum-global-dimension-font-size-75);
  }

  #context-info.no-selection {
    flex-direction: column;
    align-items: flex-start;
    gap: 2px;
  }

  .context-label {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-100);
    color: var(--spectrum-alias-text-color);
  }

  .context-label code {
    font-family: var(--spectrum-global-font-family-code);
    background: var(--spectrum-global-color-gray-200);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 11px;
  }

  .context-hint {
    color: var(--spectrum-global-color-gray-600);
    font-size: 11px;
  }

  sp-divider {
    margin: 0;
  }

  .error-banner {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spectrum-global-dimension-size-100);
    background-color: var(--spectrum-global-color-red-100);
    color: var(--spectrum-global-color-red-900);
    font-size: 12px;
    border-radius: var(--spectrum-global-dimension-size-75);
  }

  #messages-area {
    overflow-y: auto;
    padding-right: var(--spectrum-global-dimension-size-100);
    color: var(--spectrum-alias-text-color, currentColor);
    width: 100%;
    max-width: 100%;
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-150);
  }

  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: var(--spectrum-global-dimension-size-400) var(--spectrum-global-dimension-size-200);
    gap: var(--spectrum-global-dimension-size-150);
  }

  .empty-icon {
    font-size: 28px;
  }

  .empty-title {
    font-size: var(--spectrum-global-dimension-font-size-200);
    font-weight: 600;
    color: var(--spectrum-alias-text-color);
  }

  .empty-text {
    font-size: var(--spectrum-global-dimension-font-size-75);
    color: var(--spectrum-global-color-gray-700);
    max-width: 280px;
    line-height: 1.5;
  }

  .message {
    display: flex;
    flex-direction: column;
    max-width: 95%;
    gap: 4px;
  }

  .message.user {
    align-self: flex-end;
    align-items: flex-end;
  }

  .message.assistant {
    align-self: flex-start;
    align-items: flex-start;
  }

  .message-bubble {
    padding: var(--spectrum-global-dimension-size-100) var(--spectrum-global-dimension-size-150);
    border-radius: var(--spectrum-global-dimension-size-100);
    font-size: var(--spectrum-global-dimension-font-size-100);
    line-height: 1.5;
    word-wrap: break-word;
  }

  .message.user .message-bubble {
    background-color: var(--spectrum-global-color-blue-500);
    color: white;
    border-bottom-right-radius: 4px;
  }

  .message.assistant .message-bubble {
    background-color: var(--spectrum-alias-component-background-color);
    color: var(--spectrum-alias-text-color);
    border: 1px solid var(--spectrum-alias-border-color);
    border-bottom-left-radius: 4px;
  }

  .message-meta {
    font-size: 10px;
    color: var(--spectrum-global-color-gray-600);
    margin: 0 4px;
  }

  .markup-preview {
    margin-top: var(--spectrum-global-dimension-size-150);
    border: 1px solid var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-global-dimension-size-75);
    overflow: hidden;
    background: var(--spectrum-alias-component-background-color);
  }

  .markup-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spectrum-global-dimension-size-100) var(--spectrum-global-dimension-size-150);
    background: var(--spectrum-global-color-gray-100);
    border-bottom: 1px solid var(--spectrum-alias-border-color);
    font-size: 11px;
    font-weight: 600;
    color: var(--spectrum-global-color-gray-700);
  }

  .markup-code {
    margin: 0;
    padding: var(--spectrum-global-dimension-size-150);
    overflow-x: auto;
    font-family: var(--spectrum-global-font-family-code);
    font-size: 11px;
    line-height: 1.5;
    background: var(--spectrum-global-color-gray-50);
    color: var(--spectrum-alias-text-color);
    max-height: 200px;
    overflow-y: auto;
  }

  .markup-code code {
    white-space: pre-wrap;
    word-break: break-word;
  }

  .markup-actions {
    display: flex;
    justify-content: flex-end;
    padding: var(--spectrum-global-dimension-size-100) var(--spectrum-global-dimension-size-150);
    background: var(--spectrum-global-color-gray-100);
    border-top: 1px solid var(--spectrum-alias-border-color);
  }

  #input-area {
    display: flex;
    gap: var(--spectrum-global-dimension-size-100);
    align-items: flex-end;
  }

  #input-area sp-textfield {
    flex: 1;
  }

  #send-button {
    flex-shrink: 0;
  }

  .loading-indicator {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-100);
    color: var(--spectrum-global-color-gray-600);
    font-size: var(--spectrum-global-dimension-font-size-75);
    padding: var(--spectrum-global-dimension-size-100) 0;
  }
`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSend.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Send.js
var SendIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Send" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m18.64851,9.97351c-.00035-.29451-.1716-.56244-.44263-.68294L4.05753,2.93283c-.25619-.11532-.55623-.07699-.77581.0984-.21993.17643-.32282.46024-.26655.73611l1.27162,6.2407-1.2219,6.23034c-.04868.24687.03004.4996.20543.675.02037.02037.04247.03971.06491.058.22097.17401.51997.21061.77547.0946l14.09794-6.40816c.26862-.12222.44022-.38981.43987-.68432Zm-4.24251-.74634l-8.7416.02663-.88734-4.35295,9.62894,4.32632Zm-9.58888,5.8701l.85229-4.34432,8.76288-.02659-9.61517,4.37091Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Send.js
var SendIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: a23 = "Send" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M33.191 5.113 1.8 14.478a.5.5 0 0 0-.081.927l7.921 3.953ZM13.089 21.032l11.937 6a1 1 0 0 0 1.343-.446l9.267-20.222ZM10.08 23.25v7.639a.713.713 0 0 0 1.174.544l5.36-4.516Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSend.js
var IconSend = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? SendIcon({ hidden: !this.label, title: this.label }) : SendIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-send.js
init_define_element();
defineElement("sp-icon-send", IconSend);

// src/features/agent/ee-agent-panel.js
init_sp_progress_circle();

// node_modules/@spectrum-web-components/badge/src/Badge.js
init_src();
init_decorators2();
init_observe_slot_text();
init_observe_slot_presence();

// node_modules/@spectrum-web-components/badge/src/badge.css.js
init_src();
var a16 = i`
    :host{--spectrum-badge-corner-radius:var(--spectrum-corner-radius-100);--spectrum-badge-line-height:var(--spectrum-line-height-100);--spectrum-badge-line-height-cjk:var(--spectrum-cjk-line-height-100);--spectrum-badge-label-icon-color:var(--spectrum-white);--spectrum-badge-background-color-default:var(--spectrum-neutral-subdued-background-color-default);--spectrum-badge-background-color-accent:var(--spectrum-accent-background-color-default);--spectrum-badge-background-color-informative:var(--spectrum-informative-background-color-default);--spectrum-badge-background-color-negative:var(--spectrum-negative-background-color-default);--spectrum-badge-background-color-positive:var(--spectrum-positive-background-color-default);--spectrum-badge-background-color-notice:var(--spectrum-notice-background-color-default);--spectrum-badge-background-color-gray:var(--spectrum-gray-background-color-default);--spectrum-badge-background-color-red:var(--spectrum-red-background-color-default);--spectrum-badge-background-color-orange:var(--spectrum-orange-background-color-default);--spectrum-badge-background-color-yellow:var(--spectrum-yellow-background-color-default);--spectrum-badge-background-color-chartreuse:var(--spectrum-chartreuse-background-color-default);--spectrum-badge-background-color-celery:var(--spectrum-celery-background-color-default);--spectrum-badge-background-color-green:var(--spectrum-green-background-color-default);--spectrum-badge-background-color-seafoam:var(--spectrum-seafoam-background-color-default);--spectrum-badge-background-color-cyan:var(--spectrum-cyan-background-color-default);--spectrum-badge-background-color-blue:var(--spectrum-blue-background-color-default);--spectrum-badge-background-color-indigo:var(--spectrum-indigo-background-color-default);--spectrum-badge-background-color-purple:var(--spectrum-purple-background-color-default);--spectrum-badge-background-color-fuchsia:var(--spectrum-fuchsia-background-color-default);--spectrum-badge-background-color-magenta:var(--spectrum-magenta-background-color-default);--spectrum-badge-height:var(--spectrum-component-height-100);--spectrum-badge-font-size:var(--spectrum-font-size-100);--spectrum-badge-label-spacing-vertical-top:var(--spectrum-component-top-to-text-100);--spectrum-badge-label-spacing-vertical-bottom:var(--spectrum-component-bottom-to-text-100);--spectrum-badge-label-spacing-horizontal:var(--spectrum-component-edge-to-text-100);--spectrum-badge-workflow-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-badge-icon-text-spacing:var(--spectrum-text-to-visual-100);--spectrum-badge-icon-spacing-horizontal:var(--spectrum-component-edge-to-visual-100);--spectrum-badge-icon-spacing-vertical-top:var(--spectrum-component-top-to-workflow-icon-100);--spectrum-badge-icon-only-spacing-horizontal:var(--spectrum-component-edge-to-visual-only-100);--highcontrast-badge-border-color:CanvasText}:host([variant=celery]),:host([variant=chartreuse]),:host([variant=orange]),:host([variant=yellow]){--spectrum-badge-label-icon-color:var(--spectrum-black)}:host([variant=blue]),:host([variant=cyan]),:host([variant=fuchsia]),:host([variant=gray]),:host([variant=green]),:host([variant=indigo]),:host([variant=magenta]),:host([variant=purple]),:host([variant=red]),:host([variant=seafoam]){--spectrum-badge-label-icon-color:var(--spectrum-badge-label-icon-color-primary)}:host([size=s]){--spectrum-badge-height:var(--spectrum-component-height-75);--spectrum-badge-font-size:var(--spectrum-font-size-75);--spectrum-badge-label-spacing-vertical-top:var(--spectrum-component-top-to-text-75);--spectrum-badge-label-spacing-vertical-bottom:var(--spectrum-component-bottom-to-text-75);--spectrum-badge-label-spacing-horizontal:var(--spectrum-component-edge-to-text-75);--spectrum-badge-workflow-icon-size:var(--spectrum-workflow-icon-size-75);--spectrum-badge-icon-text-spacing:var(--spectrum-text-to-visual-75);--spectrum-badge-icon-spacing-horizontal:var(--spectrum-component-edge-to-visual-75);--spectrum-badge-icon-spacing-vertical-top:var(--spectrum-component-top-to-workflow-icon-75);--spectrum-badge-icon-only-spacing-horizontal:var(--spectrum-component-edge-to-visual-only-75)}:host([size=l]){--spectrum-badge-height:var(--spectrum-component-height-100);--spectrum-badge-font-size:var(--spectrum-font-size-200);--spectrum-badge-label-spacing-vertical-top:var(--spectrum-component-top-to-text-200);--spectrum-badge-label-spacing-vertical-bottom:var(--spectrum-component-bottom-to-text-200);--spectrum-badge-label-spacing-horizontal:var(--spectrum-component-edge-to-text-200);--spectrum-badge-workflow-icon-size:var(--spectrum-workflow-icon-size-200);--spectrum-badge-icon-text-spacing:var(--spectrum-text-to-visual-200);--spectrum-badge-icon-spacing-horizontal:var(--spectrum-component-edge-to-visual-200);--spectrum-badge-icon-spacing-vertical-top:var(--spectrum-component-top-to-workflow-icon-200);--spectrum-badge-icon-only-spacing-horizontal:var(--spectrum-component-edge-to-visual-only-200)}:host([size=xl]){--spectrum-badge-height:var(--spectrum-component-height-100);--spectrum-badge-font-size:var(--spectrum-font-size-300);--spectrum-badge-label-spacing-vertical-top:var(--spectrum-component-top-to-text-300);--spectrum-badge-label-spacing-vertical-bottom:var(--spectrum-component-bottom-to-text-300);--spectrum-badge-label-spacing-horizontal:var(--spectrum-component-edge-to-text-300);--spectrum-badge-workflow-icon-size:var(--spectrum-workflow-icon-size-300);--spectrum-badge-icon-text-spacing:var(--spectrum-text-to-visual-300);--spectrum-badge-icon-spacing-horizontal:var(--spectrum-component-edge-to-visual-300);--spectrum-badge-icon-spacing-vertical-top:var(--spectrum-component-top-to-workflow-icon-300);--spectrum-badge-icon-only-spacing-horizontal:var(--spectrum-component-edge-to-visual-only-300)}@media (forced-colors:active){:host{border-color:var(--highcontrast-badge-border-color)}}:host{min-block-size:var(--mod-badge-height,var(--spectrum-badge-height));vertical-align:middle;cursor:default;-webkit-font-smoothing:subpixel-antialiased;-moz-osx-font-smoothing:auto;border-radius:var(--mod-badge-corner-radius,var(--spectrum-badge-corner-radius));inline-size:auto;color:var(--mod-badge-label-icon-color,var(--spectrum-badge-label-icon-color));border:1px solid #0000;display:inline-flex;position:relative}:host,:host([variant=neutral]){background:var(--mod-badge-background-color-default,var(--spectrum-badge-background-color-default))}:host([variant=accent]){background:var(--mod-badge-background-color-accent,var(--spectrum-badge-background-color-accent))}:host([variant=informative]){background:var(--mod-badge-background-color-informative,var(--spectrum-badge-background-color-informative))}:host([variant=negative]){background:var(--mod-badge-background-color-negative,var(--spectrum-badge-background-color-negative))}:host([variant=positive]){background:var(--mod-badge-background-color-positive,var(--spectrum-badge-background-color-positive))}:host([variant=notice]){background:var(--mod-badge-background-color-notice,var(--spectrum-badge-background-color-notice))}:host([variant=gray]){background:var(--mod-badge-background-color-gray,var(--spectrum-badge-background-color-gray))}:host([variant=red]){background:var(--mod-badge-background-color-red,var(--spectrum-badge-background-color-red))}:host([variant=orange]){background:var(--mod-badge-background-color-orange,var(--spectrum-badge-background-color-orange))}:host([variant=yellow]){background:var(--mod-badge-background-color-yellow,var(--spectrum-badge-background-color-yellow))}:host([variant=chartreuse]){background:var(--mod-badge-background-color-chartreuse,var(--spectrum-badge-background-color-chartreuse))}:host([variant=celery]){background:var(--mod-badge-background-color-celery,var(--spectrum-badge-background-color-celery))}:host([variant=green]){background:var(--mod-badge-background-color-green,var(--spectrum-badge-background-color-green))}:host([variant=seafoam]){background:var(--mod-badge-background-color-seafoam,var(--spectrum-badge-background-color-seafoam))}:host([variant=cyan]){background:var(--mod-badge-background-color-cyan,var(--spectrum-badge-background-color-cyan))}:host([variant=blue]){background:var(--mod-badge-background-color-blue,var(--spectrum-badge-background-color-blue))}:host([variant=indigo]){background:var(--mod-badge-background-color-indigo,var(--spectrum-badge-background-color-indigo))}:host([variant=purple]){background:var(--mod-badge-background-color-purple,var(--spectrum-badge-background-color-purple))}:host([variant=fuchsia]){background:var(--mod-badge-background-color-fuchsia,var(--spectrum-badge-background-color-fuchsia))}:host([variant=magenta]){background:var(--mod-badge-background-color-magenta,var(--spectrum-badge-background-color-magenta))}:host([fixed=inline-start]){border-start-start-radius:0;border-end-start-radius:0}:host([fixed=inline-end]){border-start-end-radius:0;border-end-end-radius:0}:host([fixed=block-start]){border-start-start-radius:0;border-start-end-radius:0}:host([fixed=block-end]){border-end-end-radius:0;border-end-start-radius:0}.label{font-size:var(--mod-badge-font-size,var(--spectrum-badge-font-size));line-height:var(--mod-badge-line-height,var(--spectrum-badge-line-height));color:var(--mod-badge-label-icon-color,var(--spectrum-badge-label-icon-color));padding-block-start:var(--mod-badge-label-spacing-vertical-top,var(--spectrum-badge-label-spacing-vertical-top));padding-block-end:var(--mod-badge-label-spacing-vertical-bottom,var(--spectrum-badge-label-spacing-vertical-bottom));padding-inline-start:var(--mod-badge-label-spacing-horizontal,var(--spectrum-badge-label-spacing-horizontal));padding-inline-end:var(--mod-badge-label-spacing-horizontal,var(--spectrum-badge-label-spacing-horizontal))}.label:lang(ja),.label:lang(ko),.label:lang(zh){line-height:var(--mod-badge-line-height-cjk,var(--spectrum-badge-line-height-cjk))}[name=icon]+.label{padding-inline-start:0}::slotted([slot=icon]){block-size:var(--mod-badge-workflow-icon-size,var(--spectrum-badge-workflow-icon-size));inline-size:var(--mod-badge-workflow-icon-size,var(--spectrum-badge-workflow-icon-size));flex:0 0 var(--mod-badge-workflow-icon-size,var(--spectrum-badge-workflow-icon-size));color:var(--mod-badge-label-icon-color,var(--spectrum-badge-label-icon-color));padding-block-start:var(--mod-badge-icon-spacing-vertical-top,var(--spectrum-badge-icon-spacing-vertical-top));padding-block-end:var(--mod-badge-icon-spacing-vertical-top,var(--spectrum-badge-icon-spacing-vertical-top));padding-inline-start:var(--mod-badge-icon-spacing-horizontal,var(--spectrum-badge-icon-spacing-horizontal));padding-inline-end:var(--mod-badge-icon-text-spacing,var(--spectrum-badge-icon-text-spacing))}[icon-only]::slotted(*){padding-inline-start:var(--mod-badge-icon-only-spacing-horizontal,var(--spectrum-badge-icon-only-spacing-horizontal));padding-inline-end:var(--mod-badge-icon-only-spacing-horizontal,var(--spectrum-badge-icon-only-spacing-horizontal))}:host{align-items:center}:host([size=xs]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-50)}:host([size=s]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-75)}:host([size=m]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-100)}:host([size=l]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-200)}:host([size=xl]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-300)}:host([size=xxl]){--spectrum-icon-size:var(--spectrum-workflow-icon-size-400)}::slotted([slot=icon]){flex-shrink:0}.label slot{max-height:calc(var(--spectrum-badge-line-height)*var(--spectrum-badge-font-size)*2);display:block;overflow:hidden}[icon-only]+.label{display:none}
`;
var badge_css_default = a16;

// node_modules/@spectrum-web-components/badge/src/Badge.js
var u27 = Object.defineProperty;
var p23 = Object.getOwnPropertyDescriptor;
var a17 = (o52, r25, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? p23(r25, e36) : r25, s19 = o52.length - 1, n25; s19 >= 0; s19--) (n25 = o52[s19]) && (t34 = (i21 ? n25(r25, e36, t34) : n25(t34)) || t34);
  return i21 && t34 && u27(r25, e36, t34), t34;
};
var Badge = class extends SizedMixin(ObserveSlotText(ObserveSlotPresence(SpectrumElement, '[slot="icon"]'), ""), { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.variant = "informative";
  }
  static get styles() {
    return [badge_css_default];
  }
  get fixed() {
    return this._fixed;
  }
  set fixed(e36) {
    if (e36 === this.fixed) return;
    const i21 = this.fixed;
    this._fixed = e36, e36 ? this.setAttribute("fixed", e36) : this.removeAttribute("fixed"), this.requestUpdate("fixed", i21);
  }
  get hasIcon() {
    return this.slotContentIsPresent;
  }
  render() {
    return x`
            ${this.hasIcon ? x`
                      <slot
                          name="icon"
                          ?icon-only=${!this.slotHasContent}
                      ></slot>
                  ` : E}
            <div class="label">
                <slot></slot>
            </div>
        `;
  }
};
a17([n4({ reflect: true })], Badge.prototype, "fixed", 1), a17([n4({ type: String, reflect: true })], Badge.prototype, "variant", 2);

// node_modules/@spectrum-web-components/badge/sp-badge.js
init_define_element();
defineElement("sp-badge", Badge);

// src/features/agent/ee-agent-panel.js
var EEAgentPanel = class extends i4 {
  static get styles() {
    return eeAgentPanelStyles;
  }
  static get properties() {
    return {
      agentStore: { type: Object, observe: true },
      editorStore: { type: Object, observe: true }
    };
  }
  #lastEditingElement = null;
  #lastSlot = null;
  updated(changedProperties) {
    const currentElement = this.editorStore?.editingElement;
    const currentSlot = this.editorStore?.currentSlot;
    if (currentElement !== this.#lastEditingElement || currentSlot !== this.#lastSlot) {
      this.#lastEditingElement = currentElement;
      this.#lastSlot = currentSlot;
      if (!currentElement && !currentSlot) {
        this.agentStore?.closePanel?.();
      } else {
        this.agentStore?.syncConversation?.();
      }
    }
    if (changedProperties.has("agentStore") || this.agentStore?.messages?.length) {
      this.#scrollToBottom();
    }
  }
  #scrollToBottom() {
    requestAnimationFrame(() => {
      const messagesArea = this.shadowRoot?.getElementById("messages-area");
      if (messagesArea) {
        messagesArea.scrollTop = messagesArea.scrollHeight;
      }
    });
  }
  handleClose(e36) {
    e36?.preventDefault();
    e36?.stopPropagation();
    this.agentStore?.closePanel?.();
  }
  handleSend() {
    const input = this.shadowRoot?.getElementById("agent-input");
    const text = input?.value?.trim();
    if (text && this.agentStore?.canSendMessage) {
      this.agentStore.sendMessage(text);
      if (input) input.value = "";
    }
  }
  handleKeydown(e36) {
    if (e36.key === "Enter" && !e36.shiftKey) {
      e36.preventDefault();
      this.handleSend();
    }
  }
  handleClearChat() {
    this.agentStore?.clearMessages?.();
  }
  get contextInfo() {
    const context = this.agentStore?.currentContext;
    if (!context) {
      return x`
        <div id="context-info" class="no-selection">
          <span class="context-label">No element selected</span>
          <span class="context-hint">Select an element to start chatting</span>
        </div>
      `;
    }
    const { slotLabel, tagName } = context;
    const isSlot = !!slotLabel;
    return x`
      <div id="context-info">
        <sp-badge size="s" variant=${isSlot ? "fuchsia" : "informative"}>
          ${isSlot ? slotLabel : tagName}
        </sp-badge>
      </div>
    `;
  }
  renderMessage(msg) {
    const isUser = msg.role === "user";
    return x`
      <div class="message ${isUser ? "user" : "assistant"}">
        <div class="message-bubble">
          ${msg.text}
        </div>
        <div class="message-meta">
          ${new Date(msg.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}
        </div>
      </div>
    `;
  }
  get errorDisplay() {
    const error = this.agentStore?.error;
    if (!error) return E;
    return x`
      <div class="error-banner">
        <span>${error}</span>
        <sp-action-button
          quiet
          size="s"
          @click=${() => this.agentStore?.setError?.(null)}
        >
          <sp-icon-close slot="icon"></sp-icon-close>
        </sp-action-button>
      </div>
    `;
  }
  get emptyState() {
    return x`
      <div class="empty-state">
        <div class="empty-icon"></div>
        <div class="empty-title">AI Assistant</div>
        <div class="empty-text">
          Select an element and describe what changes you'd like to make.
          I'll help you modify the content and structure.
        </div>
      </div>
    `;
  }
  render() {
    const messages = this.agentStore?.messages || [];
    const isLoading = this.agentStore?.isLoading;
    const canSend = this.agentStore?.canSendMessage;
    return x`
      <div id="panel-root">
        <div id="header">
          <h3>AI Assistant</h3>
          <div id="header-actions">
            ${messages.length > 0 ? x`
              <sp-action-button
                quiet
                size="s"
                title="Clear chat"
                @click=${() => this.handleClearChat()}
              >
                <sp-icon-delete slot="icon"></sp-icon-delete>
              </sp-action-button>
            ` : E}
            <sp-action-button
              quiet
              title="Close panel"
              @click=${(e36) => this.handleClose(e36)}
            >
              <sp-icon-close slot="icon"></sp-icon-close>
            </sp-action-button>
          </div>
        </div>

        ${this.contextInfo}
        <sp-divider size="s"></sp-divider>

        ${this.errorDisplay}

        <div id="messages-area">
          ${messages.length === 0 ? this.emptyState : messages.map((m18, i21) => this.renderMessage(m18, i21))}
          ${isLoading ? x`
            <div class="loading-indicator">
              <sp-progress-circle size="s" indeterminate></sp-progress-circle>
              <span>Thinking...</span>
            </div>
          ` : E}
        </div>

        <div id="input-area">
          <sp-textfield
            id="agent-input"
            multiline
            rows="2"
            placeholder=${canSend ? "Describe the changes you want..." : "Select an element first..."}
            @keydown=${(e36) => this.handleKeydown(e36)}
            ?disabled=${isLoading || !canSend}
          ></sp-textfield>
          <sp-action-button
            id="send-button"
            variant="accent"
            ?disabled=${isLoading || !canSend}
            @click=${() => this.handleSend()}
            title="Send message"
          >
            <sp-icon-send slot="icon"></sp-icon-send>
          </sp-action-button>
        </div>
      </div>
    `;
  }
};
customElements.define("ee-agent-panel", makeLitObserver(EEAgentPanel));

// src/stores/agent-store.js
var summarizeAttributes = (attributes) => {
  if (!attributes || typeof attributes !== "object") return {};
  const summary = {};
  for (const [name, config] of Object.entries(attributes)) {
    if (!config) continue;
    const entry = {};
    if ("type" in config) entry.type = config.type;
    if (Array.isArray(config.options)) entry.options = config.options;
    if ("default" in config) entry.default = config.default;
    if (config.label) entry.label = config.label;
    if (config.description) entry.description = config.description;
    if ("required" in config) entry.required = config.required;
    if ("placeholder" in config) entry.placeholder = config.placeholder;
    summary[name] = entry;
  }
  return summary;
};
var summarizeSlotConfig = (config) => {
  if (!config) return null;
  const entry = {};
  if (config.label) entry.label = config.label;
  if (config.description) entry.description = config.description;
  if (config.allowedTags) {
    entry.allowedTags = Array.isArray(config.allowedTags) ? config.allowedTags : [config.allowedTags];
  }
  if ("maxLength" in config) entry.maxLength = config.maxLength;
  if ("minLength" in config) entry.minLength = config.minLength;
  if ("inlineEditable" in config) entry.inlineEditable = !!config.inlineEditable;
  if (Array.isArray(config.allowedFormats)) entry.allowedFormats = config.allowedFormats;
  if (Array.isArray(config.allowedStyles)) entry.allowedStyles = config.allowedStyles;
  if ("allowLinks" in config) entry.allowLinks = !!config.allowLinks;
  if ("allowPaste" in config) entry.allowPaste = !!config.allowPaste;
  if (config.tag) entry.tag = config.tag;
  if (config.placeholder) entry.placeholder = config.placeholder;
  if ("plain" in config) entry.plain = !!config.plain;
  if ("multiline" in config) entry.multiline = !!config.multiline;
  return entry;
};
var summarizeSlots = (slots) => {
  if (!slots) {
    return { order: [], configs: {} };
  }
  const order = Array.isArray(slots.order) ? slots.order : [];
  const configs = slots.configs || {};
  const entries = {};
  const names = order.length ? order : Object.keys(configs);
  for (const name of names) {
    const summary = summarizeSlotConfig(configs[name]);
    if (summary) {
      entries[name] = summary;
    }
  }
  return { order, configs: entries };
};
var buildSchemaSummary = (schema2, tagName) => {
  if (!schema2) return null;
  return {
    tagName: tagName || null,
    label: schema2.element?.label || "",
    description: schema2.element?.description || "",
    category: schema2.element?.category || "",
    attributes: summarizeAttributes(schema2.attributes),
    slots: summarizeSlots(schema2.slots)
  };
};
var buildSlotSchemaSummary = (schema2, slotName) => {
  if (!schema2 || !slotName) return null;
  const config = schema2.slots?.configs?.[slotName] || null;
  if (!config) return null;
  return {
    name: slotName,
    ...summarizeSlotConfig(config)
  };
};
var generateUUID = () => globalThis.crypto?.randomUUID?.() || `agent-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
var awsConfigCache = null;
var awsConfigRequest = null;
async function getAgentEndpoint() {
  if (awsConfigCache?.endpoints?.agent) {
    return `${awsConfigCache.endpoints.agent}/api/agent/chat`;
  }
  if (!awsConfigRequest) {
    awsConfigRequest = fetch("./aws.json").then((r25) => r25.ok ? r25.json() : null).catch(() => null);
  }
  const config = await awsConfigRequest;
  if (config) {
    awsConfigCache = config;
    return `${config.endpoints.agent}/api/agent/chat`;
  }
  return null;
}
var AgentStore = class {
  static observableActions = [
    "openPanel",
    "closePanel",
    "togglePanel",
    "setConversationId",
    "addMessage",
    "setMessages",
    "setLoading",
    "setError",
    "clearMessages",
    "sendMessage",
    "applyMarkup",
    "syncConversation"
  ];
  static computedProperties = ["canSendMessage", "currentContext", "allSchemaSummaries"];
  #editorStore = null;
  #conversationCache = /* @__PURE__ */ new Map();
  // Cache conversations by element ID
  #currentElementKey = null;
  // References to other panel stores for mutual exclusion
  commentStore = null;
  versionStore = null;
  usedInStore = null;
  panelOpen = false;
  conversationId = null;
  messages = [];
  isLoading = false;
  error = null;
  lastAppliedMarkup = null;
  debugLogs = [];
  constructor(editorStore = null) {
    this.#editorStore = editorStore;
  }
  get editorStore() {
    return this.#editorStore;
  }
  set editorStore(store) {
    this.#editorStore = store;
  }
  get canSendMessage() {
    const editorElement = this.#editorStore?.editorElement;
    return !this.isLoading && !!editorElement?.firstElementChild;
  }
  get allSchemaSummaries() {
    const summaries = {};
    libraryManager.allElements.forEach((entry) => {
      if (entry.schema) {
        summaries[entry.tag] = buildSchemaSummary(entry.schema, entry.tag);
      }
    });
    return summaries;
  }
  get currentContext() {
    const editorElement = this.#editorStore?.editorElement;
    if (!editorElement) return null;
    const topLevelElement = editorElement.firstElementChild;
    if (!topLevelElement) return null;
    const selectedElement = this.#editorStore?.editingElement;
    const slotOnlySelection = this.#editorStore?.slotOnlySelection || false;
    const rawSlotName = this.#editorStore?.currentSlot || null;
    const slotName = rawSlotName === "default" && !slotOnlySelection ? null : rawSlotName;
    const targetElement = selectedElement || topLevelElement;
    const targetTagName = targetElement.tagName?.toLowerCase() || "unknown";
    let conversationOwner = targetElement;
    let slotLabel = null;
    if (slotName) {
      const slotOwner = selectedElement;
      if (slotOwner) {
        conversationOwner = slotOwner;
      }
    }
    const elementSchemaRaw = this.#getSchemaForElement(targetElement);
    const ownerSchemaRaw = this.#getSchemaForElement(conversationOwner);
    let schema2 = slotName ? ownerSchemaRaw : elementSchemaRaw;
    if (slotName) {
      slotLabel = ownerSchemaRaw?.slots?.configs?.[slotName]?.label || ownerSchemaRaw?.slots?.configs?.[slotName]?.description || slotName;
    }
    const elementSchema2 = buildSchemaSummary(elementSchemaRaw, targetTagName);
    const slotSchema = buildSlotSchemaSummary(ownerSchemaRaw, slotName);
    const contextSchemas = {};
    const collectedTags = /* @__PURE__ */ new Set();
    const collectSchema = (tag3) => {
      if (!tag3 || !tag3.includes("-") || collectedTags.has(tag3)) return;
      collectedTags.add(tag3);
      const entry = libraryManager.getElementByTag(tag3);
      if (entry?.schema) {
        contextSchemas[tag3] = buildSchemaSummary(entry.schema, tag3);
        if (entry.schema.slots?.configs) {
          Object.values(entry.schema.slots.configs).forEach((cfg) => {
            if (Array.isArray(cfg.allowedTags)) {
              cfg.allowedTags.forEach((t34) => collectSchema(t34));
            }
          });
        }
      }
    };
    if (topLevelElement) {
      const elements = [topLevelElement, ...topLevelElement.querySelectorAll("*")];
      for (const el of elements) {
        const tag3 = el.tagName?.toLowerCase();
        collectSchema(tag3);
      }
    }
    if (schema2?.slots?.configs) {
      Object.values(schema2.slots.configs).forEach((cfg) => {
        if (Array.isArray(cfg.allowedTags)) {
          cfg.allowedTags.forEach((t34) => collectSchema(t34));
        }
      });
    }
    return {
      // Full document context
      topLevelElement,
      topLevelHtml: topLevelElement.outerHTML,
      topLevelTagName: topLevelElement.tagName?.toLowerCase() || "unknown",
      // Selected target to modify
      element: targetElement,
      tagName: targetTagName,
      slotName,
      slotLabel,
      schema: schema2,
      elementSchema: elementSchema2,
      slotSchema,
      contextSchemas,
      html: targetElement.outerHTML,
      // Element that owns the conversation (parent for slots)
      conversationOwner
    };
  }
  getLLMLogs() {
    return this.debugLogs;
  }
  #getSchemaForElement(element) {
    if (!element) return null;
    const tag3 = element.tagName?.toLowerCase?.();
    if (!tag3 || !tag3.includes("-")) return null;
    const ctor = customElements.get(tag3);
    if (!ctor?.ee) return null;
    return getElementSchema(ctor.ee, element);
  }
  #getElementKey(element, slotName) {
    if (!element) return null;
    const attrName = slotName ? `data-ee-agent-${slotName}-id` : "data-ee-agent-id";
    return element.getAttribute(attrName) || null;
  }
  #getOrCreateConversationId(element, slotName) {
    const attrName = slotName ? `data-ee-agent-${slotName}-id` : "data-ee-agent-id";
    let id = element.getAttribute(attrName);
    if (!id) {
      id = generateUUID();
      element.setAttribute(attrName, id);
    }
    return id;
  }
  #saveCurrentConversation() {
    if (this.#currentElementKey && this.messages.length > 0) {
      this.#conversationCache.set(this.#currentElementKey, {
        conversationId: this.conversationId,
        messages: [...this.messages]
      });
    }
  }
  #loadConversation(elementKey) {
    const cached = this.#conversationCache.get(elementKey);
    if (cached) {
      this.conversationId = cached.conversationId;
      this.messages = [...cached.messages];
    } else {
      this.conversationId = null;
      this.messages = [];
    }
    this.#currentElementKey = elementKey;
    this.error = null;
  }
  #formatSchema(schema2) {
    if (!schema2) return "";
    const lines = [];
    const { element, attributes, slots } = schema2;
    if (element) {
      if (element.label) lines.push(`Element: ${element.label}`);
      if (element.description) lines.push(`Description: ${element.description}`);
    }
    if (attributes && Object.keys(attributes).length > 0) {
      lines.push("Attributes:");
      for (const [name, config] of Object.entries(attributes)) {
        let desc = `- ${name}`;
        if (config.type) desc += ` (${config.type})`;
        if (config.type === "enum" && config.options) {
          desc += `: one of [${config.options.join(", ")}]`;
        }
        if (config.default !== void 0) {
          desc += `, default: ${config.default}`;
        }
        lines.push(desc);
      }
    }
    if (slots) {
      const configs = slots.configs || {};
      const order = slots.order || Object.keys(configs);
      if (order.length > 0) {
        lines.push("Slots:");
        for (const slotName of order) {
          const config = configs[slotName];
          let desc = `- ${slotName}`;
          if (config?.label) desc += ` (${config.label})`;
          if (config?.description) desc += `: ${config.description}`;
          lines.push(desc);
        }
      }
    }
    return lines.join("\n");
  }
  syncConversation() {
    const context = this.currentContext;
    if (!context) {
      this.#saveCurrentConversation();
      this.#currentElementKey = null;
      this.messages = [];
      this.conversationId = null;
      return;
    }
    const { conversationOwner, slotName } = context;
    const elementKey = this.#getElementKey(conversationOwner, slotName);
    if (elementKey && elementKey === this.#currentElementKey) {
      return;
    }
    this.#saveCurrentConversation();
    if (elementKey) {
      this.#loadConversation(elementKey);
    } else {
      this.#currentElementKey = null;
      this.messages = [];
      this.conversationId = null;
    }
  }
  openPanel() {
    this.commentStore?.closeCommentsPanel?.();
    this.versionStore?.closeVersionsPanel?.();
    this.usedInStore?.closeUsedInPanel?.();
    this.syncConversation();
    this.panelOpen = true;
  }
  closePanel() {
    this.#saveCurrentConversation();
    this.panelOpen = false;
  }
  togglePanel() {
    this.#editorStore?.exitInlineEditing?.();
    if (this.panelOpen) {
      this.closePanel();
    } else {
      this.openPanel();
    }
  }
  setConversationId(id) {
    this.conversationId = id;
    if (id) {
      this.#currentElementKey = id;
    }
  }
  addMessage(message) {
    this.messages = [...this.messages, message];
  }
  setMessages(messages) {
    this.messages = Array.isArray(messages) ? messages : [];
  }
  setLoading(loading) {
    this.isLoading = !!loading;
  }
  setError(error) {
    this.error = error;
  }
  clearMessages() {
    if (this.#currentElementKey) {
      this.#conversationCache.delete(this.#currentElementKey);
    }
    this.messages = [];
    this.conversationId = null;
    this.error = null;
  }
  async sendMessage(text) {
    const context = this.currentContext;
    if (!context || !text?.trim()) return;
    const {
      slotName,
      schema: schema2,
      html,
      topLevelHtml,
      conversationOwner
    } = context;
    const conversationId = this.#getOrCreateConversationId(
      conversationOwner,
      slotName
    );
    this.setConversationId(conversationId);
    const userMsg = {
      role: "user",
      text: text.trim(),
      timestamp: Date.now()
    };
    this.addMessage(userMsg);
    notify(this);
    this.setLoading(true);
    this.setError(null);
    notify(this);
    const payload = {
      conversationId,
      prompt: text.trim(),
      contextHtml: topLevelHtml,
      // Full document context
      elementHtml: html,
      // Selected element to modify
      schema: schema2 || {},
      schemaSummary: elementSchema || {},
      schemaDescription: this.#formatSchema(schema2),
      contextSchemas: context.contextSchemas || {},
      slotName: slotName || void 0
    };
    const logEntry = {
      timestamp: Date.now(),
      request: payload,
      response: null,
      error: null
    };
    this.debugLogs.push(logEntry);
    if (this.debugLogs.length > 50) {
      this.debugLogs.shift();
    }
    const apiEndpoint = await getAgentEndpoint();
    if (!apiEndpoint) {
      this.setError("Agent API endpoint not configured");
      this.setLoading(false);
      return;
    }
    const response = await fetch(apiEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errText = await response.text().catch(() => "Unknown error");
      logEntry.error = `API error: ${response.status} - ${errText}`;
      this.setError(`API error: ${response.status} - ${errText}`);
      this.setLoading(false);
      return;
    }
    const data = await response.json();
    logEntry.response = data;
    if (data.markup) {
      this.applyMarkup(data.markup);
    }
    const assistantMsg = {
      role: "assistant",
      text: data.comments || "Changes applied.",
      timestamp: Date.now()
    };
    this.addMessage(assistantMsg);
    this.setLoading(false);
  }
  applyMarkup(markup) {
    const element = this.#editorStore?.editingElement;
    if (!element || !markup) return;
    const agentId = element.getAttribute("data-ee-agent-id");
    const slotAgentIds = {};
    for (const attr of element.attributes) {
      if (attr.name.startsWith("data-ee-agent-") && attr.name.endsWith("-id")) {
        slotAgentIds[attr.name] = attr.value;
      }
    }
    const template = document.createElement("template");
    template.innerHTML = markup.trim();
    const parsed = template.content.firstElementChild;
    const innerContent = parsed ? parsed.innerHTML : markup;
    const domStore = this.#editorStore?.domStore;
    if (domStore) {
      if (parsed) {
        const attrs = {};
        for (const attr of parsed.attributes) {
          attrs[attr.name] = attr.value;
        }
        domStore.updateElementAttributes(element, attrs);
      }
      domStore.updateElementContent(element, innerContent);
      this.lastAppliedMarkup = markup;
    } else {
      element.innerHTML = innerContent;
      this.lastAppliedMarkup = markup;
    }
    if (agentId) {
      element.setAttribute("data-ee-agent-id", agentId);
    }
    for (const [name, value] of Object.entries(slotAgentIds)) {
      element.setAttribute(name, value);
    }
    this.#editorStore?.scheduleAutoSave?.();
  }
};
makeObservable(AgentStore);

// src/features/editor/dialogs.js
init_lit();
var renderDeleteDialog = (editor) => {
  if (!editor.confirmDeleteOpen) return E;
  const name = editor.store?.currentElement?.name || "this fragment";
  return x`
    <sp-dialog-wrapper
      open
      underlay
      dismissable
      headline="Delete fragment?"
      mode="modal"
      confirm-label="Delete"
      cancel-label="Cancel"
      @close=${() => editor.confirmDeleteOpen = false}
      @cancel=${(e36) => handleDialogCancel(editor, e36)}
      @confirm=${(e36) => handleDialogConfirm(editor, e36)}
    >
      This action will permanently delete ${name}.
    </sp-dialog-wrapper>
  `;
};
var confirmDelete = async (editor) => {
  const id = editor.store?.editorStore?.currentElementId;
  if (!id) {
    editor.confirmDeleteOpen = false;
    return;
  }
  await editor.store.deleteElement(id);
  editor.confirmDeleteOpen = false;
};
var handleBackToGalleryClick = (editor) => {
  const dirty = editor.editorStore?.hasUnsavedChanges?.();
  if (dirty) {
    editor.confirmLeaveOpen = true;
    return;
  }
  closeElement(editor);
};
var renderLeaveDialog = (editor) => {
  if (!editor.confirmLeaveOpen) return E;
  return x`
    <sp-dialog-wrapper
      open
      underlay
      dismissable
      headline="Unsaved changes"
      mode="modal"
      secondary-label="Discard"
      confirm-label="Save and Leave"
      cancel-label="Cancel"
      @close=${() => editor.confirmLeaveOpen = false}
      @secondary=${() => {
    editor.confirmLeaveOpen = false;
    closeElement(editor);
  }}
      @cancel=${() => editor.confirmLeaveOpen = false}
      @confirm=${() => saveAndLeave(editor)}
    >
      You have unsaved changes. What would you like to do?
    </sp-dialog-wrapper>
  `;
};
var saveAndLeave = async (editor) => {
  await editor.editorStore?.saveCurrentElement?.();
  editor.confirmLeaveOpen = false;
  closeElement(editor);
};
var handleDialogConfirm = (editor, event) => {
  confirmDelete(editor);
  editor.dispatchEvent(
    new CustomEvent("confirm", { bubbles: true, composed: true })
  );
};
var handleDialogCancel = (editor, event) => {
  editor.confirmDeleteOpen = false;
  editor.dispatchEvent(
    new CustomEvent("cancel", { bubbles: true, composed: true })
  );
};
var renderUnpublishDialog = (editor) => {
  if (!editor.confirmUnpublishOpen) return E;
  const name = editor.store?.currentElement?.name || "this fragment";
  return x`
    <sp-dialog-wrapper
      open
      underlay
      dismissable
      headline="Unpublish fragment?"
      mode="modal"
      confirm-label="Unpublish"
      cancel-label="Cancel"
      @close=${() => editor.confirmUnpublishOpen = false}
      @cancel=${() => editor.confirmUnpublishOpen = false}
      @confirm=${() => confirmUnpublish(editor)}
    >
      <div class="leave-dialog-body">
        <div class="leave-dialog-text">
          Unpublishing ${name} makes its published version unavailable. Your draft stays intact for further edits.
        </div>
        ${editor.isLoadingUnpublishRefs ? x`<div style="display:grid;place-items:center;min-height:80px;"><sp-progress-circle indeterminate size="m"></sp-progress-circle></div>` : editor.unpublishRefs?.length ? x`
                <div class="leave-dialog-text">Published references affected:</div>
                <div style="max-height:200px;overflow:auto;border:1px solid var(--spectrum-alias-border-color);border-radius:6px;padding: var(--spectrum-global-dimension-size-75);">
                  <sp-sidenav>
                    ${editor.unpublishRefs.map((r25) => x`
                      <sp-sidenav-item label=${r25.name || r25.urn} value=${r25.urn}></sp-sidenav-item>
                    `)}
                  </sp-sidenav>
                </div>
              ` : x`<div class="leave-dialog-text">No published references are currently affected.</div>`}
      </div>
    </sp-dialog-wrapper>
  `;
};
var confirmUnpublish = async (editor) => {
  editor.confirmUnpublishOpen = false;
  await editor.unpublishCurrent();
};
var openUnpublishDialog = (editor) => {
  editor.confirmUnpublishOpen = true;
  loadUnpublishRefs(editor);
};
var loadUnpublishRefs = async (editor) => {
  const urn = editor.store?.editorStore?.currentElementId;
  if (!urn || !editor.store?.documentStore?.getDocumentReferrers) {
    editor.unpublishRefs = [];
    return;
  }
  editor.isLoadingUnpublishRefs = true;
  const list = await editor.store.documentStore.getDocumentReferrers(urn, true, null);
  const items = Array.isArray(list) ? list : [];
  const seen = /* @__PURE__ */ new Map();
  for (const d22 of items) {
    const targetUrn = d22?.urn || d22?.targetUrn || d22?.target_urn;
    if (!targetUrn) continue;
    const isPublished = !!(d22.published || d22.published_at || d22.publishedAt);
    if (!isPublished) continue;
    const name = d22.name != null ? String(d22.name) : "Untitled";
    if (!seen.has(targetUrn)) seen.set(targetUrn, { urn: targetUrn, name });
  }
  editor.unpublishRefs = Array.from(seen.values());
  editor.isLoadingUnpublishRefs = false;
};
var handleFragmentNameChange = (editor, event) => {
  const newName = event.target.value.trim();
  if (newName && editor.store.currentElement) {
    editor.store.updateElementName(newName);
  }
};
var handleFragmentNameKeypress = (editor, event) => {
  if (event.key === "Enter") {
    event.target.blur();
    handleFragmentNameChange(editor, event);
  }
};
var openRenameDialog = (editor) => {
  const current = editor.store?.currentElement?.name || "Untitled Fragment";
  editor.renameValue = current;
  editor.renameDialogOpen = true;
};
var handleRenameInput = (editor, event) => {
  editor.renameValue = event?.target?.value ?? editor.renameValue;
};
var confirmRename = (editor) => {
  const name = (editor.renameValue || "").trim();
  if (name) editor.store.updateElementName(name);
  editor.renameDialogOpen = false;
};
var renderRenameDialog = (editor) => {
  if (!editor.renameDialogOpen) return E;
  return x`
    <sp-dialog-wrapper
      open
      underlay
      dismissable
      mode="modal"
      headline="Rename fragment"
      confirm-label="Rename"
      cancel-label="Cancel"
      @close=${() => editor.renameDialogOpen = false}
      @cancel=${() => editor.renameDialogOpen = false}
      @confirm=${() => confirmRename(editor)}
    >
      <sp-field-group>
        <sp-field-label for="rename-fragment-input">Name</sp-field-label>
        <sp-textfield
          id="rename-fragment-input"
          autofocus
          .value=${editor.renameValue}
          @input=${(e36) => handleRenameInput(editor, e36)}
          @keydown=${(e36) => {
    if (e36.key === "Enter") confirmRename(editor);
  }}
        ></sp-textfield>
      </sp-field-group>
    </sp-dialog-wrapper>
  `;
};
var closeElement = (editor) => {
  editor.closeElement();
};

// src/features/editor/comments-overlay.js
var setupCommentsOverlay = (editor) => {
  if (!editor.editorStore || editor.cleanupCommentsReaction2) return;
  if (editor.cleanupCommentsReaction) editor.cleanupCommentsReaction();
  editor.cleanupCommentsReaction2 = reaction(
    editor.commentStore,
    (cs2) => [cs2.hoveredCommentId, cs2.commentsPanelOpen],
    () => {
      syncCommentsPanelView(editor);
      editor.updateCommentsOverlay();
    }
  );
  window.addEventListener("resize", editor.updateCommentsOverlay);
  editor.cleanupCommentsReaction = () => {
    window.removeEventListener("resize", editor.updateCommentsOverlay);
  };
  syncCommentsPanelView(editor);
};
var syncCommentsPanelView = () => {
};
var updateCommentsOverlay = (editor) => {
  const canvas = editor.shadowRoot?.getElementById("comments-overlay");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  if (canvas.width !== vw * dpr || canvas.height !== vh * dpr) {
    canvas.width = vw * dpr;
    canvas.height = vh * dpr;
    canvas.style.width = `${vw}px`;
    canvas.style.height = `${vh}px`;
  }
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, vw, vh);
  const open = !!editor.commentStore?.commentsPanelOpen;
  const commentId = editor.commentStore?.hoveredCommentId || null;
  if (!open || !commentId) return;
  const panel = editor.shadowRoot?.getElementById("ee-comments-panel");
  const el = getElementForComment(editor, commentId);
  if (!panel || !el) return;
  const card = panel.getCommentItemRect?.(commentId);
  const rect = el.getBoundingClientRect();
  if (!card || !rect || rect.width === 0 || rect.height === 0) return;
  const rightSidebar = editor.shadowRoot?.getElementById("right-sidebar");
  const panelRect = rightSidebar?.getBoundingClientRect?.() || card;
  const startX = Math.min(window.innerWidth - 12, Math.max(12, card.left));
  const startY = Math.min(
    window.innerHeight - 12,
    Math.max(12, card.top + card.height * 0.5)
  );
  const arrowLen = 10;
  const arrowHalf = 5;
  const elCenterY = rect.top + rect.height / 2;
  const yAnchor = Math.min(
    rect.bottom - 4,
    Math.max(rect.top + 4, elCenterY)
  );
  const lineEndX = Math.max(12, rect.right + arrowLen);
  const tipX = rect.right;
  const tipY = yAnchor;
  const hubX = Math.max(12, (panelRect.left || startX) - 24);
  ctx.save();
  let color = getComputedStyle(editor).getPropertyValue("--spectrum-alias-focus-color").trim();
  if (!color)
    color = getComputedStyle(editor).getPropertyValue("--spectrum-global-color-blue-500").trim();
  ctx.strokeStyle = color || "currentColor";
  ctx.globalAlpha = 0.95;
  ctx.lineWidth = 2.5;
  ctx.setLineDash([6, 6]);
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(hubX, startY);
  ctx.lineTo(hubX, yAnchor);
  ctx.lineTo(lineEndX, yAnchor);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = ctx.strokeStyle;
  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(tipX + arrowLen, tipY - arrowHalf);
  ctx.lineTo(tipX + arrowLen, tipY + arrowHalf);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
  requestAnimationFrame(() => updateCommentsOverlay(editor));
};
var getElementForComment = (editor, commentId) => {
  if (!commentId) return null;
  const comment = (editor.commentStore?.comments || []).find(
    (x5) => x5.id === commentId
  );
  if (!comment || !comment.targetId) return null;
  const candidates = Array.from(
    editor.querySelectorAll("*[data-ee-comment-id]")
  );
  return candidates.find(
    (n25) => n25.getAttribute("data-ee-comment-id") === comment.targetId
  ) || null;
};

// src/features/editor/actions.js
var ensureClipboardText = async (text) => {
  if (navigator.clipboard?.writeText) {
    await navigator.clipboard.writeText(text);
    return true;
  }
  const ta = document.createElement("textarea");
  ta.value = text;
  ta.style.position = "fixed";
  ta.style.opacity = "0";
  document.body.appendChild(ta);
  ta.select();
  document.execCommand("copy");
  ta.remove();
  return true;
};
var showToast = (editor, message) => {
  const toast = document.createElement("sp-toast");
  toast.timeout = 3e3;
  toast.variant = "info";
  toast.open = true;
  toast.textContent = message;
  toast.style.position = "fixed";
  toast.style.bottom = "16px";
  toast.style.right = "16px";
  toast.style.zIndex = "3000";
  editor.shadowRoot.appendChild(toast);
};
var publishCurrent = async (editor) => {
  const urn = editor.store?.editorStore?.currentElementId;
  if (!urn) return;
  showToast(editor, "Publishing started\u2026");
  await editor.store?.documentStore?.publishDocument?.(urn);
};
var unpublishCurrent = async (editor) => {
  const urn = editor.store?.editorStore?.currentElementId;
  if (!urn) return;
  showToast(editor, "Unpublishing started\u2026");
  await editor.store?.documentStore?.unpublishDocument?.(urn);
};
var formatHTMLTree = (node, indent = "  ", level = 0) => {
  const voidTags = /* @__PURE__ */ new Set([
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  const repeat = (s19, n25) => Array(n25 + 1).join(s19);
  const formatNode = (n25, depth) => {
    if (n25.nodeType === Node.TEXT_NODE) {
      const t34 = (n25.textContent || "").trim();
      return t34 ? `${repeat(indent, depth)}${t34}
` : "";
    }
    if (n25.nodeType !== Node.ELEMENT_NODE) return "";
    const tag3 = n25.tagName.toLowerCase();
    const openEl = n25.cloneNode(false);
    const cls = openEl.getAttribute && openEl.getAttribute("class");
    if (cls != null && cls.trim() === "") openEl.removeAttribute("class");
    const sty = openEl.getAttribute && openEl.getAttribute("style");
    if (sty != null && sty.trim() === "") openEl.removeAttribute("style");
    const openOuter = openEl.outerHTML;
    const endOfOpen = openOuter.indexOf(">");
    const openTag = endOfOpen >= 0 ? openOuter.slice(0, endOfOpen + 1) : openOuter;
    if (voidTags.has(tag3)) {
      return `${repeat(indent, depth)}${openTag}
`;
    }
    let out = `${repeat(indent, depth)}${openTag}
`;
    const kids = Array.from(n25.childNodes);
    for (const c33 of kids) out += formatNode(c33, depth + 1);
    out += `${repeat(indent, depth)}</${tag3}>
`;
    return out;
  };
  return formatNode(node, level).replace(/\n+$/, "");
};
var copySanitizedHTML = async (editor) => {
  const root = editor.firstElementChild;
  if (!root) return;
  const clone = root.cloneNode(true);
  sanitizeTree(clone, {
    currentDocumentId: editor.store?.editorStore?.currentElementId || null,
    showToast: (msg) => showToast(editor, msg)
  });
  const html = formatHTMLTree(clone);
  const success = await ensureClipboardText(html);
  if (success) showToast(editor, "HTML copied to clipboard");
};
var copyDataModel = async (editor) => {
  const snapshot = editor.editorStore?.getJsonSnapshot?.();
  const text = JSON.stringify(snapshot, null, 2);
  const success = await ensureClipboardText(text);
  if (success) showToast(editor, "JSON copied to clipboard");
};

// src/features/editor/use.js
var ensureClipboardContent = async (text, html) => {
  const attempt = (promise) => promise.then(
    () => true,
    () => false
  );
  if (navigator.clipboard?.write) {
    const clipboardItem = new ClipboardItem({
      "text/plain": new Blob([text], { type: "text/plain" }),
      "text/html": new Blob([html || text], { type: "text/html" })
    });
    const wroteRichClipboard = await attempt(navigator.clipboard.write([clipboardItem]));
    if (wroteRichClipboard) return true;
  }
  if (navigator.clipboard?.writeText) {
    const wroteTextClipboard = await attempt(navigator.clipboard.writeText(text));
    if (wroteTextClipboard) return true;
  }
  const ta = document.createElement("textarea");
  ta.value = text;
  ta.style.position = "fixed";
  ta.style.opacity = "0";
  document.body.appendChild(ta);
  ta.select();
  document.execCommand("copy");
  ta.remove();
  return true;
};
var copyReferenceSnippet = (editor) => copyReferenceSnippetAs(editor, "button");
var copyReferenceSnippetAs = async (editor, type) => {
  const id = editor.store?.editorStore?.currentElementId;
  const name = editor.store?.currentElement?.name || "Untitled Fragment";
  if (!id) return;
  const escape = (s19) => String(s19).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  let snippet = "";
  if (type === "inline") {
    snippet = `<ee-reference urn="${id}" inline></ee-reference>`;
  } else if (type === "spectrum-link") {
    snippet = `<ee-reference urn="${id}"><sp-link slot="trigger">${escape(
      name
    )}</sp-link></ee-reference>`;
  } else if (type === "a") {
    snippet = `<ee-reference urn="${id}"><a slot="trigger" href="#">${escape(
      name
    )}</a></ee-reference>`;
  } else {
    snippet = `<ee-reference urn="${id}"><sp-button slot="trigger">${escape(
      name
    )}</sp-button></ee-reference>`;
  }
  const success = await ensureClipboardContent(snippet, snippet);
  if (success) showToast(editor, "Copied to clipboard");
};
var onCopyReferenceMenu = (editor, e36) => {
  let value = e36?.target?.value;
  if (!value) {
    const item = (e36.composedPath && e36.composedPath()).find(
      (n25) => n25 && n25.tagName === "SP-MENU-ITEM"
    );
    if (item && item.value) value = item.value;
  }
  value = value || "inline";
  copyReferenceSnippetAs(editor, value);
  const menu = e36?.target;
  if (menu && "value" in menu) {
    menu.value = void 0;
  }
  if (menu && "open" in menu) {
    menu.open = false;
  }
};

// src/features/editor/canvas-interactions.js
var CanvasInteractions = class {
  #editor;
  constructor(editor) {
    this.#editor = editor;
  }
  #getEventInputType(event) {
    if (!event) return null;
    const type = event.type ? String(event.type).toLowerCase() : "";
    if (type.startsWith("key")) return "keyboard";
    if (typeof event.pointerType === "string" && event.pointerType) {
      return event.pointerType;
    }
    if (type.startsWith("pointer")) {
      return event.pointerType || "pointer";
    }
    if (type.startsWith("mouse") || type === "click" || type === "dblclick") {
      return "mouse";
    }
    if (type.startsWith("touch")) return "touch";
    return null;
  }
  #findEeReferenceParent(path, clickedTarget) {
    let eeRef = clickedTarget?.closest?.("ee-reference");
    if (!eeRef) {
      const elements = Array.isArray(path) ? path : [];
      for (const el of elements) {
        if (!el || !el.tagName) continue;
        if (el.tagName?.toLowerCase() === "ee-reference") {
          eeRef = el;
          break;
        }
      }
    }
    if (!eeRef) {
      return null;
    }
    let topLevelEeRef = eeRef;
    while (topLevelEeRef) {
      const parentEeRef = topLevelEeRef.parentElement?.closest?.("ee-reference");
      if (parentEeRef) {
        topLevelEeRef = parentEeRef;
      } else {
        break;
      }
    }
    return topLevelEeRef;
  }
  #shouldIgnoreClick(path, clickedTarget, event, editor) {
    const activeRte = editor.editorStore?.richText?.activeRte;
    const isFromRte = path.some((el) => {
      if (!el || !el.tagName) return false;
      const tag3 = el.tagName.toUpperCase();
      return tag3 === "EE-RTE" || el === activeRte;
    });
    if (isFromRte) return true;
    const isModifierClick = event.metaKey || event.ctrlKey;
    if (isModifierClick && this.#isInteractiveContentClick(path)) {
      return true;
    }
    return false;
  }
  #isEditorDescendant(element) {
    const editor = this.#editor;
    if (!element || element === editor) return false;
    return editor.contains(element) && !element.contains(editor);
  }
  #analyzeClickTarget(clickedTarget, path, selectedElement) {
    const editor = this.#editor;
    const editorStore = editor?.editorStore;
    const clickedTargetHasSchema = editorStore?.hasAuthoringSchema?.(clickedTarget);
    const clickedTargetIsAuthorable = clickedTargetHasSchema && this.#editor.isAuthorableElement(clickedTarget) && this.#isEditorDescendant(clickedTarget);
    let authorableParent = null;
    if (!clickedTargetIsAuthorable && Array.isArray(path)) {
      for (const el of path) {
        const hasSchema = editorStore?.hasAuthoringSchema?.(el);
        if (el && hasSchema && this.#editor.isAuthorableElement(el) && this.#isEditorDescendant(el)) {
          authorableParent = el;
          break;
        }
      }
    }
    return {
      clickedTargetIsAuthorable,
      authorableParent
    };
  }
  #determineSelection(clickedTarget, clickedTargetIsAuthorable, authorableParent, slotSelection, selectedElement) {
    const editor = this.#editor;
    const editorStore = editor?.editorStore;
    const clickedTargetHasSchema = editorStore?.hasAuthoringSchema?.(clickedTarget);
    const authorableParentHasSchema = authorableParent && editorStore?.hasAuthoringSchema?.(authorableParent);
    const slotParentIsClickedTarget = slotSelection && slotSelection.parent === clickedTarget;
    let finalSelectedElement;
    if (clickedTargetHasSchema && clickedTargetIsAuthorable && !slotParentIsClickedTarget) {
      finalSelectedElement = clickedTarget;
    } else if (authorableParentHasSchema && !slotParentIsClickedTarget) {
      finalSelectedElement = authorableParent;
    } else if (slotSelection) {
      finalSelectedElement = slotSelection.parent;
    } else {
      finalSelectedElement = selectedElement;
    }
    if (finalSelectedElement && !this.#isEditorDescendant(finalSelectedElement)) {
      finalSelectedElement = null;
    }
    const finalSelectedHasSchema = finalSelectedElement && editorStore?.hasAuthoringSchema?.(finalSelectedElement);
    const isSelectingAuthorableElement = finalSelectedElement && finalSelectedHasSchema && (finalSelectedElement === clickedTarget || finalSelectedElement === authorableParent) && this.#editor.isAuthorableElement(finalSelectedElement) && !(slotSelection && slotSelection.parent === finalSelectedElement);
    return {
      finalSelectedElement,
      isSelectingAuthorableElement
    };
  }
  #executeSelection(editor, finalSelectedElement, slotSelection, isSelectingAuthorableElement, input) {
    if (slotSelection && !isSelectingAuthorableElement) {
      if (slotSelection.slotName === "default") {
        editor.editorStore?.selection?.selectElement(slotSelection.parent, "default", {
          inputType: input
        });
      } else {
        editor.editorStore?.selection?.selectSlot(slotSelection.parent, slotSelection.slotName, {
          inputType: input
        });
      }
    } else {
      editor.editorStore?.selection?.selectElement(finalSelectedElement, null, { inputType: input });
    }
  }
  handleClick(event) {
    const editor = this.#editor;
    const clickedTarget = event.target;
    const path = event.composedPath();
    const describeEl = (el) => {
      if (!el || !el.tagName) return null;
      const tag3 = el.tagName.toLowerCase();
      return {
        tag: tag3,
        id: el.id || null,
        slot: el.getAttribute ? el.getAttribute("slot") : null
      };
    };
    const tagName = clickedTarget?.tagName?.toLowerCase?.() || null;
    const input = this.#getEventInputType(event);
    editor.editorStore?.setUserAction?.("editor:click:capture", {
      tag: tagName,
      x: event.clientX,
      y: event.clientY,
      ...input ? { input } : {}
    });
    if (this.#shouldIgnoreClick(path, clickedTarget, event, editor)) {
      return;
    }
    const richText = editor.editorStore?.richText;
    const activeRte = richText?.activeRte;
    const activeTarget = richText?.activeTarget;
    if (activeRte && activeTarget) {
      const isWithinActiveTarget = path.includes(activeTarget);
      if (isWithinActiveTarget) {
        const isWithinRte = path.includes(activeRte);
        if (!isWithinRte) {
          const isModifierClick = event.metaKey || event.ctrlKey;
          if (!isModifierClick) {
            event.stopPropagation();
            event.preventDefault();
            return;
          }
        }
      }
    }
    const eeReference = this.#findEeReferenceParent(path, clickedTarget);
    if (eeReference) {
      const isTrigger = path.some((el) => {
        return el.parentElement === eeReference && el.getAttribute?.("slot") === "trigger";
      });
      if (!isTrigger) {
        editor.editorStore?.selection?.selectElement(eeReference, null, { inputType: input });
        editor.editorStore?.setUserAction?.("editor:click", {
          x: event.clientX,
          y: event.clientY,
          target: describeEl(clickedTarget),
          selected: describeEl(eeReference),
          fromToolbar: false,
          inShadowUI: false
        });
        return false;
      }
    }
    if (this.#isInteractiveContentClick(path)) {
      event.stopPropagation();
      event.preventDefault();
    }
    event.stopPropagation();
    event.preventDefault();
    const selectedElement = this.#findSelectableElement(
      clickedTarget,
      path,
      event.clientX,
      event.clientY
    );
    const { clickedTargetIsAuthorable, authorableParent } = this.#analyzeClickTarget(clickedTarget, path, selectedElement);
    const slotSelection = this.#resolveSlotSelection(path, event.clientX, event.clientY, clickedTarget);
    const { finalSelectedElement, isSelectingAuthorableElement } = this.#determineSelection(clickedTarget, clickedTargetIsAuthorable, authorableParent, slotSelection, selectedElement);
    if (finalSelectedElement) {
      editor.editorStore?.setUserAction?.("editor:click", {
        x: event.clientX,
        y: event.clientY,
        target: describeEl(clickedTarget),
        selected: slotSelection ? {
          tag: slotSelection.parent?.tagName?.toLowerCase?.() || null,
          id: slotSelection.parent?.id || null,
          slot: slotSelection.slotName
        } : describeEl(finalSelectedElement),
        ...input ? { input } : {}
      });
      this.#executeSelection(editor, finalSelectedElement, slotSelection, isSelectingAuthorableElement, input);
      const clickFromEEToolbar = path.some((el) => {
        return el?.tagName === "EE-TOOLBAR" || el?.host && el.host.tagName === "EE-TOOLBAR";
      });
      const isInShadowUI = path.some((el) => {
        const toolbarEl = editor.shadowRoot?.querySelector("#editor-toolbar");
        const eeToolbarEl = editor.shadowRoot?.querySelector("ee-toolbar");
        const leftSidebar = editor.shadowRoot?.querySelector("content-tree-nav");
        const rightSidebar = editor.shadowRoot?.querySelector("#right-sidebar");
        return el === toolbarEl || el === eeToolbarEl || el === leftSidebar || el === rightSidebar;
      });
      editor.editorStore?.setUserAction?.("editor:click", {
        x: event.clientX,
        y: event.clientY,
        target: describeEl(clickedTarget),
        selected: slotSelection ? {
          tag: slotSelection.parent?.tagName?.toLowerCase?.() || null,
          id: slotSelection.parent?.id || null,
          slot: slotSelection.slotName
        } : describeEl(finalSelectedElement),
        fromToolbar: !!clickFromEEToolbar,
        inShadowUI: !!isInShadowUI
      });
      const lastAction = editor.editorStore?.lastAction;
      editor.editorStore?.richText?.tryActivateInlineEdit(finalSelectedElement, lastAction);
      return false;
    }
    editor.editorStore?.selection?.selectElement(null, null, { inputType: input });
    editor.editorStore?.setUserAction?.("editor:click:empty", {
      x: event.clientX,
      y: event.clientY,
      target: describeEl(clickedTarget),
      selected: null,
      fromToolbar: false,
      inShadowUI: false,
      ...input ? { input } : {}
    });
    return false;
  }
  #isSlotInSchema(parentElement, slotName) {
    if (!parentElement || !slotName) return false;
    const editor = this.#editor;
    const store = editor?.editorStore;
    if (!store?.selection) return false;
    const slotConfig = store.selection.getNormalizedSlotConfig(parentElement, slotName);
    return slotConfig !== null;
  }
  #resolveSlotSelection(path, clientX, clientY, clickedTarget = null) {
    const editor = this.#editor;
    const store = editor?.editorStore;
    if (!store) return null;
    const nodes2 = Array.isArray(path) ? path : [];
    const elements = [];
    for (const node of nodes2) {
      if (!node || node === editor) break;
      if (node.nodeType === Node.ELEMENT_NODE) {
        elements.push(node);
      }
    }
    for (const node of elements) {
      if (node.tagName?.toUpperCase() === "SLOT") {
        const slotName = node.getAttribute?.("name")?.trim() || "default";
        let parent = node.getRootNode?.();
        if (parent instanceof ShadowRoot) {
          parent = parent.host;
        }
        if (parent && parent.tagName?.includes?.("-")) {
          if (this.#isSlotInSchema(parent, slotName)) {
            return {
              parent,
              slotName
            };
          }
        }
      }
    }
    if (clientX !== void 0 && clientY !== void 0 && Number.isFinite(clientX) && Number.isFinite(clientY)) {
      for (const node of elements) {
        if (!node.tagName?.includes?.("-")) continue;
        const shadowRoot = node.shadowRoot;
        if (!shadowRoot) continue;
        const slots = shadowRoot.querySelectorAll("slot");
        for (const slot of slots) {
          const rect = slot.getBoundingClientRect();
          if (rect && clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
            const slotName = slot.getAttribute?.("name")?.trim() || "default";
            const assignedElements = slot.assignedElements({ flatten: true });
            if (clickedTarget) {
              if (clickedTarget.assignedSlot === slot) {
                return null;
              }
              let current = clickedTarget;
              while (current && current !== node) {
                if (current.assignedSlot === slot) {
                  return null;
                }
                current = current.parentElement;
              }
            }
            if (assignedElements.length > 0) {
              for (const assignedEl of assignedElements) {
                if (!assignedEl.isConnected) continue;
                const elRect = assignedEl.getBoundingClientRect();
                if (elRect && clientX >= elRect.left && clientX <= elRect.right && clientY >= elRect.top && clientY <= elRect.bottom) {
                  return null;
                }
              }
            }
            if (this.#isSlotInSchema(node, slotName)) {
              return {
                parent: node,
                slotName
              };
            }
          }
        }
      }
    }
    const containsReference = elements.some(
      (node) => node.tagName?.toLowerCase?.() === "ee-reference"
    );
    for (const node of elements) {
      const tagUpper = node.tagName?.toUpperCase?.() || "";
      if (tagUpper === "EE-RTE") continue;
      const context = store.resolveInlineEditableSlotContext(node);
      if (context) {
        if (containsReference) {
          continue;
        }
        let ancestor = node;
        let intersectsReference = false;
        while (ancestor && ancestor !== context.element && ancestor !== editor) {
          const tagLower = ancestor.tagName?.toLowerCase?.() || "";
          if (tagLower === "ee-reference") {
            intersectsReference = true;
            break;
          }
          ancestor = ancestor.parentElement;
        }
        if (intersectsReference) continue;
        return {
          parent: context.element,
          slotName: context.slotName
        };
      }
    }
    return null;
  }
  #isInteractiveContentClick(path) {
    const interactiveTags = /* @__PURE__ */ new Set([
      "A",
      "BUTTON",
      "INPUT",
      "SELECT",
      "TEXTAREA",
      "SP-BUTTON",
      "SP-ACTION-BUTTON",
      "SP-LINK",
      "CHECKOUT-BUTTON",
      "CHECKOUT-LINK"
    ]);
    const elements = Array.isArray(path) ? path : [];
    for (const el of elements) {
      if (!el || !el.tagName) continue;
      const tn2 = el.tagName.toUpperCase();
      if (interactiveTags.has(tn2)) {
        if (tn2 === "A" && !el.getAttribute?.("href")) continue;
        return true;
      }
    }
    for (let i21 = 0; i21 < elements.length; i21++) {
      const el = elements[i21];
      if (!el || !el.tagName) continue;
      const slotName = el.getAttribute && el.getAttribute("slot");
      if (slotName === "trigger") {
        const hasEeRefAncestor = elements.slice(i21 + 1).some((ancestor) => ancestor?.tagName === "EE-REFERENCE");
        if (hasEeRefAncestor) return true;
      }
    }
    return false;
  }
  #findSelectableElement(clickedTarget, composedPath, clientX, clientY) {
    const editor = this.#editor;
    const path = Array.isArray(composedPath) ? composedPath : clickedTarget?.composedPath?.() ?? [];
    const sr2 = editor.shadowRoot;
    const surfaceWrapper = sr2?.querySelector("#surface-wrapper");
    const surfaceContent = sr2?.querySelector("#surface-content");
    const surfaceSlot = surfaceContent ? surfaceContent.querySelector("slot") : null;
    const isInSurface = (node) => {
      if (!node || !node.tagName) return false;
      if (!editor.contains(node)) return false;
      let cur = node;
      while (cur && cur.parentElement && cur.parentElement !== editor)
        cur = cur.parentElement;
      if (!(cur && cur.parentElement === editor)) return false;
      return !!(surfaceSlot && cur.assignedSlot === surfaceSlot);
    };
    for (const node of path) {
      if (!node || !node.tagName) continue;
      if (node === surfaceWrapper || node === surfaceContent) continue;
      const rootNode = node.getRootNode?.();
      if (rootNode instanceof ShadowRoot && node.tagName?.toUpperCase() !== "SLOT") {
        const nodeIndex = path.indexOf(node);
        if (nodeIndex >= 0) {
          for (let i21 = nodeIndex + 1; i21 < path.length; i21++) {
            const pathNode = path[i21];
            if (!pathNode || !pathNode.tagName) continue;
            if (pathNode === surfaceWrapper || pathNode === surfaceContent) continue;
            if (!isInSurface(pathNode)) continue;
            const editorStore2 = editor?.editorStore;
            const hasSchema2 = editorStore2?.hasAuthoringSchema?.(pathNode);
            const isAuthorable = this.#editor.isAuthorableElement(pathNode);
            if (hasSchema2) {
              if (isAuthorable) {
                return pathNode;
              }
            }
          }
        }
      }
      if (!isInSurface(node)) continue;
      const editorStore = editor?.editorStore;
      const hasSchema = editorStore?.hasAuthoringSchema?.(node);
      if (hasSchema && this.#editor.isAuthorableElement(node)) return node;
    }
    const hit = (() => {
      const x5 = Number(clientX);
      const y5 = Number(clientY);
      if (!Number.isFinite(x5) || !Number.isFinite(y5)) return null;
      const under = (document.elementsFromPoint?.(x5, y5) || []).filter(Boolean);
      if (!under.length) return null;
      for (const n25 of under) {
        if (!isInSurface(n25)) continue;
        const editorStore = editor?.editorStore;
        const hasSchema = editorStore?.hasAuthoringSchema?.(n25);
        if (hasSchema && this.#editor.isAuthorableElement(n25) && (editor.contains(n25) || !!n25.assignedSlot)) {
          return n25;
        }
      }
      return null;
    })();
    return hit;
  }
};

// src/features/editor/keyboard.js
var handleKeyDown2 = (editor, event) => {
  if (event.key === "Escape" || event.key === "Esc") {
    event.preventDefault();
    event.stopPropagation();
    editor.editorStore?.handleEscape?.();
    return;
  }
  const path = event.composedPath?.() ?? [];
  const isTyping = () => {
    if (!path || !Array.isArray(path)) {
      const target = event.target;
      return target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.getAttribute && target.getAttribute("role") === "textbox");
    }
    for (const node of path) {
      if (node && (node instanceof HTMLInputElement || node instanceof HTMLTextAreaElement)) {
        return true;
      }
      if (node && node.getAttribute && node.getAttribute("role") === "textbox") {
        return true;
      }
    }
    return false;
  };
  if (isTyping()) return;
  const lower = event.key ? event.key.toLowerCase() : "";
  const isMeta = event.metaKey || event.ctrlKey;
  if (isMeta && lower === "c") {
    const selectedElement = editor.editorStore?.editingElement;
    if (selectedElement && !isTyping()) {
      event.preventDefault();
      editor.copySelectedElement();
      return;
    }
  }
  if (isMeta && !event.shiftKey && lower === "z") {
    event.preventDefault();
    editor.performUndo();
    return;
  }
  if (isMeta && event.shiftKey && lower === "z") {
    event.preventDefault();
    editor.performRedo();
    return;
  }
};
var handleKeyUp = () => {
};

// src/features/editor/selection-outline.js
var outlinedNodes = /* @__PURE__ */ new Set();
var lastOutlinedSlotEl = null;
var clearSelectionMarker = (node) => {
  if (!node) return;
  node.removeAttribute?.("data-ee-selected");
  const style = node.style;
  if (!style) return;
  if (style.removeProperty) {
    style.removeProperty("outline");
    style.removeProperty("outline-offset");
    style.removeProperty("border-radius");
  } else {
    style.outline = "";
    style.outlineOffset = "";
    style.borderRadius = "";
  }
};
var markSelectedElement = (node) => {
  if (!node) return;
  node.setAttribute?.("data-ee-selected", "");
  outlinedNodes.add(node);
};
var markSelectedSlot = (node) => {
  if (!node) return;
  node.setAttribute?.("data-ee-selected", "");
  outlinedNodes.add(node);
};
var ensureSlotHighlightStyles = (shadowRoot) => {
  if (!shadowRoot) return;
  if (shadowRoot.querySelector("style[data-ee-slot-highlight]")) return;
  const style = document.createElement("style");
  style.setAttribute("data-ee-slot-highlight", "");
  style.textContent = `
    slot[data-ee-selected] {
      display: inline-flex;
      outline: 2px solid var(--spectrum-indigo-900);
      outline-offset: 2px;
      border-radius: var(--spectrum-global-dimension-size-50);
    }
  `;
  shadowRoot.appendChild(style);
};
var ensureGlobalSelectionStyles = (editorElement) => {
  const doc3 = editorElement?.ownerDocument || document;
  if (!doc3?.head) return;
  if (doc3.head.querySelector("style[data-ee-selection-style]")) return;
  const style = document.createElement("style");
  style.setAttribute("data-ee-selection-style", "");
  style.textContent = `
    experience-elements-editor *[data-ee-selected] {
      outline: 2px solid var(--spectrum-alias-focus-color);
      outline-offset: 2px;
    }

    div.ProseMirror-focused {
      outline: none;
    }
  `;
  doc3.head.appendChild(style);
};
var applySelectionOutline = (editor) => {
  const host = editor.editorElement || editor;
  const el = editor.editorStore?.editingElement;
  for (const n25 of outlinedNodes) clearSelectionMarker(n25);
  outlinedNodes.clear();
  if (lastOutlinedSlotEl) {
    clearSelectionMarker(lastOutlinedSlotEl);
    lastOutlinedSlotEl = null;
  }
  if (!host) return;
  const allSelected = host.querySelectorAll("[data-ee-selected]");
  for (const n25 of allSelected) {
    if (n25 !== el) {
      clearSelectionMarker(n25);
    }
  }
  if (!el) return;
  const slotName = editor.editorStore?.currentSlot || null;
  if (!slotName || slotName === "default") {
    if (el.hasAttribute("data-ee-selected")) {
      clearSelectionMarker(el);
    }
    markSelectedElement(el);
    return;
  }
  const sr2 = el.shadowRoot;
  if (sr2) {
    const selector = slotName === "default" ? "slot:not([name])" : `slot[name="${slotName}"]`;
    const slotEl = sr2.querySelector(selector);
    if (slotEl) {
      ensureSlotHighlightStyles(sr2);
      clearSelectionMarker(el);
      markSelectedSlot(slotEl);
      lastOutlinedSlotEl = slotEl;
      outlinedNodes.add(slotEl);
      return;
    }
  }
  if (el.hasAttribute("data-ee-selected")) {
    clearSelectionMarker(el);
  }
  markSelectedElement(el);
};
var setupSelectionOutline = (editor) => {
  ensureGlobalSelectionStyles(editor.editorElement || editor);
};

// src/experience-elements-editor.js
var ExperienceElementsEditor = class extends i4 {
  // Private debug click trace
  #lastClickInfo = null;
  #zoomController = null;
  #interactions = null;
  #elKeyMap;
  #elKeySeq;
  #onBeforeUnload;
  #onViewportChange;
  #cleanupToolbarReaction;
  #cleanupSelectionReaction;
  #cleanupZoomReaction;
  #onRteContextChange;
  #surfaceClickTarget = null;
  #boundHandleElementClick;
  static get styles() {
    return experienceElementsEditorStyles;
  }
  // Zoom controls
  get zoomPercentage() {
    const z3 = this.zoomStore?.z || 1;
    return Math.round(z3 * 100);
  }
  zoomInSmooth() {
    this.#applyZoom("zoomIn");
  }
  zoomOutSmooth() {
    this.#applyZoom("zoomOut");
  }
  resetZoomSmooth() {
    const store = this.zoomStore;
    if (!store) return;
    store.reset();
  }
  #applyZoom(method) {
    const store = this.zoomStore;
    const fn2 = store?.[method];
    if (typeof fn2 !== "function") return;
    fn2.call(store, void 0, this.#getCanvasCenterAnchor());
  }
  #getCanvasCenterAnchor() {
    const container = this.shadowRoot?.querySelector("#canvas-container");
    const rect = container?.getBoundingClientRect();
    if (!container || !rect) return void 0;
    return {
      x: rect.width / 2 + container.scrollLeft,
      y: rect.height / 2 + container.scrollTop
    };
  }
  static get properties() {
    return {
      store: { type: Object, throttle: 10, observe: true },
      domStore: { type: Object, throttle: 20, observe: true },
      editorStore: { type: Object, throttle: 10, observe: true },
      commentStore: { type: Object, throttle: 10, observe: true },
      versionStore: { type: Object, throttle: 10, observe: true },
      usedInStore: { type: Object, throttle: 10, observe: true },
      zoomStore: { type: Object, throttle: 10, observe: true },
      agentStore: { type: Object, throttle: 10, observe: true },
      sidebarSearchQuery: { type: String, state: true },
      confirmDeleteOpen: { type: Boolean, state: true },
      confirmUnpublishOpen: { type: Boolean, state: true },
      confirmLeaveOpen: { type: Boolean, state: true },
      renameDialogOpen: { type: Boolean, state: true },
      renameValue: { type: String, state: true },
      unpublishRefs: { type: Array, state: true },
      isLoadingUnpublishRefs: { type: Boolean, state: true },
      open: { type: Boolean, reflect: true, converter: booleanConverter }
    };
  }
  constructor() {
    super();
    this.#interactions = new CanvasInteractions(this);
    this.sidebarSearchQuery = "";
    this.#elKeyMap = /* @__PURE__ */ new WeakMap();
    this.#elKeySeq = 1;
    this.#onBeforeUnload = null;
    this.#onViewportChange = null;
    this.#cleanupToolbarReaction = null;
    this.#cleanupSelectionReaction = null;
    this.#cleanupZoomReaction = null;
    this.confirmDeleteOpen = false;
    this.confirmUnpublishOpen = false;
    this.confirmLeaveOpen = false;
    this.renameDialogOpen = false;
    this.renameValue = "";
    this.unpublishRefs = [];
    this.isLoadingUnpublishRefs = false;
    this.open = false;
    this.addEventListener(
      "fire",
      (e36) => {
        e36.stopPropagation();
        e36.preventDefault();
      },
      true
    );
    this.#onRteContextChange = (event) => this.#handleRteContextChange(event);
    this.#boundHandleElementClick = this.handleElementClick.bind(this);
  }
  recordLastClick(info) {
    this.#lastClickInfo = info;
  }
  getLastClickInfo() {
    return this.#lastClickInfo;
  }
  getZoomController() {
    return this.#zoomController;
  }
  setZoomController(controller) {
    this.#zoomController = controller;
  }
  get cleanupToolbarReaction() {
    return this.#cleanupToolbarReaction;
  }
  set cleanupToolbarReaction(fn2) {
    this.#cleanupToolbarReaction = fn2 ?? null;
  }
  get cleanupZoomReaction() {
    return this.#cleanupZoomReaction;
  }
  set cleanupZoomReaction(fn2) {
    this.#cleanupZoomReaction = fn2 ?? null;
  }
  // Friendly date formatter for status indicators
  formatFriendlyTime(dateInput) {
    return formatRelativeDate(dateInput);
  }
  setRteContext(rte, detail) {
    this.editorStore?.setRteContext(rte, detail);
  }
  clearRteContext() {
    this.editorStore?.clearRteContext?.();
  }
  getActiveRte() {
    return this.editorStore?.richText?.activeRte || null;
  }
  #handleRteContextChange(event) {
    const target = event?.target;
    if (!target || target.tagName?.toLowerCase?.() !== "ee-rte") {
      return;
    }
    this.setRteContext(target, event.detail || {});
  }
  async connectedCallback() {
    super.connectedCallback();
    this.addEventListener(
      "dblclick",
      (e36) => this.editorStore?.setUserAction?.("editor:dblclick", {
        x: e36.clientX,
        y: e36.clientY
      }),
      true
    );
    this.addEventListener("rte-contextchange", this.#onRteContextChange);
    this.#onBeforeUnload = (e36) => {
      const dirty = this.store?.editorStore?.hasUnsavedChanges?.();
      if (dirty) {
        e36.preventDefault();
        e36.returnValue = "";
      }
    };
    window.addEventListener("beforeunload", this.#onBeforeUnload);
    this.#loadCurrentStoreElement();
    if (this.editorStore?.setBaselineFromCurrent) {
      this.editorStore.setBaselineFromCurrent();
    }
    this.#setupToolbarSync();
    this.#setupSelectionOutlineSync();
    this.#setupInlineEditing();
    this.#onViewportChange = () => {
      if (this.editorStore?.isEEToolbarVisible) this.#updateToolbarPosition();
    };
    window.addEventListener("resize", this.#onViewportChange);
    window.addEventListener("orientationchange", this.#onViewportChange);
  }
  firstUpdated() {
    super.firstUpdated?.();
    const domStore = this.store?.domStore;
    if (domStore) {
      const surface = this.shadowRoot?.getElementById?.("surface-wrapper") || null;
      domStore.attach(surface, this);
      if (this.editorStore) {
        this.editorStore.attachDomStore(domStore);
      }
    }
    this.#attachSidebarWheelGuard();
    this.#attachCanvasWheelGuard();
    this.#attachClickCaptureHandler();
    this.agentStore = new AgentStore(this.editorStore);
    this.#exposeStores();
    window.getAgentLogs = () => this.agentStore?.getLLMLogs?.();
  }
  #exposeStores() {
    const stores = { ...window.eeStores };
    if (this.editorStore) stores.editorStore = this.editorStore;
    if (this.versionStore) stores.versionStore = this.versionStore;
    if (this.usedInStore) stores.usedInStore = this.usedInStore;
    if (this.commentStore) stores.commentStore = this.commentStore;
    if (this.zoomStore) stores.zoomStore = this.zoomStore;
    if (this.agentStore) stores.agentStore = this.agentStore;
    window.eeStores = stores;
  }
  #attachClickCaptureHandler() {
    const surface = this.shadowRoot?.getElementById("surface-wrapper");
    if (surface) {
      if (this.#surfaceClickTarget === surface) return;
      if (this.#surfaceClickTarget) {
        this.#surfaceClickTarget.removeEventListener("click", this.#boundHandleElementClick, true);
      }
      this.#surfaceClickTarget = surface;
      surface.addEventListener("click", this.#boundHandleElementClick, true);
      return;
    }
    if (this.#surfaceClickTarget) {
      this.#surfaceClickTarget.removeEventListener("click", this.#boundHandleElementClick, true);
      this.#surfaceClickTarget = null;
    }
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (changedProperties.has("store")) {
      const previousStore = changedProperties.get("store");
      previousStore?.documentStore?.unregisterToastTarget?.(this);
      previousStore?.editorStore?.richText?.disposeInlineEditing?.();
      this.store?.documentStore?.registerToastTarget?.(this);
    }
    if (changedProperties.has("store") && this.store) {
      this.editorStore = this.store.editorStore;
      this.editorStore.setEditorElement(this);
      this.editorStore.store = this.store;
      this.commentStore = this.store?.collaboration?.comment;
      this.versionStore = this.store?.collaboration?.version;
      this.usedInStore = this.store?.collaboration?.usedIn;
      if (this.commentStore) this.commentStore.editorStore = this.editorStore;
      if (this.versionStore) {
        this.versionStore.editorStore = this.editorStore;
        this.versionStore.documentStore = this.store?.documentStore;
        this.versionStore.commentStore = this.commentStore;
      }
      if (this.usedInStore) {
        this.usedInStore.editorStore = this.editorStore;
        this.usedInStore.documentStore = this.store?.documentStore;
        this.usedInStore.commentStore = this.commentStore;
        this.usedInStore.versionStore = this.versionStore;
      }
      if (this.agentStore) {
        this.agentStore.editorStore = this.editorStore;
        this.agentStore.commentStore = this.commentStore;
        this.agentStore.versionStore = this.versionStore;
        this.agentStore.usedInStore = this.usedInStore;
      }
      this.setupCommentsOverlay();
      this.#setupInlineEditing();
      this.#exposeStores();
    }
    if (changedProperties.has("open") && !this.open) {
      this.#destroyZoomController();
    }
    this.#initZoomPan();
    this.#attachSidebarWheelGuard();
    this.#attachCanvasWheelGuard();
    this.#attachClickCaptureHandler();
    this.#initSidebarExpansion();
    this.#setupToolbarSync();
    this.#setupSelectionOutlineSync();
    this.#setupInlineEditing();
  }
  // Generate a stable key for an element for sidebar mapping
  getElementKey(el) {
    if (!el || typeof el !== "object") return null;
    let key = this.#elKeyMap.get(el);
    if (!key) {
      key = this.#elKeySeq++;
      this.#elKeyMap.set(el, key);
    }
    return key;
  }
  // Public API for centralized reactions to mount/update content
  loadEditorContent() {
    this.#loadCurrentStoreElement();
  }
  #loadCurrentStoreElement() {
    const ce2 = this.store?.currentElement;
    if (!ce2) {
      if (this.editorStore) this.editorStore.isLoadingContent = false;
      return;
    }
    const html = ce2.html;
    if (!html) {
      if (this.editorStore) this.editorStore.isLoadingContent = false;
      return;
    }
    if (this.editorStore) this.editorStore.isLoadingContent = true;
    const domStore = this.store?.domStore;
    if (domStore) {
      const surface = this.shadowRoot?.getElementById?.("surface-wrapper") || null;
      domStore.attach(surface, this);
      if (this.editorStore) {
        this.editorStore.attachDomStore(domStore);
      }
    }
    const element = this.store.documentStore.deserializeElement(html);
    if (!element) {
      Array.from(this.children).forEach((el) => el.remove());
      if (this.editorStore) this.editorStore.isLoadingContent = false;
      return;
    }
    this.editorStore?.clearSelection?.();
    this.editorStore?.clearUndoRedo?.();
    this.commentStore?.setHoveredComment?.(null);
    this.commentStore?.setSelectedComment?.(null);
    if (this.editorStore?.setBaselineFromCurrent) {
      this.editorStore.setBaselineFromCurrent(element);
    }
    Array.from(this.children).forEach((el) => el.remove());
    this.appendChild(element);
    const id = this.store?.editorStore?.currentElementId;
    if (id) this.setAttribute("data-ee-current-id", id);
    else this.removeAttribute("data-ee-current-id");
    if (this.editorStore) {
      setTimeout(() => this.editorStore.captureSnapshot(), 100);
      const comments = this.store?.currentElement?.comments || [];
      this.commentStore?.setComments(Array.isArray(comments) ? comments : [], {
        silent: true
      });
      this.editorStore.isLoadingContent = false;
    }
  }
  // No normalization of ee-reference triggers; preserve as-authored
  hasChildElements() {
    return Array.from(this.children).some(
      (child) => child.tagName.includes("-")
    );
  }
  disconnectedCallback() {
    this.removeEventListener("rte-contextchange", this.#onRteContextChange);
    super.disconnectedCallback();
    if (this.cleanupSelectionReaction) this.cleanupSelectionReaction();
    this.cleanupSelectionReaction = null;
    if (this.cleanupCommentsReaction) this.cleanupCommentsReaction();
    this.cleanupCommentsReaction = null;
    if (this.cleanupCommentsReaction2) this.cleanupCommentsReaction2();
    this.cleanupCommentsReaction2 = null;
    window.removeEventListener("resize", this.updateCommentsOverlay);
    if (this.#onBeforeUnload) {
      window.removeEventListener("beforeunload", this.#onBeforeUnload);
    }
    this.#onBeforeUnload = null;
    this.#zoomController?.destroy?.();
    this.#zoomController = null;
    if (this.#cleanupToolbarReaction) this.#cleanupToolbarReaction();
    this.#cleanupToolbarReaction = null;
    if (this.#cleanupSelectionReaction) {
      this.#cleanupSelectionReaction();
      this.#cleanupSelectionReaction = null;
    }
    if (this.#cleanupZoomReaction) {
      this.#cleanupZoomReaction();
      this.#cleanupZoomReaction = null;
    }
    this.editorStore?.richText?.disposeInlineEditing?.();
    if (this.#onViewportChange) {
      window.removeEventListener("resize", this.#onViewportChange);
      window.removeEventListener("orientationchange", this.#onViewportChange);
      this.#onViewportChange = null;
    }
    if (this.#surfaceClickTarget) {
      this.#surfaceClickTarget.removeEventListener("click", this.#boundHandleElementClick, true);
      this.#surfaceClickTarget = null;
    }
    this.store?.documentStore?.unregisterToastTarget?.(this);
  }
  render() {
    if (!this.open) return E;
    const loadingSurface = !!this.editorStore?.isLoadingContent;
    return x`
      ${loadingSurface ? x`
            <sp-progress-circle
              class="loading-spinner"
              indeterminate
              size="l"
            ></sp-progress-circle>
          ` : E}
      <div id="editor-toolbar">
        <div id="toolbar-left">
          <sp-action-button
            id="toggle-content-tree"
            quiet
            size="m"
            toggles
            ?selected=${this.editorStore?.sidebarOpen}
            @click=${() => this.editorStore?.setSidebarOpen?.(
      !this.editorStore?.sidebarOpen
    )}
            title=${this.editorStore?.sidebarOpen ? "Hide Content Tree" : "Show Content Tree"}
          >
            <sp-icon-view-list slot="icon"></sp-icon-view-list>
            Content Tree
          </sp-action-button>
        </div>

        <div id="toolbar-center">
          <sp-action-button
            id="back-to-gallery"
            quiet
            size="m"
            title="Back to Gallery"
            @click=${() => this.onBackToGalleryClick()}
          >
            <sp-icon-home slot="icon"></sp-icon-home>
          </sp-action-button>
          <div id="name-actions">
            <sp-action-button
              id="open-preview"
              quiet
              size="m"
              title="Preview"
              ?disabled=${!this.store?.editorStore?.currentElementId}
              @click=${() => this.openPreview()}
            >
              <sp-icon-preview slot="icon"></sp-icon-preview>
            </sp-action-button>
            <span
              id="fragment-name"
              title="Click to rename"
              @click=${() => this.openRenameDialog()}
            >
              ${this.store.currentElement?.name || "Untitled Fragment"}
            </span>
          </div>

          <sp-action-button
            id="undo"
            quiet
            size="m"
            ?disabled=${!this.editorStore?.canUndo}
            @click=${() => this.performUndo()}
            title="Undo (Cmd/Ctrl + Z)"
          >
            <sp-icon-undo slot="icon"></sp-icon-undo>
          </sp-action-button>

          <sp-action-button
            id="redo"
            quiet
            size="m"
            ?disabled=${!this.editorStore?.canRedo}
            @click=${() => this.performRedo()}
            title="Redo (Cmd/Ctrl + Shift + Z)"
          >
            <sp-icon-redo slot="icon"></sp-icon-redo>
          </sp-action-button>

          <overlay-trigger placement="bottom" type="hover">
            <sp-action-button
              slot="trigger"
              id="zoom-out"
              quiet
              size="m"
              ?disabled=${!this.zoomStore?.canZoomOut}
              @click=${() => this.zoomOutSmooth()}
            >
              <sp-icon-zoom-out slot="icon"></sp-icon-zoom-out>
              Zoom out
            </sp-action-button>
            <sp-tooltip slot="tooltip">Zoom Out (Cmd/Ctrl + -)</sp-tooltip>
          </overlay-trigger>

          <overlay-trigger placement="bottom" type="hover">
            <sp-action-button
              slot="trigger"
              quiet
              id="reset-zoom"
              size="m"
              @click=${() => this.resetZoomSmooth()}
            >
              ${this.zoomPercentage}%
            </sp-action-button>
            <sp-tooltip slot="tooltip">Reset Zoom (Cmd/Ctrl + 0)</sp-tooltip>
          </overlay-trigger>

          <overlay-trigger placement="bottom" type="hover">
            <sp-action-button
              slot="trigger"
              id="zoom-in"
              quiet
              size="m"
              ?disabled=${!this.zoomStore?.canZoomIn}
              @click=${() => this.zoomInSmooth()}
            >
              <sp-icon-zoom-in slot="icon"></sp-icon-zoom-in>
              Zoom in
            </sp-action-button>
            <sp-tooltip slot="tooltip">Zoom In (Cmd/Ctrl + +)</sp-tooltip>
          </overlay-trigger>
        </div>

        <div id="toolbar-right">
          <sp-status-light
            id="save-indicator"
            variant="positive"
            size="m"
            style=${this.editorStore?.saveIndicatorVisible ? "" : "visibility: hidden;"}
          >
            Saved
          </sp-status-light>

          <sp-action-group compact>
            <overlay-trigger placement="bottom" type="hover">
              <sp-action-button
                slot="trigger"
                id="open-comments"
                quiet
                size="m"
                @click=${() => {
      const willOpen = !this.commentStore?.commentsPanelOpen;
      this.editorStore?.setUserAction?.("topbar:commentsToggle", {
        open: willOpen
      });
      this.commentStore?.toggleCommentsPanel?.();
      if (willOpen) this.versionStore?.closeVersionsPanel?.();
      if (willOpen) this.usedInStore?.closeUsedInPanel?.();
    }}
              >
                <sp-icon-comment slot="icon"></sp-icon-comment>
                ${Array.isArray(this.commentStore?.comments) ? `Comments (${this.commentStore.comments.length})` : "Comments"}
              </sp-action-button>
              <sp-tooltip slot="tooltip">Comments</sp-tooltip>
            </overlay-trigger>

            <overlay-trigger placement="bottom" type="hover">
              <sp-action-button
                slot="trigger"
                id="open-versions"
                quiet
                size="m"
                @click=${() => {
      const willOpen = !this.versionStore?.versionsPanelOpen;
      this.editorStore?.setUserAction?.("topbar:versionsToggle", {
        open: willOpen
      });
      this.versionStore?.toggleVersionsPanel?.();
      if (willOpen) this.usedInStore?.closeUsedInPanel?.();
    }}
              >
                <sp-icon-history slot="icon"></sp-icon-history>
                ${Array.isArray(this.versionStore?.versions) ? `Versions (${this.versionStore.versions.length})` : "Versions"}
              </sp-action-button>
              <sp-tooltip slot="tooltip">Version history</sp-tooltip>
            </overlay-trigger>

            <overlay-trigger placement="bottom" type="hover">
              <sp-action-button
                slot="trigger"
                id="open-used-in"
                quiet
                size="m"
                @click=${() => {
      const willOpen = !this.usedInStore?.panelOpen;
      this.editorStore?.setUserAction?.("topbar:usedInToggle", {
        open: willOpen
      });
      this.usedInStore?.toggleUsedInPanel?.();
    }}
              >
                <sp-icon-target slot="icon"></sp-icon-target>
                ${Array.isArray(this.usedInStore?.items) ? `Used In (${this.usedInStore.items.length})` : "Used In"}
              </sp-action-button>
              <sp-tooltip slot="tooltip"
                >Where this fragment is used</sp-tooltip
              >
            </overlay-trigger>
          </sp-action-group>

          <sp-action-menu
            id="copy-menu"
            quiet
            size="m"
            selects="single"
            ?disabled=${!this.store?.editorStore?.currentElementId}
            @change=${(e36) => this.onCopyReferenceMenu(e36)}
          >
            <sp-icon-review-link slot="icon"></sp-icon-review-link>
            <span slot="label">Use</span>
            <sp-menu-item value="inline">As Inline Content</sp-menu-item>
            <sp-menu-item value="button">As Spectrum Button</sp-menu-item>
            <sp-menu-item value="spectrum-link">As Spectrum Link</sp-menu-item>
            <sp-menu-item value="a">As Regular Link (a)</sp-menu-item>
          </sp-action-menu>

          <overlay-trigger placement="bottom" type="hover">
            <sp-button
              id="publish"
              slot="trigger"
              variant="primary"
              size="m"
              ?disabled=${!this.store?.editorStore?.currentElementId}
              @click=${() => this.publishCurrent()}
            >
              <sp-icon-publish
                slot="icon"
                style=${this.publishIconStyle}
              ></sp-icon-publish>
              Publish
            </sp-button>
            <sp-tooltip slot="tooltip">Publish current document</sp-tooltip>
          </overlay-trigger>

          <overlay-trigger placement="bottom" type="hover">
            <sp-button
              id="unpublish"
              slot="trigger"
              variant="secondary"
              size="m"
              ?disabled=${!this.store?.editorStore?.currentElementId}
              @click=${() => this.openUnpublishDialog()}
            >
              <sp-icon-revert slot="icon"></sp-icon-revert>
              Unpublish
            </sp-button>
            <sp-tooltip slot="tooltip">Unpublish current document</sp-tooltip>
          </overlay-trigger>

          <sp-action-menu
            id="export-menu"
            quiet
            size="m"
            selects="single"
            ?disabled=${!this.firstElementChild}
            @change=${(e36) => this.onExportMenuChange(e36)}
          >
            <sp-icon-more slot="icon"></sp-icon-more>
            <sp-menu-item value="html">Sanitized HTML</sp-menu-item>
            <sp-menu-item value="json">Data Model (JSON)</sp-menu-item>
          </sp-action-menu>
        </div>
      </div>

      <div id="editor-main">
        ${this.structureTree}
        <div id="canvas-container" @scroll=${this.updateCommentsOverlay}>
          <div id="surface-wrapper">
            ${E}
            <div id="surface-content">
              <slot part="editor" @slotchange=${this.handleSlotChange}></slot>
            </div>
          </div>
        </div>

        <div
          id="right-sidebar"
          class=${this.commentStore?.commentsPanelOpen || this.versionStore?.versionsPanelOpen || this.usedInStore?.panelOpen || this.agentStore?.panelOpen ? "open" : "closed"}
          style=${`transform: translateX(${this.commentStore?.commentsPanelOpen || this.versionStore?.versionsPanelOpen || this.usedInStore?.panelOpen || this.agentStore?.panelOpen ? "0" : "calc(100% + 8px)"});`}
        >
          ${this.agentStore?.panelOpen ? x`<ee-agent-panel
                id="ee-agent-panel"
                .agentStore=${this.agentStore}
                .editorStore=${this.editorStore}
              ></ee-agent-panel>` : this.versionStore?.versionsPanelOpen ? x`<ee-versions-panel
                id="ee-versions-panel"
                .versionStore=${this.versionStore}
                .store=${this.editorStore}
              ></ee-versions-panel>` : this.usedInStore?.panelOpen ? x`<used-in-panel
                id="used-in-panel"
                .usedInStore=${this.usedInStore}
                .store=${this.store}
              ></used-in-panel>` : x`<ee-comments-panel
                id="ee-comments-panel"
                .store=${this.editorStore}
                .commentStore=${this.commentStore}
              ></ee-comments-panel>`}
        </div>
      </div>

      <ee-toolbar
        .editorStore=${this.editorStore}
        .commentStore=${this.commentStore}
        .agentStore=${this.agentStore}
      ></ee-toolbar>

      ${this.deleteDialogUI} ${this.leaveDialogUI} ${this.unpublishDialogUI}
      ${this.renameDialogUI}

      <canvas id="comments-overlay"></canvas>
    `;
  }
  #initZoomPan() {
    this.editorStore?.toolbar?.initZoomPan();
  }
  #destroyZoomController() {
    const controller = this.#zoomController;
    if (controller) {
      controller.destroy?.();
      this.#zoomController = null;
      this.zoomStore = null;
      this.zoomTargetElement = null;
    }
    if (this.#cleanupZoomReaction) {
      this.#cleanupZoomReaction();
      this.#cleanupZoomReaction = null;
    }
  }
  // Confirm Delete Dialog UI
  get deleteDialogUI() {
    return renderDeleteDialog(this);
  }
  confirmDelete() {
    return confirmDelete(this);
  }
  onBackToGalleryClick() {
    handleBackToGalleryClick(this);
  }
  get leaveDialogUI() {
    return renderLeaveDialog(this);
  }
  saveAndLeave() {
    return saveAndLeave(this);
  }
  onDialogConfirm(e36) {
    handleDialogConfirm(this, e36);
  }
  onDialogCancel(e36) {
    handleDialogCancel(this, e36);
  }
  get unpublishDialogUI() {
    return renderUnpublishDialog(this);
  }
  confirmUnpublish() {
    return confirmUnpublish(this);
  }
  openUnpublishDialog() {
    openUnpublishDialog(this);
  }
  loadUnpublishRefs() {
    return loadUnpublishRefs(this);
  }
  // Sidebar: Structure tree rendering
  // Sidebar: Structure tree rendering
  get structureTree() {
    const tree = this.getAuthorableTree();
    return x`
      <div class="left-sidebar-container">
        <content-tree-nav
          ?open=${!!this.editorStore?.sidebarOpen}
          id="content-tree-nav"
          .store=${this.editorStore}
          .tree=${tree}
          .searchQuery=${this.sidebarSearchQuery}
          .centerOn=${this.centerOnElement.bind(this)}
        ></content-tree-nav>
        <tool-panel
          .editorStore=${this.editorStore}
          .toolbarStore=${this.editorStore?.toolbar}
        ></tool-panel>
      </div>
    `;
  }
  centerOnElement(el) {
    if (!el) return;
    if (this.#zoomController?.focusElement) {
      this.#zoomController.focusElement(el, { margin: 24 });
      return;
    }
    const container = this.shadowRoot?.querySelector("#canvas-container");
    if (!container) return;
    el.scrollIntoView({
      behavior: "smooth",
      block: "center",
      inline: "nearest"
    });
  }
  // Helpers to compute the authorable tree from current DOM
  getAuthorableTree() {
    return TreeNav.getAuthorableTree(this);
  }
  getElementLabel(el) {
    return TreeNav.getElementLabel(this, el);
  }
  // Try to render an icon provided by element's ee.getElementIcon()
  renderItemIcon(el) {
    return TreeNav.renderItemIcon(this, el);
  }
  getElementIconTemplate(el) {
    return TreeNav.getElementIconTemplate(this, el);
  }
  containsSelected(node, selectedEl) {
    return TreeNav.containsSelected(node, selectedEl);
  }
  // Ensure sidebar is expanded by default while allowing user collapse
  firstUpdatedDone = false;
  lastSidebarRoot = null;
  // Merge sidebar init logic into the primary updated() below
  #getCanvasRoot() {
    return TreeNav.getCanvasRoot(this);
  }
  #initSidebarExpansion() {
    const root = this.#getCanvasRoot();
    if (!root) return;
    const rootChanged = this.lastSidebarRoot !== root;
    if (!this.firstUpdatedDone || rootChanged) {
      setTimeout(() => this.#expandAllSidebarItems(), 0);
      this.firstUpdatedDone = true;
      this.lastSidebarRoot = root;
    }
  }
  #expandAllSidebarItems() {
    TreeNav.expandAllSidebarItems(this);
  }
  #attachSidebarWheelGuard() {
    const host = this.shadowRoot;
    if (!host) return;
    const el = host.querySelector("content-tree-nav");
    if (!el) return;
    if (el._eeWheelGuarded) return;
    const stop = (e36) => {
      e36.stopPropagation();
    };
    el.addEventListener("wheel", stop, { passive: true, capture: true });
    el._eeWheelGuarded = true;
  }
  #attachCanvasWheelGuard() {
    const host = this.shadowRoot;
    if (!host) return;
    const el = host.querySelector("#canvas-container");
    if (!el) return;
    if (el._eeWheelGuarded) return;
    const stop = (e36) => {
      if (e36.ctrlKey || e36.metaKey) return;
      e36.stopPropagation();
    };
    el.addEventListener("wheel", stop, { passive: true, capture: true });
    el._eeWheelGuarded = true;
  }
  // Fragment Name Management
  handleFragmentNameChange(e36) {
    handleFragmentNameChange(this, e36);
  }
  handleFragmentNameKeypress(e36) {
    handleFragmentNameKeypress(this, e36);
  }
  // Rename dialog
  openRenameDialog() {
    openRenameDialog(this);
  }
  onRenameInput(e36) {
    handleRenameInput(this, e36);
  }
  confirmRename() {
    confirmRename(this);
  }
  get renameDialogUI() {
    return renderRenameDialog(this);
  }
  async openPreview() {
    const urn = this.editorStore?.currentElementId;
    if (!urn) {
      this.editorStore?.setLastAction?.("topbar:preview-blocked", {
        reason: "no-current-element"
      });
      return;
    }
    await this.editorStore?.performAutoSave?.();
    const path = String(urn).replace(/\.html$/, "").replace(/^\/+/, "");
    const daUrl = `https://da.live/edit#/${path}`;
    this.editorStore?.setUserAction?.("topbar:preview-open", { urn, daUrl });
    window.open(daUrl, "_blank", "noopener,noreferrer");
  }
  // Element Management
  async closeElement() {
    await this.editorStore?.performAutoSave?.();
    await this.store.closeElement();
    this.editorStore?.selection?.selectElement(null);
    const elements = Array.from(this.children);
    elements.forEach((el) => el.remove());
  }
  // Compute ee-toolbar dimensions from its shadow DOM or fall back
  #getToolbarDims() {
    return this.editorStore?.toolbar?.getToolbarDims() ?? { width: 520, height: 40 };
  }
  // Calculate toolbar position around current selection/slot/element
  #calculateToolbarPosition(element) {
    return this.editorStore?.toolbar?.calculateToolbarPosition(element) ?? { x: 0, y: 0 };
  }
  #updateToolbarPosition() {
    this.editorStore?.toolbar?.updateToolbarPosition();
  }
  #setupToolbarSync() {
    this.editorStore?.toolbar?.setupToolbarSync();
  }
  // Selection outline: mark the selected element or its slot
  #setupSelectionOutlineSync() {
    if (!this.editorStore || this.#cleanupSelectionReaction) return;
    setupSelectionOutline(this);
    this.#cleanupSelectionReaction = reaction(
      this.editorStore,
      (s19) => [s19.editingElement, s19.currentSlot],
      () => applySelectionOutline(this)
    );
  }
  #setupInlineEditing() {
    if (!this.editorStore) return;
    this.editorStore.richText.bindInlineEditing(this);
  }
  // Comments overlay setup and drawing
  setupCommentsOverlay() {
    setupCommentsOverlay(this);
  }
  syncCommentsPanelView() {
    syncCommentsPanelView(this);
  }
  updateCommentsOverlay = () => {
    updateCommentsOverlay(this);
  };
  getElementForComment(commentId) {
    return getElementForComment(this, commentId);
  }
  showToast(message) {
    showToast(this, message);
  }
  publishCurrent() {
    return publishCurrent(this);
  }
  unpublishCurrent() {
    return unpublishCurrent(this);
  }
  copySanitizedHTML() {
    return copySanitizedHTML(this);
  }
  copyDataModel() {
    return copyDataModel(this);
  }
  copyReferenceSnippet() {
    return copyReferenceSnippet(this);
  }
  copyReferenceSnippetAs(type) {
    return copyReferenceSnippetAs(this, type);
  }
  async copySelectedElement() {
    const selectedElement = this.editorStore?.editingElement;
    if (!selectedElement) return;
    const clone = selectedElement.cloneNode(true);
    const html = clone.outerHTML;
    if (navigator.clipboard?.write) {
      const clipboardItem = new ClipboardItem({
        "text/html": new Blob([html], { type: "text/html" }),
        "text/plain": new Blob([html], { type: "text/plain" })
      });
      await navigator.clipboard.write([clipboardItem]);
      this.showToast("Element copied to clipboard");
    } else if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(html);
      this.showToast("Element copied to clipboard");
    }
  }
  onCopyReferenceMenu(e36) {
    return onCopyReferenceMenu(this, e36);
  }
  onExportMenuChange(e36) {
    const value = e36.target?.value;
    if (value === "html") {
      this.copySanitizedHTML();
    } else if (value === "json") {
      this.copyDataModel();
    }
  }
  // Helper to check if element is authorable (custom element or slot element)
  isAuthorableElement(element) {
    const isAuthorable = this.store?.domStore?.isAuthorable(element) ?? false;
    if (!isAuthorable) return false;
    const editorRoot = this.editorElement || null;
    let current = element.parentElement;
    while (current && current.nodeType === Node.ELEMENT_NODE) {
      if (current === editorRoot) break;
      const assignedSlot = current.getAttribute?.("slot")?.trim();
      const parent = current.parentElement;
      if (assignedSlot && parent && parent.tagName?.includes?.("-") && this.editorStore?.selection?.slotSupportsTextEditing?.(parent, assignedSlot)) {
        let checkElement = element;
        while (checkElement && checkElement !== current) {
          const tag3 = checkElement.tagName?.toLowerCase?.();
          if (tag3 === "ee-content" || tag3 === "ee-reference") {
            return true;
          }
          checkElement = checkElement.parentElement;
        }
        return false;
      }
      if (current.tagName?.includes?.("-")) {
        const slotName = element.getAttribute?.("slot") || "default";
        if (this.editorStore?.selection?.slotSupportsTextEditing?.(current, slotName)) {
          let checkElement = element;
          while (checkElement && checkElement !== current) {
            const tag3 = checkElement.tagName?.toLowerCase?.();
            if (tag3 === "ee-content" || tag3 === "ee-reference") {
              return true;
            }
            checkElement = checkElement.parentElement;
          }
          return false;
        }
      }
      current = parent;
    }
    return true;
  }
  // Simplified click handler for element selection
  handleElementClick(e36) {
    if (e36.metaKey || e36.ctrlKey) {
      return;
    }
    if (e36.__ee_processed) {
      return;
    }
    e36.__ee_processed = true;
    this.#interactions.handleClick(e36);
  }
  // Minimal diagnostic snapshot of the editor, store, and toolbar
  get debugState() {
    const storeDebugState = this.editorStore?.debugState || null;
    const root = this.shadowRoot;
    const canvas = root?.getElementById("canvas-container") || null;
    const surface = root?.getElementById("surface-wrapper") || null;
    let canvasScroll = null;
    if (canvas) {
      canvasScroll = {
        left: canvas.scrollLeft || 0,
        top: canvas.scrollTop || 0,
        width: canvas.scrollWidth || 0,
        height: canvas.scrollHeight || 0
      };
    }
    let surfaceTransform = null;
    if (surface) {
      const computed = getComputedStyle(surface);
      const transformValue = computed.transform || "none";
      if (!transformValue || transformValue === "none") {
        surfaceTransform = {
          scale: 1,
          translateX: 0,
          translateY: 0,
          matrix: "none"
        };
      } else {
        const matrix = new DOMMatrixReadOnly(transformValue);
        surfaceTransform = {
          scale: Number.isFinite(matrix.a) ? matrix.a : 1,
          translateX: Number.isFinite(matrix.e) ? Math.round(matrix.e) : 0,
          translateY: Number.isFinite(matrix.f) ? Math.round(matrix.f) : 0,
          matrix: transformValue
        };
      }
    }
    const history3 = storeDebugState?.history || null;
    const undoDepth2 = history3?.undoDepth || 0;
    const redoDepth2 = history3?.redoDepth || 0;
    const controls = {
      canUndo: undoDepth2 > 0,
      canRedo: redoDepth2 > 0,
      sidebarOpen: !!this.editorStore?.sidebarOpen,
      commentsOpen: !!this.commentStore?.commentsPanelOpen,
      themeColor: this.store?.themeColor || null,
      zoom: surfaceTransform?.scale ?? 1
    };
    const doc3 = {
      id: this.store?.editorStore?.currentElementId || null,
      name: this.store?.currentElement?.name || null,
      childCount: this.children ? this.children.length : 0
    };
    return {
      document: doc3,
      editor: {
        hasChildElements: this.hasChildElements(),
        canvasScroll,
        surfaceTransform
      },
      lastClick: this.getLastClickInfo?.() || null,
      controls,
      store: storeDebugState
    };
  }
  onThemeSwitch(e36) {
    const checked = !!e36?.target?.checked;
    this.store?.setThemeColor(checked ? "dark" : "light");
  }
  handleKeyDown(e36) {
    handleKeyDown2(this, e36);
  }
  handleKeyUp(e36) {
    handleKeyUp(this, e36);
  }
  /**
   * Undo/Redo Methods
   */
  performUndo() {
    if (this.editorStore) {
      this.editorStore.undo();
    }
  }
  performRedo() {
    if (this.editorStore) {
      this.editorStore.redo();
    }
  }
};
customElements.define(
  "experience-elements-editor",
  makeLitObserver(ExperienceElementsEditor)
);
var sheet = new CSSStyleSheet();
sheet.replaceSync(`
  experience-elements-editor main,
  experience-elements-editor sp-theme {
    width: 100%;
  }
`);
document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];

// src/experience-elements-home-new.js
init_lit();

// src/da/vanilla-tags.js
var VANILLA_TAGS = /* @__PURE__ */ new Set([
  "p",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "span",
  "a",
  "strong",
  "em",
  "b",
  "i",
  "u",
  "br"
]);

// src/da/to-eds.js
var EDSSerializer = class {
  constructor() {
    this.tables = [];
    this.elementCounter = {};
  }
  /**
   * Generate unique ID for an element
   */
  generateId(tagName) {
    const baseName = tagName.toLowerCase();
    if (!this.elementCounter[baseName]) {
      this.elementCounter[baseName] = 0;
    }
    this.elementCounter[baseName]++;
    return `${baseName}-${this.elementCounter[baseName]}`;
  }
  /**
   * Check if element is a vanilla HTML tag (in allowlist)
   */
  isVanillaTag(tagName) {
    return VANILLA_TAGS.has(tagName.toLowerCase());
  }
  /**
   * Check if child nodes contain mixed inline content (text + inline vanilla elements)
   * This detects cases like: "text <strong>bold</strong> more text"
   */
  #hasMixedInlineContent(childNodes) {
    let hasText = false;
    let hasInlineElement = false;
    for (const child of childNodes) {
      if (child.nodeType === Node.TEXT_NODE && child.textContent.trim()) {
        hasText = true;
      } else if (child.nodeType === Node.ELEMENT_NODE) {
        const tagName = child.tagName.toLowerCase();
        if (this.isVanillaTag(tagName) && !child.getAttribute("slot")) {
          hasInlineElement = true;
        } else {
          return false;
        }
      }
    }
    return hasText && hasInlineElement;
  }
  /**
   * Serialize mixed content (text nodes + inline elements) to a single HTML string
   */
  #serializeMixedContent(childNodes) {
    return childNodes.map((child) => {
      if (child.nodeType === Node.TEXT_NODE) {
        return child.textContent;
      }
      if (child.nodeType === Node.ELEMENT_NODE) {
        return this.serializeVanillaHTML(child);
      }
      return "";
    }).join("");
  }
  /**
   * Serialize vanilla HTML to string (including nested tags)
   */
  serializeVanillaHTML(element) {
    if (element.nodeType === Node.TEXT_NODE) {
      return element.textContent.trim();
    }
    if (element.nodeType !== Node.ELEMENT_NODE) {
      return "";
    }
    const tagName = element.tagName.toLowerCase();
    const attributes = Array.from(element.attributes).filter((attr) => attr.name !== "slot").map((attr) => `${attr.name}="${attr.value}"`).join(" ");
    const openTag = attributes ? `<${tagName} ${attributes}>` : `<${tagName}>`;
    const closeTag = `</${tagName}>`;
    if (["br", "hr", "img", "input", "source"].includes(tagName)) {
      return attributes ? `<${tagName} ${attributes} />` : `<${tagName} />`;
    }
    const childrenHTML = Array.from(element.childNodes).map((child) => {
      if (child.nodeType === Node.TEXT_NODE) {
        return child.textContent;
      }
      if (child.nodeType === Node.ELEMENT_NODE) {
        if (this.isVanillaTag(child.tagName)) {
          return this.serializeVanillaHTML(child);
        } else {
          return child.outerHTML;
        }
      }
      return "";
    }).join("");
    return `${openTag}${childrenHTML}${closeTag}`;
  }
  /**
   * Parse CSS variables from style attribute
   */
  parseStyleVariables(styleAttr) {
    const vars = {};
    if (!styleAttr) return vars;
    const declarations = styleAttr.split(";").filter((d22) => d22.trim());
    declarations.forEach((decl) => {
      const [prop, value] = decl.split(":").map((s19) => s19.trim());
      if (prop && prop.startsWith("--")) {
        const varName = prop.substring(2);
        vars[`style.${varName}`] = value;
      } else if (prop) {
        vars[`style.${prop}`] = value;
      }
    });
    return vars;
  }
  /**
   * Process custom element and create table entry
   */
  processCustomElement(element, parentId = null, slotName = null) {
    const tagName = element.tagName.toLowerCase();
    const id = this.generateId(tagName);
    const table = {
      id,
      type: tagName
    };
    if (parentId) {
      table.parent = parentId;
    }
    if (slotName) {
      table.slot = slotName;
    }
    const styleVars = this.parseStyleVariables(element.getAttribute("style"));
    Object.assign(table, styleVars);
    Array.from(element.attributes).forEach((attr) => {
      if (attr.name === "style") {
        return;
      }
      if (attr.name === "slot") {
        return;
      }
      const propName = attr.name === "type" ? "attr-type" : attr.name;
      table[propName] = attr.value;
    });
    const slotContents = {};
    const childRefs = [];
    const childNodes = Array.from(element.childNodes);
    const hasMixedInlineContent = this.#hasMixedInlineContent(childNodes);
    if (hasMixedInlineContent) {
      const htmlString = this.#serializeMixedContent(childNodes);
      if (htmlString.trim()) {
        slotContents["slot.default"] = [htmlString];
      }
    } else {
      childNodes.forEach((child) => {
        if (child.nodeType === Node.TEXT_NODE) {
          const text = child.textContent.trim();
          if (text) {
            if (!slotContents["slot.default"]) {
              slotContents["slot.default"] = [];
            }
            slotContents["slot.default"].push(text);
          }
          return;
        }
        if (child.nodeType !== Node.ELEMENT_NODE) {
          return;
        }
        const childTagName = child.tagName.toLowerCase();
        const childSlot = child.getAttribute("slot");
        if (this.isVanillaTag(childTagName)) {
          const htmlString = this.serializeVanillaHTML(child);
          if (childSlot) {
            if (!slotContents[`slot.${childSlot}`]) {
              slotContents[`slot.${childSlot}`] = [];
            }
            slotContents[`slot.${childSlot}`].push(htmlString);
          } else {
            if (!slotContents["slot.default"]) {
              slotContents["slot.default"] = [];
            }
            slotContents["slot.default"].push(htmlString);
          }
        } else {
          const childId = this.processCustomElement(child, id, childSlot);
          childRefs.push({ id: childId, slot: childSlot });
        }
      });
    }
    Object.entries(slotContents).forEach(([slotKey, values]) => {
      if (values.length === 1) {
        table[slotKey] = values[0];
      } else {
        table[slotKey] = values.join(" ");
      }
    });
    const slotRefs = {};
    const unslottedRefs = [];
    childRefs.forEach(({ id: childId, slot }) => {
      if (slot) {
        if (!slotRefs[`slot.${slot}`]) {
          slotRefs[`slot.${slot}`] = [];
        }
        slotRefs[`slot.${slot}`].push(`\u2192 ${childId}`);
      } else {
        unslottedRefs.push(`\u2192 ${childId}`);
      }
    });
    Object.entries(slotRefs).forEach(([slotKey, refs]) => {
      if (table[slotKey]) {
        table[slotKey] = table[slotKey] + ", " + refs.join(", ");
      } else {
        table[slotKey] = refs.join(", ");
      }
    });
    if (unslottedRefs.length > 0) {
      table.children = unslottedRefs.join(", ");
    }
    this.tables.push(table);
    return id;
  }
  /**
   * Convert HTML string to EDS tables
   */
  toEDS(htmlString) {
    const parser = new DOMParser();
    const doc3 = parser.parseFromString(htmlString, "text/html");
    const rootElement = doc3.body.firstElementChild;
    if (!rootElement) {
      throw new Error("No root element found");
    }
    this.processCustomElement(rootElement);
    return this.tables;
  }
  /**
   * Format tables as HTML (EDS authoring format)
   * First row contains the block name "experience-element"
   * Second row contains element-name with the actual custom element tag
   * Subsequent rows contain slot-name/value pairs
   */
  toHTML() {
    const tables = this.tables.map((table) => {
      const rows = [];
      rows.push(`    <tr><td>element-name</td><td>${table.type}</td></tr>`);
      Object.entries(table).forEach(([key, value]) => {
        if (key.startsWith("slot.")) {
          const slotName = key.substring(5);
          if (slotName !== "default") {
            rows.push(`    <tr><td><strong>${slotName}</strong></td><td>${value}</td></tr>`);
          }
        }
      });
      Object.entries(table).forEach(([key, value]) => {
        if (key.startsWith("style.")) {
          const styleName = key.substring(6);
          rows.push(`    <tr><td>style-${styleName}</td><td>${value}</td></tr>`);
        }
      });
      Object.entries(table).forEach(([key, value]) => {
        if (!["id", "type", "parent", "slot", "content", "children"].includes(key) && !key.startsWith("slot.") && !key.startsWith("style.")) {
          rows.push(`    <tr><td>${key}</td><td>${value}</td></tr>`);
        }
      });
      if (table.children) {
        rows.push(`    <tr><td>children</td><td>${table.children}</td></tr>`);
      }
      if (table["slot.default"]) {
        const value = table["slot.default"];
        const needsWrapper = /<strong\b/i.test(value) && !value.trim().startsWith("<p");
        const wrappedValue = needsWrapper ? `<p>${value}</p>` : value;
        rows.push(`    <tr><td colspan="2">${wrappedValue}</td></tr>`);
      }
      const rowsHtml = rows.join("\n");
      return `<table>
  <tr><td colspan="2">experience-element</td></tr>
${rowsHtml}
</table>`;
    });
    return tables.join("\n\n");
  }
};
function toEds(htmlString, options = {}) {
  const serializer = new EDSSerializer();
  const tables = serializer.toEDS(htmlString);
  if (options.format === "html") {
    return serializer.toHTML();
  }
  return tables;
}

// src/da/from-eds.js
var EDSBlockDeserializer = class {
  #blockMap = /* @__PURE__ */ new Map();
  #tableMap = /* @__PURE__ */ new Map();
  /**
   * Check if a class name represents a custom element block
   */
  isCustomElementClass(className) {
    if (className === "experience-element") {
      return true;
    }
    return className && className.includes("-") && !VANILLA_TAGS.has(className);
  }
  /**
   * Extract element-name from a block div
   */
  getElementName(blockDiv) {
    const rows = Array.from(blockDiv.children).filter((c33) => c33.tagName === "DIV");
    for (const row of rows) {
      const cells = Array.from(row.children).filter((c33) => c33.tagName === "DIV");
      if (cells.length === 2 && cells[0].textContent.trim() === "element-name") {
        return cells[1].textContent.trim();
      }
    }
    const classes = (blockDiv.className || "").split(/\s+/).filter(Boolean);
    const blockClass = classes.find((c33) => c33.includes("-") && !VANILLA_TAGS.has(c33) && c33 !== "experience-element");
    return blockClass || null;
  }
  /**
   * Convert CSS class name back to tag name
   * e.g., "paywall-card" -> "paywall-card"
   */
  classToTagName(className) {
    return className.toLowerCase();
  }
  /**
   * Build a map of block IDs to block elements
   */
  buildBlockMap(blocks) {
    this.#blockMap.clear();
    const blockCounts = /* @__PURE__ */ new Map();
    for (const block of blocks) {
      const elementName = this.getElementName(block);
      if (elementName) {
        const nameLower = elementName.toLowerCase();
        const count = (blockCounts.get(nameLower) || 0) + 1;
        blockCounts.set(nameLower, count);
        const blockId = `${nameLower}-${count}`;
        this.#blockMap.set(blockId, block);
      }
    }
  }
  /**
   * Parse a block row to extract slot name and content
   * Row format: <div><div>slot-name</div><div>content</div></div>
   */
  parseBlockRow(rowDiv) {
    const cells = Array.from(rowDiv.children).filter((c33) => c33.tagName === "DIV");
    if (cells.length === 0) {
      return null;
    }
    if (cells.length === 1) {
      return {
        slotName: null,
        content: cells[0]
      };
    }
    const strongEl = cells[0].querySelector("strong");
    const isSlot = !!strongEl;
    const slotName = strongEl ? strongEl.textContent.trim() : cells[0].textContent.trim();
    const content = cells[1];
    return {
      slotName,
      content,
      isSlot
    };
  }
  /**
   * Check if content div contains a nested block
   */
  findNestedBlock(contentDiv) {
    for (const child of contentDiv.children) {
      if (child.tagName === "DIV" && child.className) {
        const classes = child.className.split(/\s+/);
        const blockClass = classes.find((c33) => this.isCustomElementClass(c33));
        if (blockClass) {
          return { element: child, blockClass };
        }
      }
    }
    return null;
  }
  /**
   * Parse references from content text (e.g., " inline-price-1,  inline-price-2")
   */
  parseReferences(text) {
    const refs = [];
    const matches3 = text.matchAll(/\s*([a-z][a-z0-9-]*-\d+)/gi);
    for (const match of matches3) {
      refs.push(match[1].toLowerCase());
    }
    return refs;
  }
  /**
   * Check if content div is just a simple <p> wrapper around plain text
   * DA author format wraps all text in <p> tags, but this shouldn't create slots
   */
  #isSimplePWrapper(contentDiv) {
    const children = Array.from(contentDiv.children);
    if (children.length !== 1) return false;
    const child = children[0];
    if (child.tagName !== "P") return false;
    return child.children.length === 0;
  }
  /**
   * Check if content is purely references (no other content)
   */
  isReferenceOnly(text) {
    const withoutRefs = text.replace(/\s*[a-z][a-z0-9-]*-\d+/gi, "").replace(/,/g, "").trim();
    return withoutRefs === "";
  }
  /**
   * Convert content div to appropriate slotted content
   */
  convertContent(contentDiv, slotName) {
    const nestedBlock = this.findNestedBlock(contentDiv);
    if (nestedBlock) {
      const converted = this.convertBlock(nestedBlock.element);
      if (slotName) {
        converted.setAttribute("slot", slotName);
      }
      return converted;
    }
    const innerHTML = contentDiv.innerHTML.trim();
    const textContent = contentDiv.textContent.trim();
    const refs = this.parseReferences(textContent);
    if (refs.length > 0 && this.isReferenceOnly(textContent)) {
      const fragment = document.createDocumentFragment();
      for (const refId of refs) {
        const refBlock = this.#blockMap.get(refId);
        if (refBlock) {
          const converted = this.convertBlock(refBlock);
          if (slotName) {
            converted.setAttribute("slot", slotName);
          }
          fragment.appendChild(converted);
        }
      }
      return fragment;
    }
    const hasBlockElements = /<(p|h[1-6]|div|ul|ol|table)/i.test(innerHTML);
    if (hasBlockElements) {
      const fragment = document.createDocumentFragment();
      Array.from(contentDiv.childNodes).forEach((node) => {
        const cloned = node.cloneNode(true);
        if (cloned.nodeType === Node.ELEMENT_NODE && slotName) {
          cloned.setAttribute("slot", slotName);
        }
        fragment.appendChild(cloned);
      });
      return fragment;
    }
    const wrapper = document.createElement("span");
    wrapper.innerHTML = innerHTML;
    if (slotName) {
      wrapper.setAttribute("slot", slotName);
    }
    return wrapper;
  }
  /**
   * Convert an EDS block div to a custom element
   */
  convertBlock(blockDiv) {
    const classes = (blockDiv.className || "").split(/\s+/).filter(Boolean);
    const blockClass = classes.find((c33) => this.isCustomElementClass(c33));
    if (!blockClass) {
      return blockDiv.cloneNode(true);
    }
    const elementName = this.getElementName(blockDiv);
    if (!elementName) {
      return blockDiv.cloneNode(true);
    }
    const tagName = elementName.toLowerCase();
    const parser = new DOMParser();
    const tempDoc = parser.parseFromString(`<${tagName}></${tagName}>`, "text/html");
    const element = tempDoc.body.firstElementChild;
    if (!element) {
      const fallbackElement = document.createElement(tagName);
      return fallbackElement;
    }
    const otherClasses = classes.filter((c33) => c33 !== blockClass && c33 !== "experience-element" && c33 !== elementName);
    if (otherClasses.length > 0) {
      otherClasses.forEach((cls) => {
        element.setAttribute(cls, "");
      });
    }
    const rows = Array.from(blockDiv.children).filter((c33) => c33.tagName === "DIV");
    const styleVars = {};
    for (const row of rows) {
      const parsed = this.parseBlockRow(row);
      if (!parsed) continue;
      const { slotName, content, isSlot } = parsed;
      if (slotName === "element-name") {
        continue;
      }
      const textContent = content.textContent.trim();
      const innerHTML = content.innerHTML.trim();
      if (slotName?.startsWith("style-")) {
        const varName = slotName.substring(6);
        styleVars[`--${varName}`] = textContent;
        continue;
      }
      const refs = this.parseReferences(textContent);
      if (refs.length > 0 && this.isReferenceOnly(textContent)) {
        for (const refId of refs) {
          const refBlock = this.#blockMap.get(refId);
          if (refBlock) {
            const converted = this.convertBlock(refBlock);
            if (slotName && slotName !== "children") {
              converted.setAttribute("slot", slotName);
            }
            element.appendChild(converted);
          }
        }
        continue;
      }
      const slottedChild = content.querySelector("[slot]");
      if (slottedChild) {
        Array.from(content.childNodes).forEach((node) => {
          element.appendChild(node.cloneNode(true));
        });
        continue;
      }
      if (slotName === null) {
        const children = Array.from(content.children);
        if (children.length === 1 && children[0].tagName === "P") {
          Array.from(children[0].childNodes).forEach((node) => {
            element.appendChild(node.cloneNode(true));
          });
        } else {
          Array.from(content.childNodes).forEach((node) => {
            element.appendChild(node.cloneNode(true));
          });
        }
        continue;
      }
      if (isSlot) {
        const children = Array.from(content.children);
        if (children.length === 1 && /^(p|h[1-6]|div|ul|ol|table|blockquote|pre|figure)$/i.test(children[0].tagName)) {
          const cloned = children[0].cloneNode(true);
          cloned.setAttribute("slot", slotName);
          element.appendChild(cloned);
          continue;
        }
        const wrapper = document.createElement("p");
        wrapper.innerHTML = innerHTML;
        wrapper.setAttribute("slot", slotName);
        element.appendChild(wrapper);
        continue;
      }
      const isSimplePWrapper = this.#isSimplePWrapper(content);
      if (innerHTML !== textContent && !isSimplePWrapper) {
        const converted = this.convertContent(content, slotName);
        if (converted instanceof DocumentFragment) {
          element.appendChild(converted);
        } else if (converted) {
          element.appendChild(converted);
        }
        continue;
      }
      if (slotName) {
        const attrName = slotName === "attr-type" ? "type" : slotName;
        element.setAttribute(attrName, textContent);
      }
    }
    if (Object.keys(styleVars).length > 0) {
      const styleStr = Object.entries(styleVars).map(([k2, v6]) => `${k2}: ${v6}`).join("; ");
      element.setAttribute("style", styleStr);
    }
    return element;
  }
  /**
   * Find all block divs in the document
   */
  findBlocks(root) {
    const blocks = [];
    const walk = (node) => {
      if (node.nodeType !== Node.ELEMENT_NODE) return;
      if (node.tagName === "DIV" && node.className) {
        const classes = node.className.split(/\s+/);
        if (classes.some((c33) => this.isCustomElementClass(c33))) {
          blocks.push(node);
          return;
        }
      }
      for (const child of node.children) {
        walk(child);
      }
    };
    walk(root);
    return blocks;
  }
  /**
   * Find the root block (the one not referenced by any other block)
   */
  findRootBlock(blocks) {
    if (blocks.length === 0) return null;
    if (blocks.length === 1) return blocks[0];
    const referencedIds = /* @__PURE__ */ new Set();
    for (const block of blocks) {
      const text = block.textContent;
      const matches3 = text.matchAll(/\s*([a-z][a-z0-9-]*-\d+)/gi);
      for (const match of matches3) {
        referencedIds.add(match[1].toLowerCase());
      }
    }
    const blockCounts = /* @__PURE__ */ new Map();
    const blockIds = /* @__PURE__ */ new Map();
    for (const block of blocks) {
      const elementName = this.getElementName(block);
      if (elementName) {
        const nameLower = elementName.toLowerCase();
        const count = (blockCounts.get(nameLower) || 0) + 1;
        blockCounts.set(nameLower, count);
        const blockId = `${nameLower}-${count}`;
        blockIds.set(block, blockId);
      }
    }
    const unreferencedBlocks = [];
    for (const block of blocks) {
      const blockId = blockIds.get(block);
      if (blockId && !referencedIds.has(blockId)) {
        unreferencedBlocks.push(block);
      }
    }
    if (unreferencedBlocks.length === 1) {
      return unreferencedBlocks[0];
    }
    if (unreferencedBlocks.length > 1) {
      return unreferencedBlocks[unreferencedBlocks.length - 1];
    }
    return blocks[blocks.length - 1];
  }
  /**
   * Find all experience-element tables in the document (author format)
   */
  findTables(root) {
    const tables = [];
    for (const table of root.querySelectorAll("table")) {
      const firstCell = table.querySelector("tr td");
      if (firstCell?.textContent.trim() === "experience-element") {
        tables.push(table);
      }
    }
    return tables;
  }
  /**
   * Build a map of table IDs from author format tables
   */
  buildTableMap(tables) {
    this.#tableMap.clear();
    const tableCounts = /* @__PURE__ */ new Map();
    for (const table of tables) {
      const elementName = this.getElementNameFromTable(table);
      if (elementName) {
        const nameLower = elementName.toLowerCase();
        const count = (tableCounts.get(nameLower) || 0) + 1;
        tableCounts.set(nameLower, count);
        const tableId = `${nameLower}-${count}`;
        this.#tableMap.set(tableId, table);
      }
    }
  }
  /**
   * Extract element-name from a table
   */
  getElementNameFromTable(table) {
    const rows = table.querySelectorAll("tr");
    for (const row of rows) {
      const cells = row.querySelectorAll("td");
      if (cells.length === 2 && cells[0].textContent.trim() === "element-name") {
        return cells[1].textContent.trim();
      }
    }
    return null;
  }
  /**
   * Convert an author format table to a custom element
   */
  convertTable(table) {
    const elementName = this.getElementNameFromTable(table);
    if (!elementName) {
      return null;
    }
    const tagName = elementName.toLowerCase();
    const parser = new DOMParser();
    const tempDoc = parser.parseFromString(`<${tagName}></${tagName}>`, "text/html");
    const element = tempDoc.body.firstElementChild;
    if (!element) {
      return document.createElement(tagName);
    }
    const rows = table.querySelectorAll("tr");
    const styleVars = {};
    for (const row of rows) {
      const cells = row.querySelectorAll("td");
      if (cells.length === 1 && cells[0].getAttribute("colspan") === "2") {
        const text = cells[0].textContent.trim();
        if (text === "experience-element") {
          continue;
        }
        const children = Array.from(cells[0].children);
        if (children.length === 1 && children[0].tagName === "P") {
          Array.from(children[0].childNodes).forEach((node) => {
            element.appendChild(node.cloneNode(true));
          });
        } else {
          Array.from(cells[0].childNodes).forEach((node) => {
            element.appendChild(node.cloneNode(true));
          });
        }
        continue;
      }
      if (cells.length !== 2) continue;
      const key = cells[0].textContent.trim();
      const valueCell = cells[1];
      const textContent = valueCell.textContent.trim();
      const innerHTML = valueCell.innerHTML.trim();
      if (key === "element-name") {
        continue;
      }
      if (key.startsWith("style-")) {
        const varName = key.substring(6);
        styleVars[`--${varName}`] = textContent;
        continue;
      }
      const refs = this.parseReferences(textContent);
      if (refs.length > 0 && this.isReferenceOnly(textContent)) {
        for (const refId of refs) {
          const refTable = this.#tableMap.get(refId);
          if (refTable) {
            const converted = this.convertTable(refTable);
            if (converted) {
              if (key && key !== "children") {
                converted.setAttribute("slot", key);
              }
              element.appendChild(converted);
            }
          }
        }
        continue;
      }
      if (innerHTML !== textContent) {
        const slottedChild = valueCell.querySelector("[slot]");
        if (slottedChild) {
          Array.from(valueCell.childNodes).forEach((node) => {
            element.appendChild(node.cloneNode(true));
          });
          continue;
        }
        const children = Array.from(valueCell.children);
        if (children.length === 1 && /^(p|h[1-6]|div|ul|ol|table|blockquote|pre|figure)$/i.test(children[0].tagName)) {
          const cloned = children[0].cloneNode(true);
          if (key) {
            cloned.setAttribute("slot", key);
          }
          element.appendChild(cloned);
          continue;
        }
        const wrapper = document.createElement("span");
        wrapper.innerHTML = innerHTML;
        if (key) {
          wrapper.setAttribute("slot", key);
        }
        element.appendChild(wrapper);
        continue;
      }
      if (key) {
        const attrName = key === "attr-type" ? "type" : key;
        element.setAttribute(attrName, textContent);
      }
    }
    if (Object.keys(styleVars).length > 0) {
      const styleStr = Object.entries(styleVars).map(([k2, v6]) => `${k2}: ${v6}`).join("; ");
      element.setAttribute("style", styleStr);
    }
    return element;
  }
  /**
   * Find the root table (the one not referenced by any other table)
   */
  findRootTable(tables) {
    if (tables.length === 0) return null;
    if (tables.length === 1) return tables[0];
    const referencedIds = /* @__PURE__ */ new Set();
    for (const table of tables) {
      const text = table.textContent;
      const matches3 = text.matchAll(/\s*([a-z][a-z0-9-]*-\d+)/gi);
      for (const match of matches3) {
        referencedIds.add(match[1].toLowerCase());
      }
    }
    const tableCounts = /* @__PURE__ */ new Map();
    const tableIds = /* @__PURE__ */ new Map();
    for (const table of tables) {
      const elementName = this.getElementNameFromTable(table);
      if (elementName) {
        const nameLower = elementName.toLowerCase();
        const count = (tableCounts.get(nameLower) || 0) + 1;
        tableCounts.set(nameLower, count);
        const tableId = `${nameLower}-${count}`;
        tableIds.set(table, tableId);
      }
    }
    const unreferencedTables = [];
    for (const table of tables) {
      const tableId = tableIds.get(table);
      if (tableId && !referencedIds.has(tableId)) {
        unreferencedTables.push(table);
      }
    }
    if (unreferencedTables.length === 1) {
      return unreferencedTables[0];
    }
    if (unreferencedTables.length > 1) {
      return unreferencedTables[unreferencedTables.length - 1];
    }
    return tables[tables.length - 1];
  }
  /**
   * Convert EDS HTML to custom element markup
   * Supports both author format (tables) and published format (div blocks)
   * Expects input wrapped in <body><header></header><main>content</main></body>
   */
  fromEDS(html) {
    const parser = new DOMParser();
    const doc3 = parser.parseFromString(html, "text/html");
    const main = doc3.body.querySelector("main");
    const root = main || doc3.body;
    const tables = this.findTables(root);
    if (tables.length > 0) {
      this.buildTableMap(tables);
      const rootTable = this.findRootTable(tables);
      const converted2 = this.convertTable(rootTable);
      return converted2 ? converted2.outerHTML : html;
    }
    const blocks = this.findBlocks(root);
    if (blocks.length === 0) {
      return html;
    }
    this.buildBlockMap(blocks);
    const rootBlock = this.findRootBlock(blocks);
    const converted = this.convertBlock(rootBlock);
    return converted.outerHTML;
  }
  /**
   * Convert EDS HTML to DOM element
   * Supports both author format (tables) and published format (div blocks)
   * Expects input wrapped in <body><header></header><main>content</main></body>
   */
  toElement(html) {
    const parser = new DOMParser();
    const doc3 = parser.parseFromString(html, "text/html");
    const main = doc3.body.querySelector("main");
    const root = main || doc3.body;
    const tables = this.findTables(root);
    if (tables.length > 0) {
      this.buildTableMap(tables);
      return this.convertTable(tables[0]);
    }
    const blocks = this.findBlocks(root);
    if (blocks.length === 0) {
      return root.firstElementChild;
    }
    this.buildBlockMap(blocks);
    return this.convertBlock(blocks[0]);
  }
};
function fromEds(input, options = {}) {
  const deserializer = new EDSBlockDeserializer();
  if (options.asElement) {
    return deserializer.toElement(input);
  }
  return deserializer.fromEDS(input);
}

// src/da/da-source.js
var BASE_URL = "https://admin.da.live";
var DASource = class {
  #accessToken = null;
  #aemToken = null;
  constructor(options = {}) {
    this.org = options.org || null;
    this.repo = options.repo || null;
    this.#accessToken = options.accessToken || null;
    this.#aemToken = options.aemToken || options.token || null;
  }
  get baseUrl() {
    if (!this.repo) return null;
    return `${BASE_URL}/source/${this.repo}`;
  }
  get listUrl() {
    if (!this.repo) return null;
    return `${BASE_URL}/list/${this.repo}`;
  }
  get copyUrl() {
    if (!this.repo) return null;
    return `${BASE_URL}/copy/${this.repo}`;
  }
  get moveUrl() {
    if (!this.repo) return null;
    return `${BASE_URL}/move/${this.repo}`;
  }
  get versionSourceUrl() {
    if (!this.repo) return null;
    return `${BASE_URL}/versionsource/${this.repo}`;
  }
  get versionListUrl() {
    if (!this.repo) return null;
    return `${BASE_URL}/versionlist/${this.repo}`;
  }
  setAccessToken(token) {
    this.#accessToken = token;
  }
  getAccessToken() {
    return this.#accessToken;
  }
  setAemToken(token) {
    this.#aemToken = token;
  }
  getAemToken() {
    return this.#aemToken;
  }
  #ensureConfig() {
    if (!this.org || !this.repo) {
      throw new Error("DA config not loaded. Set org and repo first.");
    }
    if (!this.#accessToken) {
      throw new Error("Access token not set.");
    }
  }
  #normalizePath(path) {
    const pathStr = String(path || "");
    let normalized = pathStr.replace(/^\/+/, "");
    if (this.repo && normalized.startsWith(this.repo)) {
      normalized = normalized.slice(this.repo.length).replace(/^\/+/, "");
    }
    if (!normalized.endsWith(".html") && !normalized.endsWith("/")) {
      normalized += ".html";
    }
    return normalized;
  }
  #normalizeDirectoryPath(path) {
    const pathStr = String(path || "");
    let normalized = pathStr.replace(/^\/+/, "").replace(/\/+$/, "");
    if (this.repo && normalized.startsWith(this.repo)) {
      normalized = normalized.slice(this.repo.length).replace(/^\/+/, "");
    }
    return normalized;
  }
  #authHeaders(extra = {}) {
    return {
      Authorization: `Bearer ${this.#accessToken}`,
      ...extra
    };
  }
  #aemAuthHeaders(extra = {}) {
    return {
      Authorization: `token ${this.#aemToken}`,
      ...extra
    };
  }
  /**
   * Build source URL handling both full paths (from list) and relative paths
   * Full paths start with /{org}/{repo}/... and should use BASE_URL/source directly
   * Relative paths need baseUrl which includes org/repo
   */
  #buildSourceUrl(path) {
    const pathStr = String(path || "");
    if (pathStr.startsWith("/")) {
      return `${BASE_URL}/source${pathStr}`;
    }
    const cleanPath = this.#stripOrgRepoPrefix(pathStr);
    const normalized = this.#normalizePath(cleanPath);
    return `${this.baseUrl}/${normalized}`;
  }
  /**
   * Check if path already contains org/repo prefix
   */
  #isFullPath(pathStr) {
    if (pathStr.startsWith("/")) return true;
    const repoPrefix = `${this.repo}/`;
    if (pathStr.startsWith(repoPrefix)) return true;
    if (this.org) {
      const orgRepoPrefix = `${this.org}/${this.repo}/`;
      if (pathStr.startsWith(orgRepoPrefix)) return true;
    }
    return false;
  }
  /**
   * Strip org/repo prefix from path if present
   */
  #stripOrgRepoPrefix(pathStr) {
    let cleaned = pathStr.replace(/^\/+/, "");
    if (this.org) {
      const orgRepoPrefix = `${this.org}/${this.repo}/`;
      if (cleaned.startsWith(orgRepoPrefix)) {
        return cleaned.slice(orgRepoPrefix.length);
      }
    }
    const repoPrefix = `${this.repo}/`;
    if (cleaned.startsWith(repoPrefix)) {
      return cleaned.slice(repoPrefix.length);
    }
    return cleaned;
  }
  /**
   * Build version list URL handling both full paths and relative paths
   */
  #buildVersionListUrl(path) {
    const pathStr = String(path || "");
    if (pathStr.startsWith("/")) {
      return `${BASE_URL}/versionlist${pathStr}`;
    }
    const cleanPath = this.#stripOrgRepoPrefix(pathStr);
    const normalized = this.#normalizePath(cleanPath);
    return `${this.versionListUrl}/${normalized}`;
  }
  /**
   * Build move URL handling both full paths (from list) and relative paths
   */
  #buildMoveUrl(path) {
    const pathStr = String(path || "");
    if (pathStr.startsWith("/")) {
      return `${BASE_URL}/move${pathStr}`;
    }
    const cleanPath = this.#stripOrgRepoPrefix(pathStr);
    const normalized = this.#normalizePath(cleanPath);
    return `${this.moveUrl}/${normalized}`;
  }
  /**
   * Get source content (sourceDetails)
   * GET /source/{org}/{repo}/{path}
   * @param {string} path - Path to the source content (can be full path from list or relative)
   * @returns {Promise<Object|null>} Document with content property, or null if not found
   */
  async getSource(path) {
    this.#ensureConfig();
    const url = this.#buildSourceUrl(path);
    const response = await fetch(url, {
      method: "GET",
      headers: this.#authHeaders()
    });
    if (response.status === 404) return null;
    if (!response.ok) {
      throw new Error(`Failed to get source: ${response.status} ${response.statusText}`);
    }
    const content = await response.text();
    const cleanPath = this.#stripOrgRepoPrefix(path);
    const normalizedPath = this.#normalizePath(cleanPath);
    return {
      path: normalizedPath,
      content,
      lastModified: response.headers.get("Last-Modified")
    };
  }
  /**
   * Create source content (createSource)
   * POST /source/{org}/{repo}/{path}
   * @param {string} path - Path to create the source at (can be full or relative)
   * @param {string|Blob} content - Content to store
   * @param {string} contentType - MIME type of the content (default: text/html)
   * @returns {Promise<Object>} Response with source and aem info
   */
  async createSource(path, content, contentType = "text/html") {
    this.#ensureConfig();
    const url = this.#buildSourceUrl(path);
    const formData = new FormData();
    const blob = content instanceof Blob ? content : new Blob([content], { type: contentType });
    formData.append("data", blob);
    const response = await fetch(url, {
      method: "POST",
      headers: this.#authHeaders(),
      body: formData
    });
    if (!response.ok) {
      throw new Error(`Failed to create source: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    const cleanPath = this.#stripOrgRepoPrefix(path);
    const normalizedPath = this.#normalizePath(cleanPath);
    return { path: normalizedPath, status: response.status, ...result };
  }
  /**
   * Delete source content (sourceDelete)
   * DELETE /source/{org}/{repo}/{path}
   * @param {string} path - Path to delete (can be full or relative)
   * @returns {Promise<boolean>} True if deleted successfully
   */
  async deleteSource(path) {
    this.#ensureConfig();
    const url = this.#buildSourceUrl(path);
    const response = await fetch(url, {
      method: "DELETE",
      headers: this.#authHeaders()
    });
    if (!response.ok && response.status !== 204) {
      throw new Error(`Failed to delete source: ${response.status} ${response.statusText}`);
    }
    return true;
  }
  /**
   * List sources (listDetails)
   * GET /list/{org}/{repo}/{path}
   * @param {string} path - Directory path to list
   * @returns {Promise<Array>} List of sources with editUrl, contentUrl, props
   */
  async listSources(path = "") {
    this.#ensureConfig();
    const normalizedPath = this.#normalizeDirectoryPath(path);
    const url = normalizedPath ? `${this.listUrl}/${normalizedPath}` : this.listUrl;
    const response = await fetch(url, {
      method: "GET",
      headers: this.#authHeaders({ Accept: "application/json" })
    });
    if (response.status === 404) return [];
    if (!response.ok) {
      throw new Error(`Failed to list sources: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    return data || [];
  }
  /**
   * Copy source content (copySource)
   * POST /copy/{org}/{repo}/{path}
   * @param {string} sourcePath - Source path to copy from
   * @param {string} destinationPath - Destination path to copy to
   * @returns {Promise<boolean>} True if copied successfully
   */
  async copySource(sourcePath, destinationPath) {
    this.#ensureConfig();
    const normalizedSourcePath = this.#normalizePath(sourcePath);
    const formData = new FormData();
    formData.append("destination", destinationPath);
    const response = await fetch(`${this.copyUrl}/${normalizedSourcePath}`, {
      method: "POST",
      headers: this.#authHeaders(),
      body: formData
    });
    if (!response.ok && response.status !== 204) {
      throw new Error(`Failed to copy source: ${response.status} ${response.statusText}`);
    }
    return true;
  }
  /**
   * Move source content (moveSource)
   * POST /move/{org}/{repo}/{path}
   * @param {string} sourcePath - Source path to move from
   * @param {string} destinationPath - Destination path to move to
   * @returns {Promise<boolean>} True if moved successfully
   */
  async moveSource(sourcePath, destinationPath) {
    this.#ensureConfig();
    const url = this.#buildMoveUrl(sourcePath);
    const formData = new FormData();
    formData.append("destination", destinationPath);
    const response = await fetch(url, {
      method: "POST",
      headers: this.#authHeaders(),
      body: formData
    });
    if (!response.ok && response.status !== 204) {
      throw new Error(`Failed to move source: ${response.status} ${response.statusText}`);
    }
    return true;
  }
  /**
   * Get source version (versionSource)
   * GET /versionsource/{org}/{repo}/{guid}
   * @param {string} guid - GUID of the version
   * @param {string} ext - File extension (e.g., "html")
   * @returns {Promise<Object|null>} Version content or null if not found
   */
  async getVersion(guid, ext = "html") {
    this.#ensureConfig();
    const response = await fetch(`${this.versionSourceUrl}/${guid}.${ext}`, {
      method: "GET",
      headers: this.#authHeaders()
    });
    if (response.status === 404) return null;
    if (!response.ok) {
      throw new Error(`Failed to get version: ${response.status} ${response.statusText}`);
    }
    const content = await response.text();
    return { guid, content };
  }
  /**
   * Create source version (versionCreateSource)
   * POST /versionsource/{org}/{repo}/{path}
   * @param {string} path - Path to create version for
   * @returns {Promise<Object>} Version info
   */
  async createVersion(path) {
    this.#ensureConfig();
    const normalizedPath = this.#normalizePath(path);
    const response = await fetch(`${this.versionSourceUrl}/${normalizedPath}`, {
      method: "POST",
      headers: this.#authHeaders()
    });
    if (!response.ok) {
      throw new Error(`Failed to create version: ${response.status} ${response.statusText}`);
    }
    const text = await response.text();
    if (!text) return { success: true };
    return JSON.parse(text);
  }
  /**
   * List source versions (versionList)
   * GET /versionlist/{org}/{repo}/{path}
   * @param {string} path - Path to list versions for
   * @returns {Promise<Array>} List of versions with timestamp, url, path, users
   */
  async listVersions(path) {
    this.#ensureConfig();
    const url = this.#buildVersionListUrl(path);
    const response = await fetch(url, {
      method: "GET",
      headers: this.#authHeaders({ Accept: "application/json" })
    });
    if (response.status === 404 || response.status === 204) return [];
    if (!response.ok) {
      throw new Error(`Failed to list versions: ${response.status} ${response.statusText}`);
    }
    const text = await response.text();
    if (!text) return [];
    const data = JSON.parse(text);
    return Array.isArray(data) ? data : [];
  }
  // AEM Admin API methods
  // Base URL for AEM Admin API (different from DA Admin API)
  get aemAdminBaseUrl() {
    return "https://admin.hlx.page";
  }
  /**
   * Preview a document via AEM Admin API
   * POST /preview/{org}/{site}/{ref}/{path}
   * @param {string} path - Document path
   * @param {string} ref - Git reference (branch), defaults to "main"
   * @returns {Promise<Object>} Preview result
   */
  async preview(path, ref = "main") {
    this.#ensureConfig();
    const normalizedPath = this.#normalizePath(path).replace(/\.html$/, "");
    const url = `${this.aemAdminBaseUrl}/preview/${this.repo}/${ref}/${normalizedPath}`;
    const response = await fetch(url, {
      method: "POST",
      headers: this.#aemAuthHeaders()
    });
    if (!response.ok) {
      throw new Error(`Failed to preview: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    return result;
  }
  /**
   * Publish a document via AEM Admin API
   * POST /live/{org}/{site}/{ref}/{path}
   * @param {string} path - Document path
   * @param {string} ref - Git reference (branch), defaults to "main"
   * @returns {Promise<Object>} Publish result
   */
  async publish(path, ref = "main") {
    this.#ensureConfig();
    const normalizedPath = this.#normalizePath(path).replace(/\.html$/, "");
    const url = `${this.aemAdminBaseUrl}/live/${this.repo}/${ref}/${normalizedPath}`;
    const response = await fetch(url, {
      method: "POST",
      headers: this.#aemAuthHeaders()
    });
    if (!response.ok) {
      throw new Error(`Failed to publish: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    return result;
  }
  /**
   * Unpublish a document via AEM Admin API
   * DELETE /live/{org}/{site}/{ref}/{path}
   * @param {string} path - Document path
   * @param {string} ref - Git reference (branch), defaults to "main"
   * @returns {Promise<Object>} Unpublish result
   */
  async unpublish(path, ref = "main") {
    this.#ensureConfig();
    const normalizedPath = this.#normalizePath(path).replace(/\.html$/, "");
    const url = `${this.aemAdminBaseUrl}/live/${this.repo}/${ref}/${normalizedPath}`;
    const response = await fetch(url, {
      method: "DELETE",
      headers: this.#aemAuthHeaders()
    });
    if (!response.ok) {
      throw new Error(`Failed to unpublish: ${response.status} ${response.statusText}`);
    }
    if (response.status === 204) {
      return { success: true };
    }
    const text = await response.text();
    if (!text) return { success: true };
    return JSON.parse(text);
  }
  // Alias methods for backward compatibility
  async getDocument(path) {
    return this.getSource(path);
  }
  async saveDocument(path, content) {
    return this.createSource(path, content);
  }
  async deleteDocument(path) {
    return this.deleteSource(path);
  }
  async listFolder(path = "") {
    return this.listSources(path);
  }
  async moveDocument(sourcePath, destinationPath) {
    return this.moveSource(sourcePath, destinationPath);
  }
  /**
   * Create a folder by creating a placeholder file inside it
   * DA doesn't have explicit folder creation - folders are implicit
   * @param {string} path - Folder path to create
   * @returns {Promise<Object>} Result with path
   */
  async createFolder(path) {
    this.#ensureConfig();
    const normalizedPath = this.#normalizeDirectoryPath(path);
    return { path: normalizedPath, success: true };
  }
  /**
   * Rename a document by moving it to a new path with a different name
   * @param {string} currentPath - Current document path
   * @param {string} newName - New name for the document (without .html extension)
   * @returns {Promise<Object>} Result with new path
   */
  async renameDocument(currentPath, newName) {
    const cleanPath = this.#stripOrgRepoPrefix(currentPath);
    const normalized = this.#normalizePath(cleanPath);
    const lastSlash = normalized.lastIndexOf("/");
    const parentDir = lastSlash > 0 ? normalized.substring(0, lastSlash) : "";
    const sanitizedName = String(newName || "").trim().replace(/\.html$/, "");
    const relativePath = parentDir ? `${parentDir}/${sanitizedName}.html` : `${sanitizedName}.html`;
    const destinationPath = `/${this.repo}/${relativePath}`;
    await this.moveSource(currentPath, destinationPath);
    return { path: relativePath, name: newName };
  }
};

// src/da/da-document-store.js
var daConfigCache = null;
var daConfigRequest = null;
var jwtConfigCache = null;
var jwtConfigRequest = null;
var DocumentStore = class {
  static observableActions = [
    "setIsSaving",
    "setIsLoading",
    "setIsInitializing",
    "setIsLoadingElements",
    "getDocumentsMarkdown",
    "createFoldersByPath",
    "moveByPath"
  ];
  static computedProperties = ["isBusy"];
  #accessTokenRequest = null;
  #writes = /* @__PURE__ */ new Set();
  #toastTargets = /* @__PURE__ */ new Set();
  #daSource = null;
  constructor() {
    this.org = null;
    this.repo = null;
    this.configLoaded = false;
    this.accessToken = null;
    this.aemToken = null;
    this.isInitializing = true;
    this.isSaving = false;
    this.isLoading = false;
    this.isLoadingElements = false;
    this.isMcpActive = false;
    this.localUserEmail = null;
    this.localUserName = null;
    this.localOwnerOrg = null;
    this.appStore = null;
    this.commentStore = null;
    this.apiBaseUrl = null;
    this.websocketUrl = null;
    this.#daSource = new DASource();
  }
  get baseUrl() {
    if (!this.repo) return null;
    return `https://admin.da.live/source/${this.repo}`;
  }
  get isBusy() {
    return this.#writes.size > 0;
  }
  async waitUntilIdle() {
    while (this.#writes.size) {
      const snapshot = Array.from(this.#writes);
      await Promise.allSettled(snapshot);
    }
  }
  #trackWrite(promise) {
    let trackedPromise;
    const finalize = () => {
      this.#writes.delete(trackedPromise);
      if (this.#writes.size === 0) this.setIsSaving(false);
    };
    trackedPromise = promise.finally(finalize);
    this.#writes.add(trackedPromise);
    this.setIsSaving(true);
    return trackedPromise;
  }
  /**
   * Load configuration from da.json
   */
  async loadConfig() {
    if (this.configLoaded) {
      return { org: this.org, repo: this.repo, token: this.aemToken };
    }
    if (daConfigCache) {
      this.org = daConfigCache.org;
      this.repo = daConfigCache.repo;
      this.aemToken = daConfigCache.token || null;
      this.configLoaded = true;
      return { org: this.org, repo: this.repo, token: this.aemToken };
    }
    if (daConfigRequest) {
      await daConfigRequest;
      if (daConfigCache) {
        this.org = daConfigCache.org;
        this.repo = daConfigCache.repo;
        this.aemToken = daConfigCache.token || null;
        this.configLoaded = true;
      }
      return { org: this.org, repo: this.repo, token: this.aemToken };
    }
    const request = (async () => {
      const response = await fetch("./da.json").catch((error) => {
        console.warn("Could not load da.json:", error);
        return null;
      });
      if (response?.ok) {
        const config = await response.json();
        daConfigCache = config;
        this.org = config.org;
        this.repo = config.repo;
        this.aemToken = config.token || null;
        this.configLoaded = true;
        return { org: this.org, repo: this.repo, token: this.aemToken };
      }
      return null;
    })();
    daConfigRequest = request;
    return request.finally(() => {
      if (daConfigRequest === request) {
        daConfigRequest = null;
      }
    });
  }
  /**
   * Get access token for DA API authentication
   */
  async getAccessToken() {
    if (this.accessToken) {
      return this.accessToken;
    }
    if (this.#accessTokenRequest) {
      return this.#accessTokenRequest;
    }
    const request = (async () => {
      const token = await this.#resolveAccessToken();
      if (token) {
        this.accessToken = token;
      }
      return this.accessToken;
    })();
    this.#accessTokenRequest = request;
    return request.finally(() => {
      if (this.#accessTokenRequest === request) {
        this.#accessTokenRequest = null;
      }
    });
  }
  async #resolveAccessToken() {
    if (typeof window !== "undefined") {
      const urlParams = new URLSearchParams(window.location.search);
      const mcpToken = urlParams.get("mcp-token") || sessionStorage.getItem("mcp-token");
      if (mcpToken) {
        this.accessToken = mcpToken;
        sessionStorage.setItem("mcp-token", mcpToken);
        this.isMcpActive = true;
        return mcpToken;
      }
      this.isMcpActive = false;
      const host = window.location?.hostname || "";
      if (host === "localhost" || host === "127.0.0.1" || host === "::1") {
        if (jwtConfigCache) {
          const token = jwtConfigCache?.accessToken ? String(jwtConfigCache.accessToken) : null;
          this.localUserEmail = jwtConfigCache?.email ? String(jwtConfigCache.email) : null;
          this.localUserName = jwtConfigCache?.name ? String(jwtConfigCache.name) : null;
          if (!this.accessToken && token) {
            this.accessToken = token;
          }
          if (this.accessToken) return this.accessToken;
        }
        if (jwtConfigRequest) {
          await jwtConfigRequest;
          return this.accessToken;
        }
        const request = (async () => {
          const response = await fetch("/jwt.json").catch((error) => {
            console.warn("Failed to load local jwt.json token:", error);
            return null;
          });
          if (response?.ok) {
            const data = await response.json();
            jwtConfigCache = data;
            const token = data?.accessToken ? String(data.accessToken) : null;
            this.localUserEmail = data?.email ? String(data.email) : null;
            this.localUserName = data?.name ? String(data.name) : null;
            if (!this.accessToken && token) {
              this.accessToken = token;
            }
          }
          return this.accessToken;
        })();
        jwtConfigRequest = request;
        return request.finally(() => {
          if (jwtConfigRequest === request) {
            jwtConfigRequest = null;
          }
        });
      }
      if (this.accessToken) return this.accessToken;
    }
    const ims = globalThis.adobeIMS;
    if (ims?.getAccessToken) {
      const token = await ims.getAccessToken().catch((error) => {
        console.error("Failed to acquire access token:", error);
        return null;
      });
      if (token) {
        return token;
      }
    }
    return this.accessToken;
  }
  /**
   * Initialize the store
   */
  async init() {
    await this.loadConfig();
    await this.getAccessToken();
    this.#daSource.org = this.org;
    this.#daSource.repo = this.repo;
    this.#daSource.setAccessToken(this.accessToken);
    this.#daSource.setAemToken(this.aemToken);
    this.setIsInitializing(false);
    return true;
  }
  setIsSaving(value) {
    this.isSaving = !!value;
  }
  setIsLoading(value) {
    this.isLoading = !!value;
  }
  setIsInitializing(value) {
    this.isInitializing = !!value;
  }
  setIsLoadingElements(value) {
    this.isLoadingElements = !!value;
  }
  /**
   * Register a toast target for notifications
   */
  registerToastTarget(target) {
    if (!target) return;
    this.#toastTargets.add(target);
  }
  /**
   * Unregister a toast target
   */
  unregisterToastTarget(target) {
    if (!target) return;
    this.#toastTargets.delete(target);
  }
  /**
   * Serialize an element to HTML string
   */
  serializeElement(element) {
    if (!element) return "";
    if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      const parts = [];
      const kids = Array.from(element.childNodes || []).filter(
        (n25) => n25.nodeType === Node.ELEMENT_NODE
      );
      for (const child of kids) {
        parts.push(child.outerHTML);
      }
      return parts.join("\n");
    }
    return element.outerHTML;
  }
  /**
   * Deserialize HTML string to element
   */
  deserializeElement(htmlString) {
    if (typeof htmlString !== "string") return null;
    const parser = new DOMParser();
    const doc3 = parser.parseFromString(htmlString, "text/html");
    const frag = document.createDocumentFragment();
    const children = Array.from(doc3.body.children || []);
    if (!children.length) return null;
    for (const child of children) {
      const clone = document.importNode?.(child, true) ?? child.cloneNode(true);
      frag.appendChild(clone);
    }
    return frag;
  }
  /**
   * Load API endpoint (compatibility stub - DA uses da.json config)
   */
  async loadApiEndpoint() {
    await this.loadConfig();
    this.apiBaseUrl = this.baseUrl;
    return this.apiBaseUrl;
  }
  /**
   * Load all elements into app store (stub for gallery compatibility)
   */
  async loadAllElementsInto(appStore, options = {}) {
    this.setIsLoadingElements(true);
    await this.waitUntilIdle();
    const view = appStore?.galleryView;
    const useFolderScope = view === "files";
    const folderPath = useFolderScope ? appStore?.currentFolderUrn ?? "" : "";
    const items = await this.listFolder(folderPath).catch(() => []);
    const docs = items.map((item) => {
      const itemPath = item.path || item.name || "";
      const isFolder = !item.ext || itemPath.endsWith("/");
      const name = item.name || itemPath.split("/").filter(Boolean).pop() || "Untitled";
      return {
        path: itemPath,
        urn: itemPath,
        // Alias for UI compatibility
        name,
        isFolder,
        lastModified: item.lastModified
      };
    });
    this.setIsLoadingElements(false);
    if (options.append) {
      appStore.appendSavedElements?.(docs || []);
    } else {
      appStore.setSavedElements?.(docs || []);
    }
    appStore.setIsReady?.(true);
    return docs;
  }
  /**
   * Save a document to DA
   * @param {Object|string} docOrHtml - Document object with {name, html, parentUrn} or HTML string
   * @param {Object} options - Options object (e.g., { create: true })
   * @returns {Promise<Object>} Response with path property
   */
  async saveDocument(docOrHtml, options = {}) {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    let html;
    let path;
    let name;
    let parentUrn;
    if (typeof docOrHtml === "object" && docOrHtml !== null) {
      html = docOrHtml.html || "";
      path = docOrHtml.path || "";
      name = docOrHtml.name || "";
      parentUrn = docOrHtml.parentUrn || "";
    } else {
      html = String(docOrHtml || "");
      path = typeof options === "string" ? options : "";
      name = path;
      parentUrn = "";
    }
    if (options.create && !path && name) {
      const slug = this.#generateSlug(name);
      path = parentUrn ? `${parentUrn}/${slug}` : slug;
    }
    const edsHtml = html ? toEds(html, { format: "html" }) : "";
    const savePromise = this.#daSource.saveDocument(path, edsHtml);
    const result = await this.#trackWrite(savePromise);
    return { ...result, path: result.path, urn: result.path, name };
  }
  /**
   * Generate a URL-safe slug from a name
   * @param {string} name - Document name
   * @returns {string} URL-safe slug with random suffix
   */
  #generateSlug(name) {
    const base2 = String(name || "untitled").toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").substring(0, 30) || "untitled";
    const suffix = Math.random().toString(36).substring(2, 7);
    return `${base2}-${suffix}`;
  }
  /**
   * Get a document from DA
   * @param {string} path - Document path (e.g., "drafts/my-element"), defaults to root
   * @returns {Promise<Object>} Document with html property
   */
  async getDocument(path = "") {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    this.setIsLoading(true);
    const result = await this.#daSource.getDocument(path);
    this.setIsLoading(false);
    if (!result) return null;
    const html = fromEds(result.content);
    const pathStr = result.path || path || "";
    const segments = pathStr.split("/").filter(Boolean);
    const lastSegment = segments[segments.length - 1] || "Untitled";
    const name = lastSegment.replace(/\.html$/, "");
    return {
      path: result.path,
      name,
      html,
      edsHtml: result.content,
      lastModified: result.lastModified
    };
  }
  /**
   * Get documents that reference this document (stub - DA doesn't support this)
   * @param {string} path - Document path
   * @param {boolean} recursive - Whether to search recursively
   * @param {number} depth - Search depth
   * @returns {Promise<Array>} Empty array (not supported in DA)
   */
  async getDocumentReferrers(path, recursive = false, depth = null) {
    return [];
  }
  /**
   * Delete a document from DA
   * @param {string} path - Document path, defaults to root
   * @returns {Promise<boolean>} True if deleted
   */
  async deleteDocument(path = "") {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    const deletePromise = this.#daSource.deleteDocument(path);
    return this.#trackWrite(deletePromise);
  }
  /**
   * List contents of a folder
   * @param {string} path - Folder path (e.g., "drafts")
   * @returns {Promise<Array>} List of items in folder
   */
  async listFolder(path = "") {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    this.setIsLoading(true);
    const items = await this.#daSource.listFolder(path);
    this.setIsLoading(false);
    return items;
  }
  /**
   * Create a folder
   * @param {string} path - Folder path to create
   * @returns {Promise<Object>} Response from DA API
   */
  async createFolder(path) {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    const createPromise = this.#daSource.createFolder(path);
    return this.#trackWrite(createPromise);
  }
  /**
   * Get list of versions for a document
   * @param {string} path - Document path, defaults to root
   * @returns {Promise<Array>} List of versions with timestamp, url, path, users
   */
  async getVersions(path = "") {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    return this.#daSource.listVersions(path);
  }
  /**
   * Create a new version of a document
   * @param {string} path - Document path, defaults to root
   * @returns {Promise<Object>} Version info
   */
  async createVersion(path = "") {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    const createPromise = this.#daSource.createVersion(path);
    return this.#trackWrite(createPromise);
  }
  /**
   * Get a specific version's content
   * @param {string} guid - Version GUID
   * @param {string} ext - File extension (default: "html")
   * @returns {Promise<Object|null>} Version content or null if not found
   */
  async getVersionContent(guid, ext = "html") {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    this.setIsLoading(true);
    const result = await this.#daSource.getVersion(guid, ext);
    this.setIsLoading(false);
    if (!result) return null;
    const html = fromEds(result.content);
    return {
      guid: result.guid,
      html,
      edsHtml: result.content
    };
  }
  /**
   * Restore a document to a specific version
   * @param {string} guid - Version GUID to restore
   * @param {string} path - Document path, defaults to root
   * @returns {Promise<Object>} Result of the restore operation
   */
  async restoreVersion(guid, path = "") {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    const version2 = await this.getVersionContent(guid);
    if (!version2) {
      throw new Error(`Version ${guid} not found`);
    }
    const savePromise = this.#daSource.saveDocument(path, version2.edsHtml);
    return this.#trackWrite(savePromise);
  }
  /**
   * Update document name by moving it to a new path
   * @param {string} path - Current document path
   * @param {string} newName - New name for the document
   * @param {string} html - HTML content (unused for DA, rename is path-based)
   * @returns {Promise<Object>} Result with new path and name
   */
  async updateDocumentName(path, newName, html) {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    const sanitizedName = String(newName || "").trim().replace(/\.html$/, "");
    if (!sanitizedName) return null;
    const renamePromise = this.#daSource.renameDocument(path, sanitizedName);
    const result = await this.#trackWrite(renamePromise);
    return { path: result.path, urn: result.path, name: newName };
  }
  /**
   * Get documents as markdown table (for MCP tools)
   * @param {string} parentPath - Parent folder path (null for root)
   * @param {number} limit - Maximum number of documents to return
   * @param {number} offset - Number of documents to skip
   * @returns {Promise<string>} Markdown table of documents
   */
  async getDocumentsMarkdown(parentPath = null, limit = 50, offset4 = 0) {
    const folderPath = parentPath || "";
    const items = await this.listFolder(folderPath);
    if (!items || items.length === 0) {
      return "No documents found.";
    }
    const paginatedItems = items.slice(offset4, offset4 + limit);
    if (paginatedItems.length === 0) {
      return "No documents found.";
    }
    let markdown = "| Name | Last Modified | Type | Path |\n| :--- | :--- | :--- | :--- |\n";
    for (const item of paginatedItems) {
      const itemPath = item.path || item.name || "";
      const isFolder = !item.ext || itemPath.endsWith("/");
      const name = item.name || itemPath.split("/").filter(Boolean).pop() || "Untitled";
      const type = isFolder ? "Folder" : "Document";
      const date = item.lastModified ? new Date(item.lastModified).toLocaleString() : "Unknown";
      const url = isFolder ? "#" : `http://localhost:3001/?id=${encodeURIComponent(itemPath)}`;
      markdown += `| [${name}](${url}) | ${date} | ${type} | \`${itemPath}\` |
`;
    }
    const hasMore = items.length > offset4 + limit;
    if (hasMore) {
      const nextOffset = offset4 + limit;
      const parentParam = parentPath ? `&parentUrn=${encodeURIComponent(parentPath)}` : "";
      markdown += `

[Load More Documents](mcp://experience-elements/list_documents?offset=${nextOffset}&limit=${limit}${parentParam})`;
    }
    return markdown;
  }
  /**
   * Create folders by path (for MCP tools)
   * Creates nested folders if path contains slashes
   * @param {string} name - Folder name or path (e.g., "folder/subfolder")
   * @param {string} parentPath - Parent folder path
   * @returns {Promise<Object>} Last created folder with path and urn
   */
  async createFoldersByPath(name, parentPath = null) {
    const parts = String(name || "").split("/").filter(Boolean);
    if (parts.length === 0) {
      throw new Error("Folder name is required");
    }
    let currentPath = parentPath || "";
    let lastFolder = null;
    for (const part of parts) {
      const folderPath = currentPath ? `${currentPath}/${part}` : part;
      const items = await this.listFolder(currentPath);
      const existingFolder = items.find(
        (item) => (!item.ext || item.path?.endsWith("/")) && (item.name === part || item.path === folderPath || item.path === `${folderPath}/`)
      );
      if (existingFolder) {
        currentPath = existingFolder.path?.replace(/\/$/, "") || folderPath;
        lastFolder = { path: currentPath, urn: currentPath, name: part };
      } else {
        await this.createFolder(folderPath);
        currentPath = folderPath;
        lastFolder = { path: folderPath, urn: folderPath, name: part };
      }
    }
    return lastFolder;
  }
  /**
   * Move documents to a target folder (for MCP tools)
   * Target can be a path or existing folder path
   * @param {Array<string>} paths - Array of document paths to move
   * @param {string} target - Target folder path (will be created if doesn't exist)
   * @returns {Promise<Object>} Result with targetUrn
   */
  async moveByPath(paths, target) {
    if (!Array.isArray(paths) || paths.length === 0) {
      throw new Error("paths array is required");
    }
    if (!target) {
      throw new Error("target is required");
    }
    const targetPath = String(target).replace(/\/+$/, "");
    const movePromises = [];
    for (const sourcePath of paths) {
      const cleanSource = String(sourcePath).replace(/^\/+/, "");
      const fileName = cleanSource.split("/").filter(Boolean).pop() || "";
      if (!fileName) continue;
      const destinationPath = `/${this.repo}/${targetPath}/${fileName}`;
      const movePromise = this.#daSource.moveDocument(sourcePath, destinationPath);
      movePromises.push(this.#trackWrite(movePromise));
    }
    await Promise.all(movePromises);
    return { targetUrn: targetPath };
  }
  /**
   * Preview a document via AEM Admin API
   * @param {string} path - Document path
   * @returns {Promise<Object>} Result with preview URL
   */
  async previewDocument(path) {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    const result = await this.#daSource.preview(path);
    return result;
  }
  /**
   * Publish a document via AEM Admin API
   * @param {string} path - Document path
   * @returns {Promise<Object>} Result with published URL
   */
  async publishDocument(path) {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    const result = await this.#daSource.publish(path);
    return result;
  }
  /**
   * Unpublish a document via AEM Admin API
   * @param {string} path - Document path
   * @returns {Promise<Object>} Result
   */
  async unpublishDocument(path) {
    if (!this.baseUrl) {
      throw new Error("DA config not loaded. Call init() first.");
    }
    const result = await this.#daSource.unpublish(path);
    return result;
  }
  /**
   * Get documents list (for compatibility with MCP tools)
   * @param {string} parentPath - Parent folder path (null for root)
   * @param {Object} opts - Options (limit, offset)
   * @returns {Promise<Array>} List of documents
   */
  async getDocuments(parentPath = null, opts = {}) {
    const folderPath = parentPath || "";
    const items = await this.listFolder(folderPath);
    const docs = items.map((item) => {
      const itemPath = item.path || item.name || "";
      const isFolder = !item.ext || itemPath.endsWith("/");
      const name = item.name || itemPath.split("/").filter(Boolean).pop() || "Untitled";
      return {
        path: itemPath,
        urn: itemPath,
        name,
        isFolder,
        lastModified: item.lastModified
      };
    });
    const offset4 = opts.offset || 0;
    const limit = opts.limit || docs.length;
    return docs.slice(offset4, offset4 + limit);
  }
};
makeObservable(DocumentStore);

// src/stores/template-store.js
var TemplateStore = class {
  static observableActions = [
    "loadTemplates",
    "addTemplate",
    "removeTemplate",
    "clearTemplates",
    "fetchTemplateContent",
    "setTemplatePreview"
  ];
  #pendingRequests = /* @__PURE__ */ new Map();
  templates = [
    ["Compare 2 merch cards", "./templates/compare-cards-2.html"],
    ["Compare 3 merch cards", "./templates/compare-cards-3.html"],
    ["Single merch card", "./templates/single-card.html"],
    ["CC Pro - subscribe modal", "./templates/subscribe-all-plans-3.html"],
    ["ACOM remove objects aside", "./templates/acom-aside-remove-objects.html"],
    ["ACOM action tile", "./templates/acom-action-tile.html"],
    ["ACOM hero marquee", "./templates/acom-hero-marquee.html"]
  ];
  templatePreviews = /* @__PURE__ */ new Map();
  async init() {
    return true;
  }
  loadTemplates(templateSources) {
    if (!Array.isArray(templateSources)) return this.templates;
    this.templates = templateSources.map(([title, url]) => [title, url]);
    notify(this);
    return this.templates;
  }
  addTemplate(template) {
    if (!template.title || !template.url) {
      console.warn("Template must have both title and url");
      return;
    }
    this.templates = [...this.templates, [template.title, template.url]];
    notify(this);
  }
  removeTemplate(templateUrl) {
    const url = String(templateUrl || "");
    this.templates = this.templates.filter(([_2, u36]) => u36 !== url);
    const next = new Map(this.templatePreviews);
    next.delete(url);
    this.templatePreviews = next;
    notify(this);
  }
  clearTemplates() {
    this.templates = [];
    this.templatePreviews = /* @__PURE__ */ new Map();
    notify(this);
  }
  getTemplatePreview(url) {
    return this.templatePreviews.get(url) || null;
  }
  setTemplatePreview(url, html) {
    const next = new Map(this.templatePreviews);
    next.set(url, html);
    this.templatePreviews = next;
    notify(this);
  }
  async fetchTemplateContent(url) {
    const urlString = typeof url === "string" ? url : String(url || "");
    if (!urlString) return null;
    if (this.templatePreviews.has(urlString)) {
      return this.templatePreviews.get(urlString);
    }
    if (this.#pendingRequests.has(urlString)) {
      return this.#pendingRequests.get(urlString);
    }
    const requestPromise = (async () => {
      try {
        const response = await fetch(urlString);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const content = await response.text();
        this.setTemplatePreview(urlString, content);
        return content;
      } catch (error) {
        console.error(`Failed to fetch template "${urlString}":`, error);
        return null;
      } finally {
        this.#pendingRequests.delete(urlString);
      }
    })();
    this.#pendingRequests.set(urlString, requestPromise);
    return requestPromise;
  }
};
makeObservable(TemplateStore);

// src/stores/user-store.js
var UserStore = class {
  static observableActions = [
    "setCurrentUser",
    "updateCurrentUser",
    "addUser",
    "removeUser",
    "updateUser",
    "setUserPresence",
    "clearUsers",
    "setUsers",
    "updateUserActivity",
    "setError"
  ];
  static computedProperties = [
    "allUsers",
    "activeUsers",
    "currentUserInfo",
    "usersList",
    "usersByEmail",
    "onlineUsers",
    "offlineUsers",
    "isAuthenticated"
  ];
  // Error state
  error = null;
  // Current user information
  currentUser = {
    email: "",
    displayName: "",
    avatar: "",
    color: "",
    // Unique color for user indicators
    ownerOrg: "",
    isActive: true,
    lastActivity: /* @__PURE__ */ new Date()
  };
  // All users map (email -> user info) - excluding current user
  users = /* @__PURE__ */ new Map();
  // User presence tracking (email -> presence info)
  userPresence = /* @__PURE__ */ new Map();
  /**
   * Set the error state
   */
  setError(error) {
    this.error = error;
  }
  /**
   * Set the current user
   */
  setCurrentUser(email, displayName = "", ownerOrg = "") {
    const color = this.generateUserColor(email);
    const existingOrg = this.currentUser?.ownerOrg || "";
    const normalizedOrg = typeof ownerOrg === "string" && ownerOrg.trim() ? ownerOrg.trim() : existingOrg;
    this.currentUser = {
      email,
      displayName: displayName || this.extractNameFromEmail(email),
      avatar: "",
      // No avatar support - using initials instead
      color,
      ownerOrg: normalizedOrg,
      isActive: true,
      lastActivity: /* @__PURE__ */ new Date()
    };
    this.persistCurrentUser();
    return this.currentUser;
  }
  /**
   * Ensure the current user is initialized from available sources.
   * Priority: previously saved current-user -> legacy keys -> default,
   * then attempt to update from IMS profile asynchronously if available.
   */
  ensureInitialized() {
    if (this.currentUser && this.currentUser.email) return;
    if (this.loadCurrentUser && this.loadCurrentUser()) {
      this.initFromIMSIfAvailable?.();
      return;
    }
    const storage = typeof window !== "undefined" ? window.localStorage : null;
    const savedEmail = storage?.getItem?.("user-email");
    const savedName = storage?.getItem?.("user-display-name");
    const savedOrg = storage?.getItem?.("user-owner-org");
    if (savedEmail) {
      this.setCurrentUser(
        savedEmail,
        savedName || this.extractNameFromEmail(savedEmail),
        savedOrg || ""
      );
      this.initFromIMSIfAvailable?.();
      return;
    }
    this.initFromIMSIfAvailable?.();
  }
  /**
   * If IMS is available in the environment, try to populate/refresh user
   * information. This runs asynchronously and does not block UI rendering.
   */
  initFromIMSIfAvailable() {
    const ims = typeof window !== "undefined" ? window.adobeIMS : null;
    if (!ims || typeof ims.getProfile !== "function") return;
    ims.getProfile().then((profile) => {
      if (!profile) return;
      const email = profile.email || profile.userId || this.currentUser.email;
      const displayName = profile.displayName || profile.name || this.extractNameFromEmail(email);
      const ownerOrg = profile?.ownerOrg;
      this.currentUser.ownerOrg;
      if (email && email !== this.currentUser.email) {
        this.setCurrentUser(email, displayName, ownerOrg);
      } else {
        const updates = { displayName };
        if (typeof ownerOrg === "string" && ownerOrg.trim()) {
          updates.ownerOrg = ownerOrg.trim();
        }
        this.updateCurrentUser(updates);
      }
    });
  }
  /**
   * Update current user information
   */
  updateCurrentUser(updates) {
    const merged = {
      ...this.currentUser,
      ...updates,
      lastActivity: /* @__PURE__ */ new Date()
    };
    if (typeof merged.ownerOrg === "string") {
      merged.ownerOrg = merged.ownerOrg.trim();
    }
    this.currentUser = merged;
    this.persistCurrentUser();
  }
  /**
   * Add a user (does not make them current)
   */
  addUser(email, displayName = "") {
    const color = this.generateUserColor(email);
    const user = {
      email,
      displayName: displayName || this.extractNameFromEmail(email),
      avatar: "",
      // No avatar support - using initials instead
      color,
      isActive: false,
      lastActivity: /* @__PURE__ */ new Date()
    };
    this.users.set(email, user);
    this.userPresence.set(email, {
      online: false,
      cursor: null,
      selectedElement: null,
      lastSeen: /* @__PURE__ */ new Date()
    });
    return user;
  }
  /**
   * Remove a user
   */
  removeUser(email) {
    this.users.delete(email);
    this.userPresence.delete(email);
  }
  /**
   * Update a user's information
   */
  updateUser(email, updates) {
    const user = this.users.get(email);
    if (user) {
      this.users.set(email, {
        ...user,
        ...updates,
        lastActivity: /* @__PURE__ */ new Date()
      });
    }
  }
  /**
   * Set user presence information
   */
  setUserPresence(email, presence) {
    const currentPresence = this.userPresence.get(email) || {};
    this.userPresence.set(email, {
      ...currentPresence,
      ...presence,
      lastSeen: /* @__PURE__ */ new Date()
    });
  }
  /**
   * Update user activity timestamp
   */
  updateUserActivity(email) {
    if (email === this.currentUser.email) {
      this.currentUser.lastActivity = /* @__PURE__ */ new Date();
    } else {
      const user = this.users.get(email);
      if (user) {
        user.lastActivity = /* @__PURE__ */ new Date();
        this.users.set(email, user);
      }
    }
    const presence = this.userPresence.get(email);
    if (presence) {
      presence.lastSeen = /* @__PURE__ */ new Date();
      this.userPresence.set(email, presence);
    }
  }
  /**
   * Clear all users (except current)
   */
  clearUsers() {
    this.users.clear();
    this.userPresence.clear();
  }
  /**
   * Set multiple users at once (for loading from storage/API)
   */
  setUsers(usersList) {
    this.clearUsers();
    for (const user of usersList) {
      if (user.email !== this.currentUser.email) {
        this.addUser(user.email, user.displayName);
        if (user.presence) {
          this.setUserPresence(user.email, user.presence);
        }
      }
    }
  }
  /**
   * Get all users (current + others)
   */
  get allUsers() {
    const allUsers = [this.currentUser];
    for (const user of this.users.values()) {
      allUsers.push(user);
    }
    return allUsers;
  }
  /**
   * Get active users (recently active)
   */
  get activeUsers() {
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1e3);
    return this.allUsers.filter(
      (user) => user.lastActivity > fiveMinutesAgo
    );
  }
  /**
   * Get current user info
   */
  get currentUserInfo() {
    return this.currentUser;
  }
  /**
   * Get list of all users (excluding current)
   */
  get usersList() {
    return Array.from(this.users.values());
  }
  /**
   * Get users indexed by email
   */
  get usersByEmail() {
    const map2 = /* @__PURE__ */ new Map();
    map2.set(this.currentUser.email, this.currentUser);
    for (const [email, user] of this.users) {
      map2.set(email, user);
    }
    return map2;
  }
  /**
   * Get online users
   */
  get onlineUsers() {
    const online = [];
    online.push(this.currentUser);
    for (const [email, user] of this.users) {
      const presence = this.userPresence.get(email);
      if (presence?.online) {
        online.push(user);
      }
    }
    return online;
  }
  /**
   * Get offline users
   */
  get offlineUsers() {
    const offline = [];
    for (const [email, user] of this.users) {
      const presence = this.userPresence.get(email);
      if (!presence?.online) {
        offline.push(user);
      }
    }
    return offline;
  }
  /**
   * Check if the user is authenticated (has an email)
   */
  get isAuthenticated() {
    return !!this.currentUser?.email;
  }
  /**
   * Get user by email
   */
  getUserByEmail(email) {
    if (!email) return null;
    if (email === this.currentUser.email) {
      return this.currentUser;
    }
    return this.users.get(email) || null;
  }
  /**
   * Get user avatar URL (always empty now - using initials instead)
   */
  getUserAvatar(email) {
    return "";
  }
  /**
   * Get user display name or extract from email
   */
  getUserDisplayName(email) {
    const user = this.getUserByEmail(email);
    return user?.displayName || this.extractNameFromEmail(email);
  }
  /**
   * Get user color for indicators
   */
  getUserColor(email) {
    const user = this.getUserByEmail(email);
    return user?.color || this.generateUserColor(email);
  }
  /**
   * Get user initials
   */
  getUserInitials(email) {
    const displayName = this.getUserDisplayName(email);
    if (!displayName) return "?";
    const parts = displayName.split(" ");
    if (parts.length >= 2) {
      return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
    }
    return displayName.substring(0, 2).toUpperCase();
  }
  /**
   * Check if user is online
   */
  isUserOnline(email) {
    if (email === this.currentUser.email) {
      return true;
    }
    const presence = this.userPresence.get(email);
    return presence?.online || false;
  }
  /**
   * Extract name from email
   */
  extractNameFromEmail(email) {
    if (!email) return "Unknown User";
    const [localPart] = email.split("@");
    return localPart.replace(/[._-]/g, " ").replace(/\b\w/g, (char) => char.toUpperCase());
  }
  /**
   * Generate a consistent color for a user based on their email
   */
  generateUserColor(email) {
    if (!email) return "#808080";
    const colors = [
      "#FF6B6B",
      // Red
      "#4ECDC4",
      // Teal
      "#45B7D1",
      // Blue
      "#96CEB4",
      // Green
      "#FECA57",
      // Yellow
      "#9B59B6",
      // Purple
      "#FD79A8",
      // Pink
      "#A29BFE",
      // Lavender
      "#6C5CE7",
      // Violet
      "#00B894",
      // Mint
      "#FDCB6E",
      // Orange
      "#E17055",
      // Coral
      "#74B9FF",
      // Sky Blue
      "#A3CB38",
      // Lime
      "#FF7675",
      // Light Red
      "#2D3436"
      // Dark Gray
    ];
    let hash = 0;
    for (let i21 = 0; i21 < email.length; i21++) {
      hash = email.charCodeAt(i21) + ((hash << 5) - hash);
    }
    return colors[Math.abs(hash) % colors.length];
  }
  /**
   * Load current user from localStorage
   */
  loadCurrentUser() {
    const storage = typeof window !== "undefined" ? window.localStorage : null;
    const stored = storage?.getItem?.("current-user");
    if (stored) {
      const user = JSON.parse(stored);
      const legacyOrg = storage?.getItem?.("user-owner-org") || "";
      const storedOrg = typeof user.ownerOrg === "string" ? user.ownerOrg : "";
      this.currentUser = {
        ...this.currentUser,
        ...user,
        ownerOrg: storedOrg || legacyOrg || "",
        lastActivity: new Date(user.lastActivity || Date.now())
      };
      return true;
    }
    return false;
  }
  /**
   * Persist current user to localStorage
   */
  persistCurrentUser() {
    const storage = typeof window !== "undefined" ? window.localStorage : null;
    storage?.setItem?.("current-user", JSON.stringify({
      email: this.currentUser.email,
      displayName: this.currentUser.displayName,
      avatar: this.currentUser.avatar,
      color: this.currentUser.color,
      ownerOrg: this.currentUser.ownerOrg || "",
      lastActivity: this.currentUser.lastActivity.toISOString()
    }));
    storage?.setItem?.("user-owner-org", this.currentUser.ownerOrg || "");
  }
  /**
   * Export users for persistence
   */
  exportUsers() {
    return {
      currentUser: {
        ...this.currentUser,
        lastActivity: this.currentUser.lastActivity.toISOString()
      },
      users: Array.from(this.users.entries()).map(([email, user]) => ({
        ...user,
        lastActivity: user.lastActivity.toISOString()
      })),
      presence: Array.from(this.userPresence.entries()).map(([email, presence]) => ({
        email,
        ...presence,
        lastSeen: presence.lastSeen.toISOString()
      }))
    };
  }
  /**
   * Import users from persistence
   */
  importUsers(data) {
    if (!data) return;
    if (data.currentUser) {
      this.setCurrentUser(
        data.currentUser.email,
        data.currentUser.displayName,
        data.currentUser.ownerOrg || ""
      );
    }
    if (data.users || data.remoteUsers) {
      const usersList = data.users || data.remoteUsers;
      for (const user of usersList) {
        this.addUser(user.email, user.displayName);
      }
    }
    if (data.presence) {
      for (const presenceData of data.presence) {
        const { email, ...presence } = presenceData;
        this.setUserPresence(email, {
          ...presence,
          lastSeen: new Date(presence.lastSeen)
        });
      }
    }
  }
};
makeObservable(UserStore);

// src/stores/comment-store.js
var randomUUID = () => globalThis.crypto?.randomUUID?.();
var createAnchorId = () => {
  const id = randomUUID();
  return id || `cmt-${Math.random().toString(36).slice(2, 10)}-${Date.now().toString(36)}`;
};
var createCommentId = () => {
  const id = randomUUID();
  return id || `c_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
};
var CommentStore = class {
  // Attach to EditorStore for element selection, autosave, etc.
  editorStore = null;
  static observableActions = [
    "openCommentsPanel",
    "closeCommentsPanel",
    "toggleCommentsPanel",
    "setComments",
    "addCommentForEditingElement",
    "updateComment",
    "removeComment",
    "setHoveredComment",
    "setSelectedComment",
    "ensureCommentAnchor",
    "regenerateAnchors"
  ];
  static computedProperties = ["canComment"];
  constructor(editorStore) {
    this.editorStore = editorStore || null;
  }
  // State
  comments = [];
  commentsPanelOpen = false;
  hoveredCommentId = null;
  selectedCommentId = null;
  // Whether current selection supports comments.
  // Comments are allowed on any selected element within the editor canvas.
  get canComment() {
    const el = this.editorStore?.editingElement;
    if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
    if (this.editorStore?.slotOnlySelection) return false;
    const host = this.editorStore?.editorElement || null;
    if (!host) return !!el;
    return host.contains(el);
  }
  openCommentsPanel() {
    this.commentsPanelOpen = true;
  }
  closeCommentsPanel() {
    this.commentsPanelOpen = false;
  }
  toggleCommentsPanel() {
    this.commentsPanelOpen = !this.commentsPanelOpen;
  }
  setComments(list, options = {}) {
    const normalize2 = (c33) => {
      if (!c33) return null;
      const id = String(c33.id || "");
      const targetId = String(c33.targetId || "");
      const text = String(c33.text || "");
      const status = c33.status === "resolved" ? "resolved" : "open";
      const createdAt = c33.createdAt ? String(c33.createdAt) : (/* @__PURE__ */ new Date()).toISOString();
      const updatedAt = c33.updatedAt ? String(c33.updatedAt) : createdAt;
      const author = c33.author ? String(c33.author) : null;
      const authorEmail = c33.authorEmail ? String(c33.authorEmail) : null;
      return {
        id,
        targetId,
        text,
        status,
        createdAt,
        updatedAt,
        ...author ? { author } : {},
        ...authorEmail ? { authorEmail } : {}
      };
    };
    const arr = Array.isArray(list) ? list.map(normalize2).filter(Boolean) : [];
    const prev = Array.isArray(this.comments) ? this.comments : [];
    this.comments = arr;
    if (!options.silent) {
      const changed = (() => {
        if (prev.length !== arr.length) return true;
        for (let i21 = 0; i21 < arr.length; i21++) {
          const a23 = arr[i21];
          const b12 = prev[i21];
          if (!b12) return true;
          if (a23.id !== b12.id || a23.targetId !== b12.targetId || a23.text !== b12.text || a23.status !== b12.status || a23.author !== b12.author || a23.authorEmail !== b12.authorEmail)
            return true;
        }
        return false;
      })();
      if (changed) this.editorStore?.scheduleAutoSave?.();
    }
  }
  // Ensure the element has an anchor and return it
  ensureCommentAnchor(element) {
    if (!element || !element.setAttribute) return null;
    let id = element.getAttribute("data-ee-comment-id");
    if (!id) {
      id = createAnchorId();
      element.setAttribute("data-ee-comment-id", id);
      this.editorStore?.scheduleAutoSave?.();
    }
    return id;
  }
  addCommentForEditingElement(text) {
    const el = this.editorStore?.editingElement;
    const message = (text || "").toString().trim();
    if (!el || !message) return;
    const slotSelected = !!this.editorStore?.slotOnlySelection;
    const host = this.editorStore?.editorElement || null;
    const allowed = !!el && !slotSelected && (!!host ? host.contains(el) : true);
    if (!allowed) return;
    const targetId = this.ensureCommentAnchor(el);
    if (!targetId) return;
    const id = createCommentId();
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const usr = host?.userStore?.currentUser || null;
    const author = usr?.displayName || usr?.email || null;
    const authorEmail = usr?.email || null;
    const comment = { id, targetId, text: message, status: "open", createdAt: now, updatedAt: now, ...author ? { author } : {}, ...authorEmail ? { authorEmail } : {} };
    this.comments = [...this.comments, comment];
    this.selectedCommentId = id;
    this.openCommentsPanel();
    this.editorStore?.scheduleAutoSave?.();
  }
  updateComment(id, patch) {
    if (!id) return;
    const idx = this.comments.findIndex((c33) => c33.id === id);
    if (idx < 0) return;
    const prev = this.comments[idx];
    const next = {
      ...prev,
      ...patch || {},
      status: patch && patch.status === "resolved" ? "resolved" : patch && patch.status === "open" ? "open" : prev.status,
      text: patch && typeof patch.text === "string" ? patch.text : prev.text,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const copy2 = this.comments.slice();
    copy2[idx] = next;
    this.comments = copy2;
    this.editorStore?.scheduleAutoSave?.();
  }
  removeComment(id) {
    if (!id) return;
    this.comments = this.comments.filter((c33) => c33.id !== id);
    if (this.hoveredCommentId === id) this.hoveredCommentId = null;
    if (this.selectedCommentId === id) this.selectedCommentId = null;
    this.editorStore?.scheduleAutoSave?.();
  }
  setHoveredComment(id) {
    this.hoveredCommentId = id || null;
  }
  setSelectedComment(id) {
    this.selectedCommentId = id || null;
  }
  // Regenerate anchors in a cloned subtree
  regenerateAnchors(node) {
    const walk = (n25) => {
      if (!n25 || n25.nodeType !== Node.ELEMENT_NODE) return;
      if (n25.hasAttribute && n25.hasAttribute("data-ee-comment-id")) {
        const newId = createAnchorId();
        n25.setAttribute("data-ee-comment-id", newId);
      }
      Array.from(n25.children || []).forEach(walk);
    };
    walk(node);
  }
};
makeObservable(CommentStore);

// src/stores/version-store.js
function extractGuidFromUrl(url) {
  if (!url) return null;
  const match = url.match(/\/versionsource\/[^/]+\/[^/]+\/([^/.]+)/);
  return match ? match[1] : null;
}
function formatTimestamp(timestamp) {
  if (!timestamp) return (/* @__PURE__ */ new Date()).toISOString();
  return new Date(timestamp).toISOString();
}
var VersionStore = class {
  static observableActions = [
    "openVersionsPanel",
    "closeVersionsPanel",
    "toggleVersionsPanel",
    "setVersions",
    "setIsLoading",
    "createVersion",
    "refreshVersions",
    "setSelectedVersionId",
    "restoreVersionById"
  ];
  constructor() {
    this.editorStore = null;
    this.documentStore = null;
    this.commentStore = null;
  }
  // State
  versionsPanelOpen = false;
  isLoading = false;
  versions = [];
  selectedVersionId = null;
  openVersionsPanel() {
    this.versionsPanelOpen = true;
    this.commentStore?.closeCommentsPanel?.();
  }
  closeVersionsPanel() {
    this.versionsPanelOpen = false;
  }
  toggleVersionsPanel() {
    this.versionsPanelOpen = !this.versionsPanelOpen;
    if (this.versionsPanelOpen) {
      this.commentStore?.closeCommentsPanel?.();
    }
  }
  setIsLoading(value) {
    this.isLoading = !!value;
  }
  /**
   * Set versions from DA API response format
   * DA API returns: { timestamp, url, path, users[] }
   * We normalize to: { id (guid), created, path, users }
   */
  setVersions(list) {
    const arr = Array.isArray(list) ? list.map((v6) => ({
      id: extractGuidFromUrl(v6.url) || String(v6.timestamp || ""),
      url: v6.url || null,
      path: v6.path || null,
      created: formatTimestamp(v6.timestamp),
      users: Array.isArray(v6.users) ? v6.users : []
    })) : [];
    this.versions = arr;
  }
  setSelectedVersionId(id) {
    this.selectedVersionId = id || null;
  }
  async restoreVersionById(versionId) {
    const path = this.editorStore?.currentElementId;
    if (!path) return { success: false, error: "No current element" };
    await this.documentStore.restoreVersion(versionId, path);
    return { success: true };
  }
  async refreshVersions() {
    const path = this.editorStore?.currentElementId;
    if (!path) return [];
    this.setIsLoading(true);
    const list = await this.documentStore.getVersions(path).finally(() => this.setIsLoading(false));
    this.setVersions(list);
    return list;
  }
  async createVersion() {
    const path = this.editorStore?.currentElementId;
    if (!path) return null;
    const ver = await this.documentStore.createVersion(path);
    await this.refreshVersions();
    return ver;
  }
};
makeObservable(VersionStore);

// src/stores/used-in-store.js
var UsedInStore = class {
  static observableActions = [
    "openUsedInPanel",
    "closeUsedInPanel",
    "toggleUsedInPanel",
    "setIsLoading",
    "setItems",
    "refreshFor"
  ];
  constructor() {
    this.documentStore = null;
    this.editorStore = null;
    this.commentStore = null;
    this.versionStore = null;
  }
  // State
  panelOpen = false;
  isLoading = false;
  items = [];
  openUsedInPanel() {
    this.panelOpen = true;
    this.commentStore?.closeCommentsPanel?.();
    this.versionStore?.closeVersionsPanel?.();
  }
  closeUsedInPanel() {
    this.panelOpen = false;
  }
  toggleUsedInPanel() {
    this.panelOpen = !this.panelOpen;
    if (this.panelOpen) {
      this.commentStore?.closeCommentsPanel?.();
      this.versionStore?.closeVersionsPanel?.();
      const urn = this.editorStore?.currentElementId;
      if (urn) this.refreshFor(urn);
    }
  }
  setIsLoading(v6) {
    this.isLoading = !!v6;
  }
  setItems(list) {
    const norm = Array.isArray(list) ? list.map((d22) => ({
      urn: String(d22.urn || d22.id || d22.target || d22.target_urn || d22.source || d22.source_urn || ""),
      name: d22.name != null ? String(d22.name) : "Untitled",
      isFolder: !!(d22.is_folder || d22.isFolder)
    })) : [];
    this.items = norm.filter((x5) => !!x5.urn && !x5.isFolder);
  }
  async refreshFor(urn) {
    if (!urn || !this.documentStore) return [];
    this.setIsLoading(true);
    const list = await this.documentStore.getDocumentReferrers(urn, true, null).finally(() => this.setIsLoading(false));
    this.setItems(list);
    return list;
  }
};
makeObservable(UsedInStore);

// src/stores/collaboration-store.js
var CollaborationStore = class {
  static observableActions = ["init", "dispose"];
  constructor({ editorStore, documentStore } = {}) {
    this.editorStore = editorStore ?? null;
    this.documentStore = documentStore ?? null;
    this.commentStore = new CommentStore(this.editorStore);
    this.versionStore = new VersionStore();
    this.usedInStore = new UsedInStore();
  }
  get comment() {
    return this.commentStore;
  }
  get version() {
    return this.versionStore;
  }
  get usedIn() {
    return this.usedInStore;
  }
  init() {
    if (this.versionStore) {
      this.versionStore.editorStore = this.editorStore;
      this.versionStore.documentStore = this.documentStore;
      this.versionStore.commentStore = this.commentStore;
    }
    if (this.usedInStore) {
      this.usedInStore.editorStore = this.editorStore;
      this.usedInStore.documentStore = this.documentStore;
      this.usedInStore.commentStore = this.commentStore;
      this.usedInStore.versionStore = this.versionStore;
    }
  }
  dispose() {
  }
};
makeObservable(CollaborationStore);

// src/stores/dom-store.js
var INLINE_EDITOR_ATTR2 = "data-ee-inline-editor";
var AUTO_CONTAINER_ATTR2 = "data-ee-inline-container";
var DEFAULT_SLOT = "default";
var isAuthorableElement = (node) => {
  if (!node || node.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  const tag3 = node.tagName?.toLowerCase?.() || "";
  if (tag3 === "script" || tag3 === "style") {
    return false;
  }
  if (tag3 === "experience-elements-editor" || tag3 === "ee-rte") {
    return false;
  }
  if (node.hasAttribute(INLINE_EDITOR_ATTR2)) {
    return false;
  }
  if (node.closest?.("ee-rte")) {
    return false;
  }
  if (node.closest) {
    const refHost = node.closest("ee-reference");
    if (refHost && refHost !== node) {
      let curr = node;
      let withinTrigger = false;
      while (curr && curr !== refHost) {
        if (curr.getAttribute?.("slot") === "trigger") {
          withinTrigger = true;
          break;
        }
        curr = curr.parentElement;
      }
      if (!withinTrigger) return false;
    }
  }
  if (tag3 === "ee-reference") {
    return true;
  }
  if (tag3.includes("-")) {
    const ctor = customElements.get(tag3);
    if (ctor?.ee) return true;
    return true;
  }
  if (typeof window !== "undefined" && window.eeDefaults && window.eeDefaults[tag3]) {
    return true;
  }
  const parent = node.parentElement;
  if (parent && parent.tagName?.includes?.("-")) {
    return true;
  }
  if (parent && typeof window !== "undefined" && window.eeDefaults) {
    const parentTag = parent.tagName?.toLowerCase?.() || "";
    if (window.eeDefaults[parentTag]) {
      return true;
    }
  }
  return false;
};
var toSlotName = (slotName) => {
  if (!slotName) return DEFAULT_SLOT;
  const normalized = String(slotName).trim();
  return normalized === "" ? DEFAULT_SLOT : normalized;
};
var logMutation = (method, detail = {}) => {
  console.log(`[DomStore] ${method}`, detail);
};
var DomStore = class {
  static observableActions = [
    "attach",
    "detach",
    "moveElement",
    "moveElementBefore",
    "moveElementAfter",
    "insertElement",
    "deleteElement",
    "updateElementAttributes",
    "updateElementContent",
    "setElementSlot",
    "ensureSlotContainer",
    "duplicateElement",
    "clear",
    "notifyMutation",
    "updateContent"
  ];
  constructor() {
    this.version = 0;
  }
  #surface = null;
  #host = null;
  #observer = null;
  #mutationListeners = /* @__PURE__ */ new Set();
  attach(surfaceElement, hostElement = null) {
    if (surfaceElement === this.#surface && hostElement === this.#host) {
      return;
    }
    this.detach();
    this.#surface = surfaceElement || null;
    this.#host = hostElement || surfaceElement?.getRootNode?.()?.host || null;
    if (this.#host) {
      this.#observer = new MutationObserver(
        (mutations) => this.#handleMutations(mutations)
      );
      this.#observer.observe(this.#host, {
        childList: true,
        subtree: true,
        attributes: true,
        characterData: true
      });
    }
    this.#bumpVersion();
    logMutation("attach", {
      surface: !!surfaceElement,
      host: !!hostElement
    });
  }
  detach() {
    if (this.#observer) {
      this.#observer.disconnect();
      this.#observer = null;
    }
    this.#surface = null;
    this.#host = null;
  }
  isEditingRte() {
    return !!this.#host?.querySelector?.("ee-rte");
  }
  onMutation(listener) {
    if (typeof listener !== "function") {
      return () => {
      };
    }
    this.#mutationListeners.add(listener);
    return () => {
      this.#mutationListeners.delete(listener);
    };
  }
  get host() {
    return this.#host;
  }
  get surface() {
    return this.#surface;
  }
  get defaultSlotName() {
    return DEFAULT_SLOT;
  }
  getRootElements() {
    const host = this.#host;
    if (!host) return [];
    return Array.from(host.children || []).filter(isAuthorableElement);
  }
  getAuthorableChildren(parent) {
    if (!parent) return [];
    return Array.from(parent.children || []).filter(isAuthorableElement);
  }
  isAuthorable(element) {
    return isAuthorableElement(element);
  }
  normalizeSlotName(slotName) {
    return toSlotName(slotName);
  }
  getElementSlotName(element) {
    if (!element) return DEFAULT_SLOT;
    return toSlotName(element.getAttribute?.("slot"));
  }
  countSlotChildren(parent, slotName) {
    if (!parent) return 0;
    const normalized = toSlotName(slotName);
    return this.getAuthorableChildren(parent).filter(
      (child) => toSlotName(child.getAttribute?.("slot")) === normalized
    ).length;
  }
  getAuthorableSiblings(element) {
    if (!isAuthorableElement(element)) return [];
    const parent = element.parentElement;
    if (!parent) return [];
    return this.getAuthorableChildren(parent);
  }
  getPreviousAuthorableSibling(element) {
    const siblings = this.getAuthorableSiblings(element);
    const index = siblings.indexOf(element);
    if (index <= 0) return null;
    return siblings[index - 1] || null;
  }
  getNextAuthorableSibling(element) {
    const siblings = this.getAuthorableSiblings(element);
    const index = siblings.indexOf(element);
    if (index === -1 || index >= siblings.length - 1) return null;
    return siblings[index + 1] || null;
  }
  getPreviousSlotSibling(element) {
    return this.#getSlotSiblings(element).previous;
  }
  getNextSlotSibling(element) {
    return this.#getSlotSiblings(element).next;
  }
  canMoveElementUp(element) {
    return !!this.getPreviousSlotSibling(element);
  }
  canMoveElementDown(element) {
    return !!this.getNextSlotSibling(element);
  }
  moveElement(element, targetParent, position = Infinity) {
    if (!isAuthorableElement(element)) return false;
    const parent = targetParent || this.#host;
    if (!isAuthorableElement(parent) && parent !== this.#host) {
      return false;
    }
    if (!parent) return false;
    if (element === parent) return false;
    if (parent.contains(element)) {
    } else {
      let current = parent;
      while (current && current !== this.#host) {
        if (current === element) {
          return false;
        }
        current = current.parentElement;
      }
    }
    const currentParent = element.parentElement;
    if (!currentParent) return false;
    if (parent === currentParent) {
      const siblings = this.getAuthorableChildren(parent);
      const currentIndex = siblings.indexOf(element);
      if (currentIndex === -1) return false;
      let desiredIndex = Number.isFinite(position) ? Math.max(0, Math.min(position, siblings.length)) : siblings.length;
      if (desiredIndex > currentIndex) desiredIndex -= 1;
      if (desiredIndex === currentIndex) return true;
      const anchor = siblings[desiredIndex + (desiredIndex >= currentIndex ? 1 : 0)] || null;
      parent.insertBefore(element, anchor);
    } else {
      const siblings = this.getAuthorableChildren(parent);
      const desiredIndex = Number.isFinite(position) ? Math.max(0, Math.min(position, siblings.length)) : siblings.length;
      const anchor = siblings[desiredIndex] || null;
      parent.insertBefore(element, anchor);
    }
    this.#bumpVersion();
    markElementSchemaDirty(element);
    if (parent) {
      markElementSchemaDirty(parent);
    }
    if (currentParent && currentParent !== parent) {
      markElementSchemaDirty(currentParent);
    }
    logMutation("moveElement", {
      tag: element.tagName?.toLowerCase?.() || null
    });
    return true;
  }
  moveElementBefore(element, sibling = null) {
    if (!isAuthorableElement(element)) return false;
    let reference = sibling;
    if (!reference) {
      reference = this.getPreviousSlotSibling(element);
    }
    if (!reference || reference.parentElement == null) return false;
    const parent = reference.parentElement;
    const index = this.getAuthorableChildren(parent).indexOf(reference);
    if (index === -1) return false;
    return this.moveElement(element, parent, index);
  }
  moveElementAfter(element, sibling = null) {
    if (!isAuthorableElement(element)) return false;
    let reference = sibling;
    if (!reference) {
      reference = this.getNextSlotSibling(element);
    }
    if (!reference || reference.parentElement == null) return false;
    const parent = reference.parentElement;
    const siblings = this.getAuthorableChildren(parent);
    const index = siblings.indexOf(reference);
    if (index === -1) return false;
    return this.moveElement(element, parent, index + 1);
  }
  insertElement(nodeData, parentElement = null, position = Infinity) {
    if (!nodeData) return null;
    const parent = parentElement || this.#host;
    if (!parent) return null;
    const node = this.#createNodeFromData(nodeData, parent.ownerDocument || document);
    if (!node) return null;
    const siblings = this.getAuthorableChildren(parent);
    const desiredIndex = Number.isFinite(position) ? Math.max(0, Math.min(position, siblings.length)) : siblings.length;
    const anchor = siblings[desiredIndex] || null;
    parent.insertBefore(node, anchor);
    this.#bumpVersion();
    if (node.nodeType === Node.ELEMENT_NODE) {
      markElementSchemaDirty(node);
    }
    if (parent) {
      markElementSchemaDirty(parent);
    }
    logMutation("insertElement", {
      tag: node.nodeType === Node.ELEMENT_NODE ? node.tagName?.toLowerCase?.() : "#text"
    });
    return node.nodeType === Node.ELEMENT_NODE ? node : null;
  }
  deleteElement(element) {
    if (!element || !element.parentElement) return false;
    const parent = element.parentElement;
    element.remove();
    this.#bumpVersion();
    if (parent) {
      markElementSchemaDirty(parent);
    }
    logMutation("deleteElement", {
      tag: element.tagName?.toLowerCase?.() || null
    });
    return true;
  }
  updateElementAttributes(element, attrs = {}) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) return false;
    Object.entries(attrs || {}).forEach(([name, value]) => {
      if (value === false || value === null || value === void 0) {
        element.removeAttribute(name);
        return;
      }
      if (value === "true") {
        element.setAttribute(name, "");
      } else if (value === "false") {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, String(value));
      }
    });
    this.#bumpVersion();
    markElementSchemaDirty(element);
    logMutation("updateElementAttributes", {
      tag: element.tagName?.toLowerCase?.() || null
    });
    return true;
  }
  updateElementContent(element, html = "") {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) return false;
    const doc3 = element.ownerDocument || document;
    const template = doc3.createElement("template");
    template.innerHTML = typeof html === "string" ? html : "";
    this.#removeInlineArtifacts(template.content);
    const inlineEditor = Array.from(element.childNodes || []).find(
      (child) => child.nodeType === Node.ELEMENT_NODE && child.hasAttribute?.(INLINE_EDITOR_ATTR2)
    );
    for (const child of Array.from(element.childNodes || [])) {
      if (inlineEditor && child === inlineEditor) continue;
      if (child.parentNode === element) {
        element.removeChild(child);
      }
    }
    const fragment = template.content.cloneNode(true);
    const insertionTarget = inlineEditor && inlineEditor.parentNode === element ? inlineEditor : null;
    element.insertBefore(fragment, insertionTarget);
    this.#bumpVersion();
    markElementSchemaDirty(element);
    logMutation("updateElementContent", {
      tag: element.tagName?.toLowerCase?.() || null
    });
    return true;
  }
  setElementSlot(element, slotName) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) return false;
    const normalized = toSlotName(slotName);
    if (normalized === DEFAULT_SLOT) {
      element.removeAttribute("slot");
    } else {
      element.setAttribute("slot", normalized);
    }
    this.#bumpVersion();
    markElementSchemaDirty(element);
    const parent = element.parentElement;
    if (parent) {
      markElementSchemaDirty(parent);
    }
    logMutation("setElementSlot", {
      tag: element.tagName?.toLowerCase?.() || null,
      slotName: normalized
    });
    return true;
  }
  ensureSlotContainer(parent, slotName, options = {}) {
    if (!parent) return null;
    const desiredSlot = toSlotName(slotName);
    const children = this.getAuthorableChildren(parent);
    const existing = children.find((child) => {
      const childSlot = toSlotName(child.getAttribute("slot"));
      return childSlot === desiredSlot;
    });
    if (existing) {
      return existing;
    }
    const tagName = typeof options.tag === "string" && options.tag.trim() || (options.multiline === false ? "span" : "div");
    const doc3 = parent.ownerDocument || document;
    const element = doc3.createElement(tagName);
    element.setAttribute(AUTO_CONTAINER_ATTR2, "true");
    if (desiredSlot !== DEFAULT_SLOT) {
      element.setAttribute("slot", desiredSlot);
    }
    parent.appendChild(element);
    this.#bumpVersion();
    markElementSchemaDirty(parent);
    markElementSchemaDirty(element);
    logMutation("ensureSlotContainer", {
      parentTag: parent.tagName?.toLowerCase?.() || null,
      slotName: desiredSlot,
      tag: tagName
    });
    return element;
  }
  duplicateElement(element, { insertAfter = true } = {}) {
    if (!isAuthorableElement(element)) return null;
    const parent = element.parentElement || this.#host;
    if (!parent) return null;
    const clone = element.cloneNode(true);
    this.#removeInlineArtifacts(clone);
    this.#dedupeElementId(clone);
    const reference = insertAfter ? element.nextSibling : element;
    parent.insertBefore(clone, reference);
    this.#bumpVersion();
    markElementSchemaDirty(clone);
    markElementSchemaDirty(parent);
    logMutation("duplicateElement", {
      sourceTag: element.tagName?.toLowerCase?.() || null
    });
    return {
      element: clone
    };
  }
  clear() {
    if (!this.#host) return;
    this.#host.textContent = "";
    this.#bumpVersion();
    markElementSchemaDirty(this.#host);
    logMutation("clear");
  }
  notifyMutation() {
    this.#bumpVersion();
  }
  async updateContent(html) {
    return this.updateElementContent(this.#host, html);
  }
  #handleMutations(mutations = []) {
    if (!mutations.length) return;
    for (const mutation of mutations) {
      if (mutation.type === "attributes" && mutation.target) {
        markElementSchemaDirty(mutation.target);
      } else if (mutation.type === "childList") {
        if (mutation.target) {
          markElementSchemaDirty(mutation.target);
        }
        mutation.addedNodes?.forEach((node) => {
          if (node && node.nodeType === Node.ELEMENT_NODE) {
            markElementSchemaDirty(node);
          }
        });
        mutation.removedNodes?.forEach((node) => {
          if (node && node.nodeType === Node.ELEMENT_NODE) {
            markElementSchemaDirty(node);
          }
        });
      } else if (mutation.type === "characterData") {
        const parent = mutation.target?.parentElement;
        if (parent) {
          markElementSchemaDirty(parent);
        }
      }
    }
    this.notifyMutation();
  }
  #bumpVersion() {
    this.version += 1;
    for (const listener of Array.from(this.#mutationListeners)) {
      try {
        listener(this.version);
      } catch (error) {
        console.error("[DomStore] mutation listener error", error);
      }
    }
    notify(this);
  }
  #removeInlineArtifacts(root) {
    if (!root) return;
    const inlineEditors = root.querySelectorAll?.(`[${INLINE_EDITOR_ATTR2}]`) || [];
    inlineEditors.forEach((el) => el.remove());
  }
  #getSlotSiblings(element) {
    if (!isAuthorableElement(element)) {
      return {
        previous: null,
        next: null
      };
    }
    const parent = element.parentElement;
    if (!parent) {
      return {
        previous: null,
        next: null
      };
    }
    const slotName = toSlotName(element.getAttribute?.("slot"));
    const siblings = this.getAuthorableChildren(parent).filter(
      (child) => toSlotName(child.getAttribute?.("slot")) === slotName
    );
    const index = siblings.indexOf(element);
    if (index === -1) {
      return {
        previous: null,
        next: null
      };
    }
    return {
      previous: index > 0 ? siblings[index - 1] : null,
      next: index < siblings.length - 1 ? siblings[index + 1] : null
    };
  }
  #createNodeFromData(nodeData, doc3) {
    if (nodeData.type === "text") {
      const textContent = nodeData.textContent === void 0 || nodeData.textContent === null ? "" : String(nodeData.textContent);
      return doc3.createTextNode(textContent);
    }
    const tagName = typeof nodeData.tag === "string" && nodeData.tag.trim() ? nodeData.tag.trim() : "div";
    const element = doc3.createElement(tagName);
    Object.entries(nodeData.attrs || {}).forEach(([name, value]) => {
      if (value === null || value === void 0 || value === false) return;
      element.setAttribute(name, value === true ? "" : String(value));
    });
    if (nodeData.slotName && nodeData.slotName !== DEFAULT_SLOT) {
      element.setAttribute("slot", nodeData.slotName);
    }
    if (Array.isArray(nodeData.children)) {
      nodeData.children.forEach((child) => {
        const childNode = this.#createNodeFromData(child, doc3);
        if (childNode) {
          element.appendChild(childNode);
        }
      });
    } else if (typeof nodeData.html === "string") {
      element.innerHTML = nodeData.html;
    }
    this.#removeInlineArtifacts(element);
    return element;
  }
  #dedupeElementId(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) return;
    const id = element.getAttribute("id");
    if (!id) return;
    const doc3 = element.ownerDocument || document;
    if (!doc3.getElementById(id)) {
      return;
    }
    const base2 = id.replace(/-\d+$/, "");
    let counter = 1;
    let candidate = `${base2}-${counter}`;
    while (doc3.getElementById(candidate)) {
      counter += 1;
      candidate = `${base2}-${counter}`;
    }
    element.setAttribute("id", candidate);
  }
};
makeObservable(DomStore);

// src/stores/app/gallery/gallery-views.js
var GalleryViews = {
  ALL: "all",
  RECENT: "recent",
  MY_FILES: "files",
  SHARED: "shared",
  TEMPLATES: "templates"
};
var DEFAULT_GALLERY_VIEW = GalleryViews.ALL;
var RECENT_WINDOW_IN_DAYS = 7;

// src/stores/app/gallery/gallery-filter-store.js
var RECENT_LIMIT = 8;
var GalleryFilterStore = class {
  static observableActions = [
    "setGalleryView",
    "setSearchQuery",
    "setSavedElements",
    "setRecentWindowInDays"
  ];
  constructor({
    defaultView,
    recentWindowInDays,
    views
  } = {}) {
    this.savedElements = [];
    this.searchQuery = "";
    this.galleryView = defaultView ?? null;
    this.recentWindowInDays = recentWindowInDays ?? 0;
    this.views = {
      all: views?.all ?? null,
      recent: views?.recent ?? null,
      templates: views?.templates ?? null
    };
  }
  setGalleryView(view) {
    this.galleryView = view;
  }
  setSearchQuery(query) {
    this.searchQuery = typeof query === "string" ? query : String(query ?? "");
  }
  setSavedElements(list) {
    this.savedElements = Array.isArray(list) ? list : [];
  }
  setRecentWindowInDays(days) {
    this.recentWindowInDays = typeof days === "number" ? days : 0;
  }
  filterElements({
    savedElements = this.savedElements,
    galleryView = this.galleryView,
    searchQuery = this.searchQuery
  } = {}) {
    let elements = Array.isArray(savedElements) ? [...savedElements] : [];
    const { all, recent, templates } = this.views;
    if (galleryView === all || galleryView === recent) {
      elements = elements.filter((el) => !el?.isFolder);
    }
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      elements = elements.filter((el) => {
        if (!el) return false;
        const nameMatch = el.name?.toLowerCase?.().includes(query);
        const tag3 = this.#getRootTag(el);
        const tagMatch = tag3.includes(query);
        return nameMatch || tagMatch;
      });
    }
    if (galleryView === recent) {
      const cutoff = /* @__PURE__ */ new Date();
      cutoff.setDate(cutoff.getDate() - this.recentWindowInDays);
      return elements.filter((el) => {
        const modified = el?.lastModified ? new Date(el.lastModified) : 0;
        return modified && !Number.isNaN(modified) && modified > cutoff;
      }).slice(0, RECENT_LIMIT);
    }
    if (galleryView === templates) {
      return elements.filter((el) => !!el?.isTemplate);
    }
    return elements;
  }
  #getRootTag(doc3) {
    const root = doc3?.html;
    if (!root) return "";
    if (typeof root === "string") {
      const match = root.match(/<\s*([a-zA-Z0-9-]+)/);
      return match && match[1] ? match[1].toLowerCase() : "";
    }
    if (root?.tagName) {
      return String(root.tagName).toLowerCase();
    }
    return "";
  }
};
makeObservable(GalleryFilterStore);

// src/stores/app/gallery/gallery-store.js
var VALID_VIEWS = new Set(Object.values(GalleryViews));
var GalleryStore = class {
  static observableActions = [
    "setGalleryView",
    "setSearchQuery",
    "setSavedElements",
    "setCurrentFolder",
    "enterFolder",
    "goUpOne",
    "navigateToCrumb",
    "selectAllVisible",
    "setHasMore",
    "appendSavedElements"
  ];
  static computedProperties = ["filteredElements", "folderBreadcrumbs"];
  #filter;
  constructor({ selectionStore, navigationStore } = {}) {
    this.selection = selectionStore ?? null;
    this.navigation = navigationStore ?? null;
    this.galleryView = DEFAULT_GALLERY_VIEW;
    this.searchQuery = "";
    this.savedElements = [];
    this.hasMore = true;
    this.#filter = new GalleryFilterStore({
      defaultView: this.galleryView,
      recentWindowInDays: RECENT_WINDOW_IN_DAYS,
      views: {
        all: GalleryViews.ALL,
        recent: GalleryViews.RECENT,
        templates: GalleryViews.TEMPLATES
      }
    });
    this.#filter.setSavedElements(this.savedElements);
    this.#filter.setSearchQuery(this.searchQuery);
  }
  setGalleryView(view) {
    const next = VALID_VIEWS.has(view) ? view : DEFAULT_GALLERY_VIEW;
    this.galleryView = next;
    this.#filter.setGalleryView(next);
    this.selection?.setSelectionMode(false);
    this.setHasMore(true);
  }
  setSearchQuery(query) {
    const next = typeof query === "string" ? query : String(query ?? "");
    this.searchQuery = next;
    this.#filter.setSearchQuery(next);
    const visible = this.#filter.filterElements({
      savedElements: this.savedElements,
      galleryView: this.galleryView,
      searchQuery: next
    });
    this.selection?.keepOnly(visible.map((doc3) => doc3?.urn).filter(Boolean));
  }
  setSavedElements(list) {
    this.savedElements = Array.isArray(list) ? list : [];
    this.#filter.setSavedElements(this.savedElements);
    const visible = this.#filter.filterElements({
      savedElements: this.savedElements,
      galleryView: this.galleryView,
      searchQuery: this.searchQuery
    });
    this.selection?.keepOnly(visible.map((doc3) => doc3?.urn).filter(Boolean));
  }
  appendSavedElements(list, limit = 50) {
    const items = Array.isArray(list) ? list : [];
    this.savedElements = [...this.savedElements, ...items];
    this.#filter.setSavedElements(this.savedElements);
    this.setHasMore(items.length >= limit);
  }
  setHasMore(value) {
    this.hasMore = !!value;
  }
  setCurrentFolder(urn, name) {
    this.navigation?.setCurrentFolder(urn, name);
    this.setHasMore(true);
  }
  enterFolder(doc3) {
    this.navigation?.enterFolder(doc3);
  }
  goUpOne() {
    this.navigation?.goUpOne();
  }
  navigateToCrumb(index) {
    this.navigation?.navigateToCrumb(index);
  }
  selectAllVisible() {
    const items = this.filteredElements || [];
    this.selection?.selectAll(items);
  }
  get filteredElements() {
    return this.#filter.filterElements({
      savedElements: this.savedElements,
      galleryView: this.galleryView,
      searchQuery: this.searchQuery
    });
  }
  get folderBreadcrumbs() {
    return this.navigation?.breadcrumbs || [];
  }
};
makeObservable(GalleryStore);

// src/stores/app/gallery/gallery-selection-store.js
var GallerySelectionStore = class {
  static observableActions = [
    "setSelectionMode",
    "toggleSelect",
    "clearSelection",
    "selectAll",
    "keepOnly"
  ];
  constructor() {
    this.selectionMode = false;
    this.selectedUrns = /* @__PURE__ */ new Set();
  }
  setSelectionMode(on2) {
    const next = !!on2;
    this.selectionMode = next;
    if (!next) {
      this.selectedUrns = /* @__PURE__ */ new Set();
    }
  }
  toggleSelect(urn) {
    if (!urn) return;
    const next = new Set(this.selectedUrns || []);
    if (next.has(urn)) {
      next.delete(urn);
    } else {
      next.add(urn);
    }
    this.selectedUrns = next;
    if (!next.size) {
      this.selectionMode = false;
    } else if (!this.selectionMode) {
      this.selectionMode = true;
    }
  }
  clearSelection() {
    this.selectedUrns = /* @__PURE__ */ new Set();
    this.selectionMode = false;
  }
  selectAll(documents) {
    const urns = Array.from(documents || [], (doc3) => doc3?.urn).filter(Boolean);
    this.selectedUrns = new Set(urns);
    this.selectionMode = this.selectedUrns.size > 0;
  }
  keepOnly(allowed) {
    const accepted = new Set(allowed || []);
    if (!accepted.size) {
      this.clearSelection();
      return;
    }
    const next = /* @__PURE__ */ new Set();
    for (const urn of this.selectedUrns || []) {
      if (accepted.has(urn)) {
        next.add(urn);
      }
    }
    this.selectedUrns = next;
    if (!next.size) {
      this.selectionMode = false;
    }
  }
};
makeObservable(GallerySelectionStore);

// src/stores/app/gallery/gallery-navigation-store.js
var GalleryNavigationStore = class {
  static observableActions = [
    "setFolderChain",
    "setCurrentFolder",
    "enterFolder",
    "goUpOne",
    "navigateToCrumb"
  ];
  static computedProperties = ["breadcrumbs"];
  constructor({ selectionStore } = {}) {
    this.currentFolderUrn = null;
    this.folderCrumbs = [];
    this.#selection = selectionStore ?? null;
  }
  #selection;
  setFolderChain(chain) {
    const crumbs = Array.isArray(chain) ? chain.filter((item) => item && item.urn).map((item) => ({
      urn: item.urn,
      name: item.name || "Folder"
    })) : [];
    this.#selection?.setSelectionMode(false);
    this.folderCrumbs = crumbs;
    const last = crumbs[crumbs.length - 1] || null;
    this.currentFolderUrn = last ? last.urn : null;
  }
  setCurrentFolder(urn, name = null) {
    const normalized = urn || null;
    this.currentFolderUrn = normalized;
    this.#selection?.setSelectionMode(false);
    if (normalized === null) {
      this.folderCrumbs = [];
      return;
    }
    const crumbs = Array.isArray(this.folderCrumbs) ? [...this.folderCrumbs] : [];
    const last = crumbs[crumbs.length - 1];
    if (!last || last.urn !== normalized) {
      crumbs.push({ urn: normalized, name: name || "Folder" });
    }
    this.folderCrumbs = crumbs;
  }
  enterFolder(doc3) {
    if (!doc3 || !doc3.urn) return;
    this.setCurrentFolder(doc3.urn, doc3.name || "Folder");
  }
  goUpOne() {
    if (!Array.isArray(this.folderCrumbs) || !this.folderCrumbs.length) {
      this.setCurrentFolder(null);
      return;
    }
    const crumbs = [...this.folderCrumbs];
    crumbs.pop();
    this.folderCrumbs = crumbs;
    const parent = crumbs[crumbs.length - 1] || null;
    this.currentFolderUrn = parent ? parent.urn : null;
  }
  navigateToCrumb(index) {
    const crumbs = Array.isArray(this.folderCrumbs) ? [...this.folderCrumbs] : [];
    if (index < 0 || index >= crumbs.length) {
      this.setCurrentFolder(null);
      return;
    }
    const next = crumbs.slice(0, index + 1);
    this.folderCrumbs = next;
    const current = next[next.length - 1] || null;
    this.currentFolderUrn = current ? current.urn : null;
  }
  get breadcrumbs() {
    return this.folderCrumbs || [];
  }
};
makeObservable(GalleryNavigationStore);

// src/stores/app/ui-store.js
var DEFAULT_THEME = "dark";
var HOME_NAV_STORAGE_KEY = "ee:homeNav";
var HOME_NAV_OPTIONS = /* @__PURE__ */ new Set([
  "home",
  "my-workspace",
  "shared",
  "team-workspace"
]);
var AppUiStore = class {
  static observableActions = [
    "setShowCreationDialog",
    "setCreationDialogCategory",
    "setThemeColor",
    "setIsReady",
    "setIsNavigating",
    "setHomeNavSelection"
  ];
  constructor() {
    this.showCreationDialog = false;
    this.creationDialogCategory = "templates";
    this.themeColor = this.#readStoredTheme();
    this.isReady = false;
    this.isNavigating = true;
    this.homeNavSelection = this.#readStoredHomeNav();
  }
  setShowCreationDialog(show) {
    this.showCreationDialog = !!show;
  }
  setCreationDialogCategory(category) {
    this.creationDialogCategory = category || "templates";
  }
  setThemeColor(color) {
    const next = color || DEFAULT_THEME;
    this.themeColor = next;
    const storage = typeof window !== "undefined" && "localStorage" in window ? window.localStorage : null;
    storage?.setItem?.("theme", next);
  }
  setIsReady(ready) {
    this.isReady = !!ready;
  }
  setIsNavigating(value) {
    this.isNavigating = !!value;
  }
  setHomeNavSelection(selection) {
    const next = HOME_NAV_OPTIONS.has(selection) ? selection : "home";
    if (this.homeNavSelection === next) {
      return;
    }
    this.homeNavSelection = next;
    const storage = typeof window !== "undefined" && "localStorage" in window ? window.localStorage : null;
    storage?.setItem?.(HOME_NAV_STORAGE_KEY, next);
  }
  #readStoredTheme() {
    const storage = typeof window !== "undefined" && "localStorage" in window ? window.localStorage : null;
    const stored = storage?.getItem?.("theme");
    return stored || DEFAULT_THEME;
  }
  #readStoredHomeNav() {
    const storage = typeof window !== "undefined" && "localStorage" in window ? window.localStorage : null;
    const stored = storage?.getItem?.(HOME_NAV_STORAGE_KEY) || "home";
    return HOME_NAV_OPTIONS.has(stored) ? stored : "home";
  }
};
makeObservable(AppUiStore);

// src/stores/app/workspace-store.js
var WorkspaceStore = class {
  static observableActions = [
    "setCurrentElement",
    "setCurrentElementId",
    "openElement",
    "closeElement",
    "updateElementName"
  ];
  static computedProperties = ["isEditingElement"];
  constructor({ documentStore } = {}) {
    this.documentStore = documentStore ?? null;
    this.currentElement = null;
    this.currentElementId = null;
  }
  setCurrentElement(element) {
    this.currentElement = element ?? null;
    if (!element) {
      this.currentElementId = null;
      return;
    }
    const inferredId = element.urn ?? element.id ?? null;
    if (inferredId) {
      this.currentElementId = inferredId;
    }
  }
  setCurrentElementId(id) {
    this.currentElementId = id ?? null;
  }
  get isEditingElement() {
    return this.currentElementId !== null;
  }
  async openElement(elementId) {
    if (!this.documentStore) return null;
    const elementConfig = await this.documentStore.getDocument(elementId);
    if (!elementConfig) return null;
    this.setCurrentElementId(elementId);
    this.setCurrentElement(elementConfig);
    const html = elementConfig.html ?? null;
    return html ? this.documentStore.deserializeElement(html) : null;
  }
  async closeElement() {
    this.setCurrentElement(null);
    this.setCurrentElementId(null);
  }
  async updateElementName(newName) {
    if (!this.currentElement || !this.currentElementId || !this.documentStore) {
      return;
    }
    let html = this.currentElement.html;
    const editorStore = this.documentStore.appStore?.editorStore;
    if (editorStore && editorStore.currentElementId === this.currentElementId && editorStore.editorElement) {
      html = editorStore.editorElement.innerHTML;
    }
    const result = await this.documentStore.updateDocumentName(
      this.currentElementId,
      newName,
      html
    );
    this.currentElement.name = newName;
    if (result?.path && result.path !== this.currentElementId) {
      this.currentElement.path = result.path;
      this.currentElement.urn = result.path;
      this.currentElementId = result.path;
      if (editorStore && editorStore.setCurrentElementId) {
        editorStore.setCurrentElementId(result.path);
      }
    }
  }
};
makeObservable(WorkspaceStore);

// src/stores/app-store.js
var Store = class {
  static observableActions = [
    "loadElements",
    "openElement",
    "closeElement",
    "deleteElement",
    "setGalleryView",
    "setSearchQuery",
    "setShowCreationDialog",
    "setCreationDialogCategory",
    "setCurrentElement",
    "setIsReady",
    "updateElementName",
    "setThemeColor",
    // Navigation state
    "setIsNavigating",
    // Saved elements list
    "setSavedElements",
    "appendSavedElements",
    "loadMore",
    // Folder navigation
    "setFolderChain",
    "setCurrentFolder",
    "enterFolder",
    "goUpOne",
    "navigateToCrumb",
    // Selection mode in Home
    "setSelectionMode",
    "toggleSelect",
    "clearSelection",
    "selectAllVisible",
    // Home UI state
    "setHomeNavSelection"
  ];
  static computedProperties = [
    "isEditingElement",
    "filteredElements",
    "folderBreadcrumbs"
  ];
  documentStore = new DocumentStore();
  editorStore = new EditorStore();
  collaboration = new CollaborationStore({
    editorStore: this.editorStore,
    documentStore: this.documentStore
  });
  templateStore = new TemplateStore();
  userStore = new UserStore();
  domStore = new DomStore();
  selectionStore = new GallerySelectionStore();
  navigationStore = new GalleryNavigationStore({
    selectionStore: this.selectionStore
  });
  galleryStore = new GalleryStore({
    selectionStore: this.selectionStore,
    navigationStore: this.navigationStore
  });
  uiStore = new AppUiStore();
  workspaceStore = new WorkspaceStore({
    documentStore: this.documentStore
  });
  homeElement = null;
  #usersMeRequest = null;
  // Track previous gallery state to restore it when closing an element
  lastGalleryState = null;
  async init() {
    this.documentStore.appStore = this;
    this.workspaceStore.documentStore = this.documentStore;
    await this.documentStore.init();
    this.editorStore.documentStore = this.documentStore;
    this.editorStore.domStore = this.domStore;
    this.collaboration.editorStore = this.editorStore;
    this.collaboration.documentStore = this.documentStore;
    this.collaboration.init();
    this.documentStore.commentStore = this.collaboration.comment;
    this.userStore.ensureInitialized?.();
    await this.documentStore.getAccessToken();
    if (this.documentStore.localUserEmail) {
      this.userStore.setCurrentUser(
        this.documentStore.localUserEmail,
        this.documentStore.localUserName || "",
        this.documentStore.localOwnerOrg || ""
      );
    } else if (this.documentStore.isMcpActive) {
      this.userStore.setCurrentUser(
        "mcp-agent@adobe.com",
        "MCP Agent",
        "MCP-ORG"
      );
    }
    if (!this.userStore.isAuthenticated) {
      this.userStore.setError("Authentication failed. No user identity found.");
    }
    await this.#updateUserOnSignIn();
    await this.templateStore.init();
    this.setIsReady(true);
  }
  async #updateUserOnSignIn() {
    return;
    if (this.#usersMeRequest) {
      return this.#usersMeRequest;
    }
    const request = (async () => {
      await this.documentStore.init?.();
      const apiBase = this.documentStore.apiBaseUrl || await this.documentStore.loadApiEndpoint();
      const token = await this.documentStore.getAccessToken();
      const email = this.userStore?.currentUser?.email || "";
      const name = this.userStore?.currentUser?.displayName || "";
      const ownerOrg = this.userStore?.currentUser?.ownerOrg?.trim?.() || "";
      if (!apiBase || !token || !email) return null;
      const payload = { email, name };
      if (ownerOrg) {
        payload.ownerOrg = ownerOrg;
      }
      return fetch(`${apiBase}/users/me`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(payload)
      }).catch(() => null);
    })();
    this.#usersMeRequest = request;
    return request.finally(() => {
      if (this.#usersMeRequest === request) {
        this.#usersMeRequest = null;
      }
    });
  }
  get isEditingElement() {
    return this.workspaceStore.isEditingElement;
  }
  get filteredElements() {
    return this.galleryStore.filteredElements;
  }
  get folderBreadcrumbs() {
    return this.galleryStore.folderBreadcrumbs;
  }
  get folderCrumbs() {
    return this.navigationStore.folderCrumbs || [];
  }
  get galleryView() {
    return this.galleryStore.galleryView;
  }
  get searchQuery() {
    return this.galleryStore.searchQuery;
  }
  get savedElements() {
    return this.galleryStore.savedElements;
  }
  get selectionMode() {
    return this.selectionStore.selectionMode;
  }
  get selectedUrns() {
    return this.selectionStore.selectedUrns;
  }
  get currentFolderUrn() {
    return this.navigationStore.currentFolderUrn;
  }
  get showCreationDialog() {
    return this.uiStore.showCreationDialog;
  }
  get creationDialogCategory() {
    return this.uiStore.creationDialogCategory;
  }
  get themeColor() {
    return this.uiStore.themeColor;
  }
  get homeNavSelection() {
    return this.uiStore.homeNavSelection;
  }
  get isReady() {
    return this.uiStore.isReady;
  }
  get isNavigating() {
    return this.uiStore.isNavigating;
  }
  get currentElement() {
    return this.workspaceStore.currentElement;
  }
  async openElement(elementId) {
    this.lastGalleryState = {
      galleryView: this.galleryView,
      currentFolderUrn: this.currentFolderUrn,
      homeNavSelection: this.homeNavSelection
    };
    const result = await this.workspaceStore.openElement(elementId);
    const nextId = this.workspaceStore.currentElementId;
    if (this.editorStore.currentElementId !== nextId) {
      this.editorStore.setCurrentElementId(nextId);
    }
    return result;
  }
  async closeElement() {
    const parentUrn = this.workspaceStore.currentElement?.parentUrn ?? null;
    await this.workspaceStore.closeElement();
    if (this.editorStore.currentElementId !== null) {
      this.editorStore.setCurrentElementId(null);
    }
    if (this.lastGalleryState) {
      const { galleryView, currentFolderUrn, homeNavSelection } = this.lastGalleryState;
      this.setGalleryView(galleryView);
      if (homeNavSelection) {
        this.uiStore.setHomeNavSelection(homeNavSelection);
      }
      this.setCurrentFolder(currentFolderUrn);
      this.lastGalleryState = null;
      return;
    }
    if (parentUrn) {
      this.setGalleryView(GalleryViews.MY_FILES);
      this.setCurrentFolder(parentUrn);
    } else {
      this.setCurrentFolder(null);
    }
  }
  async updateElementName(newName) {
    return this.workspaceStore.updateElementName(newName);
  }
  async deleteElement(elementId) {
    await this.documentStore.deleteDocument(elementId);
    if (this.editorStore?.currentElementId === elementId) {
      await this.closeElement();
    }
  }
  setFolderChain(chain) {
    this.navigationStore?.setFolderChain(chain);
  }
  setCurrentFolder(urn, name = null) {
    this.galleryStore.setCurrentFolder(urn, name);
  }
  enterFolder(doc3) {
    this.galleryStore.enterFolder(doc3);
    this.setGalleryView(this.galleryView);
  }
  goUpOne() {
    this.galleryStore.goUpOne();
  }
  navigateToCrumb(index) {
    this.galleryStore.navigateToCrumb(index);
  }
  setGalleryView(view) {
    this.galleryStore.setGalleryView(view);
    const navSelection = view === GalleryViews.MY_FILES ? "my-workspace" : view === GalleryViews.SHARED ? "shared" : "home";
    const keepTeamSelection = this.uiStore.homeNavSelection === "team-workspace" && navSelection === "home";
    if (!keepTeamSelection) {
      this.uiStore.setHomeNavSelection(navSelection);
    }
  }
  setSearchQuery(query) {
    this.galleryStore.setSearchQuery(query);
    if (!this.selectionStore.selectedUrns?.size) {
      this.selectionStore.setSelectionMode(false);
    }
  }
  setShowCreationDialog(show) {
    this.uiStore.setShowCreationDialog(show);
  }
  setCreationDialogCategory(category) {
    this.uiStore.setCreationDialogCategory(category);
  }
  setCurrentElement(element) {
    this.workspaceStore.setCurrentElement(element);
    const nextId = this.workspaceStore.currentElementId;
    if (this.editorStore.currentElementId !== nextId) {
      this.editorStore.setCurrentElementId(nextId);
    }
  }
  setIsReady(ready) {
    this.uiStore.setIsReady(ready);
  }
  setIsNavigating(value) {
    this.uiStore.setIsNavigating(value);
  }
  async loadElements() {
    return this.documentStore.loadAllElementsInto(this);
  }
  async loadMore() {
    return this.documentStore.loadAllElementsInto(this, { append: true });
  }
  setSavedElements(list) {
    this.galleryStore.setSavedElements(list);
    if (!this.selectionStore.selectedUrns?.size) {
      this.selectionStore.setSelectionMode(false);
    }
  }
  appendSavedElements(list, limit) {
    this.galleryStore.appendSavedElements(list, limit);
  }
  setThemeColor(color) {
    this.uiStore.setThemeColor(color);
  }
  setHomeNavSelection(selection) {
    this.uiStore.setHomeNavSelection(selection);
  }
  setSelectionMode(on2) {
    this.selectionStore.setSelectionMode(on2);
  }
  toggleSelect(urn) {
    this.selectionStore.toggleSelect(urn);
  }
  clearSelection() {
    this.selectionStore.clearSelection();
  }
  selectAllVisible() {
    this.galleryStore.selectAllVisible();
  }
};
makeObservable(Store);

// src/experience-elements-home-new.css.js
init_lit();

// src/features/home-gallery/gallery-common.css.js
init_lit();
var galleryCommonStyles = i`
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  .files-toolbar {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-100);
    margin-bottom: var(--spectrum-global-dimension-size-200);
  }

  /* Breadcrumbs */
  .breadcrumbs-wrap {
    margin-bottom: var(--spectrum-global-dimension-size-200);
  }

  /* Loading States */
  .section-loading {
    display: grid;
    place-items: center;
    min-height: calc(100vh - 60px);
  }

  /* Elements Grid */
  .elements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(270px, 1fr));
    gap: var(--spectrum-global-dimension-size-500);
    padding: 0;
    width: 100%;
    justify-items: stretch;
  }

  .elements-grid .element-thumbnail {
    min-height: 180px;
    max-width: 270px;
    width: 100%;
    overflow: hidden;
  }

  /* Element Cards */
  .element-card {
    width: 100%;
    padding: var(--spectrum-global-dimension-size-200);
    border: 1px solid var(--spectrum-alias-border-color-quiet);
    border-radius: var(--spectrum-global-dimension-size-100);
    background: var(--spectrum-global-color-gray-75);
    cursor: pointer;
    text-align: left;
    outline: none;
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-200);
    transition: box-shadow 0.2s ease, border-color 0.2s ease;
  }

  .element-card:hover,
  .element-card:focus-visible {
    outline: 2px solid var(--spectrum-global-color-blue-500);
    outline-offset: 2px;
  }

  .element-card.drag-over {
    outline: 2px solid var(--spectrum-global-color-purple-500);
    outline-offset: 2px;
  }

  .element-card.folder {
    align-items: flex-start;
    justify-content: flex-start;
  }

  .element-card.folder .element-thumbnail {
    display: grid;
    place-items: center;
  }

  .element-card.folder sp-icon-folder {
    color: var(--spectrum-global-color-gray-700);
    max-width: 100%;
    max-height: 100%;
  }

  .element-card[data-selected="true"] {
    box-shadow: 0 0 0 2px var(--spectrum-global-color-blue-500);
  }

  .element-card-header {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-150);
  }

  .element-title {
    font-weight: 600;
    color: var(--spectrum-alias-heading-text-color);
  }

  .element-description {
    color: var(--spectrum-alias-text-color-secondary);
    font-size: var(--spectrum-global-font-size-75);
    line-height: 1.4;
  }

  /* On hover/focus, unify tile visuals by removing inner surfaces */
  .element-card:hover .element-preview,
  .element-card:focus-visible .element-preview {
    background: transparent;
    border-color: transparent;
  }

  /* Element Thumbnail */
  .element-thumbnail {
    background: var(--spectrum-global-color-gray-200);
    border-radius: 16px;
    padding: 16px;
    aspect-ratio: 1.5;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--spectrum-alias-border-color-quiet);
    overflow: hidden;
    position: relative;
  }

  .element-thumbnail > * {
    pointer-events: none;
  }

  /* Element Preview */
  .element-preview {
    align-items: center;
    background: transparent;
    border-radius: var(--spectrum-global-dimension-size-100);
    border: none;
    display: flex;
    justify-content: center;
    margin: 0;
    max-height: 256px;
    height: 100%;
    overflow: hidden;
    padding: 0;
    pointer-events: none;
    position: relative;
  }

  .element-preview > * {
    max-width: 100%;
  }

  .element-preview-placeholder {
    color: var(--spectrum-alias-placeholder-text-color);
    font-size: 12px;
    font-family: "Adobe Clean", sans-serif;
  }

  /* Scale down all content in preview mode to prevent layout issues */
  [data-ee-preview] {
    font-size: 0.75em;
  }

  [data-ee-preview] * {
    font-size: inherit;
  }

  /* Element Info */
  .element-info {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-50);
  }

  .element-name {
    font-size: 14px;
    font-weight: 700;
    color: var(--spectrum-alias-text-color);
    font-family: "Adobe Clean", sans-serif;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .element-time {
    font-size: 12px;
    color: var(--spectrum-alias-secondary-text-color);
    font-family: "Adobe Clean", sans-serif;
    opacity: 1;
  }

  /* Dividers */
  .folders-docs-divider {
    margin: var(--spectrum-global-dimension-size-300) 0;
  }

  /* New Folder Dialog */
  #new-folder-content {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-200);
    padding: var(--spectrum-global-dimension-size-200);
  }

  /* Action Bar */
  sp-action-bar {
    position: fixed;
    bottom: 20px;
    right: 50%;
    transform: translateX(50%);
  }
`;

// src/experience-elements-home-new.css.js
var homeSpecificStyles = i`
  :host {
    display: block;
    height: 100vh;
    overflow: hidden;
    background: var(--spectrum-alias-background-color-default);
    color: var(--spectrum-alias-text-color);
    position: relative;
    box-sizing: border-box;
    /* Header height token for layout math */
    /*
     * App-specific surface tokens for tiles. These derive from Spectrum
     * aliases so that light/dark themes both look correct while ensuring
     * a visible surface in light mode.
     */
    /* Lighter neutral surface for tiles */
    --ee-tile-bg: var(--spectrum-global-color-gray-200);
    --ee-tile-border: var(--spectrum-alias-border-color-quiet);
  }

  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  /* Main Layout Container */
  .home-container {
    display: flex;
    height: 100vh;
    position: relative;
  }

  /* Left Sidebar Navigation */
  .sidebar-nav {
    width: 72px;
    background: var(--spectrum-alias-background-color-default);
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-top: var(--spectrum-global-dimension-size-150);
    gap: var(--spectrum-global-dimension-size-150);
    border-right: 1px solid var(--spectrum-alias-border-color);
  }

  .nav-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-50);
    padding: var(--spectrum-global-dimension-size-50) 0;
    width: 68px;
    position: relative;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 8px;
  }

  .nav-item::before {
    content: "";
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%) scaleY(0);
    width: 3px;
    height: 32px;
    background: var(--spectrum-global-color-blue-600);
    border-radius: 0 3px 3px 0;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .nav-item:hover {
    background-color: var(
      --spectrum-alias-background-color-hover,
      rgba(0, 0, 0, 0.04)
    );
    transform: translateX(2px);
  }

  .nav-item.selected {
    background-color: transparent;
    transform: translateX(3px);
  }

  .nav-item sp-action-button {
    --mod-actionbutton-border-radius: 8px;
    --mod-actionbutton-height: 30px;
    --mod-actionbutton-width: 30px;
    min-width: 30px;
    pointer-events: none;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .nav-item.selected sp-action-button {
    transform: scale(1.1);
  }

  .nav-item.selected sp-action-button,
  .nav-item sp-action-button[selected] {
    --mod-actionbutton-background-color-default: var(
      --spectrum-alias-text-color
    );
    --mod-actionbutton-background-color-hover: var(
      --spectrum-alias-text-color
    );
    --mod-actionbutton-background-color-down: var(
      --spectrum-alias-text-color
    );
    --mod-actionbutton-content-color-default: var(
      --spectrum-alias-background-color-default
    );
    --mod-actionbutton-content-color-hover: var(
      --spectrum-alias-background-color-default
    );
    --mod-actionbutton-content-color-down: var(
      --spectrum-alias-background-color-default
    );
  }

  .nav-item-label {
    font-size: 12px;
    line-height: 18px;
    text-align: center;
    color: var(--spectrum-alias-text-color);
    font-family: "Adobe Clean", sans-serif;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .nav-item.selected .nav-item-label {
    font-weight: 600;
    color: var(--spectrum-alias-text-color);
  }

  /* Main Content Area */
  .main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
  }

  /* Scrollable area containing hero + content */
  .content-scroll {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
  }

  /* Header */
  .header {
    background: var(--spectrum-alias-background-color-default);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 var(--spectrum-global-dimension-size-400);
    border-bottom: 1px solid var(--spectrum-alias-border-color);
    position: sticky;
    height: 60px;
  }

  .header-brand {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-100);
  }

  .adobe-logo {
    width: 92px;
    height: 24px;
  }

  .brand-text {
    font-size: 21px;
    font-weight: 800;
    color: var(--spectrum-alias-heading-text-color);
    font-family: "Adobe Clean", sans-serif;
    letter-spacing: -0.378px;
  }

  .header-search {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 400px;
  }

  .header-search sp-search {
    width: 100%;
    background: var(--spectrum-alias-background-color-secondary);
    border-radius: 34px;
    border: 2px solid var(--spectrum-alias-border-color-quiet);
  }

  .header-actions {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-100);
  }

  .section-loading {
    display: grid;
    place-items: center;
    /* Center within the visible viewport area below the header */
    min-height: calc(100vh - 60px);
  }

  /* Recent section loading centered within its own container */
  .recent-section-loading {
    display: grid;
    place-items: center;
    min-height: 280px;
  }

  /* No overlay/z-index needed; spinner centers in layout via .section-loading */

  .user-avatar {
    width: 32px;
    height: 32px;
    border-radius: 12px;
    background: var(--spectrum-global-color-gray-400);
    overflow: hidden;
  }

  /* Back references list inside delete dialog */
  .backrefs-title {
    margin-top: var(--spectrum-global-dimension-size-200);
    margin-bottom: var(--spectrum-global-dimension-size-75);
    font-size: 12px;
    color: var(--spectrum-alias-label-text-color, var(--spectrum-global-color-gray-800));
  }
  .backrefs-loading {
    margin-top: var(--spectrum-global-dimension-size-200);
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .backrefs-list {
    height: 200px;
    overflow: auto;
    border: 1px solid var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-alias-border-radius-regular, 6px);
    background: var(--spectrum-alias-background-color-secondary);
    padding: var(--spectrum-global-dimension-size-75);
  }
  /* sp-sidenav will render items; container paddings adjusted above */

  /* Divider between folders and documents */
  .folders-docs-divider {
    margin: var(--spectrum-global-dimension-size-300) 0;
  }

  /* Hero Section with Gradient */
  .hero-section {
    /*
     * Full-bleed, color-rich gradient derived from the design image.
     * Uses Spectrum tokens with hex fallbacks to ensure theming works
     * while avoiding a half-white/empty side at large widths.
     */
    --hero-peach-0: var(--spectrum-global-color-static-orange-50, #fff4ef);
    --hero-peach-1: var(--spectrum-global-color-static-orange-100, #ffe8dc);
    --hero-orange-0: var(--spectrum-global-color-static-orange-400, #ff9a3d);
    --hero-orange-1: var(--spectrum-global-color-static-orange-500, #ff7b00);
    --hero-red-0: var(--spectrum-global-color-static-red-500, #ef4a2a);
    --hero-purple-0: var(--spectrum-global-color-static-purple-500, #8b84ff);

    /* Layered gradients: warm radial core, purple top-right glow, red/orange lower-right,
       on top of a soft peach base so the left side is never white. */
    background:
      /* Left-side warm wash to avoid any white gap */
      linear-gradient(90deg,
        color-mix(in srgb, var(--hero-orange-0) 28%, transparent) 0%,
        transparent 45%),
      /* Additional left glow to deepen color on wide screens */
      radial-gradient(80% 120% at -10% 50%,
        color-mix(in srgb, var(--hero-orange-0) 55%, transparent) 0%,
        transparent 70%),
      radial-gradient(65% 85% at 75% 55%,
        color-mix(in srgb, var(--hero-orange-0) 85%, transparent) 0%,
        color-mix(in srgb, var(--hero-orange-1) 70%, transparent) 35%,
        transparent 72%),
      radial-gradient(55% 70% at 100% 0%,
        color-mix(in srgb, var(--hero-purple-0) 80%, transparent) 0%,
        color-mix(in srgb, var(--hero-purple-0) 45%, transparent) 35%,
        transparent 70%),
      radial-gradient(60% 70% at 85% 110%,
        color-mix(in srgb, var(--hero-red-0) 85%, transparent) 0%,
        color-mix(in srgb, var(--hero-orange-1) 65%, transparent) 35%,
        transparent 65%),
      linear-gradient(90deg, var(--hero-peach-0) 0%, var(--hero-peach-1) 100%);

    background-repeat: no-repeat;
    background-size: 100% 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 500px;
    position: relative;
    overflow: hidden;
  }

  .hero-content {
    max-width: 600px;
    text-align: center;
    color: #000;
  }

  .hero-headline {
    font-size: 36px;
    font-weight: 800;
    margin: 0 0 var(--spectrum-global-dimension-size-200) 0;
    font-family: "Adobe Clean", sans-serif;
    line-height: 42px;
  }

  .hero-description {
    font-size: 22px;
    line-height: 1.5;
    margin: 0 0 var(--spectrum-global-dimension-size-400) 0;
    font-family: "Adobe Clean", sans-serif;
  }

  /* Quick Action Card */
  .quick-action-card {
    background: var(--spectrum-alias-background-color-secondary);
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0px 2px 8px 0px rgba(0, 0, 0, 0.16);
    margin-bottom: var(--spectrum-global-dimension-size-400);
  }

  .quick-action-title {
    font-size: 18px;
    font-weight: 700;
    color: var(--spectrum-alias-text-color);
    margin-bottom: var(--spectrum-global-dimension-size-200);
    font-family: "Adobe Clean", sans-serif;
  }

  .quick-actions {
    display: flex;
    gap: var(--spectrum-global-dimension-size-200);
  }

  .quick-action-item {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-100);
  }

  .quick-action-button {
    height: 100px;
    background: var(--spectrum-alias-background-color-secondary);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background 0.2s ease;
    border: none;
  }

  .quick-action-button:hover {
    background: var(--spectrum-alias-background-color-hover);
  }

  .quick-action-label {
    font-size: 14px;
    font-weight: 700;
    color: var(--spectrum-alias-text-color);
    text-align: center;
    font-family: "Adobe Clean", sans-serif;
  }

  /* Element Type Icons */
  .element-types {
    display: flex;
    gap: var(--spectrum-global-dimension-size-300);
    justify-content: center;
  }

  .element-type-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-50);
    cursor: pointer;
  }

  .element-type-icon {
    width: 64px;
    height: 64px;
    background: var(--spectrum-alias-background-color-secondary);
    border-radius: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease;
  }

  .element-type-icon:hover {
    transform: scale(1.05);
  }

  .element-type-label {
    font-size: 12px;
    font-weight: 700;
    color: #000;
    text-align: center;
    font-family: "Adobe Clean", sans-serif;
  }

  /* Content Section */
  .content-section {
    flex: 0 0 auto;
    padding: var(--spectrum-global-dimension-size-400);
    background: var(--spectrum-alias-background-color-default, #f8f8f8);
    max-width: 100%;
    overflow-x: hidden;
  }

  /* Recent Section */
  .recent-section {
    max-width: 1200px;
    margin: 0 auto;
  }

  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spectrum-global-dimension-size-300);
  }

  .section-title {
    font-size: 20px;
    font-weight: 800;
    font-family: "Adobe Clean", sans-serif;
  }

  .view-all-link {
    font-size: 14px;
    color: var(--spectrum-alias-text-color);
    text-decoration: none;
    font-family: "Adobe Clean", sans-serif;
    cursor: pointer;
  }

  .view-all-link:hover {
    text-decoration: underline;
  }

  /* Creation Dialog - cleaner design */
  #dialog-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 var(--spectrum-global-dimension-size-300) var(--spectrum-global-dimension-size-200);
    margin-bottom: var(--spectrum-global-dimension-size-200);
  }

  #dialog-title {
    font-size: 20px;
    font-weight: 700;
    margin: 0;
    color: var(--spectrum-alias-text-color);
  }

  #dialog-search {
    width: 300px;
  }

  #dialog-content-wrapper {
    display: flex;
    flex-direction: column;
    min-height: 800px;
    overflow: hidden;
  }

  #dialog-content-wrapper sp-accordion {
    flex: 1;
    overflow-y: auto;
    width: 100%;
    border: none;
  }

  #dialog-content-wrapper sp-accordion-item {
    width: 100%;
    border: none;
    border-top: 1px solid var(--spectrum-alias-border-color-quiet);
  }

  #dialog-content-wrapper sp-accordion-item:first-child {
    border-top: none;
  }

  #dialog-content-wrapper sp-accordion-item[open] {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--spectrum-alias-background-color-transparent);
  }

  .templates-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, 320px);
    gap: var(--spectrum-global-dimension-size-1000);
    overflow-y: auto;
    width: 100%;
    background: transparent;
    justify-items: start;
    padding: var(--spectrum-global-dimension-size-300);
    box-sizing: border-box;
  }

  #create-dialog {
    --mod-dialog-min-width: 1200px;
  }

  .create-dialog-body {
    min-width: 1200px;
    min-height: 800px;
  }

  .library-section-list {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-300);
    padding: var(--spectrum-global-dimension-size-300);
  }

  .library-section {
    background: var(--ee-surface-100, transparent);
    border: 1px solid var(--ee-tile-border);
    border-radius: var(--spectrum-global-dimension-size-125);
  }

  .library-section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spectrum-global-dimension-size-200);
    padding: var(--spectrum-global-dimension-size-300);
  }

  .library-section-title {
    margin: 0;
    font-size: var(--spectrum-global-dimension-size-300);
  }

  .library-section-description {
    margin: 0;
    padding: 0 var(--spectrum-global-dimension-size-300);
    color: var(--spectrum-alias-text-color);
  }

  .library-section .elements-grid {
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    padding: var(--spectrum-global-dimension-size-300);
    padding-top: 0;
    align-items: stretch;
  }

  .template-loading {
    color: var(--spectrum-alias-text-color-secondary);
    font-size: var(--spectrum-global-font-size-100);
    text-align: center;
    width: 100%;
    padding: var(--spectrum-global-dimension-size-200);
  }

  .element-card {
    background: var(--ee-tile-bg);
  }

  .preview-wrapper {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    overflow: hidden;
  }

  .preview-scaler {
    display: inline-block;
    transform-origin: top left;
  }

  .preview-scaler-template {
    width: 100%;
  }

  .template-card .element-preview {
    justify-content: center;
    align-items: center;
    font-size: var(--spectrum-global-font-size-75);
    color: var(--spectrum-alias-text-color-secondary);
    background: var(--ee-surface-200, var(--spectrum-global-color-gray-200));
  }

  /* Loading State */
  .loading-spinner {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

`;
var experienceElementsHomeNewStyles = [
  galleryCommonStyles,
  homeSpecificStyles
];

// src/features/home-gallery/ee-files-section.js
init_lit();
init_lit();

// node_modules/@spectrum-web-components/action-bar/src/ActionBar.js
init_src();
init_decorators2();
init_sp_popover();

// node_modules/@spectrum-web-components/action-bar/src/action-bar.css.js
init_src();
var o45 = i`
    :host{--spectrum-actionbar-height:var(--spectrum-action-bar-height);--spectrum-actionbar-corner-radius:var(--spectrum-corner-radius-100);--spectrum-actionbar-item-counter-font-size:var(--spectrum-font-size-100);--spectrum-actionbar-item-counter-line-height:var(--spectrum-line-height-100);--spectrum-actionbar-item-counter-color:var(--spectrum-neutral-content-color-default);--spectrum-actionbar-emphasized-background-color:var(--spectrum-informative-background-color-default);--spectrum-actionbar-emphasized-item-counter-color:var(--spectrum-white);--spectrum-actionbar-spacing-outer-edge:var(--spectrum-spacing-300);--spectrum-actionbar-spacing-close-button-top:var(--spectrum-spacing-100);--spectrum-actionbar-spacing-close-button-start:var(--spectrum-spacing-100);--spectrum-actionbar-spacing-close-button-end:var(--spectrum-spacing-75);--spectrum-actionbar-spacing-item-counter-top:var(--spectrum-action-bar-top-to-item-counter);--spectrum-actionbar-spacing-item-counter-end:var(--spectrum-spacing-400);--spectrum-actionbar-spacing-action-group-top:var(--spectrum-spacing-100);--spectrum-actionbar-spacing-action-group-end:var(--spectrum-spacing-100);--spectrum-actionbar-shadow-horizontal:var(--spectrum-drop-shadow-x);--spectrum-actionbar-shadow-vertical:var(--spectrum-drop-shadow-y);--spectrum-actionbar-shadow-blur:var(--spectrum-drop-shadow-blur);--spectrum-actionbar-shadow-color:var(--spectrum-drop-shadow-color)}:host:lang(ja),:host:lang(ko),:host:lang(zh){--spectrum-actionbar-item-counter-line-height-cjk:var(--spectrum-cjk-line-height-100)}@media (forced-colors:active){:host,:host([emphasized]) #popover{--highcontrast-actionbar-popover-border-color:CanvasText}}:host{padding:0 var(--mod-actionbar-spacing-outer-edge,var(--spectrum-actionbar-spacing-outer-edge));z-index:1;box-sizing:border-box;pointer-events:none;opacity:0;block-size:0;inset-block-end:0}:host([open]){block-size:calc(var(--mod-actionbar-spacing-outer-edge,var(--spectrum-actionbar-spacing-outer-edge)) + var(--mod-actionbar-height,var(--spectrum-actionbar-height)));opacity:1}#popover{block-size:var(--mod-actionbar-height,var(--spectrum-actionbar-height));box-sizing:border-box;border-radius:var(--mod-actionbar-corner-radius,var(--spectrum-actionbar-corner-radius));border-color:var(--highcontrast-actionbar-popover-border-color,var(--mod-actionbar-popover-border-color,var(--spectrum-actionbar-popover-border-color)));background-color:var(--mod-actionbar-popover-background-color,var(--spectrum-actionbar-popover-background-color));inline-size:100%;filter:drop-shadow(var(--mod-actionbar-shadow-horizontal,var(--spectrum-actionbar-shadow-horizontal))var(--mod-actionbar-shadow-vertical,var(--spectrum-actionbar-shadow-vertical))var(--mod-actionbar-shadow-blur,var(--spectrum-actionbar-shadow-blur))var(--mod-actionbar-shadow-color,var(--spectrum-actionbar-shadow-color)));pointer-events:auto;flex-direction:row;margin:auto;padding-block:0;display:flex;position:relative}.close-button{flex-shrink:0;margin-block-start:var(--mod-actionbar-spacing-close-button-top,var(--spectrum-actionbar-spacing-close-button-top));margin-inline-start:var(--mod-actionbar-spacing-close-button-start,var(--spectrum-actionbar-spacing-close-button-start));margin-inline-end:var(--mod-actionbar-spacing-close-button-end,var(--spectrum-actionbar-spacing-close-button-end))}.field-label{font-size:var(--mod-actionbar-item-counter-font-size,var(--spectrum-actionbar-item-counter-font-size));color:var(--mod-actionbar-item-counter-color,var(--spectrum-actionbar-item-counter-color));line-height:var(--mod-actionbar-item-counter-line-height,var(--spectrum-actionbar-item-counter-line-height));margin-block-start:var(--mod-actionbar-spacing-item-counter-top,var(--spectrum-actionbar-spacing-item-counter-top));margin-inline-end:var(--mod-actionbar-spacing-item-counter-end,var(--spectrum-actionbar-spacing-item-counter-end));padding:0}.field-label:lang(ja),.field-label:lang(ko),.field-label:lang(zh){line-height:var(--mod-actionbar-item-counter-line-height-cjk,var(--spectrum-actionbar-item-counter-line-height-cjk))}.action-group{margin-block-start:var(--mod-actionbar-spacing-action-group-top,var(--spectrum-actionbar-spacing-action-group-top));margin-inline-start:auto;margin-inline-end:var(--mod-actionbar-spacing-action-group-end,var(--spectrum-actionbar-spacing-action-group-end))}:host([emphasized]) #popover{filter:none;background-color:var(--mod-actionbar-emphasized-background-color,var(--spectrum-actionbar-emphasized-background-color));border-color:#0000}:host([emphasized]) .field-label{color:var(--mod-actionbar-emphasized-item-counter-color,var(--spectrum-actionbar-emphasized-item-counter-color))}:host([variant=sticky]){position:sticky;inset-inline:0}:host([variant=fixed]){position:fixed}:host([flexible]) #popover{inline-size:auto}:host{--spectrum-actionbar-popover-background-color:var(--system-action-bar-popover-background-color);--spectrum-actionbar-popover-border-color:var(--system-action-bar-popover-border-color)}:host{display:block}:host([flexible]){display:inline-block}
`;
var action_bar_css_default = o45;

// node_modules/@spectrum-web-components/action-bar/src/ActionBar.js
init_directives();
init_focus_visible();
var u28 = Object.defineProperty;
var c29 = Object.getOwnPropertyDescriptor;
var l13 = (o52, i21, e36, r25) => {
  for (var t34 = r25 > 1 ? void 0 : r25 ? c29(i21, e36) : i21, p30 = o52.length - 1, a23; p30 >= 0; p30--) (a23 = o52[p30]) && (t34 = (r25 ? a23(i21, e36, t34) : a23(t34)) || t34);
  return r25 && t34 && u28(i21, e36, t34), t34;
};
var actionBarVariants = ["sticky", "fixed"];
var ActionBar = class extends FocusVisiblePolyfillMixin(SpectrumElement) {
  constructor() {
    super(...arguments);
    this.emphasized = false;
    this.flexible = false;
    this.open = false;
    this._variant = "";
  }
  static get styles() {
    return [action_bar_css_default];
  }
  set variant(e36) {
    if (e36 !== this.variant) {
      if (actionBarVariants.includes(e36)) {
        this.setAttribute("variant", e36), this._variant = e36;
        return;
      }
      this.removeAttribute("variant"), this._variant = "";
    }
  }
  get variant() {
    return this._variant;
  }
  handleClick() {
    this.open = false, this.dispatchEvent(new Event("close", { bubbles: true, composed: true, cancelable: true })) || (this.open = true);
  }
  render() {
    return x`
            <sp-popover ?open=${this.open} id="popover">
                <slot name="override">
                    <sp-close-button
                        static-color=${o9(this.emphasized ? "white" : void 0)}
                        class="close-button"
                        label="Clear selection"
                        @click=${this.handleClick}
                    ></sp-close-button>
                    <sp-field-label class="field-label">
                        <slot></slot>
                    </sp-field-label>
                    <sp-action-group
                        class="action-group"
                        quiet
                        static-color=${o9(this.emphasized ? "white" : void 0)}
                    >
                        <slot name="buttons"></slot>
                    </sp-action-group>
                </slot>
            </sp-popover>
        `;
  }
};
l13([n4({ type: Boolean, reflect: true })], ActionBar.prototype, "emphasized", 2), l13([n4({ type: Boolean, reflect: true })], ActionBar.prototype, "flexible", 2), l13([n4({ type: Boolean, reflect: true })], ActionBar.prototype, "open", 2), l13([n4({ type: String })], ActionBar.prototype, "variant", 1);

// node_modules/@spectrum-web-components/action-bar/sp-action-bar.js
init_define_element();
defineElement("sp-action-bar", ActionBar);

// node_modules/@spectrum-web-components/breadcrumbs/src/Breadcrumbs.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/breadcrumbs/src/BreadcrumbItem.js
init_src();
init_directives();
init_decorators2();
init_focusable();
init_like_anchor();

// node_modules/@spectrum-web-components/breadcrumbs/src/breadcrumb-item.css.js
init_src();
var e28 = i`
    #separator{margin-block:var(--mod-breadcrumbs-icon-spacing-block,var(--spectrum-breadcrumbs-icon-spacing-block));margin-inline:var(--mod-breadcrumbs-separator-spacing-inline,var(--spectrum-breadcrumbs-separator-spacing-inline));opacity:1;color:var(--highcontrast-breadcrumbs-separator-color,var(--mod-breadcrumbs-separator-color,var(--spectrum-breadcrumbs-separator-color)));position:relative}#separator:dir(rtl),:host([dir=rtl]) #separator{transform:scaleX(-1)}:host{box-sizing:border-box;white-space:nowrap;font-family:var(--mod-breadcrumbs-font-family,var(--spectrum-breadcrumbs-font-family));font-size:var(--mod-breadcrumbs-font-size,var(--spectrum-breadcrumbs-font-size));font-weight:var(--mod-breadcrumbs-font-weight,var(--spectrum-breadcrumbs-font-weight));line-height:var(--mod-breadcrumbs-line-height,var(--spectrum-breadcrumbs-line-height));align-items:center;display:inline-flex;position:relative}:host(:not(.is-menu):last-of-type){font-family:var(--mod-breadcrumbs-font-family-current,var(--spectrum-breadcrumbs-font-family-current));font-size:var(--mod-breadcrumbs-font-size-current,var(--spectrum-breadcrumbs-font-size-current));font-weight:var(--mod-breadcrumbs-font-weight-current,var(--spectrum-breadcrumbs-font-weight-current))}:host(:not(.is-menu):last-of-type) #separator{display:none}::slotted(sp-action-menu){margin-inline:var(--mod-breadcrumbs-action-button-spacing-inline,var(--spectrum-breadcrumbs-action-button-spacing-inline));margin-block:var(--mod-breadcrumbs-action-button-spacing-block,var(--spectrum-breadcrumbs-action-button-spacing-block));color:var(--highcontrast-breadcrumbs-action-button-color,var(--mod-breadcrumbs-action-button-color,var(--spectrum-breadcrumbs-action-button-color)))}::slotted(sp-action-menu[disabled]){color:var(--highcontrast-breadcrumbs-action-button-color-disabled,var(--mod-breadcrumbs-action-button-color-disabled,var(--spectrum-breadcrumbs-action-button-color-disabled)))}:host(:first-of-type)>::slotted(sp-action-menu){margin-inline-start:var(--mod-breadcrumbs-action-button-spacing-inline-start,var(--spectrum-breadcrumbs-action-button-spacing-inline-start))}#item-link{cursor:default;box-sizing:border-box;border-radius:var(--mod-breadcrumbs-item-link-border-radius,var(--spectrum-breadcrumbs-item-link-border-radius));color:var(--highcontrast-breadcrumbs-text-color,var(--mod-breadcrumbs-text-color,var(--spectrum-breadcrumbs-text-color)));outline:none;margin-block-start:var(--mod-breadcrumbs-text-spacing-block-start,var(--spectrum-breadcrumbs-text-spacing-block-start));margin-block-end:var(--mod-breadcrumbs-text-spacing-block-end,var(--spectrum-breadcrumbs-text-spacing-block-end));-webkit-text-decoration:none;text-decoration:none;display:block;position:relative}#item-link.is-disabled,:host([aria-disabled=true]) #item-link{color:var(--highcontrast-breadcrumbs-text-color-disabled,var(--mod-breadcrumbs-text-color-disabled,var(--spectrum-breadcrumbs-text-color-disabled)))}:host(:not(.is-menu):last-of-type) #item-link{color:var(--highcontrast-breadcrumbs-text-color-current,var(--mod-breadcrumbs-text-color-current,var(--spectrum-breadcrumbs-text-color-current)))}#item-link[href],#item-link[tabindex]{cursor:pointer}#item-link[href]:focus-visible,#item-link[tabindex]:focus-visible{-webkit-text-decoration:underline;text-decoration:underline;text-decoration-thickness:var(--mod-breadcrumbs-text-decoration-thickness,var(--spectrum-breadcrumbs-text-decoration-thickness));text-underline-offset:var(--mod-breadcrumbs-text-decoration-gap,var(--spectrum-breadcrumbs-text-decoration-gap))}@media (hover:hover){#item-link[href]:hover,#item-link[tabindex]:hover{-webkit-text-decoration:underline;text-decoration:underline;text-decoration-thickness:var(--mod-breadcrumbs-text-decoration-thickness,var(--spectrum-breadcrumbs-text-decoration-thickness));text-underline-offset:var(--mod-breadcrumbs-text-decoration-gap,var(--spectrum-breadcrumbs-text-decoration-gap))}}:host .is-dragged #item-link:before,#item-link:focus-visible:before{box-sizing:border-box;inline-size:calc(100% + var(--mod-breadcrumbs-focus-indicator-gap,var(--spectrum-breadcrumbs-focus-indicator-gap))*2 + var(--mod-breadcrumbs-focus-indicator-thickness,var(--spectrum-breadcrumbs-focus-indicator-thickness))*2);block-size:calc(100% + var(--mod-breadcrumbs-focus-indicator-gap,var(--spectrum-breadcrumbs-focus-indicator-gap))*2 + var(--mod-breadcrumbs-focus-indicator-thickness,var(--spectrum-breadcrumbs-focus-indicator-thickness))*2);border-width:var(--mod-breadcrumbs-focus-indicator-thickness,var(--spectrum-breadcrumbs-focus-indicator-thickness));border-radius:var(--mod-breadcrumbs-item-link-border-radius,var(--spectrum-breadcrumbs-item-link-border-radius));content:"";pointer-events:none;border-style:solid;border-color:var(--highcontrast-breadcrumbs-focus-indicator-color,var(--mod-breadcrumbs-focus-indicator-color,var(--spectrum-breadcrumbs-focus-indicator-color)));margin-block-start:calc((var(--mod-breadcrumbs-focus-indicator-gap,var(--spectrum-breadcrumbs-focus-indicator-gap)) + var(--mod-breadcrumbs-focus-indicator-thickness,var(--spectrum-breadcrumbs-focus-indicator-thickness)))*-1);margin-inline-start:calc((var(--mod-breadcrumbs-focus-indicator-gap,var(--spectrum-breadcrumbs-focus-indicator-gap)) + var(--mod-breadcrumbs-focus-indicator-thickness,var(--spectrum-breadcrumbs-focus-indicator-thickness)))*-1);display:block;position:absolute}:host([hidden]){display:none}:host([disabled]){pointer-events:none}
`;
var breadcrumb_item_css_default = e28;

// node_modules/@spectrum-web-components/breadcrumbs/src/BreadcrumbItem.js
var u29 = Object.defineProperty;
var p24 = Object.getOwnPropertyDescriptor;
var a18 = (s19, i21, e36, r25) => {
  for (var t34 = r25 > 1 ? void 0 : r25 ? p24(i21, e36) : i21, o52 = s19.length - 1, l16; o52 >= 0; o52--) (l16 = s19[o52]) && (t34 = (r25 ? l16(i21, e36, t34) : l16(t34)) || t34);
  return r25 && t34 && u29(i21, e36, t34), t34;
};
var BreadcrumbItem = class extends LikeAnchor(Focusable) {
  constructor() {
    super(...arguments);
    this.value = void 0;
    this.isLastOfType = false;
  }
  static get styles() {
    return [breadcrumb_item_css_default, spectrum_icon_chevron_css_default];
  }
  get focusElement() {
    return this.shadowRoot.querySelector("#item-link");
  }
  connectedCallback() {
    super.connectedCallback(), this.hasAttribute("role") || this.setAttribute("role", "listitem");
  }
  announceSelected(e36) {
    const r25 = { value: e36 }, t34 = new CustomEvent("breadcrumb-select", { bubbles: true, composed: true, detail: r25 });
    this.dispatchEvent(t34);
  }
  handleClick(e36) {
    !this.href && e36 && e36.preventDefault(), (!this.href || e36 != null && e36.defaultPrevented) && this.value && !this.isLastOfType && this.announceSelected(this.value);
  }
  handleKeyDown(e36) {
    (e36.key === "Enter" || e36.keyCode === 13) && this.handleClick(e36);
  }
  renderLink() {
    return x`
            <a
                id="item-link"
                href=${o9(this.isLastOfType ? void 0 : this.href)}
                tabindex=${0}
                aria-current=${o9(this.isLastOfType ? "page" : void 0)}
                @keydown=${this.handleKeyDown}
                @click=${this.handleClick}
            >
                <slot></slot>
            </a>
        `;
  }
  renderSeparator() {
    return x`
            <sp-icon-chevron100
                id="separator"
                size="xs"
                class="spectrum-UIIcon-ChevronRight100"
            ></sp-icon-chevron100>
        `;
  }
  render() {
    return x`
            ${this.renderLink()}
            <slot name="menu"></slot>
            ${this.renderSeparator()}
        `;
  }
  updated(e36) {
    e36.has("disabled") && (this.disabled ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled"));
  }
};
a18([n4()], BreadcrumbItem.prototype, "value", 2), a18([n4({ type: Boolean })], BreadcrumbItem.prototype, "isLastOfType", 2);

// node_modules/@spectrum-web-components/breadcrumbs/sp-breadcrumb-item.js
customElements.define("sp-breadcrumb-item", BreadcrumbItem);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFolderOpen.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/FolderOpen.js
var FolderOpenIcon = ({ width: e36 = 24, height: l16 = 24, hidden: t34 = false, title: r25 = "Folder Open" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M19.21143,8.89648c-.4292-.56934-1.08398-.89648-1.79736-.89648H6.65918c-.99756,0-1.88672.66992-2.1626,1.62891l-1.64954,5.73682c-.20404-.13428-.34705-.35413-.34705-.61572V4.25c0-.41309.33643-.75.75-.75h3.56494c.21826,0,.42529.09473.56689.25684l1.70117,1.96875c.42773.49219,1.04688.77441,1.69922.77441h6.18945c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75h-6.18945c-.21777,0-.42432-.09473-.56592-.25684l-1.70117-1.96875c-.42773-.49219-1.04736-.77441-1.7002-.77441h-3.56494c-1.24072,0-2.25,1.00977-2.25,2.25v10.5c0,1.24023,1.00928,2.25,2.25,2.25.0235,0,.04327-.01123.06622-.01343.01978.00171.03687.01343.05682.01343h12.74756c.99805,0,1.88721-.66992,2.16211-1.62891l1.29395-4.5c.19727-.68457.06396-1.4043-.36523-1.97461ZM18.13525,10.45703l-1.29395,4.5c-.0918.31934-.38818.54297-.7207.54297H4.36914l1.56885-5.45703c.09229-.31934.38867-.54297.72119-.54297h10.75488c.23779,0,.45605.10938.59912.29883.14307.19043.1875.42969.12207.6582Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/FolderOpen.js
var FolderOpenIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: a23 = "Folder Open" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M30 14V9a1 1 0 0 0-1-1l-12.332.008-3.3-3.4A2 2 0 0 0 11.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h26.307a1 1 0 0 0 .936-.649l5.25-14A1 1 0 0 0 34.557 14ZM4 6h7.929l3.305 3.4.59.607h.845L28 10v4H8.693a1 1 0 0 0-.936.649L4 24.667Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFolderOpen.js
var IconFolderOpen = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? FolderOpenIcon({ hidden: !this.label, title: this.label }) : FolderOpenIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-folder-open.js
init_define_element();
defineElement("sp-icon-folder-open", IconFolderOpen);

// node_modules/@spectrum-web-components/breadcrumbs/src/Breadcrumbs.js
init_directives();

// node_modules/@spectrum-web-components/breadcrumbs/src/breadcrumbs.css.js
init_src();
var r21 = i`
    :host{--spectrum-breadcrumbs-block-size:var(--spectrum-breadcrumbs-height);--spectrum-breadcrumbs-block-size-compact:var(--spectrum-breadcrumbs-height-compact);--spectrum-breadcrumbs-block-size-multiline:var(--spectrum-breadcrumbs-height-multiline);--spectrum-breadcrumbs-line-height:var(--spectrum-line-height-100);--spectrum-breadcrumbs-font-size:var(--spectrum-font-size-200);--spectrum-breadcrumbs-font-family:var(--spectrum-sans-font-family-stack);--spectrum-breadcrumbs-font-weight:var(--spectrum-regular-font-weight);--spectrum-breadcrumbs-font-size-current:var(--spectrum-font-size-200);--spectrum-breadcrumbs-font-family-current:var(--spectrum-sans-font-family-stack);--spectrum-breadcrumbs-font-weight-current:var(--spectrum-bold-font-weight);--spectrum-breadcrumbs-font-size-compact:var(--spectrum-font-size-100);--spectrum-breadcrumbs-font-family-compact:var(--spectrum-sans-font-family-stack);--spectrum-breadcrumbs-font-weight-compact:var(--spectrum-regular-font-weight);--spectrum-breadcrumbs-font-size-compact-current:var(--spectrum-font-size-100);--spectrum-breadcrumbs-font-family-compact-current:var(--spectrum-sans-font-family-stack);--spectrum-breadcrumbs-font-weight-compact-current:var(--spectrum-bold-font-weight);--spectrum-breadcrumbs-font-size-multiline:var(--spectrum-font-size-75);--spectrum-breadcrumbs-font-family-multiline:var(--spectrum-sans-font-family-stack);--spectrum-breadcrumbs-font-weight-multiline:var(--spectrum-regular-font-weight);--spectrum-breadcrumbs-font-size-multiline-current:var(--spectrum-font-size-300);--spectrum-breadcrumbs-font-family-multiline-current:var(--spectrum-sans-font-family-stack);--spectrum-breadcrumbs-font-weight-multiline-current:var(--spectrum-bold-font-weight);--spectrum-breadcrumbs-text-decoration-thickness:var(--spectrum-text-underline-thickness);--spectrum-breadcrumbs-text-decoration-gap:var(--spectrum-text-underline-gap);--spectrum-breadcrumbs-separator-spacing-inline:var(--spectrum-text-to-visual-100);--spectrum-breadcrumbs-text-spacing-block-start:var(--spectrum-breadcrumbs-top-to-text);--spectrum-breadcrumbs-text-spacing-block-end:var(--spectrum-breadcrumbs-bottom-to-text);--spectrum-breadcrumbs-icon-spacing-block:var(--spectrum-breadcrumbs-top-to-separator-icon);--spectrum-breadcrumbs-text-spacing-block-start-compact:var(--spectrum-breadcrumbs-top-to-text-compact);--spectrum-breadcrumbs-text-spacing-block-end-compact:var(--spectrum-breadcrumbs-bottom-to-text-compact);--spectrum-breadcrumbs-icon-spacing-block-compact:var(--spectrum-breadcrumbs-top-to-separator-icon-compact);--spectrum-breadcrumbs-text-spacing-block-start-multiline:var(--spectrum-breadcrumbs-top-to-text-multiline);--spectrum-breadcrumbs-text-spacing-block-end-multiline:var(--spectrum-breadcrumbs-bottom-to-text-multiline);--spectrum-breadcrumbs-text-spacing-block-between-multiline:var(--spectrum-breadcrumbs-top-text-to-bottom-text);--spectrum-breadcrumbs-icon-spacing-block-start-multiline:var(--spectrum-breadcrumbs-top-to-separator-icon-multiline);--spectrum-breadcrumbs-icon-spacing-block-between-multiline:var(--spectrum-breadcrumbs-separator-icon-to-bottom-text-multiline);--spectrum-breadcrumbs-inline-start:var(--spectrum-breadcrumbs-start-edge-to-text);--spectrum-breadcrumbs-inline-end:var(--spectrum-breadcrumbs-end-edge-to-text);--spectrum-breadcrumbs-action-button-spacing-inline:var(--spectrum-breadcrumbs-truncated-menu-to-separator-icon);--spectrum-breadcrumbs-action-button-spacing-block:var(--spectrum-breadcrumbs-top-to-truncated-menu);--spectrum-breadcrumbs-action-button-spacing-block-compact:var(--spectrum-breadcrumbs-top-to-truncated-menu-compact);--spectrum-breadcrumbs-action-button-spacing-inline-start:var(--spectrum-breadcrumbs-start-edge-to-truncated-menu);--spectrum-breadcrumbs-action-button-spacing-block-multiline:var(--spectrum-breadcrumbs-top-to-truncated-menu-compact);--spectrum-breadcrumbs-action-button-spacing-block-between-multiline:var(--spectrum-breadcrumbs-truncated-menu-to-bottom-text);--spectrum-breadcrumbs-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-breadcrumbs-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--spectrum-breadcrumbs-item-link-border-radius:var(--spectrum-corner-radius-100);--spectrum-breadcrumbs-text-color:var(--spectrum-neutral-subdued-content-color-default);--spectrum-breadcrumbs-text-color-current:var(--spectrum-neutral-content-color-default);--spectrum-breadcrumbs-text-color-disabled:var(--spectrum-disabled-content-color);--spectrum-breadcrumbs-separator-color:var(--spectrum-neutral-content-color-default);--spectrum-breadcrumbs-action-button-color:var(--spectrum-neutral-subdued-content-color-default);--spectrum-breadcrumbs-action-button-color-disabled:var(--spectrum-disabled-content-color);--spectrum-breadcrumbs-focus-indicator-color:var(--spectrum-focus-indicator-color)}@media (forced-colors:active){:host{--highcontrast-breadcrumbs-text-color:LinkText;--highcontrast-breadcrumbs-text-color-current:CanvasText;--highcontrast-breadcrumbs-text-color-disabled:GrayText;--highcontrast-breadcrumbs-separator-color:CanvasText;--highcontrast-breadcrumbs-action-button-color:LinkText;--highcontrast-breadcrumbs-action-button-color-disabled:GrayText;--highcontrast-breadcrumbs-focus-indicator-color:CanvasText}}#list{block-size:var(--mod-breadcrumbs-block-size,var(--spectrum-breadcrumbs-block-size));flex-flow:row;flex:1 0;justify-content:flex-start;align-items:center;margin:0;padding-inline-start:var(--mod-breadcrumbs-inline-start,var(--spectrum-breadcrumbs-inline-start));padding-inline-end:var(--mod-breadcrumbs-inline-end,var(--spectrum-breadcrumbs-inline-end));list-style-type:none;display:flex}:host([compact]) #list{block-size:var(--mod-breadcrumbs-block-size-compact,var(--spectrum-breadcrumbs-block-size-compact))}.spectrum-Breadcrumbs--multiline{block-size:var(--mod-breadcrumbs-block-size-multiline,var(--spectrum-breadcrumbs-block-size-multiline));flex-wrap:wrap;align-content:center}:host([compact]) ::slotted(sp-breadcrumb-item){font-family:var(--mod-breadcrumbs-font-family-compact,var(--spectrum-breadcrumbs-font-family-compact));font-size:var(--mod-breadcrumbs-font-size-compact,var(--spectrum-breadcrumbs-font-size-compact));font-weight:var(--mod-breadcrumbs-font-weight-compact,var(--spectrum-breadcrumbs-font-weight-compact))}:host([compact]) ::slotted(:last-of-type){font-family:var(--mod-breadcrumbs-font-family-compact-current,var(--spectrum-breadcrumbs-font-family-compact-current));font-size:var(--mod-breadcrumbs-font-size-compact-current,var(--spectrum-breadcrumbs-font-size-compact-current));font-weight:var(--mod-breadcrumbs-font-weight-compact-current,var(--spectrum-breadcrumbs-font-weight-compact-current))}:host{display:block}:host([compact]){--mod-breadcrumbs-icon-spacing-block:var(--mod-breadcrumbs-icon-spacing-block-compact,var(--spectrum-breadcrumbs-icon-spacing-block-compact));--mod-breadcrumbs-text-spacing-block-start:var(--mod-breadcrumbs-text-spacing-block-start-compact,var(--spectrum-breadcrumbs-text-spacing-block-start-compact));--mod-breadcrumbs-text-spacing-block-end:var(--mod-breadcrumbs-text-spacing-block-end-compact,var(--spectrum-breadcrumbs-text-spacing-block-end-compact));--mod-breadcrumbs-action-button-spacing-block:var(--mod-breadcrumbs-action-button-spacing-block-compact,var(--spectrum-breadcrumbs-action-button-spacing-block-compact))}:host([dir]) slot[slot=icon]::slotted([slot=icon]),:host([dir]) slot[slot=icon] .icon{margin-inline:calc((var(--custom-actionbutton-edge-to-text,var(--spectrum-actionbutton-edge-to-text)) - var(--custom-actionbutton-edge-to-visual-only,var(--spectrum-actionbutton-edge-to-visual-only)))*-1)}
`;
var breadcrumbs_css_default = r21;

// node_modules/@spectrum-web-components/breadcrumbs/src/Breadcrumbs.js
init_directives();
var d15 = Object.defineProperty;
var c30 = Object.getOwnPropertyDescriptor;
var s15 = (o52, a23, e36, t34) => {
  for (var i21 = t34 > 1 ? void 0 : t34 ? c30(a23, e36) : a23, l16 = o52.length - 1, r25; l16 >= 0; l16--) (r25 = o52[l16]) && (i21 = (t34 ? r25(a23, e36, i21) : r25(i21)) || i21);
  return t34 && i21 && d15(a23, e36, i21), i21;
};
var Breadcrumbs = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.maxVisibleItems = 4;
    this.label = "";
    this.menuLabel = "More items";
    this.compact = false;
    this.items = [];
    this.visibleItems = 0;
    this.firstRender = true;
    this.menuRef = e12();
  }
  static get styles() {
    return [breadcrumbs_css_default];
  }
  get hasMenu() {
    var e36, t34;
    return this.visibleItems < ((t34 = (e36 = this.breadcrumbsElements) == null ? void 0 : e36.length) != null ? t34 : 0);
  }
  connectedCallback() {
    super.connectedCallback(), this.hasAttribute("role") || this.setAttribute("role", "navigation"), this.resizeObserver = new ResizeObserver(() => {
      if (this.firstRender) {
        this.firstRender = false;
        return;
      }
      this.adjustOverflow();
    }), this.resizeObserver.observe(this);
  }
  disconnectedCallback() {
    var e36;
    (e36 = this.resizeObserver) == null || e36.unobserve(this), super.disconnectedCallback();
  }
  updated(e36) {
    super.updated(e36), e36.has("label") && this.setAttribute("aria-label", this.label || "Breadcrumbs"), (e36.has("maxVisibleItems") || e36.has("compact")) && (this.calculateBreadcrumbItemsWidth(), this.adjustOverflow()), e36.has("visibleItems") && this.items.forEach((t34, i21) => {
      this.breadcrumbsElements[i21].isLastOfType = i21 === this.breadcrumbsElements.length - 1, this.breadcrumbsElements[i21].toggleAttribute("hidden", !t34.isVisible);
    });
  }
  calculateBreadcrumbItemsWidth() {
    this.items = this.breadcrumbsElements.map((e36, t34) => {
      let i21 = e36.offsetWidth;
      return e36.hasAttribute("hidden") && (e36.removeAttribute("hidden"), i21 = e36.offsetWidth, e36.setAttribute("hidden", "")), { label: e36.innerText, href: e36.href, value: e36.value || t34.toString(), offsetWidth: i21, isVisible: true };
    });
  }
  adjustOverflow() {
    let e36 = 0, t34 = 0;
    const i21 = this.list.clientWidth;
    this.hasMenu && this.menuRef.value && (e36 += this.menuRef.value.offsetWidth || 0), this.rootElement.length > 0 && (e36 += this.rootElement[0].offsetWidth);
    const l16 = 0;
    for (let r25 = this.items.length - 1; r25 >= l16; r25--) if (e36 += this.items[r25].offsetWidth, e36 < i21 && t34 < Math.max(this.maxVisibleItems, 1)) this.items[r25].isVisible = true, t34++;
    else {
      for (let m18 = r25; m18 >= l16; m18--) this.items[m18].isVisible = false;
      break;
    }
    t34 === 0 && (this.items[this.items.length - 1].isVisible = true, t34++), t34 !== this.visibleItems && (this.visibleItems = t34);
  }
  announceChange(e36) {
    const t34 = { value: e36 }, i21 = new CustomEvent("change", { bubbles: true, composed: true, detail: t34 });
    this.dispatchEvent(i21);
  }
  handleSelect(e36) {
    e36.stopPropagation(), this.announceChange(e36.detail.value);
  }
  handleMenuChange(e36) {
    e36.stopPropagation(), this.announceChange(e36.target.value);
  }
  renderMenu() {
    return x`
            <sp-breadcrumb-item role="listitem" class="is-menu">
                <sp-action-menu
                    ${n10(this.menuRef)}
                    quiet
                    label=${this.menuLabel}
                    selects="single"
                    value=${this.items[this.items.length - 1].value}
                    @change=${this.handleMenuChange}
                    slot="menu"
                >
                    <slot slot="icon" name="icon">
                        <sp-icon-folder-open class="icon"></sp-icon-folder-open>
                    </slot>

                    ${this.items.map((e36) => x`
                            <sp-menu-item
                                href=${o9(e36.href)}
                                value=${e36.value}
                            >
                                ${e36.label}
                            </sp-menu-item>
                        `)}
                </sp-action-menu>
            </sp-breadcrumb-item>
        `;
  }
  async slotChangeHandler() {
    if (this.breadcrumbsElements.length === 0) {
      this.items = [], this.visibleItems = 0;
      return;
    }
    await Promise.all(this.breadcrumbsElements.map((e36) => e36.updateComplete)), this.calculateBreadcrumbItemsWidth(), this.visibleItems = 0, this.adjustOverflow();
  }
  render() {
    return x`
            <ul @breadcrumb-select=${this.handleSelect} id="list">
                <slot name="root"></slot>
                ${this.hasMenu ? this.renderMenu() : ""}
                <slot @slotchange=${this.slotChangeHandler}></slot>
            </ul>
        `;
  }
};
s15([n4({ type: Number, attribute: "max-visible-items" })], Breadcrumbs.prototype, "maxVisibleItems", 2), s15([n4({ type: String })], Breadcrumbs.prototype, "label", 2), s15([n4({ type: String, attribute: "menu-label" })], Breadcrumbs.prototype, "menuLabel", 2), s15([n4({ type: Boolean })], Breadcrumbs.prototype, "compact", 2), s15([o8({ selector: "sp-breadcrumb-item" })], Breadcrumbs.prototype, "breadcrumbsElements", 2), s15([o8({ slot: "root", selector: "sp-breadcrumb-item" })], Breadcrumbs.prototype, "rootElement", 2), s15([e5("#list")], Breadcrumbs.prototype, "list", 2), s15([r5()], Breadcrumbs.prototype, "items", 2), s15([r5()], Breadcrumbs.prototype, "visibleItems", 2);

// node_modules/@spectrum-web-components/breadcrumbs/sp-breadcrumbs.js
customElements.define("sp-breadcrumbs", Breadcrumbs);

// src/features/home-gallery/ee-files-section.js
init_sp_progress_circle();

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconNew.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/New.js
var NewIcon = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: l16 = "New" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m18,4.25v11.5c0,1.24072-1.00928,2.25-2.25,2.25H4.25c-1.24072,0-2.25-1.00928-2.25-2.25V4.25c0-1.24072,1.00928-2.25,2.25-2.25h11.5c1.24072,0,2.25,1.00928,2.25,2.25Zm-1.5,0c0-.41357-.33643-.75-.75-.75H4.25c-.41357,0-.75.33643-.75.75v11.5c0,.41357.33643.75.75.75h11.5c.41357,0,.75-.33643.75-.75V4.25Z"
      fill="currentColor"
    />
    <path
      d="m13.76318,10c0,.42139-.3418.76318-.76318.76318h-2.23682v2.23682c0,.42139-.3418.76318-.76318.76318s-.76318-.3418-.76318-.76318v-2.23682h-2.23682c-.42139,0-.76318-.3418-.76318-.76318s.3418-.76318.76318-.76318h2.23682v-2.23682c0-.42139.3418-.76318.76318-.76318s.76318.3418.76318.76318v2.23682h2.23682c.42139,0,.76318.3418.76318.76318Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/NewItem.js
var NewItemIcon = ({ width: a23 = 24, height: e36 = 24, hidden: t34 = false, title: r25 = "New Item" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${a23}"
    height="${e36}"
    viewBox="0 0 36 36"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M6 6h22v22H6Zm-.8-2A1.19 1.19 0 0 0 4 5.2V29a1 1 0 0 0 1 1h23.8a1.19 1.19 0 0 0 1.2-1.2V5.2A1.189 1.189 0 0 0 28.8 4Z"
    />
    <path
      d="M16.5 10a.5.5 0 0 0-.5.5V16h-5.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5H16v5.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V18h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H18v-5.5a.5.5 0 0 0-.5-.5Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconNew.js
var IconNew = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? NewIcon({ hidden: !this.label, title: this.label }) : NewItemIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-new.js
init_define_element();
defineElement("sp-icon-new", IconNew);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSelectMulti.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/SelectMulti.js
var SelectMultiIcon = ({ width: l16 = 24, height: t34 = 24, hidden: e36 = false, title: c33 = "Select Multi" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${c33}"
  >
    <path
      d="M14.62842,8.39464c-.33496-.24414-.80371-.17188-1.04834.16211l-3.07477,4.19824-1.0141-1.30566c-.25439-.32715-.7251-.38477-1.05225-.13281-.32715.25488-.38623.72559-.13232,1.05273l1.62402,2.09082c.01715.02197.04315.03052.06219.05029.02991.03125.0506.06885.08673.09521.02643.01929.05658.02759.08453.04297.02393.01318.04602.02588.07104.03613.09314.03906.18939.06543.28729.06543h.00098c.10095,0,.19995-.02808.29535-.06934.02667-.01172.0498-.02563.07513-.04028.02942-.01685.0614-.02637.08899-.04761.03583-.02783.05579-.06641.08514-.09912.01807-.01953.04364-.02832.05988-.05029l3.66211-5c.24463-.33398.17236-.80371-.16162-1.04883Z"
      fill="currentColor"
    />
    <path
      d="M15.75,18.0001H7.25c-1.24072,0-2.25-1.00977-2.25-2.25V7.2501c0-1.24023,1.00928-2.25,2.25-2.25h8.5c1.24072,0,2.25,1.00977,2.25,2.25v8.5c0,1.24023-1.00928,2.25-2.25,2.25ZM7.25,6.5001c-.41357,0-.75.33691-.75.75v8.5c0,.41309.33643.75.75.75h8.5c.41357,0,.75-.33691.75-.75V7.2501c0-.41309-.33643-.75-.75-.75H7.25Z"
      fill="currentColor"
    />
    <path
      d="M2.75,13.7501c-.41406,0-.75-.33594-.75-.75V4.2501c0-1.24023,1.00928-2.25,2.25-2.25h8.75c.41406,0,.75.33594.75.75s-.33594.75-.75.75H4.25c-.41357,0-.75.33691-.75.75v8.75c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/SelectBoxAll.js
var SelectBoxAllIcon = ({ width: e36 = 24, height: l16 = 24, hidden: t34 = false, title: a23 = "Select Box All" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${l16}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M29.2 8H12.8A4.8 4.8 0 0 0 8 12.8v16.4a4.8 4.8 0 0 0 4.8 4.8h16.4a4.8 4.8 0 0 0 4.8-4.8V12.8A4.8 4.8 0 0 0 29.2 8Zm1.223 9.049L18.988 28.573a.8.8 0 0 1-1.131 0l-6.28-6.278a.8.8 0 0 1 0-1.131l2.491-2.491a.8.8 0 0 1 1.131 0l3.224 3.227 8.378-8.47a.8.8 0 0 1 1.131 0l2.491 2.491a.8.8 0 0 1 0 1.128Z"
    />
    <path d="M26 2H6.8A4.8 4.8 0 0 0 2 6.8V26a4 4 0 0 0 4 4V6h24a4 4 0 0 0-4-4Z" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSelectMulti.js
var IconSelectMulti = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? SelectMultiIcon({ hidden: !this.label, title: this.label }) : SelectBoxAllIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-select-multi.js
init_define_element();
defineElement("sp-icon-select-multi", IconSelectMulti);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSelectAllItems.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/SelectAllItems.js
var SelectAllItemsIcon = ({ width: l16 = 24, height: c33 = 24, hidden: r25 = false, title: t34 = "Select All Items" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${c33}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="M10.5,5.52148h-1.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.25c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M10.5,16.02148h-1.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.25c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M15.25,7.02148c-.41406,0-.75-.33594-.75-.75,0-.41309-.33691-.75-.75-.75-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75c1.24023,0,2.25,1.00977,2.25,2.25,0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M15.25,11.27148c-.41406,0-.75-.33594-.75-.75v-1.25c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.25c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M4.75,11.27148c-.41406,0-.75-.33594-.75-.75v-1.25c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.25c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M6.25,16.02148c-1.24023,0-2.25-1.00977-2.25-2.25,0-.41406.33594-.75.75-.75s.75.33594.75.75c0,.41309.33691.75.75.75.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M4.75,7.02148c-.41406,0-.75-.33594-.75-.75,0-1.24023,1.00977-2.25,2.25-2.25.41406,0,.75.33594.75.75s-.33594.75-.75.75c-.41309,0-.75.33691-.75.75,0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M13.75,16.02148c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75c.41309,0,.75-.33691.75-.75,0-.41406.33594-.75.75-.75s.75.33594.75.75c0,1.24023-1.00977,2.25-2.25,2.25Z"
      fill="currentColor"
    />
    <path
      d="M18.25,5.75c-.41406,0-.75-.33594-.75-.75v-1.75c0-.41309-.33691-.75-.75-.75h-1.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.75c1.24023,0,2.25,1.00977,2.25,2.25v1.75c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M16.75,19h-1.75c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.75c.41309,0,.75-.33691.75-.75v-1.75c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.75c0,1.24023-1.00977,2.25-2.25,2.25Z"
      fill="currentColor"
    />
    <path
      d="M5,19h-1.75c-1.24023,0-2.25-1.00977-2.25-2.25v-1.75c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.75c0,.41309.33691.75.75.75h1.75c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="M1.75,5.75c-.41406,0-.75-.33594-.75-.75v-1.75c0-1.24023,1.00977-2.25,2.25-2.25h1.75c.41406,0,.75.33594.75.75s-.33594.75-.75.75h-1.75c-.41309,0-.75.33691-.75.75v1.75c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSelectAllItems.js
var IconSelectAllItems = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? SelectAllItemsIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-select-all-items.js
init_define_element();
defineElement("sp-icon-select-all-items", IconSelectAllItems);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUserGroup.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/UserGroup.js
var UserGroupIcon = ({ width: e36 = 24, height: r25 = 24, hidden: t34 = false, title: l16 = "User Group" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m12.25293,11.94922c-2.27637,0-4.12793-1.94629-4.12793-4.33887s1.85156-4.33887,4.12793-4.33887,4.12793,1.94629,4.12793,4.33887-1.85156,4.33887-4.12793,4.33887Zm0-7.17773c-1.44922,0-2.62793,1.27344-2.62793,2.83887s1.17871,2.83887,2.62793,2.83887,2.62793-1.27344,2.62793-2.83887-1.17871-2.83887-2.62793-2.83887Zm-5.37598,12.84082c.21484-1.99219,2.57617-3.55273,5.37598-3.55273,2.82324,0,5.18457,1.55664,5.37598,3.54492.04004.41309.41602.72656.81836.67383.41211-.03906.71387-.40527.67383-.81836-.26367-2.74805-3.28125-4.90039-6.86816-4.90039-3.61426,0-6.56641,2.10352-6.86816,4.89258-.04395.41113.25391.78125.66602.82617.02734.00293.05371.00391.08105.00391.37793,0,.70312-.28516.74512-.66992Zm.24023-7.89355c.16895-.37793.00098-.82227-.37695-.99219-.98535-.44238-1.62109-1.47168-1.62109-2.62207,0-1.56543,1.17871-2.83887,2.62793-2.83887.15234,0,.30078.01465.44629.04102.40234.08105.7998-.19238.87402-.60059.0752-.40723-.19336-.79883-.60059-.87402-.2334-.04395-.47363-.06641-.71973-.06641-2.27637,0-4.12793,1.94629-4.12793,4.33887,0,1.74023.9834,3.30664,2.50586,3.99121.09961.04395.2041.06543.30762.06543.28613,0,.55957-.16504.68457-.44238Zm-4.74609,6.38867c.20508-1.90234,2.36914-3.42676,5.03223-3.5459.41406-.01855.73438-.36816.71582-.78223-.01758-.40234-.34961-.7168-.74805-.7168-.01172,0-.02344,0-.03418.00098-3.45312.1543-6.16797,2.20703-6.45801,4.88184-.04395.41211.25391.78223.66504.82715.02832.00293.05469.00391.08203.00391.37793,0,.70312-.28516.74512-.66895Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/UserGroup.js
var UserGroupIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "User Group" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M26.922 20.476c-1.441-.125-1.464-1.284-1.464-2.729a13.151 13.151 0 0 0 3.09-7.837c0-4.746-2.7-7.91-6.589-7.91a6.3 6.3 0 0 0-2.679.574c3.206 1.69 5.24 5.28 5.24 9.9a15.6 15.6 0 0 1-2.42 7.949.861.861 0 0 0 .474 1.288A13.488 13.488 0 0 1 31.779 30h3.257a.871.871 0 0 0 .879-.922c-.579-6.289-7.023-8.43-8.993-8.602Z"
    />
    <path
      d="M28.973 34a.931.931 0 0 0 .941-.988c-.62-6.734-7.525-9.028-9.636-9.212-1.544-.134-1.569-1.377-1.569-2.925a14.093 14.093 0 0 0 3.311-8.4C22.02 7.391 19.126 4 14.959 4S7.9 7.391 7.9 12.477a14.093 14.093 0 0 0 3.311 8.4c0 1.548-.025 2.791-1.569 2.925-2.113.182-9.018 2.476-9.642 9.21A.931.931 0 0 0 .945 34Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconUserGroup.js
var IconUserGroup = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? UserGroupIcon({ hidden: !this.label, title: this.label }) : UserGroupIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-user-group.js
init_define_element();
defineElement("sp-icon-user-group", IconUserGroup);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFolder.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Folder.js
var FolderIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Folder" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m16.75,5h-5.96387c-.21777,0-.42383-.09473-.56689-.25879l-1.70361-1.96484c-.42773-.49316-1.04736-.77637-1.7002-.77637h-3.56543c-1.24072,0-2.25,1.00977-2.25,2.25v10.5c0,1.24023,1.00928,2.25,2.25,2.25h13.5c1.24072,0,2.25-1.00977,2.25-2.25v-7.5c0-1.24023-1.00928-2.25-2.25-2.25ZM3.25,3.5h3.56543c.21777,0,.42383.09473.56689.25879l1.07617,1.24121H2.5v-.75c0-.41309.33643-.75.75-.75Zm14.25,11.25c0,.41309-.33643.75-.75.75H3.25c-.41357,0-.75-.33691-.75-.75V6.5h14.25c.41357,0,.75.33691.75.75v7.5Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/FolderOutline.js
var FolderOutlineIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: a23 = "Folder Outline" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="m33 8-14.331.008-3.3-3.4A2 2 0 0 0 13.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1Zm-1 20H4V10h28Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFolder.js
var IconFolder = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? FolderIcon({ hidden: !this.label, title: this.label }) : FolderOutlineIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-folder.js
init_define_element();
defineElement("sp-icon-folder", IconFolder);

// src/features/home-gallery/element-preview-manager.js
var ElementPreviewManager = class {
  #host;
  #observer = null;
  #fetchCache = /* @__PURE__ */ new Map();
  constructor(host) {
    this.#host = host;
  }
  observe() {
    this.teardown();
    if (!this.#host?.shadowRoot) return;
    this.#observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (!entry.isIntersecting) continue;
          const thumbnail = entry.target;
          const docId = thumbnail.dataset.docUrn;
          if (!docId) continue;
          if (thumbnail.classList.contains("loaded") || thumbnail.dataset.loading) {
            continue;
          }
          thumbnail.dataset.loading = "1";
          void this.#loadElementThumbnail(thumbnail, docId);
        }
      },
      {
        root: null,
        rootMargin: "100px",
        threshold: 0.01
      }
    );
    requestAnimationFrame(() => {
      this.#forEachThumbnail((thumbnail) => this.#observer?.observe(thumbnail));
    });
  }
  teardown() {
    if (this.#observer) {
      this.#observer.disconnect();
      this.#observer = null;
    }
    this.#fetchCache.clear();
  }
  refreshTargets() {
    if (!this.#observer) return;
    this.#forEachThumbnail((thumbnail) => this.#observer?.observe(thumbnail));
  }
  #forEachThumbnail(callback) {
    const thumbnails = this.#host?.shadowRoot?.querySelectorAll(".element-preview[data-doc-urn]");
    if (!thumbnails || !thumbnails.length) return;
    thumbnails.forEach((thumbnail) => callback(thumbnail));
  }
  async #fetchDocumentHtml(docId, doc3, store) {
    if (this.#fetchCache.has(docId)) {
      return this.#fetchCache.get(docId);
    }
    const documentStore = store?.documentStore;
    if (!documentStore?.getDocument) {
      return null;
    }
    const identifier = doc3.path || docId;
    const fetchPromise = (async () => {
      const fullDoc = await documentStore.getDocument(identifier);
      const html2 = fullDoc?.html || null;
      if (html2 && doc3) {
        doc3.html = html2;
      }
      return html2;
    })();
    this.#fetchCache.set(docId, fetchPromise);
    const html = await fetchPromise;
    this.#fetchCache.set(docId, html);
    return html;
  }
  async #loadElementThumbnail(thumbnailContainer, docId) {
    const store = this.#host?.store;
    const documents = store?.filteredElements || [];
    const doc3 = documents.find((d22) => d22.urn === docId || d22.path === docId);
    if (!doc3) {
      this.#setPlaceholder(thumbnailContainer);
      return;
    }
    let html = doc3.html;
    if (!html) {
      html = await this.#fetchDocumentHtml(docId, doc3, store);
    }
    if (!html) {
      this.#setPlaceholder(thumbnailContainer);
      return;
    }
    const element = store?.documentStore?.deserializeElement(html);
    if (!element) {
      this.#setPlaceholder(thumbnailContainer);
      return;
    }
    this.#stripPreviewMedia(element);
    thumbnailContainer.innerHTML = "";
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.alignItems = "flex-start";
    wrapper.style.justifyContent = "center";
    wrapper.style.width = "100%";
    wrapper.style.height = "100%";
    wrapper.style.overflow = "hidden";
    wrapper.style.position = "relative";
    wrapper.setAttribute("data-ee-preview", "");
    const previewContainer = document.createElement("div");
    previewContainer.style.transformOrigin = "top center";
    previewContainer.style.willChange = "transform";
    previewContainer.setAttribute("data-ee-preview", "");
    let measureTarget = null;
    if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      const inner = document.createElement("div");
      inner.style.display = "inline-block";
      inner.appendChild(element.cloneNode(true));
      previewContainer.appendChild(inner);
      measureTarget = inner;
    } else {
      const clonedElement = element.cloneNode(true);
      previewContainer.appendChild(clonedElement);
      measureTarget = clonedElement;
    }
    wrapper.appendChild(previewContainer);
    thumbnailContainer.appendChild(wrapper);
    this.#markPreviewNodes(previewContainer);
    requestAnimationFrame(() => {
      previewContainer.style.transform = "scale(1)";
      const rect = measureTarget?.getBoundingClientRect?.();
      const contentWidth = rect?.width || measureTarget?.scrollWidth || measureTarget?.offsetWidth || 0;
      const containerWidth = thumbnailContainer.clientWidth || 0;
      let scale = 1;
      if (contentWidth > 0 && containerWidth > 0) {
        const maxWidth = Math.max(0, containerWidth - 8);
        scale = Math.min(1, maxWidth / contentWidth);
      }
      previewContainer.style.transform = `scale(${scale})`;
    });
    thumbnailContainer.classList.add("loaded");
    delete thumbnailContainer.dataset.loading;
  }
  #setPlaceholder(thumbnailContainer) {
    thumbnailContainer.innerHTML = '<div class="element-preview-placeholder">Element</div>';
    thumbnailContainer.classList.add("loaded");
    delete thumbnailContainer.dataset.loading;
  }
  #markPreviewNodes(root) {
    if (!root) return;
    const elements = root instanceof Element ? [root, ...root.querySelectorAll("*")] : [];
    elements.forEach((el) => {
      if (!el.hasAttribute("data-ee-preview")) {
        el.setAttribute("data-ee-preview", "true");
      }
    });
  }
  #stripPreviewMedia(root) {
    if (!root || typeof root.querySelectorAll !== "function") {
      return;
    }
    const mediaNodes = root.querySelectorAll("ee-media");
    if (!mediaNodes.length) return;
    mediaNodes.forEach((media) => {
      const slotName = media.getAttribute("slot") || "";
      const video = media.querySelector("video");
      const poster = video?.getAttribute("poster") || media.getAttribute("poster") || "";
      const placeholder = document.createElement("div");
      placeholder.setAttribute("data-ee-preview", "media");
      if (slotName) {
        placeholder.setAttribute("slot", slotName);
      }
      placeholder.style.display = "grid";
      placeholder.style.placeItems = "center";
      placeholder.style.width = "100%";
      placeholder.style.height = "100%";
      placeholder.style.background = "var(--spectrum-global-color-gray-100, #f5f5f5)";
      placeholder.style.borderRadius = "var(--spectrum-global-dimension-size-100, 8px)";
      placeholder.style.overflow = "hidden";
      if (poster) {
        const img = document.createElement("img");
        img.src = poster;
        img.alt = video?.getAttribute("aria-label") || media.getAttribute("aria-label") || "Media preview";
        img.style.width = "100%";
        img.style.height = "100%";
        img.style.objectFit = "cover";
        placeholder.appendChild(img);
      } else {
        placeholder.style.padding = "16px";
        placeholder.style.fontSize = "12px";
        placeholder.style.lineHeight = "16px";
        placeholder.style.color = "var(--spectrum-global-color-gray-700, #4b4b4b)";
        placeholder.textContent = "Media preview";
      }
      media.replaceWith(placeholder);
    });
  }
};

// src/features/home-gallery/ee-files-section.js
var EEFilesSection = class extends i4 {
  static styles = [
    galleryCommonStyles,
    i`
      :host {
        display: block;
      }
    `
  ];
  static get properties() {
    return {
      store: { type: Object, observe: true },
      showNewFolderDialog: { type: Boolean, converter: booleanConverter },
      newFolderName: { type: String },
      newFolderError: { type: String },
      renamingUrn: { type: String },
      renameValue: { type: String },
      renameError: { type: String }
    };
  }
  constructor() {
    super();
    this.store = null;
    this.showNewFolderDialog = false;
    this.newFolderName = "";
    this.newFolderError = "";
    this.renamingUrn = null;
    this.renameValue = "";
    this.renameError = "";
    this.#previewManager = new ElementPreviewManager(this);
    this.#sentinelObserver = null;
  }
  #previewManager;
  #sentinelObserver;
  connectedCallback() {
    super.connectedCallback();
    this.#setupSentinelObserver();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.#previewManager?.teardown();
    this.#sentinelObserver?.disconnect();
  }
  #setupSentinelObserver() {
    if (this.#sentinelObserver) return;
    this.#sentinelObserver = new IntersectionObserver((entries) => {
      const entry = entries[0];
      if (entry.isIntersecting) {
        this.#loadMore();
      }
    }, { threshold: 0.1 });
  }
  async #loadMore() {
    if (this.store?.documentStore?.isLoadingElements) return;
    if (!this.store?.galleryStore?.hasMore) return;
    await this.store.loadMore();
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (this.store?.filteredElements?.length > 0) {
      this.#setupElementObserver();
    }
    const sentinel = this.shadowRoot.querySelector("#sentinel");
    if (sentinel) {
      this.#sentinelObserver?.observe(sentinel);
    }
  }
  render() {
    const loading = !!this.store?.documentStore?.isLoadingElements;
    const items = (this.store?.filteredElements || []).slice();
    return x`
      ${this.#toolbarTemplate}
      ${loading ? x`<div class="section-loading">
            <sp-progress-circle indeterminate size="l"></sp-progress-circle>
          </div>` : !items.length ? x`
            ${this.#breadcrumbsTemplate}
            <sp-illustrated-message
              heading="Empty"
              description="Create a folder or element to get started"
            ></sp-illustrated-message>` : x`
            ${this.#breadcrumbsTemplate}
            ${this.#renderFoldersAndDocs(items)}
            <div id="sentinel" style="height: 1px;"></div>
          `}
      ${this.#newFolderDialogTemplate}
      ${this.#selectionActionBarTemplate}
    `;
  }
  #renderFoldersAndDocs(items) {
    const folders = items.filter((item) => !!item.isFolder);
    const docs = items.filter((item) => !item.isFolder);
    return x`
      ${folders.length ? x`<div class="elements-grid">
            ${folders.map((doc3) => this.#renderFileTile(doc3))}
          </div>` : E}
      ${folders.length && docs.length ? x`<sp-divider class="folders-docs-divider" size="m"></sp-divider>` : E}
      ${docs.length ? x`<div class="elements-grid">
            ${docs.map((doc3) => this.#renderFileTile(doc3))}
          </div>` : E}
    `;
  }
  get #toolbarTemplate() {
    const inSelection = !!this.store?.selectionMode;
    const count = this.store?.selectedUrns?.size || 0;
    return x`
      <div class="files-toolbar">
        <sp-action-group quiet>
          <sp-action-menu label="Create" @change=${this.#onCreateMenuChange}>
            <sp-icon-new slot="icon"></sp-icon-new>
            <sp-menu-item value="document">Document</sp-menu-item>
            <sp-menu-item value="folder">Folder</sp-menu-item>
            <span slot="label">Create</span>
          </sp-action-menu>
        </sp-action-group>
        <sp-action-group quiet>
          <sp-action-button @click=${this.#toggleSelectionMode}>
            ${inSelection ? "Done" : "Select"}
            <sp-icon-select-multi slot="icon"></sp-icon-select-multi>
          </sp-action-button>
          ${inSelection && count === 0 ? x`<sp-action-button @click=${() => this.store?.selectAllVisible?.()}>
                Select All
                <sp-icon-select-all-items slot="icon"></sp-icon-select-all-items>
              </sp-action-button>` : E}
        </sp-action-group>
      </div>
    `;
  }
  get #selectionActionBarTemplate() {
    const count = this.store?.selectedUrns?.size || 0;
    const open = !!this.store?.selectionMode;
    const view = this.store?.galleryView;
    const bulkView = view === GalleryViews.MY_FILES || view === GalleryViews.SHARED;
    if (!open || !bulkView || count === 0) return E;
    const selectedUrn = count === 1 ? Array.from(this.store?.selectedUrns || [])[0] : null;
    const items = this.store?.filteredElements || [];
    const selectedItem = selectedUrn ? items.find((item) => item.urn === selectedUrn) : null;
    const isFolder = !!selectedItem?.isFolder;
    return x`<sp-action-bar emphasized open @close=${this.#closeSelectionActionBar}>
      <span
        role="button"
        tabindex="0"
        title="Clear selection"
        @click=${this.#clearSelectionOnly}
        @keydown=${(event) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        this.#clearSelectionOnly();
      }
    }}
        style="cursor: pointer; user-select: none;"
      >
        ${count} Selected  Clear
      </span>
      ${count === 1 ? x`
            <sp-action-button
              slot="buttons"
              label="Share"
              @click=${this.#openShareForSelection}
            >
              <sp-icon-user-group slot="icon"></sp-icon-user-group>
            </sp-action-button>
            ${!isFolder ? x`
                  <sp-action-button
                    slot="buttons"
                    label="Publish"
                    @click=${() => this.#performBulkPublish("publish")}
                  >
                    <sp-icon-upload-to-cloud slot="icon"></sp-icon-upload-to-cloud>
                  </sp-action-button>
                  <sp-action-button
                    slot="buttons"
                    label="Unpublish"
                    @click=${() => this.#performBulkPublish("unpublish")}
                  >
                    <sp-icon-revert slot="icon"></sp-icon-revert>
                  </sp-action-button>
                ` : E}
            <sp-action-button
              slot="buttons"
              label="Delete"
              variant="negative"
              @click=${this.#openConfirmDelete}
            >
              <sp-icon-delete slot="icon"></sp-icon-delete>
            </sp-action-button>
          ` : E}
    </sp-action-bar>`;
  }
  get #newFolderDialogTemplate() {
    if (!this.showNewFolderDialog) return E;
    return x`
      <sp-dialog-wrapper
        open
        size="s"
        headline="New Folder"
        cancel-label="Cancel"
        confirm-label="Create"
        dismissable
        underlay
        mode="modal"
        @close=${() => this.showNewFolderDialog = false}
        @confirm=${this.#confirmCreateFolder}
      >
        <div id="new-folder-content">
          <sp-field-group>
            <sp-field-label for="new-folder-name">Folder name</sp-field-label>
            <sp-textfield
              id="new-folder-name"
              placeholder="Enter folder name"
              value=${this.newFolderName}
              autofocus
              @input=${(event) => {
      this.newFolderName = event.target.value;
      this.newFolderError = "";
    }}
              @keydown=${(event) => {
      if (event.key === "Enter") this.#confirmCreateFolder();
    }}
            ></sp-textfield>
            ${this.newFolderError ? x`<sp-help-text validation-state="negative"
                  >${this.newFolderError}</sp-help-text
                >` : E}
          </sp-field-group>
          <sp-help-text size="s">
            Press Enter or Create to add the folder.
          </sp-help-text>
        </div>
      </sp-dialog-wrapper>
    `;
  }
  get #breadcrumbsTemplate() {
    const crumbs = this.store?.folderBreadcrumbs || [];
    const rootLabel = "My Workspace";
    if (!crumbs.length) {
      return x`<sp-breadcrumbs class="breadcrumbs-wrap">
        <sp-breadcrumb-item>${rootLabel}</sp-breadcrumb-item>
      </sp-breadcrumbs>`;
    }
    if (crumbs.length <= 3) {
      return x`<sp-breadcrumbs class="breadcrumbs-wrap">
        <sp-breadcrumb-item @click=${() => this.store?.setCurrentFolder?.(null)}
          >${rootLabel}</sp-breadcrumb-item
        >
        ${crumbs.map(
        (crumb, index) => x`<sp-breadcrumb-item
            @click=${() => this.store?.navigateToCrumb?.(index)}
            >${crumb.name || "Folder"}</sp-breadcrumb-item
          >`
      )}
      </sp-breadcrumbs>`;
    }
    const first = crumbs[0];
    const last = crumbs[crumbs.length - 1];
    return x`<sp-breadcrumbs
      class="breadcrumbs-wrap"
      style="margin-bottom: var(--spectrum-global-dimension-size-200);"
    >
      <sp-breadcrumb-item @click=${() => this.store?.setCurrentFolder?.(null)}
        >${rootLabel}</sp-breadcrumb-item
      >
      <sp-breadcrumb-item @click=${() => this.store?.navigateToCrumb?.(0)}
        >${first.name || "Folder"}</sp-breadcrumb-item
      >
      <sp-breadcrumb-item>
        <sp-action-button quiet @click=${(event) => event.stopPropagation()}
          ></sp-action-button
        >
      </sp-breadcrumb-item>
      <sp-breadcrumb-item
        @click=${() => this.store?.navigateToCrumb?.(crumbs.length - 1)}
        >${last.name || "Folder"}</sp-breadcrumb-item
      >
    </sp-breadcrumbs>`;
  }
  #renderFileTile(doc3) {
    const isFolder = !!doc3.isFolder;
    const renaming = isFolder && this.renamingUrn === doc3.urn;
    const selected = !!this.store?.selectedUrns?.has?.(doc3.urn);
    return x`<div
      class="element-card ${isFolder ? "folder" : ""}"
      role="button"
      tabindex="0"
      data-selected=${selected ? "true" : "false"}
      draggable=${!isFolder && !this.store?.selectionMode}
      @dragstart=${(event) => this.#onFileDragStart(doc3, event)}
      @click=${(event) => {
      if (this.store?.selectionMode) {
        event.preventDefault();
        event.stopPropagation();
        this.store?.toggleSelect?.(doc3.urn);
        return;
      }
      if (isFolder) this.store?.enterFolder?.(doc3);
      else this.#openElementByUrn(doc3.urn);
    }}
      @keydown=${(event) => {
      if (event.key === "Enter") {
        if (isFolder) this.store?.enterFolder?.(doc3);
        else this.#openElementByUrn(doc3.urn);
      }
    }}
    >
      ${isFolder ? x`<div
            class="element-thumbnail"
            @dragenter=${(event) => this.#onFolderDragEnter(doc3, event)}
            @dragover=${(event) => this.#onFolderDragOver(event)}
            @dragleave=${(event) => this.#onFolderDragLeave(doc3, event)}
            @drop=${(event) => this.#onFolderDrop(doc3, event)}
          >
            <sp-icon-folder size="xl"></sp-icon-folder>
          </div>` : x`<div class="element-thumbnail">
            <div class="element-preview" data-doc-urn=${doc3.urn}>
              <div class="element-preview-placeholder">Loading...</div>
            </div>
          </div>`}
      <div class="element-info">
        ${renaming ? x`<div>
              <sp-textfield
                value=${this.renameValue}
                autofocus
                @input=${(event) => this.renameValue = event.target.value}
                @keydown=${(event) => {
      if (event.key === "Enter") this.#commitRename(doc3);
      if (event.key === "Escape") this.#cancelRename();
    }}
                @blur=${() => this.#commitRename(doc3)}
              ></sp-textfield>
              ${this.renameError ? x`<sp-help-text validation-state="negative"
                    >${this.renameError}</sp-help-text
                  >` : E}
            </div>` : x`<div
              class="element-name"
              @dblclick=${() => isFolder && this.#startRename(doc3)}
            >
              ${doc3.name || (isFolder ? "Folder" : "Untitled")}
            </div>`}
        <div class="element-time">
          ${this.#formatRelativeDate(doc3.lastModified)}
        </div>
      </div>
    </div>`;
  }
  #onCreateMenuChange(event) {
    const value = event?.target?.value;
    if (value === "document") {
      this.dispatchEvent(new CustomEvent("open-creation-dialog", {
        detail: { category: "templates" },
        bubbles: true,
        composed: true
      }));
    } else if (value === "folder") {
      this.#openNewFolderDialog();
    }
  }
  #openNewFolderDialog() {
    this.newFolderName = "";
    this.showNewFolderDialog = true;
  }
  async #confirmCreateFolder() {
    const name = (this.newFolderName || "").trim();
    if (!name) {
      this.newFolderError = "Please enter a folder name";
      return;
    }
    const parent = this.store?.currentFolderUrn || null;
    await this.store?.documentStore?.createFolder?.(name, parent);
    this.showNewFolderDialog = false;
    this.#showToast("Folder created", "positive");
  }
  #startRename(doc3) {
    this.renamingUrn = doc3.urn;
    this.renameValue = doc3.name || "";
    this.renameError = "";
  }
  #cancelRename() {
    this.renamingUrn = null;
    this.renameValue = "";
    this.renameError = "";
  }
  async #commitRename(doc3) {
    const value = (this.renameValue || "").trim();
    if (!value) {
      this.#cancelRename();
      return;
    }
    await this.store?.documentStore?.updateFolderName?.(doc3.urn, value);
    this.renameError = "";
    this.#cancelRename();
    this.#showToast("Renamed", "positive");
  }
  #toggleSelectionMode() {
    const on2 = !this.store?.selectionMode;
    this.store?.setSelectionMode?.(on2);
    if (!on2) this.store?.clearSelection?.();
  }
  #closeSelectionActionBar() {
    this.store?.setSelectionMode?.(false);
    this.store?.clearSelection?.();
  }
  #clearSelectionOnly() {
    this.store?.clearSelection?.();
  }
  #openShareForSelection() {
    this.dispatchEvent(new CustomEvent("open-share-for-selection", {
      bubbles: true,
      composed: true
    }));
  }
  async #performBulkPublish(kind) {
    const selected = Array.from(this.store?.selectedUrns || []);
    if (!selected.length) return;
    if (kind === "publish") {
      for (const urn of selected) {
        await this.store?.documentStore?.publishDocument?.(urn);
      }
      this.#showToast("Publish started", "info");
    } else if (kind === "unpublish") {
      for (const urn of selected) {
        await this.store?.documentStore?.unpublishDocument?.(urn);
      }
      this.#showToast("Unpublish started", "info");
    }
    this.#closeSelectionActionBar();
  }
  #openConfirmDelete() {
    this.dispatchEvent(new CustomEvent("open-confirm-delete", {
      bubbles: true,
      composed: true
    }));
    this.#closeSelectionActionBar();
  }
  #openElementByUrn(urn) {
    this.dispatchEvent(new CustomEvent("open-element", {
      detail: { urn },
      bubbles: true,
      composed: true
    }));
  }
  #onFileDragStart(doc3, event) {
    if (doc3?.isFolder) return;
    event.dataTransfer?.setData("text/urn", doc3.urn);
    event.dataTransfer?.setDragImage?.(event.currentTarget, 10, 10);
  }
  #onFolderDragEnter(doc3, event) {
    event.preventDefault();
    const card = event.currentTarget?.closest?.(".element-card");
    if (card) card.classList.add("drag-over");
  }
  #onFolderDragOver(event) {
    event.preventDefault();
  }
  #onFolderDragLeave(doc3, event) {
    const card = event.currentTarget?.closest?.(".element-card");
    if (card) card.classList.remove("drag-over");
  }
  async #onFolderDrop(doc3, event) {
    event.preventDefault();
    const card = event.currentTarget?.closest?.(".element-card");
    if (card) card.classList.remove("drag-over");
    const urn = event.dataTransfer?.getData("text/urn");
    if (!urn || urn === doc3.urn) return;
    await this.store?.documentStore?.updateDocumentParent?.(urn, doc3.urn);
    this.#showToast("Moved", "positive");
  }
  #formatRelativeDate(dateString) {
    return formatRelativeDate(dateString);
  }
  #showToast(label, variant = "info") {
    this.dispatchEvent(new CustomEvent("show-toast", {
      detail: { label, variant },
      bubbles: true,
      composed: true
    }));
  }
  #setupElementObserver() {
    this.#previewManager?.observe();
  }
};
customElements.define("ee-files-section", makeLitObserver(EEFilesSection));

// src/features/home-gallery/ee-share-manager.js
init_lit();
init_lit();

// src/features/home-gallery/sort-utils.js
var compareByName = (first, second) => {
  const a23 = (first?.name || "").toLowerCase();
  const b12 = (second?.name || "").toLowerCase();
  if (a23 < b12) return -1;
  if (a23 > b12) return 1;
  return 0;
};

// node_modules/@spectrum-web-components/avatar/src/Avatar.js
init_src();
init_decorators2();
init_directives();
init_like_anchor();
init_focusable();

// node_modules/@spectrum-web-components/avatar/src/avatar.css.js
init_src();
var r22 = i`
    :host{--spectrum-avatar-color-opacity:1;--spectrum-avatar-inline-size:var(--spectrum-avatar-size-100);--spectrum-avatar-block-size:var(--spectrum-avatar-size-100);--spectrum-avatar-border-radius:var(--spectrum-avatar-block-size);--spectrum-avatar-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-avatar-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--spectrum-avatar-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-avatar-color-opacity-disabled:var(--spectrum-avatar-opacity-disabled)}:host([size="50"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-50);--spectrum-avatar-block-size:var(--spectrum-avatar-size-50)}:host([size="75"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-75);--spectrum-avatar-block-size:var(--spectrum-avatar-size-75)}:host([size="100"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-100);--spectrum-avatar-block-size:var(--spectrum-avatar-size-100)}:host([size="200"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-200);--spectrum-avatar-block-size:var(--spectrum-avatar-size-200)}:host([size="300"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-300);--spectrum-avatar-block-size:var(--spectrum-avatar-size-300)}:host([size="400"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-400);--spectrum-avatar-block-size:var(--spectrum-avatar-size-400)}:host([size="500"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-500);--spectrum-avatar-block-size:var(--spectrum-avatar-size-500)}:host([size="600"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-600);--spectrum-avatar-block-size:var(--spectrum-avatar-size-600)}:host([size="700"]){--spectrum-avatar-inline-size:var(--spectrum-avatar-size-700);--spectrum-avatar-block-size:var(--spectrum-avatar-size-700)}@media (forced-colors:active){:host{--highcontrast-avatar-focus-indicator-color:CanvasText}}:host{inline-size:var(--mod-avatar-inline-size,var(--spectrum-avatar-inline-size));block-size:var(--mod-avatar-block-size,var(--spectrum-avatar-block-size));border-radius:var(--mod-avatar-border-radius,var(--spectrum-avatar-border-radius));-webkit-user-drag:none;-webkit-user-select:none;user-select:none;opacity:var(--mod-avatar-color-opacity,var(--spectrum-avatar-color-opacity));border-width:0;outline:none;display:inline-block;position:relative;overflow:visible}:host([disabled]){opacity:var(--mod-avatar-color-opacity-disabled,var(--spectrum-avatar-color-opacity-disabled))}:host(:not([disabled])) .is-focused:after,:host(:not([disabled])) .link:focus-visible:after{pointer-events:none;content:"";inline-size:calc(var(--mod-avatar-inline-size,var(--spectrum-avatar-inline-size)) + var(--mod-avatar-focus-indicator-gap,var(--spectrum-avatar-focus-indicator-gap))*2);block-size:calc(var(--mod-avatar-inline-size,var(--spectrum-avatar-inline-size)) + var(--mod-avatar-focus-indicator-gap,var(--spectrum-avatar-focus-indicator-gap))*2);border-style:solid;border-width:var(--mod-avatar-focus-indicator-thickness,var(--spectrum-avatar-focus-indicator-thickness));border-color:var(--highcontrast-avatar-focus-indicator-color,var(--mod-avatar-focus-indicator-color,var(--spectrum-avatar-focus-indicator-color)));border-radius:var(--mod-avatar-border-radius,var(--spectrum-avatar-border-radius));position:absolute;inset-block-start:calc((var(--mod-avatar-focus-indicator-gap,var(--spectrum-avatar-focus-indicator-gap)) + var(--mod-avatar-focus-indicator-thickness,var(--spectrum-avatar-focus-indicator-thickness)))*-1);inset-inline-start:calc((var(--mod-avatar-focus-indicator-gap,var(--spectrum-avatar-focus-indicator-gap)) + var(--mod-avatar-focus-indicator-thickness,var(--spectrum-avatar-focus-indicator-thickness)))*-1)}.link{outline:0}.image{inline-size:var(--mod-avatar-inline-size,var(--spectrum-avatar-inline-size));block-size:var(--mod-avatar-block-size,var(--spectrum-avatar-block-size));border-radius:var(--mod-avatar-border-radius,var(--spectrum-avatar-border-radius))}img{vertical-align:top}
`;
var avatar_css_default = r22;

// node_modules/@spectrum-web-components/avatar/src/Avatar.js
var p25 = Object.defineProperty;
var d16 = Object.getOwnPropertyDescriptor;
var o46 = (a23, r25, t34, i21) => {
  for (var e36 = i21 > 1 ? void 0 : i21 ? d16(r25, t34) : r25, s19 = a23.length - 1, l16; s19 >= 0; s19--) (l16 = a23[s19]) && (e36 = (i21 ? l16(r25, t34, e36) : l16(e36)) || e36);
  return i21 && e36 && p25(r25, t34, e36), e36;
};
var c31 = [50, 75, 100, 200, 300, 400, 500, 600, 700];
var u30 = c31[2];
var Avatar = class extends LikeAnchor(Focusable) {
  constructor() {
    super(...arguments);
    this.src = "";
    this._size = u30;
  }
  static get styles() {
    return [avatar_css_default];
  }
  get focusElement() {
    return this.anchorElement || this;
  }
  get size() {
    return this._size;
  }
  set size(t34) {
    const i21 = t34, e36 = c31.includes(i21) ? i21 : u30;
    if (e36 && this.setAttribute("size", `${e36}`), this._size === e36) return;
    const s19 = this._size;
    this._size = e36, this.requestUpdate("size", s19);
  }
  render() {
    const t34 = x`
            <img
                class="image"
                alt=${o9(this.label || void 0)}
                src=${this.src}
            />
        `;
    return this.href ? this.renderAnchor({ id: "link", className: "link", anchorContent: t34 }) : t34;
  }
  firstUpdated(t34) {
    super.firstUpdated(t34), this.hasAttribute("size") || this.setAttribute("size", `${this.size}`);
  }
};
o46([e5("#link")], Avatar.prototype, "anchorElement", 2), o46([n4()], Avatar.prototype, "src", 2), o46([n4({ type: Number, reflect: true })], Avatar.prototype, "size", 1);

// node_modules/@spectrum-web-components/avatar/sp-avatar.js
init_define_element();
defineElement("sp-avatar", Avatar);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconInfoCircle.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/InfoOutline.js
var InfoOutlineIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: a23 = "Info Outline" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 36 36"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M20.15 12A2.15 2.15 0 1 1 18 9.85 2.15 2.15 0 0 1 20.15 12Zm.183 12H20v-7.6a.4.4 0 0 0-.4-.4h-3.934s-1.166.032-1.166 1c0 .967 1.167 1 1.167 1H16v6h-.333s-1.167.032-1.167 1c0 .967 1.167 1 1.167 1h4.667s1.166-.033 1.166-1c0-.968-1.167-1-1.167-1ZM18 1a17 17 0 1 0 17 17A17 17 0 0 0 18 1Zm0 30.35A13.35 13.35 0 1 1 31.35 18 13.35 13.35 0 0 1 18 31.35Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconInfoCircle.js
var IconInfoCircle = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? InfoCircleIcon({ hidden: !this.label, title: this.label }) : InfoOutlineIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-info-circle.js
init_define_element();
defineElement("sp-icon-info-circle", IconInfoCircle);

// src/features/home-gallery/ee-share-manager.js
init_sp_popover();
init_sp_progress_circle();

// node_modules/@spectrum-web-components/table/src/Table.js
init_src();

// node_modules/@spectrum-web-components/table/src/TableBody.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/table/src/table-body.css.js
init_src();
var o47 = i`
    :host{border-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius));border:none;display:table-row-group;position:relative}:host([drop-target]){--mod-table-border-color:transparent;outline-width:var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness));outline-style:solid;outline-color:var(--highcontrast-table-focus-indicator-color,var(--mod-table-drop-zone-outline-color,var(--spectrum-table-drop-zone-outline-color)))}:host{border-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius));border-inline:var(--mod-table-outer-border-inline-width,var(--spectrum-table-outer-border-inline-width))solid var(--highcontrast-table-border-color,var(--mod-table-border-color,var(--spectrum-table-border-color)));border-block:var(--mod-table-border-width,var(--spectrum-table-border-width))solid var(--highcontrast-table-border-color,var(--mod-table-border-color,var(--spectrum-table-border-color)));flex-grow:1;display:block;overflow:auto}:host(:not([tabindex])){overflow:visible}
`;
var table_body_css_default = o47;

// node_modules/@spectrum-web-components/table/src/TableBody.js
init_mutation_controller();
var a19 = Object.defineProperty;
var m16 = Object.getOwnPropertyDescriptor;
var u31 = (o52, t34, s19, r25) => {
  for (var e36 = r25 > 1 ? void 0 : r25 ? m16(t34, s19) : t34, i21 = o52.length - 1, l16; i21 >= 0; i21--) (l16 = o52[i21]) && (e36 = (r25 ? l16(t34, s19, e36) : l16(e36)) || e36);
  return r25 && e36 && a19(t34, s19, e36), e36;
};
var TableBody = class extends SpectrumElement {
  constructor() {
    super();
    this.role = "rowgroup";
    new t12(this, { config: { childList: true, subtree: true }, callback: () => {
      requestAnimationFrame(() => {
        this.shouldHaveTabIndex();
      });
    } });
  }
  static get styles() {
    return [table_body_css_default];
  }
  shouldHaveTabIndex() {
    this.offsetHeight < this.scrollHeight ? this.tabIndex = 0 : this.removeAttribute("tabindex");
  }
  render() {
    return x`
            <slot></slot>
        `;
  }
};
u31([n4({ reflect: true })], TableBody.prototype, "role", 2);

// node_modules/@spectrum-web-components/table/sp-table-body.js
init_define_element();
defineElement("sp-table-body", TableBody);

// node_modules/@spectrum-web-components/table/src/TableRow.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/table/src/table-row.css.js
init_src();
var e29 = i`
    @media (forced-colors:active){:host([focused]) .spectrum-Table-checkbox .spectrum-Checkbox-box:before,:host(:focus-visible) .spectrum-Table-checkbox .spectrum-Checkbox-box:before{outline:var(--highcontrast-table-row-text-color-hover)1px solid}@media (hover:hover){:host(:hover) .spectrum-Table-checkbox .spectrum-Checkbox-box:before{outline:var(--highcontrast-table-row-text-color-hover)1px solid}}:host([drop-target]) .spectrum-Table-body,:host([drop-target]),:host([selected]){--highcontrast-table-cell-focus-indicator-color:var(--highcontrast-table-selected-row-text-color);--highcontrast-table-cell-focus-extra-offset:1px}:host([drop-target]) .spectrum-Table-body .spectrum-Table-checkbox .spectrum-Checkbox-box:before,:host([drop-target]) .spectrum-Table-checkbox .spectrum-Checkbox-box:before,:host([selected]) .spectrum-Table-checkbox .spectrum-Checkbox-box:before{outline:var(--highcontrast-table-selected-row-text-color)1px solid}}:host(:first-child) .spectrum-Table-body ::slotted(*){border-block-start:var(--mod-table-border-width,var(--spectrum-table-border-width))solid var(--highcontrast-table-border-color,var(--mod-table-border-color,var(--spectrum-table-border-color)))}:host(:last-child) .spectrum-Table-body ::slotted(*){border-block-end:var(--mod-table-border-width,var(--spectrum-table-border-width))solid var(--highcontrast-table-border-color,var(--mod-table-border-color,var(--spectrum-table-border-color)))}:host .spectrum-Table-body ::slotted(:first-child){border-inline-start:var(--mod-table-outer-border-inline-width,var(--spectrum-table-outer-border-inline-width))solid var(--highcontrast-table-border-color,var(--mod-table-border-color,var(--spectrum-table-border-color)))}:host .spectrum-Table-body ::slotted(:last-child){border-inline-end:var(--mod-table-outer-border-inline-width,var(--spectrum-table-outer-border-inline-width))solid var(--highcontrast-table-border-color,var(--mod-table-border-color,var(--spectrum-table-border-color)))}:host{transition:background-color var(--highcontrast-table-transition-duration,var(--mod-table-transition-duration,var(--spectrum-table-transition-duration)))ease-in-out;cursor:pointer;cursor:var(--mod-table-cursor-row-default,pointer);border-block-start:none;position:relative}:host(:first-child) ::slotted(:first-child){border-start-start-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius))}:host(:first-child) ::slotted(:last-child){border-start-end-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius))}:host(:last-child) ::slotted(:first-child){border-end-start-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius))}:host(:last-child) ::slotted(:last-child){border-end-end-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius))}:host(:first-child){border-start-start-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius));border-start-end-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius))}:host(:last-child){border-end-end-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius));border-end-start-radius:var(--mod-table-border-radius,var(--spectrum-table-border-radius))}:host(:focus){outline:0}:host([focused]),:host(:focus-visible){--highcontrast-table-row-text-color:var(--highcontrast-table-row-text-color-hover);--highcontrast-table-icon-color:var(--highcontrast-table-row-text-color-hover);--spectrum-table-cell-background-color:var(--highcontrast-table-row-background-color-hover,var(--mod-table-row-background-color-hover,var(--spectrum-table-row-background-color-hover)))}:host:active{--highcontrast-table-row-text-color:var(--highcontrast-table-row-text-color-hover);--highcontrast-table-icon-color:var(--highcontrast-table-row-text-color-hover);--spectrum-table-cell-background-color:var(--highcontrast-table-row-background-color-hover,var(--mod-table-row-active-color,var(--spectrum-table-row-active-color)))}:host([selected]){--highcontrast-table-row-text-color:var(--highcontrast-table-selected-row-text-color);--highcontrast-table-icon-color:var(--highcontrast-table-selected-row-text-color);--spectrum-table-cell-background-color:var(--highcontrast-table-selected-row-background-color,var(--spectrum-table-selected-cell-background-color))}:host([selected][focused]),:host([selected]:focus-visible){--highcontrast-table-row-text-color:var(--highcontrast-table-selected-row-text-color-focus);--highcontrast-table-icon-color:var(--highcontrast-table-selected-row-text-color-focus);--spectrum-table-cell-background-color:var(--highcontrast-table-selected-row-background-color-focus,var(--spectrum-table-selected-cell-background-color-focus))}:host([drop-target]) .spectrum-Table-body,:host([drop-target]){--highcontrast-table-row-text-color:var(--highcontrast-table-selected-row-text-color);--highcontrast-table-icon-color:var(--highcontrast-table-selected-row-text-color);--spectrum-table-cell-background-color:var(--highcontrast-table-selected-row-background-color,var(--mod-table-drop-zone-background-color,var(--spectrum-table-drop-zone-background-color)))}:host([drop-target]){--mod-table-border-color:var(--highcontrast-table-focus-indicator-color,transparent);outline-width:var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness));outline-style:solid;outline-color:var(--highcontrast-table-focus-indicator-color,var(--mod-table-drop-zone-outline-color,var(--spectrum-table-drop-zone-outline-color)));outline-offset:calc(var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness))*-1)}:host([drop-target]) ::slotted(*){border-block-start-color:var(--highcontrast-table-focus-indicator-color,var(--mod-table-drop-zone-outline-color,var(--spectrum-table-drop-zone-outline-color)))}.spectrum-Table-row--summary{--spectrum-table-cell-background-color:var(--highcontrast-table-row-background-color,var(--mod-table-summary-row-background-color,var(--spectrum-table-summary-row-background-color)))}.spectrum-Table-row--summary ::slotted(*){font-weight:var(--mod-table-summary-row-font-weight,var(--spectrum-table-summary-row-font-weight));font-size:var(--mod-table-summary-row-font-size,var(--spectrum-table-row-font-size));font-family:var(--mod-table-summary-row-font-family,var(--spectrum-table-row-font-family));font-style:var(--mod-table-summary-row-font-style,var(--spectrum-table-row-font-style));line-height:var(--mod-table-summary-row-line-height,var(--spectrum-table-row-line-height));color:var(--highcontrast-table-row-text-color,var(--mod-table-summary-row-text-color,var(--spectrum-table-row-text-color)))}.spectrum-Table-row--sectionHeader{--spectrum-table-cell-background-color:var(--highcontrast-table-section-header-background-color,var(--mod-table-section-header-background-color,var(--spectrum-table-section-header-background-color)));cursor:auto;cursor:var(--mod-table-cursor-section-header,initial)}.spectrum-Table-row--sectionHeader ::slotted(*){font-weight:var(--mod-table-section-header-font-weight,var(--spectrum-table-section-header-font-weight));text-align:start;block-size:var(--mod-table-section-header-min-height,var(--spectrum-table-section-header-min-height));font-size:var(--mod-table-section-header-font-size,var(--spectrum-table-row-font-size));font-family:var(--mod-table-section-header-font-family,var(--spectrum-table-row-font-family));font-style:var(--mod-table-section-header-font-style,var(--spectrum-table-row-font-style));line-height:var(--mod-table-section-header-line-height,var(--spectrum-table-row-line-height));color:var(--highcontrast-table-section-header-text-color,var(--mod-table-section-header-text-color,var(--spectrum-table-row-text-color)));padding-block-start:calc(var(--mod-table-section-header-block-start-spacing,var(--spectrum-table-section-header-block-start-spacing)) - var(--mod-table-border-width,var(--spectrum-table-border-width)));padding-block-end:calc(var(--mod-table-section-header-block-end-spacing,var(--spectrum-table-section-header-block-end-spacing)) - var(--mod-table-border-width,var(--spectrum-table-border-width)))}:host{display:table-row}:host(:first-child) .spectrum-Table-scroller .spectrum-Table-body ::slotted(*){border-block-start:none;border-radius:0}:host(:last-child) .spectrum-Table-scroller .spectrum-Table-body ::slotted(*){border-block-end:none;border-radius:0}:host .spectrum-Table-scroller .spectrum-Table-body ::slotted(:first-child){border-inline-start:none}:host .spectrum-Table-scroller .spectrum-Table-body ::slotted(:last-child){border-inline-end:none}.spectrum-Table-row--collapsible{--spectrum-table-row-tier:0}:host([data-tier="1"]) .spectrum-Table-row--collapsible{--spectrum-table-row-tier:1}:host([data-tier="2"]) .spectrum-Table-row--collapsible{--spectrum-table-row-tier:2}:host([data-tier="3"]) .spectrum-Table-row--collapsible{--spectrum-table-row-tier:3}:host([data-tier="4"]) .spectrum-Table-row--collapsible{--spectrum-table-row-tier:4}:host([data-tier="5"]) .spectrum-Table-row--collapsible{--spectrum-table-row-tier:5}:host([data-tier="6"]) .spectrum-Table-row--collapsible{--spectrum-table-row-tier:6}.spectrum-Table-row--collapsible .spectrum-Table-checkboxCell{padding-inline-end:0}.spectrum-Table-row--collapsible.is-last-tier .spectrum-Table-cell--collapsible{padding-inline-start:calc(var(--spectrum-table-row-tier)*var(--spectrum-table-collapsible-tier-indent) + var(--mod-table-disclosure-icon-size,var(--spectrum-table-disclosure-icon-size)) + var(--mod-table-collapsible-disclosure-inline-spacing,var(--spectrum-table-collapsible-disclosure-inline-spacing))*2)}.spectrum-Table-row--collapsible.is-last-tier .spectrum-Table-disclosureIcon{display:none}.spectrum-Table-row--collapsible .spectrum-Table-disclosureIcon{margin-inline:var(--mod-table-collapsible-disclosure-inline-spacing,var(--spectrum-table-collapsible-disclosure-inline-spacing));margin-block-start:max(0px,calc((var(--mod-table-min-row-height,var(--spectrum-table-min-row-height)) - var(--mod-table-disclosure-icon-size,var(--spectrum-table-disclosure-icon-size)))/2))}:host([hidden]) .spectrum-Table-row--collapsible{display:none}@media (hover:hover){:host(:hover){--highcontrast-table-row-text-color:var(--highcontrast-table-row-text-color-hover);--highcontrast-table-icon-color:var(--highcontrast-table-row-text-color-hover);--spectrum-table-cell-background-color:var(--highcontrast-table-row-background-color-hover,var(--mod-table-row-background-color-hover,var(--spectrum-table-row-background-color-hover)))}:host([selected]:hover){--highcontrast-table-row-text-color:var(--highcontrast-table-selected-row-text-color-focus);--highcontrast-table-icon-color:var(--highcontrast-table-selected-row-text-color-focus);--spectrum-table-cell-background-color:var(--highcontrast-table-selected-row-background-color-focus,var(--spectrum-table-selected-cell-background-color-focus))}.spectrum-Table-row--sectionHeader:hover{--highcontrast-table-row-text-color:var(--highcontrast-table-section-header-text-color);--spectrum-table-cell-background-color:var(--highcontrast-table-section-header-background-color,var(--mod-table-section-header-background-color,var(--spectrum-table-section-header-background-color)))}}.spectrum-Table-row--thumbnail{--spectrum-table-thumbnail-cell-block-spacing:var(--mod-table-thumbnail-block-spacing,var(--spectrum-table-thumbnail-block-spacing));--spectrum-table-thumbnail-inner-content-block-spacing:max(0px,calc((var(--mod-table-thumbnail-size,var(--spectrum-table-thumbnail-size)) - (var(--mod-table-row-line-height,var(--spectrum-table-row-line-height))*var(--mod-table-header-font-size,var(--spectrum-table-row-font-size))))/2))}.spectrum-Table-row--thumbnail ::slotted(*){padding-block:calc(var(--spectrum-table-thumbnail-cell-block-spacing) + var(--spectrum-table-thumbnail-inner-content-block-spacing))}.spectrum-Table-row--thumbnail .spectrum-Table-cell--thumbnail{padding-block:0}.spectrum-Table-row--thumbnail.spectrum-Table-row--collapsible{--spectrum-table-thumbnail-inner-minimum-block-spacing:max(0px,calc((var(--mod-table-disclosure-icon-size,var(--spectrum-table-disclosure-icon-size)) - var(--mod-table-thumbnail-size,var(--spectrum-table-thumbnail-size)))/2));--spectrum-table-thumbnail-cell-block-spacing:max(var(--mod-table-thumbnail-block-spacing,var(--spectrum-table-thumbnail-block-spacing)),var(--spectrum-table-thumbnail-inner-minimum-block-spacing))}:host,:host([role=row]){width:100%;display:flex}:host(:first-child) ::slotted(*){border-block-start:none}:host(:last-child) ::slotted(*){border-block-end:none}::slotted(:first-child){border-inline-start:none}::slotted(:last-child){border-inline-end:none}
`;
var table_row_css_default = e29;

// node_modules/@spectrum-web-components/table/src/TableRow.js
var h15 = Object.defineProperty;
var d17 = Object.getOwnPropertyDescriptor;
var s16 = (i21, c33, e36, l16) => {
  for (var t34 = l16 > 1 ? void 0 : l16 ? d17(c33, e36) : c33, a23 = i21.length - 1, o52; a23 >= 0; a23--) (o52 = i21[a23]) && (t34 = (l16 ? o52(c33, e36, t34) : o52(t34)) || t34);
  return l16 && t34 && h15(c33, e36, t34), t34;
};
var TableRow = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.role = "row";
    this.selectable = false;
    this.selected = false;
    this.value = "";
  }
  static get styles() {
    return [table_row_css_default];
  }
  async handleChange(e36) {
    e36.target.checkbox && (this.selected = e36.target.checkbox.checked, await 0, e36.defaultPrevented && (this.selected = !this.selected));
  }
  handleSlotchange({ target: e36 }) {
    const l16 = e36.assignedElements();
    this.selectable = !!l16.find((t34) => t34.localName === "sp-table-checkbox-cell");
  }
  async manageSelected() {
    await this.updateComplete, this.selectable ? this.setAttribute("aria-selected", this.selected ? "true" : "false") : this.removeAttribute("aria-selected");
    const [e36] = this.checkboxCells;
    e36 && (e36.checked = this.selected);
  }
  handleClick(e36) {
    if (e36.composedPath().find((t34) => t34.localName === "sp-table-checkbox-cell")) return;
    const [l16] = this.checkboxCells;
    l16 && l16.click();
  }
  render() {
    return x`
            <slot
                @change=${this.handleChange}
                @slotchange=${this.handleSlotchange}
            ></slot>
        `;
  }
  willUpdate(e36) {
    e36.has("selected") && this.manageSelected(), e36.has("selectable") && (this.selectable ? this.addEventListener("click", this.handleClick) : this.removeEventListener("click", this.handleClick));
  }
};
s16([o8({ selector: "sp-table-checkbox-cell", flatten: true })], TableRow.prototype, "checkboxCells", 2), s16([n4({ reflect: true })], TableRow.prototype, "role", 2), s16([n4({ type: Boolean })], TableRow.prototype, "selectable", 2), s16([n4({ type: Boolean, reflect: true })], TableRow.prototype, "selected", 2), s16([n4({ type: String })], TableRow.prototype, "value", 2);

// node_modules/@spectrum-web-components/table/sp-table-row.js
init_define_element();
defineElement("sp-table-row", TableRow);

// node_modules/@spectrum-web-components/table/src/TableCheckboxCell.js
init_src();
init_decorators2();
init_directives();

// node_modules/@spectrum-web-components/table/src/table-checkbox-cell.css.js
init_src();
var t30 = i`
    @media (forced-colors:active){:host(:not([head-cell])){forced-color-adjust:none}}:host([head-cell]){--spectrum-table-icon-color:var(--highcontrast-table-icon-color,var(--mod-table-icon-color-default,var(--spectrum-table-icon-color-default)));box-sizing:border-box;text-align:start;vertical-align:var(--mod-table-header-vertical-align,var(--spectrum-table-header-vertical-align));font-family:var(--mod-table-header-font-family,var(--spectrum-table-row-font-family));font-size:var(--mod-table-header-font-size,var(--spectrum-table-row-font-size));font-weight:var(--mod-table-header-font-weight,var(--spectrum-table-header-font-weight));line-height:var(--mod-table-header-line-height,var(--spectrum-table-row-line-height));text-transform:none;text-transform:var(--mod-table-header-text-transform,none);block-size:var(--mod-table-min-header-height,var(--spectrum-table-min-header-height));padding-block:var(--mod-table-header-top-to-text,var(--spectrum-table-header-top-to-text))var(--mod-table-header-bottom-to-text,var(--spectrum-table-header-bottom-to-text));padding-inline:var(--mod-table-cell-inline-space,var(--spectrum-table-cell-inline-space));color:var(--mod-table-header-text-color,var(--spectrum-table-header-text-color));background-color:var(--mod-table-header-background-color,var(--spectrum-table-header-background-color));transition:color var(--highcontrast-table-transition-duration,var(--mod-table-transition-duration,var(--spectrum-table-transition-duration)))ease-in-out;cursor:auto;cursor:var(--mod-table-cursor-header-default,initial);border-radius:0;outline:0}:host(:not([head-cell])){border-block-start:var(--mod-table-border-width,var(--spectrum-table-border-width))solid var(--highcontrast-table-divider-color,var(--mod-table-divider-color,var(--spectrum-table-divider-color)));box-sizing:border-box;font-size:var(--mod-table-row-font-size,var(--spectrum-table-row-font-size));font-weight:var(--mod-table-row-font-weight,var(--spectrum-table-row-font-weight));line-height:var(--mod-table-row-line-height,var(--spectrum-table-row-line-height));vertical-align:var(--mod-table-default-vertical-align,var(--spectrum-table-default-vertical-align));color:var(--highcontrast-table-row-text-color,var(--mod-table-row-text-color,var(--spectrum-table-row-text-color)));background-color:var(--spectrum-table-cell-background-color);block-size:var(--mod-table-min-row-height,var(--spectrum-table-min-row-height));padding-block-start:calc(var(--mod-table-row-top-to-text,var(--spectrum-table-row-top-to-text)) - var(--mod-table-border-width,var(--spectrum-table-border-width)));padding-block-end:var(--mod-table-row-bottom-to-text,var(--spectrum-table-row-bottom-to-text));padding-inline:calc(var(--mod-table-edge-to-content,var(--spectrum-table-edge-to-content)) - var(--mod-table-outer-border-inline-width,var(--spectrum-table-outer-border-inline-width)))}:host(:not([head-cell])),:host([head-cell]){display:table-cell;position:relative}:host(:not([head-cell])[focused]),:host(:not([head-cell]):focus-visible),:host([head-cell][focused]),:host([head-cell]:focus-visible){outline-width:var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness));outline-style:solid;outline-color:var(--highcontrast-table-cell-focus-indicator-color,var(--highcontrast-table-focus-indicator-color,var(--mod-table-focus-indicator-color,var(--spectrum-table-focus-indicator-color))));outline-offset:calc(var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness))*-1);outline-offset:calc(var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness))*-1 - var(--highcontrast-table-cell-focus-extra-offset,0px))}:host(:host){inline-size:var(--spectrum-checkbox-control-size-small);padding-block:0;padding-inline-end:calc(var(--mod-table-checkbox-to-text,var(--spectrum-table-checkbox-to-text)) - var(--mod-table-edge-to-content,var(--spectrum-table-edge-to-content)))}:host(:host) sp-checkbox{--mod-checkbox-spacing:0px;min-block-size:0}:host(:host:not([head-cell])) sp-checkbox{margin-block-start:calc(var(--mod-table-row-checkbox-block-spacing,var(--spectrum-table-row-checkbox-block-spacing)) - var(--mod-table-border-width,var(--spectrum-table-border-width)));margin-block-end:var(--mod-table-row-checkbox-block-spacing,var(--spectrum-table-row-checkbox-block-spacing))}:host(:host[head-cell]) sp-checkbox{margin-block-start:calc(var(--mod-table-header-checkbox-block-spacing,var(--spectrum-table-header-checkbox-block-spacing)) - var(--mod-table-border-width,var(--spectrum-table-border-width)));margin-block-end:var(--mod-table-header-checkbox-block-spacing,var(--spectrum-table-header-checkbox-block-spacing))}:host{border-radius:0;flex:0;align-items:center;block-size:auto;display:flex}:host(:not([head-cell])),:host([head-cell]){block-size:auto;inline-size:auto;display:flex}:host([selects-single]) sp-checkbox{visibility:hidden}
`;
var table_checkbox_cell_css_default = t30;

// node_modules/@spectrum-web-components/table/src/TableCheckboxCell.js
var d18 = Object.defineProperty;
var a20 = Object.getOwnPropertyDescriptor;
var e30 = (s19, r25, l16, c33) => {
  for (var t34 = c33 > 1 ? void 0 : c33 ? a20(r25, l16) : r25, p30 = s19.length - 1, o52; p30 >= 0; p30--) (o52 = s19[p30]) && (t34 = (c33 ? o52(r25, l16, t34) : o52(t34)) || t34);
  return c33 && t34 && d18(r25, l16, t34), t34;
};
var TableCheckboxCell = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.headCell = false;
    this.role = "gridcell";
    this.indeterminate = false;
    this.checked = false;
    this.disabled = false;
    this.selectsSingle = false;
    this.emphasized = false;
  }
  static get styles() {
    return [table_checkbox_cell_css_default];
  }
  click() {
    this.checkbox.click();
  }
  render() {
    return x`
            <sp-checkbox
                ?checked=${this.checked}
                ?indeterminate=${this.indeterminate}
                ?disabled=${this.disabled}
                ?emphasized=${this.emphasized}
                aria-hidden=${o9(this.selectsSingle)}
                class="checkbox"
            ></sp-checkbox>
        `;
  }
};
e30([n4({ type: Boolean, reflect: true, attribute: "head-cell" })], TableCheckboxCell.prototype, "headCell", 2), e30([n4({ reflect: true })], TableCheckboxCell.prototype, "role", 2), e30([e5(".checkbox")], TableCheckboxCell.prototype, "checkbox", 2), e30([n4({ type: Boolean })], TableCheckboxCell.prototype, "indeterminate", 2), e30([n4({ type: Boolean })], TableCheckboxCell.prototype, "checked", 2), e30([n4({ type: Boolean })], TableCheckboxCell.prototype, "disabled", 2), e30([n4({ type: Boolean, reflect: true, attribute: "selects-single" })], TableCheckboxCell.prototype, "selectsSingle", 2), e30([n4({ type: Boolean, reflect: true })], TableCheckboxCell.prototype, "emphasized", 2);

// node_modules/@spectrum-web-components/table/sp-table-checkbox-cell.js
init_define_element();
defineElement("sp-table-checkbox-cell", TableCheckboxCell);

// node_modules/@spectrum-web-components/table/src/Table.js
init_decorators2();

// node_modules/@spectrum-web-components/table/src/table.css.js
init_src();
var e31 = i`
    @media (forced-colors:active){:host{--highcontrast-table-row-background-color:Canvas;--highcontrast-table-row-text-color:CanvasText;--highcontrast-table-divider-color:CanvasText;--highcontrast-table-border-color:CanvasText;--highcontrast-table-icon-color:CanvasText;--highcontrast-table-icon-color-focus:Highlight;--highcontrast-table-selected-row-background-color:Highlight;--highcontrast-table-selected-row-text-color:HighlightText;--highcontrast-table-selected-row-background-color-focus:Highlight;--highcontrast-table-selected-row-text-color-focus:HighlightText;--highcontrast-table-row-background-color-hover:Highlight;--highcontrast-table-row-text-color-hover:HighlightText;--highcontrast-table-section-header-text-color:Canvas;--highcontrast-table-section-header-background-color:CanvasText;--highcontrast-table-focus-indicator-color:Highlight;--highcontrast-table-transition-duration:0}@supports (color:SelectedItem){:host{--highcontrast-table-selected-row-background-color:SelectedItem;--highcontrast-table-selected-row-text-color:SelectedItemText}}}:host{--spectrum-table-cell-inline-space:var(--spectrum-table-edge-to-content);--spectrum-table-border-radius:var(--spectrum-corner-radius-100);--spectrum-table-border-width:var(--spectrum-table-border-divider-width);--spectrum-table-outer-border-inline-width:var(--spectrum-table-border-divider-width);--spectrum-table-default-vertical-align:top;--spectrum-table-header-vertical-align:middle;--spectrum-table-header-font-weight:var(--spectrum-bold-font-weight);--spectrum-table-row-font-family:var(--spectrum-sans-font-family-stack);--spectrum-table-row-font-weight:var(--spectrum-regular-font-weight);--spectrum-table-row-font-style:var(--spectrum-default-font-style);--spectrum-table-row-line-height:var(--spectrum-line-height-100);--spectrum-table-border-color:var(--spectrum-gray-300);--spectrum-table-divider-color:var(--spectrum-gray-300);--spectrum-table-header-background-color:var(--spectrum-transparent-white-100);--spectrum-table-header-text-color:var(--spectrum-body-color);--spectrum-table-row-background-color:var(--spectrum-gray-50);--spectrum-table-row-text-color:var(--spectrum-neutral-content-color-default);--spectrum-table-selected-row-background-color:rgba(var(--spectrum-blue-900-rgb),var(--spectrum-table-selected-row-background-opacity));--spectrum-table-selected-row-background-color-non-emphasized:rgba(var(--spectrum-gray-700-rgb),var(--spectrum-table-selected-row-background-opacity-non-emphasized));--spectrum-table-row-background-color-hover:rgba(var(--spectrum-gray-900-rgb),var(--spectrum-table-row-hover-opacity));--spectrum-table-row-active-color:rgba(var(--spectrum-gray-900-rgb),var(--spectrum-table-row-down-opacity));--spectrum-table-selected-row-background-color-focus:rgba(var(--spectrum-blue-900-rgb),var(--spectrum-table-selected-row-background-opacity-hover));--spectrum-table-selected-row-background-color-non-emphasized-focus:rgba(var(--spectrum-gray-700-rgb),var(--spectrum-table-selected-row-background-opacity-non-emphasized-hover));--spectrum-table-icon-color-default:var(--spectrum-neutral-subdued-content-color-default);--spectrum-table-icon-color-hover:var(--spectrum-neutral-subdued-content-color-hover);--spectrum-table-icon-color-active:var(--spectrum-neutral-subdued-content-color-down);--spectrum-table-icon-color-focus:var(--spectrum-neutral-subdued-content-color-key-focus);--spectrum-table-icon-color-focus-hover:var(--spectrum-neutral-subdued-content-color-key-focus);--spectrum-table-icon-color-key-focus:var(--spectrum-neutral-subdued-content-color-key-focus);--spectrum-table-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-table-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-table-drop-zone-background-color:rgba(var(--spectrum-drop-zone-background-color-rgb),var(--spectrum-drop-zone-background-color-opacity));--spectrum-table-drop-zone-outline-color:var(--spectrum-accent-visual-color);--spectrum-table-transition-duration:var(--spectrum-animation-duration-100);--spectrum-table-summary-row-font-weight:var(--spectrum-bold-font-weight);--spectrum-table-summary-row-background-color:var(--spectrum-gray-200);--spectrum-table-section-header-font-weight:var(--spectrum-bold-font-weight);--spectrum-table-section-header-background-color:var(--spectrum-gray-200);--spectrum-table-collapsible-tier-indent:var(--spectrum-spacing-300);--spectrum-table-collapsible-disclosure-inline-spacing:0px;--spectrum-table-collapsible-icon-animation-duration:var(--spectrum-animation-duration-100);--spectrum-table-cell-background-color:var(--highcontrast-table-row-background-color,var(--mod-table-row-background-color,var(--spectrum-table-row-background-color)));--spectrum-table-selected-cell-background-color:var(--highcontrast-table-selected-row-background-color,var(--mod-table-selected-row-background-color-non-emphasized,var(--spectrum-table-selected-row-background-color-non-emphasized)));--spectrum-table-selected-cell-background-color-focus:var(--highcontrast-table-selected-row-background-color-focus,var(--mod-table-selected-row-background-color-non-emphasized-focus,var(--spectrum-table-selected-row-background-color-non-emphasized-focus)));--mod-thumbnail-size:var(--mod-table-thumbnail-size,var(--spectrum-table-thumbnail-size))}:host:dir(rtl),:host([dir=rtl]){--spectrum-logical-rotation:matrix(-1,0,0,1,0,0)}:host,.spectrum-Table--sizeM{--spectrum-table-min-header-height:var(--spectrum-component-height-100);--spectrum-table-header-top-to-text:var(--spectrum-table-column-header-row-top-to-text-medium);--spectrum-table-header-bottom-to-text:var(--spectrum-table-column-header-row-bottom-to-text-medium);--spectrum-table-min-row-height:var(--spectrum-table-row-height-medium-regular);--spectrum-table-row-top-to-text:var(--spectrum-table-row-top-to-text-medium-regular);--spectrum-table-row-bottom-to-text:var(--spectrum-table-row-bottom-to-text-medium-regular);--spectrum-table-icon-to-text:var(--spectrum-text-to-visual-100);--spectrum-table-row-font-size:var(--spectrum-font-size-100);--spectrum-table-header-checkbox-block-spacing:var(--spectrum-table-header-row-checkbox-to-top-medium);--spectrum-table-row-checkbox-block-spacing:var(--spectrum-table-row-checkbox-to-top-medium-regular);--spectrum-table-section-header-min-height:var(--spectrum-table-section-header-row-height-medium);--spectrum-table-section-header-block-start-spacing:var(--spectrum-component-top-to-text-100);--spectrum-table-section-header-block-end-spacing:var(--spectrum-component-bottom-to-text-100);--spectrum-table-disclosure-icon-size:var(--spectrum-component-height-100);--spectrum-table-thumbnail-block-spacing:var(--spectrum-table-thumbnail-to-top-minimum-medium-regular);--spectrum-table-thumbnail-to-text:var(--spectrum-text-to-visual-100);--spectrum-table-thumbnail-size:var(--spectrum-thumbnail-size-300)}:host([size=s]){--spectrum-table-min-header-height:var(--spectrum-component-height-100);--spectrum-table-header-top-to-text:var(--spectrum-table-column-header-row-top-to-text-small);--spectrum-table-header-bottom-to-text:var(--spectrum-table-column-header-row-bottom-to-text-small);--spectrum-table-min-row-height:var(--spectrum-table-row-height-small-regular);--spectrum-table-row-top-to-text:var(--spectrum-table-row-top-to-text-small-regular);--spectrum-table-row-bottom-to-text:var(--spectrum-table-row-bottom-to-text-small-regular);--spectrum-table-icon-to-text:var(--spectrum-text-to-visual-100);--spectrum-table-row-font-size:var(--spectrum-font-size-75);--spectrum-table-header-checkbox-block-spacing:var(--spectrum-table-header-row-checkbox-to-top-small);--spectrum-table-row-checkbox-block-spacing:var(--spectrum-table-row-checkbox-to-top-small-regular);--spectrum-table-section-header-min-height:var(--spectrum-table-section-header-row-height-small);--spectrum-table-section-header-block-start-spacing:var(--spectrum-component-top-to-text-75);--spectrum-table-section-header-block-end-spacing:var(--spectrum-component-bottom-to-text-75);--spectrum-table-disclosure-icon-size:var(--spectrum-component-height-75);--spectrum-table-thumbnail-block-spacing:var(--spectrum-table-thumbnail-to-top-minimum-small-regular);--spectrum-table-thumbnail-to-text:var(--spectrum-text-to-visual-100);--spectrum-table-thumbnail-size:var(--spectrum-thumbnail-size-200)}:host([size=l]){--spectrum-table-min-header-height:var(--spectrum-component-height-200);--spectrum-table-header-top-to-text:var(--spectrum-table-column-header-row-top-to-text-large);--spectrum-table-header-bottom-to-text:var(--spectrum-table-column-header-row-bottom-to-text-large);--spectrum-table-min-row-height:var(--spectrum-table-row-height-large-regular);--spectrum-table-row-top-to-text:var(--spectrum-table-row-top-to-text-large-regular);--spectrum-table-row-bottom-to-text:var(--spectrum-table-row-bottom-to-text-large-regular);--spectrum-table-icon-to-text:var(--spectrum-text-to-visual-200);--spectrum-table-row-font-size:var(--spectrum-font-size-200);--spectrum-table-header-checkbox-block-spacing:var(--spectrum-table-header-row-checkbox-to-top-large);--spectrum-table-row-checkbox-block-spacing:var(--spectrum-table-row-checkbox-to-top-large-regular);--spectrum-table-section-header-min-height:var(--spectrum-table-section-header-row-height-large);--spectrum-table-section-header-block-start-spacing:var(--spectrum-component-top-to-text-200);--spectrum-table-section-header-block-end-spacing:var(--spectrum-component-bottom-to-text-200);--spectrum-table-disclosure-icon-size:var(--spectrum-component-height-200);--spectrum-table-thumbnail-block-spacing:var(--spectrum-table-thumbnail-to-top-minimum-large-regular);--spectrum-table-thumbnail-to-text:var(--spectrum-text-to-visual-200);--spectrum-table-thumbnail-size:var(--spectrum-thumbnail-size-500)}:host([size=xl]){--spectrum-table-min-header-height:var(--spectrum-component-height-300);--spectrum-table-header-top-to-text:var(--spectrum-table-column-header-row-top-to-text-extra-large);--spectrum-table-header-bottom-to-text:var(--spectrum-table-column-header-row-bottom-to-text-extra-large);--spectrum-table-min-row-height:var(--spectrum-table-row-height-extra-large-regular);--spectrum-table-row-top-to-text:var(--spectrum-table-row-top-to-text-extra-large-regular);--spectrum-table-row-bottom-to-text:var(--spectrum-table-row-bottom-to-text-extra-large-regular);--spectrum-table-icon-to-text:var(--spectrum-text-to-visual-300);--spectrum-table-row-font-size:var(--spectrum-font-size-300);--spectrum-table-header-checkbox-block-spacing:var(--spectrum-table-header-row-checkbox-to-top-extra-large);--spectrum-table-row-checkbox-block-spacing:var(--spectrum-table-row-checkbox-to-top-extra-large-regular);--spectrum-table-section-header-min-height:var(--spectrum-table-section-header-row-height-extra-large);--spectrum-table-section-header-block-start-spacing:var(--spectrum-component-top-to-text-300);--spectrum-table-section-header-block-end-spacing:var(--spectrum-component-bottom-to-text-300);--spectrum-table-disclosure-icon-size:var(--spectrum-component-height-300);--spectrum-table-thumbnail-block-spacing:var(--spectrum-table-thumbnail-to-top-minimum-extra-large-regular);--spectrum-table-thumbnail-to-text:var(--spectrum-text-to-visual-300);--spectrum-table-thumbnail-size:var(--spectrum-thumbnail-size-700)}:host([density=compact]){--mod-table-min-row-height:var(--mod-table-min-row-height--compact,var(--spectrum-table-row-height-medium-compact));--mod-table-row-top-to-text:var(--mod-table-row-top-to-text--compact,var(--spectrum-table-row-top-to-text-medium-compact));--mod-table-row-bottom-to-text:var(--mod-table-row-bottom-to-text--compact,var(--spectrum-table-row-bottom-to-text-medium-compact));--mod-table-row-checkbox-block-spacing:var(--mod-table-row-checkbox-block-spacing--compact,var(--spectrum-table-row-checkbox-to-top-medium-compact));--mod-table-thumbnail-block-spacing:var(--mod-table-thumbnail-block-spacing-compact,var(--spectrum-table-thumbnail-to-top-minimum-medium-compact));--mod-table-thumbnail-size:var(--mod-table-thumbnail-size-compact,var(--spectrum-thumbnail-size-200))}:host([density=compact][size=s]){--mod-table-min-row-height:var(--mod-table-min-row-height--compact,var(--spectrum-table-row-height-small-compact));--mod-table-row-top-to-text:var(--mod-table-row-top-to-text--compact,var(--spectrum-table-row-top-to-text-small-compact));--mod-table-row-bottom-to-text:var(--mod-table-row-bottom-to-text--compact,var(--spectrum-table-row-bottom-to-text-small-compact));--mod-table-row-checkbox-block-spacing:var(--mod-table-row-checkbox-block-spacing--compact,var(--spectrum-table-row-checkbox-to-top-small-compact));--mod-table-thumbnail-block-spacing:var(--mod-table-thumbnail-block-spacing-compact,var(--spectrum-table-thumbnail-to-top-minimum-small-compact));--mod-table-thumbnail-size:var(--mod-table-thumbnail-size-compact,var(--spectrum-thumbnail-size-50))}:host([density=compact][size=l]){--mod-table-min-row-height:var(--mod-table-min-row-height--compact,var(--spectrum-table-row-height-large-compact));--mod-table-row-top-to-text:var(--mod-table-row-top-to-text--compact,var(--spectrum-table-row-top-to-text-large-compact));--mod-table-row-bottom-to-text:var(--mod-table-row-bottom-to-text--compact,var(--spectrum-table-row-bottom-to-text-large-compact));--mod-table-row-checkbox-block-spacing:var(--mod-table-row-checkbox-block-spacing--compact,var(--spectrum-table-row-checkbox-to-top-large-compact));--mod-table-thumbnail-block-spacing:var(--mod-table-thumbnail-block-spacing-compact,var(--spectrum-table-thumbnail-to-top-minimum-large-compact));--mod-table-thumbnail-size:var(--mod-table-thumbnail-size-compact,var(--spectrum-thumbnail-size-300))}:host([density=compact][size=xl]){--mod-table-min-row-height:var(--mod-table-min-row-height--compact,var(--spectrum-table-row-height-extra-large-compact));--mod-table-row-top-to-text:var(--mod-table-row-top-to-text--compact,var(--spectrum-table-row-top-to-text-extra-large-compact));--mod-table-row-bottom-to-text:var(--mod-table-row-bottom-to-text--compact,var(--spectrum-table-row-bottom-to-text-extra-large-compact));--mod-table-row-checkbox-block-spacing:var(--mod-table-row-checkbox-block-spacing--compact,var(--spectrum-table-row-checkbox-to-top-extra-large-compact));--mod-table-thumbnail-block-spacing:var(--mod-table-thumbnail-block-spacing-compact,var(--spectrum-table-thumbnail-to-top-minimum-extra-large-compact));--mod-table-thumbnail-size:var(--mod-table-thumbnail-size-compact,var(--spectrum-thumbnail-size-500))}:host([density=spacious]){--mod-table-min-row-height:var(--mod-table-min-row-height--spacious,var(--spectrum-table-row-height-medium-spacious));--mod-table-row-top-to-text:var(--mod-table-row-top-to-text--spacious,var(--spectrum-table-row-top-to-text-medium-spacious));--mod-table-row-bottom-to-text:var(--mod-table-row-bottom-to-text--spacious,var(--spectrum-table-row-bottom-to-text-medium-spacious));--mod-table-row-checkbox-block-spacing:var(--mod-table-row-checkbox-block-spacing--spacious,var(--spectrum-table-row-checkbox-to-top-medium-spacious));--mod-table-thumbnail-block-spacing:var(--mod-table-thumbnail-block-spacing-spacious,var(--spectrum-table-thumbnail-to-top-minimum-medium-spacious));--mod-table-thumbnail-size:var(--mod-table-thumbnail-size-spacious,var(--spectrum-thumbnail-size-500))}:host([density=spacious][size=s]){--mod-table-min-row-height:var(--mod-table-min-row-height--spacious,var(--spectrum-table-row-height-small-spacious));--mod-table-row-top-to-text:var(--mod-table-row-top-to-text--spacious,var(--spectrum-table-row-top-to-text-small-spacious));--mod-table-row-bottom-to-text:var(--mod-table-row-bottom-to-text--spacious,var(--spectrum-table-row-bottom-to-text-small-spacious));--mod-table-row-checkbox-block-spacing:var(--mod-table-row-checkbox-block-spacing--spacious,var(--spectrum-table-row-checkbox-to-top-small-spacious));--mod-table-thumbnail-block-spacing:var(--mod-table-thumbnail-block-spacing-spacious,var(--spectrum-table-thumbnail-to-top-minimum-small-spacious));--mod-table-thumbnail-size:var(--mod-table-thumbnail-size-spacious,var(--spectrum-thumbnail-size-300))}:host([density=spacious][size=l]){--mod-table-min-row-height:var(--mod-table-min-row-height--spacious,var(--spectrum-table-row-height-large-spacious));--mod-table-row-top-to-text:var(--mod-table-row-top-to-text--spacious,var(--spectrum-table-row-top-to-text-large-spacious));--mod-table-row-bottom-to-text:var(--mod-table-row-bottom-to-text--spacious,var(--spectrum-table-row-bottom-to-text-large-spacious));--mod-table-row-checkbox-block-spacing:var(--mod-table-row-checkbox-block-spacing--spacious,var(--spectrum-table-row-checkbox-to-top-large-spacious));--mod-table-thumbnail-block-spacing:var(--mod-table-thumbnail-block-spacing-spacious,var(--spectrum-table-thumbnail-to-top-minimum-large-spacious));--mod-table-thumbnail-size:var(--mod-table-thumbnail-size-spacious,var(--spectrum-thumbnail-size-700))}:host([density=spacious][size=xl]){--mod-table-min-row-height:var(--mod-table-min-row-height--spacious,var(--spectrum-table-row-height-extra-large-spacious));--mod-table-row-top-to-text:var(--mod-table-row-top-to-text--spacious,var(--spectrum-table-row-top-to-text-extra-large-spacious));--mod-table-row-bottom-to-text:var(--mod-table-row-bottom-to-text--spacious,var(--spectrum-table-row-bottom-to-text-extra-large-spacious));--mod-table-row-checkbox-block-spacing:var(--mod-table-row-checkbox-block-spacing--spacious,var(--spectrum-table-row-checkbox-to-top-extra-large-spacious));--mod-table-thumbnail-block-spacing:var(--mod-table-thumbnail-block-spacing-spacious,var(--spectrum-table-thumbnail-to-top-minimum-extra-large-spacious));--mod-table-thumbnail-size:var(--mod-table-thumbnail-size-spacious,var(--spectrum-thumbnail-size-800))}:host([emphasized]){--spectrum-table-selected-cell-background-color:var(--highcontrast-table-selected-row-background-color,var(--mod-table-selected-row-background-color,var(--spectrum-table-selected-row-background-color)));--spectrum-table-selected-cell-background-color-focus:var(--highcontrast-table-selected-row-background-color-focus,var(--mod-table-selected-row-background-color-focus,var(--spectrum-table-selected-row-background-color-focus)))}:host([quiet]){--mod-table-border-radius:var(--mod-table-border-radius--quiet,0px);--mod-table-outer-border-inline-width:var(--mod-table-outer-border-inline-width--quiet,0px);--mod-table-header-background-color:var(--mod-table-header-background-color--quiet,var(--spectrum-transparent-white-100));--mod-table-row-background-color:var(--mod-table-row-background-color--quiet,var(--spectrum-transparent-white-100))}:host:not(.spectrum-Table-scroller){border-collapse:initial;border-spacing:0;display:table}:host{--spectrum-table-header-background-color:var(--system-table-header-background-color);--spectrum-table-border-color:var(--system-table-border-color);--spectrum-table-divider-color:var(--system-table-divider-color);--spectrum-table-row-background-color:var(--system-table-row-background-color);--spectrum-table-summary-row-background-color:var(--system-table-summary-row-background-color);--spectrum-table-section-header-background-color:var(--system-table-section-header-background-color);--spectrum-table-icon-color-focus:var(--system-table-icon-color-focus);--spectrum-table-icon-color-focus-hover:var(--system-table-icon-color-focus-hover)}:host([quiet]){--spectrum-table-header-background-color:var(--system-table-quiet-header-background-color);--spectrum-table-row-background-color:var(--system-table-quiet-row-background-color)}:host{flex-direction:column;display:flex}
`;
var table_css_default = e31;

// node_modules/@lit-labs/virtualizer/virtualize.js
init_lit();

// node_modules/lit/directive.js
init_directive();

// node_modules/@lit-labs/virtualizer/virtualize.js
init_repeat2();

// node_modules/@lit-labs/virtualizer/events.js
var RangeChangedEvent = class _RangeChangedEvent extends Event {
  constructor(range) {
    super(_RangeChangedEvent.eventName, { bubbles: false });
    this.first = range.first;
    this.last = range.last;
  }
};
RangeChangedEvent.eventName = "rangeChanged";
var VisibilityChangedEvent = class _VisibilityChangedEvent extends Event {
  constructor(range) {
    super(_VisibilityChangedEvent.eventName, { bubbles: false });
    this.first = range.first;
    this.last = range.last;
  }
};
VisibilityChangedEvent.eventName = "visibilityChanged";
var UnpinnedEvent = class _UnpinnedEvent extends Event {
  constructor() {
    super(_UnpinnedEvent.eventName, { bubbles: false });
  }
};
UnpinnedEvent.eventName = "unpinned";

// node_modules/@lit-labs/virtualizer/ScrollerController.js
var ScrollerShim = class {
  constructor(element) {
    this._element = null;
    const node = element ?? window;
    this._node = node;
    if (element) {
      this._element = element;
    }
  }
  get element() {
    return this._element || document.scrollingElement || document.documentElement;
  }
  get scrollTop() {
    return this.element.scrollTop || window.scrollY;
  }
  get scrollLeft() {
    return this.element.scrollLeft || window.scrollX;
  }
  get scrollHeight() {
    return this.element.scrollHeight;
  }
  get scrollWidth() {
    return this.element.scrollWidth;
  }
  get viewportHeight() {
    return this._element ? this._element.getBoundingClientRect().height : window.innerHeight;
  }
  get viewportWidth() {
    return this._element ? this._element.getBoundingClientRect().width : window.innerWidth;
  }
  get maxScrollTop() {
    return this.scrollHeight - this.viewportHeight;
  }
  get maxScrollLeft() {
    return this.scrollWidth - this.viewportWidth;
  }
};
var ScrollerController = class extends ScrollerShim {
  constructor(client, element) {
    super(element);
    this._clients = /* @__PURE__ */ new Set();
    this._retarget = null;
    this._end = null;
    this.__destination = null;
    this.correctingScrollError = false;
    this._checkForArrival = this._checkForArrival.bind(this);
    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);
    this.scrollTo = this.scrollTo.bind(this);
    this.scrollBy = this.scrollBy.bind(this);
    const node = this._node;
    this._originalScrollTo = node.scrollTo;
    this._originalScrollBy = node.scrollBy;
    this._originalScroll = node.scroll;
    this._attach(client);
  }
  get _destination() {
    return this.__destination;
  }
  get scrolling() {
    return this._destination !== null;
  }
  scrollTo(p1, p210) {
    const options = typeof p1 === "number" && typeof p210 === "number" ? { left: p1, top: p210 } : p1;
    this._scrollTo(options);
  }
  scrollBy(p1, p210) {
    const options = typeof p1 === "number" && typeof p210 === "number" ? { left: p1, top: p210 } : p1;
    if (options.top !== void 0) {
      options.top += this.scrollTop;
    }
    if (options.left !== void 0) {
      options.left += this.scrollLeft;
    }
    this._scrollTo(options);
  }
  _nativeScrollTo(options) {
    this._originalScrollTo.bind(this._element || window)(options);
  }
  _scrollTo(options, retarget = null, end = null) {
    if (this._end !== null) {
      this._end();
    }
    if (options.behavior === "smooth") {
      this._setDestination(options);
      this._retarget = retarget;
      this._end = end;
    } else {
      this._resetScrollState();
    }
    this._nativeScrollTo(options);
  }
  _setDestination(options) {
    let { top, left } = options;
    top = top === void 0 ? void 0 : Math.max(0, Math.min(top, this.maxScrollTop));
    left = left === void 0 ? void 0 : Math.max(0, Math.min(left, this.maxScrollLeft));
    if (this._destination !== null && left === this._destination.left && top === this._destination.top) {
      return false;
    }
    this.__destination = { top, left, behavior: "smooth" };
    return true;
  }
  _resetScrollState() {
    this.__destination = null;
    this._retarget = null;
    this._end = null;
  }
  _updateManagedScrollTo(coordinates) {
    if (this._destination) {
      if (this._setDestination(coordinates)) {
        this._nativeScrollTo(this._destination);
      }
    }
  }
  managedScrollTo(options, retarget, end) {
    this._scrollTo(options, retarget, end);
    return this._updateManagedScrollTo;
  }
  correctScrollError(coordinates) {
    this.correctingScrollError = true;
    requestAnimationFrame(() => requestAnimationFrame(() => this.correctingScrollError = false));
    this._nativeScrollTo(coordinates);
    if (this._retarget) {
      this._setDestination(this._retarget());
    }
    if (this._destination) {
      this._nativeScrollTo(this._destination);
    }
  }
  _checkForArrival() {
    if (this._destination !== null) {
      const { scrollTop, scrollLeft } = this;
      let { top, left } = this._destination;
      top = Math.min(top || 0, this.maxScrollTop);
      left = Math.min(left || 0, this.maxScrollLeft);
      const topDiff = Math.abs(top - scrollTop);
      const leftDiff = Math.abs(left - scrollLeft);
      if (topDiff < 1 && leftDiff < 1) {
        if (this._end) {
          this._end();
        }
        this._resetScrollState();
      }
    }
  }
  detach(client) {
    this._clients.delete(client);
    if (this._clients.size === 0) {
      this._node.scrollTo = this._originalScrollTo;
      this._node.scrollBy = this._originalScrollBy;
      this._node.scroll = this._originalScroll;
      this._node.removeEventListener("scroll", this._checkForArrival);
    }
    return null;
  }
  _attach(client) {
    this._clients.add(client);
    if (this._clients.size === 1) {
      this._node.scrollTo = this.scrollTo;
      this._node.scrollBy = this.scrollBy;
      this._node.scroll = this.scrollTo;
      this._node.addEventListener("scroll", this._checkForArrival);
    }
  }
};

// node_modules/@lit-labs/virtualizer/Virtualizer.js
var _ResizeObserver = window?.ResizeObserver;
var virtualizerRef = Symbol("virtualizerRef");
var SIZER_ATTRIBUTE = "virtualizer-sizer";
var DefaultLayoutConstructor;
var Virtualizer = class {
  constructor(config) {
    this._benchmarkStart = null;
    this._layout = null;
    this._clippingAncestors = [];
    this._scrollSize = null;
    this._scrollError = null;
    this._childrenPos = null;
    this._childMeasurements = null;
    this._toBeMeasured = /* @__PURE__ */ new Map();
    this._rangeChanged = true;
    this._itemsChanged = true;
    this._visibilityChanged = true;
    this._scrollerController = null;
    this._isScroller = false;
    this._sizer = null;
    this._hostElementRO = null;
    this._childrenRO = null;
    this._mutationObserver = null;
    this._scrollEventListeners = [];
    this._scrollEventListenerOptions = {
      passive: true
    };
    this._loadListener = this._childLoaded.bind(this);
    this._scrollIntoViewTarget = null;
    this._updateScrollIntoViewCoordinates = null;
    this._items = [];
    this._first = -1;
    this._last = -1;
    this._firstVisible = -1;
    this._lastVisible = -1;
    this._scheduled = /* @__PURE__ */ new WeakSet();
    this._measureCallback = null;
    this._measureChildOverride = null;
    this._layoutCompletePromise = null;
    this._layoutCompleteResolver = null;
    this._layoutCompleteRejecter = null;
    this._pendingLayoutComplete = null;
    this._layoutInitialized = null;
    if (!config) {
      throw new Error("Virtualizer constructor requires a configuration object");
    }
    if (config.hostElement) {
      this._init(config);
    } else {
      throw new Error('Virtualizer configuration requires the "hostElement" property');
    }
  }
  set items(items) {
    if (Array.isArray(items) && items !== this._items) {
      this._itemsChanged = true;
      this._items = items;
      this._schedule(this._updateLayout);
    }
  }
  _init(config) {
    this._isScroller = !!config.scroller;
    this._initHostElement(config);
    const layoutConfig = config.layout || {};
    this._layoutInitialized = this._initLayout(layoutConfig);
  }
  _initObservers() {
    this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));
    this._hostElementRO = new _ResizeObserver(() => this._hostElementSizeChanged());
    this._childrenRO = new _ResizeObserver(this._childrenSizeChanged.bind(this));
  }
  _initHostElement(config) {
    const hostElement = this._hostElement = config.hostElement;
    this._applyVirtualizerStyles();
    hostElement[virtualizerRef] = this;
  }
  connected() {
    this._initObservers();
    const includeSelf = this._isScroller;
    this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);
    this._scrollerController = new ScrollerController(this, this._clippingAncestors[0]);
    this._schedule(this._updateLayout);
    this._observeAndListen();
  }
  _observeAndListen() {
    this._mutationObserver.observe(this._hostElement, { childList: true });
    this._hostElementRO.observe(this._hostElement);
    this._scrollEventListeners.push(window);
    window.addEventListener("scroll", this, this._scrollEventListenerOptions);
    this._clippingAncestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", this, this._scrollEventListenerOptions);
      this._scrollEventListeners.push(ancestor);
      this._hostElementRO.observe(ancestor);
    });
    this._hostElementRO.observe(this._scrollerController.element);
    this._children.forEach((child) => this._childrenRO.observe(child));
    this._scrollEventListeners.forEach((target) => target.addEventListener("scroll", this, this._scrollEventListenerOptions));
  }
  disconnected() {
    this._scrollEventListeners.forEach((target) => target.removeEventListener("scroll", this, this._scrollEventListenerOptions));
    this._scrollEventListeners = [];
    this._clippingAncestors = [];
    this._scrollerController?.detach(this);
    this._scrollerController = null;
    this._mutationObserver?.disconnect();
    this._mutationObserver = null;
    this._hostElementRO?.disconnect();
    this._hostElementRO = null;
    this._childrenRO?.disconnect();
    this._childrenRO = null;
    this._rejectLayoutCompletePromise("disconnected");
  }
  _applyVirtualizerStyles() {
    const hostElement = this._hostElement;
    const style = hostElement.style;
    style.display = style.display || "block";
    style.position = style.position || "relative";
    style.contain = style.contain || "size layout";
    if (this._isScroller) {
      style.overflow = style.overflow || "auto";
      style.minHeight = style.minHeight || "150px";
    }
  }
  _getSizer() {
    const hostElement = this._hostElement;
    if (!this._sizer) {
      let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);
      if (!sizer) {
        sizer = document.createElement("div");
        sizer.setAttribute(SIZER_ATTRIBUTE, "");
        hostElement.appendChild(sizer);
      }
      Object.assign(sizer.style, {
        position: "absolute",
        margin: "-2px 0 0 0",
        padding: 0,
        visibility: "hidden",
        fontSize: "2px"
      });
      sizer.textContent = "&nbsp;";
      sizer.setAttribute(SIZER_ATTRIBUTE, "");
      this._sizer = sizer;
    }
    return this._sizer;
  }
  async updateLayoutConfig(layoutConfig) {
    await this._layoutInitialized;
    const Ctor4 = layoutConfig.type || // The new config is compatible with the current layout,
    // so we update the config and return true to indicate
    // a successful update
    DefaultLayoutConstructor;
    if (typeof Ctor4 === "function" && this._layout instanceof Ctor4) {
      const config = { ...layoutConfig };
      delete config.type;
      this._layout.config = config;
      return true;
    }
    return false;
  }
  async _initLayout(layoutConfig) {
    let config;
    let Ctor4;
    if (typeof layoutConfig.type === "function") {
      Ctor4 = layoutConfig.type;
      const copy2 = { ...layoutConfig };
      delete copy2.type;
      config = copy2;
    } else {
      config = layoutConfig;
    }
    if (Ctor4 === void 0) {
      DefaultLayoutConstructor = Ctor4 = (await Promise.resolve().then(() => (init_flow(), flow_exports))).FlowLayout;
    }
    this._layout = new Ctor4((message) => this._handleLayoutMessage(message), config);
    if (this._layout.measureChildren && typeof this._layout.updateItemSizes === "function") {
      if (typeof this._layout.measureChildren === "function") {
        this._measureChildOverride = this._layout.measureChildren;
      }
      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);
    }
    if (this._layout.listenForChildLoadEvents) {
      this._hostElement.addEventListener("load", this._loadListener, true);
    }
    this._schedule(this._updateLayout);
  }
  // TODO (graynorton): Rework benchmarking so that it has no API and
  // instead is always on except in production builds
  startBenchmarking() {
    if (this._benchmarkStart === null) {
      this._benchmarkStart = window.performance.now();
    }
  }
  stopBenchmarking() {
    if (this._benchmarkStart !== null) {
      const now = window.performance.now();
      const timeElapsed = now - this._benchmarkStart;
      const entries = performance.getEntriesByName("uv-virtualizing", "measure");
      const virtualizationTime = entries.filter((e36) => e36.startTime >= this._benchmarkStart && e36.startTime < now).reduce((t34, m18) => t34 + m18.duration, 0);
      this._benchmarkStart = null;
      return { timeElapsed, virtualizationTime };
    }
    return null;
  }
  _measureChildren() {
    const mm = {};
    const children = this._children;
    const fn2 = this._measureChildOverride || this._measureChild;
    for (let i21 = 0; i21 < children.length; i21++) {
      const child = children[i21];
      const idx = this._first + i21;
      if (this._itemsChanged || this._toBeMeasured.has(child)) {
        mm[idx] = fn2.call(this, child, this._items[idx]);
      }
    }
    this._childMeasurements = mm;
    this._schedule(this._updateLayout);
    this._toBeMeasured.clear();
  }
  /**
   * Returns the width, height, and margins of the given child.
   */
  _measureChild(element) {
    const { width, height } = element.getBoundingClientRect();
    return Object.assign({ width, height }, getMargins(element));
  }
  async _schedule(method) {
    if (!this._scheduled.has(method)) {
      this._scheduled.add(method);
      await Promise.resolve();
      this._scheduled.delete(method);
      method.call(this);
    }
  }
  async _updateDOM(state) {
    this._scrollSize = state.scrollSize;
    this._adjustRange(state.range);
    this._childrenPos = state.childPositions;
    this._scrollError = state.scrollError || null;
    const { _rangeChanged, _itemsChanged } = this;
    if (this._visibilityChanged) {
      this._notifyVisibility();
      this._visibilityChanged = false;
    }
    if (_rangeChanged || _itemsChanged) {
      this._notifyRange();
      this._rangeChanged = false;
    }
    this._finishDOMUpdate();
  }
  _finishDOMUpdate() {
    this._children.forEach((child) => this._childrenRO.observe(child));
    this._checkScrollIntoViewTarget(this._childrenPos);
    this._positionChildren(this._childrenPos);
    this._sizeHostElement(this._scrollSize);
    this._correctScrollError();
    if (this._benchmarkStart && "mark" in window.performance) {
      window.performance.mark("uv-end");
    }
  }
  _updateLayout() {
    if (this._layout && this._scrollerController) {
      this._layout.items = this._items;
      this._updateView();
      if (this._childMeasurements !== null) {
        if (this._measureCallback) {
          this._measureCallback(this._childMeasurements);
        }
        this._childMeasurements = null;
      }
      this._layout.reflowIfNeeded();
      if (this._benchmarkStart && "mark" in window.performance) {
        window.performance.mark("uv-end");
      }
    }
  }
  _handleScrollEvent() {
    if (this._benchmarkStart && "mark" in window.performance) {
      try {
        window.performance.measure("uv-virtualizing", "uv-start", "uv-end");
      } catch (e36) {
        console.warn("Error measuring performance data: ", e36);
      }
      window.performance.mark("uv-start");
    }
    if (this._scrollerController.correctingScrollError === false) {
      this._layout?.unpin();
    }
    this._schedule(this._updateLayout);
  }
  handleEvent(event) {
    switch (event.type) {
      case "scroll":
        if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {
          this._handleScrollEvent();
        }
        break;
      default:
        console.warn("event not handled", event);
    }
  }
  _handleLayoutMessage(message) {
    if (message.type === "stateChanged") {
      this._updateDOM(message);
    } else if (message.type === "visibilityChanged") {
      this._firstVisible = message.firstVisible;
      this._lastVisible = message.lastVisible;
      this._notifyVisibility();
    } else if (message.type === "unpinned") {
      this._hostElement.dispatchEvent(new UnpinnedEvent());
    }
  }
  get _children() {
    const arr = [];
    let next = this._hostElement.firstElementChild;
    while (next) {
      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {
        arr.push(next);
      }
      next = next.nextElementSibling;
    }
    return arr;
  }
  _updateView() {
    const hostElement = this._hostElement;
    const scrollingElement = this._scrollerController?.element;
    const layout = this._layout;
    if (hostElement && scrollingElement && layout) {
      let top, left, bottom, right;
      const hostElementBounds = hostElement.getBoundingClientRect();
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      const ancestorBounds = this._clippingAncestors.map((ancestor) => ancestor.getBoundingClientRect());
      ancestorBounds.unshift(hostElementBounds);
      for (const bounds of ancestorBounds) {
        top = Math.max(top, bounds.top);
        left = Math.max(left, bounds.left);
        bottom = Math.min(bottom, bounds.bottom);
        right = Math.min(right, bounds.right);
      }
      const scrollingElementBounds = scrollingElement.getBoundingClientRect();
      const offsetWithinScroller = {
        left: hostElementBounds.left - scrollingElementBounds.left,
        top: hostElementBounds.top - scrollingElementBounds.top
      };
      const totalScrollSize = {
        width: scrollingElement.scrollWidth,
        height: scrollingElement.scrollHeight
      };
      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;
      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;
      const height = bottom - top;
      const width = right - left;
      layout.viewportSize = { width, height };
      layout.viewportScroll = { top: scrollTop, left: scrollLeft };
      layout.totalScrollSize = totalScrollSize;
      layout.offsetWithinScroller = offsetWithinScroller;
    }
  }
  /**
   * Styles the host element so that its size reflects the
   * total size of all items.
   */
  _sizeHostElement(size3) {
    const max2 = 82e5;
    const h16 = size3 && size3.width !== null ? Math.min(max2, size3.width) : 0;
    const v6 = size3 && size3.height !== null ? Math.min(max2, size3.height) : 0;
    if (this._isScroller) {
      this._getSizer().style.transform = `translate(${h16}px, ${v6}px)`;
    } else {
      const style = this._hostElement.style;
      style.minWidth = h16 ? `${h16}px` : "100%";
      style.minHeight = v6 ? `${v6}px` : "100%";
    }
  }
  /**
   * Sets the top and left transform style of the children from the values in
   * pos.
   */
  _positionChildren(pos) {
    if (pos) {
      pos.forEach(({ top, left, width, height, xOffset, yOffset }, index) => {
        const child = this._children[index - this._first];
        if (child) {
          child.style.position = "absolute";
          child.style.boxSizing = "border-box";
          child.style.transform = `translate(${left}px, ${top}px)`;
          if (width !== void 0) {
            child.style.width = width + "px";
          }
          if (height !== void 0) {
            child.style.height = height + "px";
          }
          child.style.left = xOffset === void 0 ? null : xOffset + "px";
          child.style.top = yOffset === void 0 ? null : yOffset + "px";
        }
      });
    }
  }
  async _adjustRange(range) {
    const { _first, _last, _firstVisible, _lastVisible } = this;
    this._first = range.first;
    this._last = range.last;
    this._firstVisible = range.firstVisible;
    this._lastVisible = range.lastVisible;
    this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;
    this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;
  }
  _correctScrollError() {
    if (this._scrollError) {
      const { scrollTop, scrollLeft } = this._scrollerController;
      const { top, left } = this._scrollError;
      this._scrollError = null;
      this._scrollerController.correctScrollError({
        top: scrollTop - top,
        left: scrollLeft - left
      });
    }
  }
  element(index) {
    if (index === Infinity) {
      index = this._items.length - 1;
    }
    return this._items?.[index] === void 0 ? void 0 : {
      scrollIntoView: (options = {}) => this._scrollElementIntoView({ ...options, index })
    };
  }
  _scrollElementIntoView(options) {
    if (options.index >= this._first && options.index <= this._last) {
      this._children[options.index - this._first].scrollIntoView(options);
    } else {
      options.index = Math.min(options.index, this._items.length - 1);
      if (options.behavior === "smooth") {
        const coordinates = this._layout.getScrollIntoViewCoordinates(options);
        const { behavior } = options;
        this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, { behavior }), () => this._layout.getScrollIntoViewCoordinates(options), () => this._scrollIntoViewTarget = null);
        this._scrollIntoViewTarget = options;
      } else {
        this._layout.pin = options;
      }
    }
  }
  /**
   * If we are smoothly scrolling to an element and the target element
   * is in the DOM, we update our target coordinates as needed
   */
  _checkScrollIntoViewTarget(pos) {
    const { index } = this._scrollIntoViewTarget || {};
    if (index && pos?.has(index)) {
      this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));
    }
  }
  /**
   * Emits a rangechange event with the current first, last, firstVisible, and
   * lastVisible.
   */
  _notifyRange() {
    this._hostElement.dispatchEvent(new RangeChangedEvent({ first: this._first, last: this._last }));
  }
  _notifyVisibility() {
    this._hostElement.dispatchEvent(new VisibilityChangedEvent({
      first: this._firstVisible,
      last: this._lastVisible
    }));
  }
  get layoutComplete() {
    if (!this._layoutCompletePromise) {
      this._layoutCompletePromise = new Promise((resolve, reject) => {
        this._layoutCompleteResolver = resolve;
        this._layoutCompleteRejecter = reject;
      });
    }
    return this._layoutCompletePromise;
  }
  _rejectLayoutCompletePromise(reason) {
    if (this._layoutCompleteRejecter !== null) {
      this._layoutCompleteRejecter(reason);
    }
    this._resetLayoutCompleteState();
  }
  _scheduleLayoutComplete() {
    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {
      this._pendingLayoutComplete = requestAnimationFrame(() => requestAnimationFrame(() => this._resolveLayoutCompletePromise()));
    }
  }
  _resolveLayoutCompletePromise() {
    if (this._layoutCompleteResolver !== null) {
      this._layoutCompleteResolver();
    }
    this._resetLayoutCompleteState();
  }
  _resetLayoutCompleteState() {
    this._layoutCompletePromise = null;
    this._layoutCompleteResolver = null;
    this._layoutCompleteRejecter = null;
    this._pendingLayoutComplete = null;
  }
  /**
   * Render and update the view at the next opportunity with the given
   * hostElement size.
   */
  _hostElementSizeChanged() {
    this._schedule(this._updateLayout);
  }
  // TODO (graynorton): Rethink how this works. Probably child loading is too specific
  // to have dedicated support for; might want some more generic lifecycle hooks for
  // layouts to use. Possibly handle measurement this way, too, or maybe that remains
  // a first-class feature?
  _childLoaded() {
  }
  // This is the callback for the ResizeObserver that watches the
  // virtualizer's children. We land here at the end of every virtualizer
  // update cycle that results in changes to physical items, and we also
  // end up here if one or more children change size independently of
  // the virtualizer update cycle.
  _childrenSizeChanged(changes) {
    if (this._layout?.measureChildren) {
      for (const change of changes) {
        this._toBeMeasured.set(change.target, change.contentRect);
      }
      this._measureChildren();
    }
    this._scheduleLayoutComplete();
    this._itemsChanged = false;
    this._rangeChanged = false;
  }
};
function getMargins(el) {
  const style = window.getComputedStyle(el);
  return {
    marginTop: getMarginValue(style.marginTop),
    marginRight: getMarginValue(style.marginRight),
    marginBottom: getMarginValue(style.marginBottom),
    marginLeft: getMarginValue(style.marginLeft)
  };
}
function getMarginValue(value) {
  const float = value ? parseFloat(value) : NaN;
  return Number.isNaN(float) ? 0 : float;
}
function getParentElement(el) {
  if (el.assignedSlot !== null) {
    return el.assignedSlot;
  }
  if (el.parentElement !== null) {
    return el.parentElement;
  }
  const parentNode2 = el.parentNode;
  if (parentNode2 && parentNode2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    return parentNode2.host || null;
  }
  return null;
}
function getElementAncestors(el, includeSelf = false) {
  const ancestors = [];
  let parent = includeSelf ? el : getParentElement(el);
  while (parent !== null) {
    ancestors.push(parent);
    parent = getParentElement(parent);
  }
  return ancestors;
}
function getClippingAncestors(el, includeSelf = false) {
  let foundFixed = false;
  return getElementAncestors(el, includeSelf).filter((a23) => {
    if (foundFixed) {
      return false;
    }
    const style = getComputedStyle(a23);
    foundFixed = style.position === "fixed";
    return style.overflow !== "visible";
  });
}

// node_modules/@lit-labs/virtualizer/virtualize.js
var defaultKeyFunction = (item) => item;
var defaultRenderItem = (item, idx) => x`${idx}: ${JSON.stringify(item, null, 2)}`;
var VirtualizeDirective = class extends f4 {
  constructor(part) {
    super(part);
    this._virtualizer = null;
    this._first = 0;
    this._last = -1;
    this._renderItem = (item, idx) => defaultRenderItem(item, idx + this._first);
    this._keyFunction = (item, idx) => defaultKeyFunction(item, idx + this._first);
    this._items = [];
    if (part.type !== t4.CHILD) {
      throw new Error("The virtualize directive can only be used in child expressions");
    }
  }
  render(config) {
    if (config) {
      this._setFunctions(config);
    }
    const itemsToRender = [];
    if (this._first >= 0 && this._last >= this._first) {
      for (let i21 = this._first; i21 <= this._last; i21++) {
        itemsToRender.push(this._items[i21]);
      }
    }
    return c5(itemsToRender, this._keyFunction, this._renderItem);
  }
  update(part, [config]) {
    this._setFunctions(config);
    const itemsChanged = this._items !== config.items;
    this._items = config.items || [];
    if (this._virtualizer) {
      this._updateVirtualizerConfig(part, config);
    } else {
      this._initialize(part, config);
    }
    return itemsChanged ? T : this.render();
  }
  async _updateVirtualizerConfig(part, config) {
    const compatible = await this._virtualizer.updateLayoutConfig(config.layout || {});
    if (!compatible) {
      const hostElement = part.parentNode;
      this._makeVirtualizer(hostElement, config);
    }
    this._virtualizer.items = this._items;
  }
  _setFunctions(config) {
    const { renderItem, keyFunction } = config;
    if (renderItem) {
      this._renderItem = (item, idx) => renderItem(item, idx + this._first);
    }
    if (keyFunction) {
      this._keyFunction = (item, idx) => keyFunction(item, idx + this._first);
    }
  }
  _makeVirtualizer(hostElement, config) {
    if (this._virtualizer) {
      this._virtualizer.disconnected();
    }
    const { layout, scroller, items } = config;
    this._virtualizer = new Virtualizer({ hostElement, layout, scroller });
    this._virtualizer.items = items;
    this._virtualizer.connected();
  }
  _initialize(part, config) {
    const hostElement = part.parentNode;
    if (hostElement && hostElement.nodeType === 1) {
      hostElement.addEventListener("rangeChanged", (e36) => {
        this._first = e36.first;
        this._last = e36.last;
        this.setValue(this.render());
      });
      this._makeVirtualizer(hostElement, config);
    }
  }
  disconnected() {
    this._virtualizer?.disconnected();
  }
  reconnected() {
    this._virtualizer?.connected();
  }
};
var virtualize = e9(VirtualizeDirective);

// node_modules/@spectrum-web-components/table/src/Table.js
var b9 = Object.defineProperty;
var u32 = Object.getOwnPropertyDescriptor;
var a21 = (n25, h16, e36, t34) => {
  for (var s19 = t34 > 1 ? void 0 : t34 ? u32(h16, e36) : h16, i21 = n25.length - 1, l16; i21 >= 0; i21--) (l16 = n25[i21]) && (s19 = (t34 ? l16(h16, e36, s19) : l16(s19)) || s19);
  return t34 && s19 && b9(h16, e36, s19), s19;
};
var RowType = ((e36) => (e36[e36.ITEM = 0] = "ITEM", e36[e36.INFORMATION = 1] = "INFORMATION", e36))(RowType || {});
var Table = class extends SizedMixin(SpectrumElement, { validSizes: ["s", "m", "l", "xl"], noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this._renderItem = () => x``;
    this.role = "grid";
    this.selected = [];
    this.selectedSet = /* @__PURE__ */ new Set();
    this.items = [];
    this.itemValue = (e36, t34) => `${t34}`;
    this.scroller = false;
    this.emphasized = false;
    this.quiet = false;
  }
  static get styles() {
    return [table_css_default];
  }
  get renderItem() {
    return this._renderItem;
  }
  set renderItem(e36) {
    this._renderItem = (t34, s19) => {
      const i21 = this.itemValue(t34, s19), l16 = this.selected.includes(i21), r25 = this.selects && (t34 == null ? void 0 : t34._$rowType$) !== 1;
      return x`
                <sp-table-row
                    value=${i21}
                    aria-rowindex=${s19 + 1}
                    ?selected=${l16}
                >
                    ${r25 ? x`
                              <sp-table-checkbox-cell
                                  ?checked=${l16}
                              ></sp-table-checkbox-cell>
                          ` : E}
                    ${e36(t34, s19)}
                </sp-table-row>
            `;
    };
  }
  get tableHead() {
    return this.querySelector("sp-table-head");
  }
  get tableRows() {
    return this.isVirtualized ? [] : [...this.querySelectorAll("sp-table-row")];
  }
  get isVirtualized() {
    return !!this.items.length;
  }
  focus() {
    const e36 = this.querySelector("sp-table-head-cell[sortable]");
    e36 && e36.focus();
  }
  selectAllRows() {
    this.isVirtualized ? this.items.forEach((e36, t34) => {
      e36._$rowType$ !== 1 && this.selectedSet.add(this.itemValue(e36, t34));
    }) : this.tableRows.forEach((e36) => {
      e36.selected = true, this.selectedSet.add(e36.value);
    }), this.selected = [...this.selectedSet], this.tableHeadCheckboxCell && (this.tableHeadCheckboxCell.checked = true, this.tableHeadCheckboxCell.indeterminate = false);
  }
  deselectAllRows() {
    this.selectedSet.clear(), this.selected = [], this.isVirtualized || [...this.querySelectorAll("[selected]")].forEach((t34) => {
      t34.selected = false;
    }), this.tableHeadCheckboxCell && (this.tableHeadCheckboxCell.checked = false, this.tableHeadCheckboxCell.indeterminate = false);
  }
  manageSelects() {
    var s19;
    const e36 = this.querySelectorAll("sp-table-checkbox-cell"), t34 = document.createElement("sp-table-checkbox-cell");
    if (this.selects) {
      let i21 = false;
      this.isVirtualized ? i21 = this.selected.length > 0 && this.selected.length === this.items.length : (this.tableRows.forEach((l16) => {
        if (l16.selected = this.selectedSet.has(l16.value), !l16.querySelector(":scope > sp-table-checkbox-cell")) {
          const r25 = t34.cloneNode();
          t34.emphasized = this.emphasized, l16.insertAdjacentElement("afterbegin", r25), t34.checked = l16.selected;
        }
      }), i21 = this.selected.length === this.tableRows.length), this.tableHeadCheckboxCell || (this.tableHeadCheckboxCell = document.createElement("sp-table-checkbox-cell"), this.tableHeadCheckboxCell.headCell = true, this.tableHeadCheckboxCell.emphasized = this.emphasized, (s19 = this.tableHead) == null || s19.insertAdjacentElement("afterbegin", this.tableHeadCheckboxCell)), this.manageHeadCheckbox(i21);
    } else e36.forEach((i21) => {
      i21.remove();
    }), delete this.tableHeadCheckboxCell;
  }
  validateSelected() {
    const e36 = /* @__PURE__ */ new Set();
    this.isVirtualized ? this.items.forEach((s19, i21) => {
      const l16 = this.itemValue(s19, i21);
      e36.add(l16);
    }) : this.tableRows.forEach((s19) => {
      e36.add(s19.value);
    });
    const t34 = this.selected.length;
    this.selected = this.selected.filter((s19) => e36.has(s19)), t34 !== this.selected.length && this.dispatchEvent(new Event("change", { cancelable: true, bubbles: true, composed: true })), this.selectedSet = new Set(this.selected);
  }
  manageSelected() {
    this.validateSelected(), !this.isVirtualized && (this.tableRows.forEach((e36) => {
      e36.selected = this.selectedSet.has(e36.value);
    }), this.tableHeadCheckboxCell && (this.tableHeadCheckboxCell.checked = this.selected.length === this.tableRows.length));
  }
  manageCheckboxes() {
    var e36, t34, s19;
    if (this.selects) {
      this.tableHeadCheckboxCell = document.createElement("sp-table-checkbox-cell"), this.tableHeadCheckboxCell.headCell = true, this.tableHeadCheckboxCell.emphasized = this.emphasized;
      const i21 = this.selected.length === this.tableRows.length;
      this.manageHeadCheckbox(i21), (e36 = this.tableHead) == null || e36.insertAdjacentElement("afterbegin", this.tableHeadCheckboxCell), this.tableRows.forEach((l16) => {
        const r25 = document.createElement("sp-table-checkbox-cell");
        r25.emphasized = this.emphasized, l16.insertAdjacentElement("afterbegin", r25), l16.selected = this.selectedSet.has(l16.value), r25.checked = l16.selected;
      });
    } else (s19 = (t34 = this.tableHead) == null ? void 0 : t34.querySelector("sp-table-checkbox-cell")) == null || s19.remove(), this.tableRows.forEach((i21) => {
      var l16;
      (l16 = i21.checkboxCells[0]) == null || l16.remove(), this.selected.length && (i21.selected = this.selectedSet.has(i21.value));
    });
  }
  manageHeadCheckbox(e36) {
    this.tableHeadCheckboxCell && (this.tableHeadCheckboxCell.selectsSingle = this.selects === "single", this.tableHeadCheckboxCell.emphasized = this.emphasized, this.tableHeadCheckboxCell.checked = e36, this.tableHeadCheckboxCell.indeterminate = this.selected.length > 0 && !e36);
  }
  handleChange(e36) {
    e36.stopPropagation();
    const t34 = new Set(this.selectedSet), s19 = [...this.selected], { target: i21 } = e36, { parentElement: l16 } = i21;
    if (l16.value) switch (this.selects) {
      case "single": {
        this.deselectAllRows(), l16.selected && (this.selectedSet.add(l16.value), this.selected = [...this.selectedSet]);
        break;
      }
      case "multiple": {
        l16.selected ? this.selectedSet.add(l16.value) : this.selectedSet.delete(l16.value), this.selected = [...this.selectedSet];
        const d22 = this.selected.length === this.tableRows.length;
        if (!this.tableHeadCheckboxCell) return;
        this.tableHeadCheckboxCell.checked = d22, this.tableHeadCheckboxCell.indeterminate = this.selected.length > 0 && !d22;
        break;
      }
      default:
        break;
    }
    else {
      const { checkbox: d22 } = i21;
      if (!d22) return;
      d22.checked || d22.indeterminate ? this.selectAllRows() : this.deselectAllRows();
    }
    this.dispatchEvent(new Event("change", { cancelable: true, bubbles: true, composed: true })) || (e36.preventDefault(), this.selectedSet = t34, this.selected = s19);
  }
  scrollToIndex(e36) {
    if (e36 && this.tableBody) {
      const s19 = this.tableBody[virtualizerRef].element(e36);
      s19 && s19.scrollIntoView();
    }
  }
  render() {
    return x`
            <slot @change=${this.handleChange}></slot>
        `;
  }
  willUpdate(e36) {
    this.hasUpdated || (this.validateSelected(), this.manageCheckboxes()), e36.has("selects") && this.manageSelects(), e36.has("selected") && this.hasUpdated && this.manageSelected();
  }
  updated() {
    this.items.length ? this.renderVirtualizedItems() : this.removeAttribute("aria-rowcount");
  }
  renderVirtualizedItems() {
    if (!this.isConnected) return;
    this.tableBody || (this.tableBody = this.querySelector("sp-table-body"), this.tableBody || (this.tableBody = document.createElement("sp-table-body"), this.append(this.tableBody)), this.tableBody.addEventListener("rangeChanged", (t34) => {
      this.dispatchEvent(new RangeChangedEvent({ first: t34.first, last: t34.last }));
    }), this.tableBody.addEventListener("visibilityChanged", (t34) => {
      this.dispatchEvent(new VisibilityChangedEvent({ first: t34.first, last: t34.last }));
    })), this.setAttribute("aria-rowcount", `${this.items.length}`);
    const e36 = { items: this.items, renderItem: this.renderItem, scroller: this.scroller };
    B(x`
                ${virtualize(e36)}
            `, this.tableBody);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
};
a21([n4({ reflect: true })], Table.prototype, "role", 2), a21([n4({ type: String, reflect: true })], Table.prototype, "selects", 2), a21([n4({ type: Array })], Table.prototype, "selected", 2), a21([n4({ type: Array })], Table.prototype, "items", 2), a21([n4({ type: Object })], Table.prototype, "itemValue", 2), a21([n4({ type: Boolean, reflect: true })], Table.prototype, "scroller", 2), a21([n4({ type: Boolean, reflect: true })], Table.prototype, "emphasized", 2), a21([n4({ type: Boolean, reflect: true })], Table.prototype, "quiet", 2), a21([n4({ type: String, reflect: true })], Table.prototype, "density", 2);

// node_modules/@spectrum-web-components/table/sp-table.js
init_define_element();
defineElement("sp-table", Table);

// node_modules/@spectrum-web-components/table/src/TableCell.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/table/src/table-cell.css.js
init_src();
var e32 = i`
    @media (forced-colors:active){:host{forced-color-adjust:none}}:host([align=center]){text-align:center}:host([align=end]){text-align:end}:host{border-block-start:var(--mod-table-border-width,var(--spectrum-table-border-width))solid var(--highcontrast-table-divider-color,var(--mod-table-divider-color,var(--spectrum-table-divider-color)));box-sizing:border-box;font-size:var(--mod-table-row-font-size,var(--spectrum-table-row-font-size));font-weight:var(--mod-table-row-font-weight,var(--spectrum-table-row-font-weight));line-height:var(--mod-table-row-line-height,var(--spectrum-table-row-line-height));vertical-align:var(--mod-table-default-vertical-align,var(--spectrum-table-default-vertical-align));color:var(--highcontrast-table-row-text-color,var(--mod-table-row-text-color,var(--spectrum-table-row-text-color)));background-color:var(--spectrum-table-cell-background-color);block-size:var(--mod-table-min-row-height,var(--spectrum-table-min-row-height));padding-block-start:calc(var(--mod-table-row-top-to-text,var(--spectrum-table-row-top-to-text)) - var(--mod-table-border-width,var(--spectrum-table-border-width)));padding-block-end:var(--mod-table-row-bottom-to-text,var(--spectrum-table-row-bottom-to-text));padding-inline:calc(var(--mod-table-edge-to-content,var(--spectrum-table-edge-to-content)) - var(--mod-table-outer-border-inline-width,var(--spectrum-table-outer-border-inline-width)));display:table-cell;position:relative}:host([focused]),:host(:focus-visible){outline-width:var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness));outline-style:solid;outline-color:var(--highcontrast-table-cell-focus-indicator-color,var(--highcontrast-table-focus-indicator-color,var(--mod-table-focus-indicator-color,var(--spectrum-table-focus-indicator-color))));outline-offset:calc(var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness))*-1);outline-offset:calc(var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness))*-1 - var(--highcontrast-table-cell-focus-extra-offset,0px))}.divider{border-inline-end:var(--mod-table-border-width,var(--spectrum-table-border-width))solid var(--highcontrast-table-divider-color,var(--mod-table-divider-color,var(--spectrum-table-divider-color)))}.spectrum-Table-cell--collapsible{padding-block:0;padding-inline-start:calc(var(--spectrum-table-row-tier,0px)*var(--spectrum-table-collapsible-tier-indent))}:host{flex:1;block-size:auto;display:block}
`;
var table_cell_css_default = e32;

// node_modules/@spectrum-web-components/table/src/TableCell.js
var i18 = Object.defineProperty;
var u33 = Object.getOwnPropertyDescriptor;
var m17 = (l16, r25, o52, t34) => {
  for (var e36 = t34 > 1 ? void 0 : t34 ? u33(r25, o52) : r25, s19 = l16.length - 1, p30; s19 >= 0; s19--) (p30 = l16[s19]) && (e36 = (t34 ? p30(r25, o52, e36) : p30(e36)) || e36);
  return t34 && e36 && i18(r25, o52, e36), e36;
};
var TableCell = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.role = "gridcell";
  }
  static get styles() {
    return [table_cell_css_default];
  }
  render() {
    return x`
            <slot></slot>
        `;
  }
};
m17([n4({ reflect: true })], TableCell.prototype, "role", 2);

// node_modules/@spectrum-web-components/table/sp-table-cell.js
init_define_element();
defineElement("sp-table-cell", TableCell);

// node_modules/@spectrum-web-components/table/src/TableHead.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/table/src/table-head.css.js
init_src();
var t31 = i`
    :host .spectrum-Table-scroller{z-index:1;position:sticky;inset-block-start:0}:host{display:flex}
`;
var table_head_css_default = t31;

// node_modules/@spectrum-web-components/table/src/TableHead.js
var c32 = Object.defineProperty;
var n22 = Object.getOwnPropertyDescriptor;
var d19 = (o52, r25, t34, l16) => {
  for (var e36 = l16 > 1 ? void 0 : l16 ? n22(r25, t34) : r25, i21 = o52.length - 1, a23; i21 >= 0; i21--) (a23 = o52[i21]) && (e36 = (l16 ? a23(r25, t34, e36) : a23(e36)) || e36);
  return l16 && e36 && c32(r25, t34, e36), e36;
};
var TableHead = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.role = "row";
  }
  static get styles() {
    return [table_head_css_default];
  }
  handleSorted({ target: t34 }) {
    [...this.children].forEach((e36) => {
      e36 !== t34 && (e36.sortDirection = void 0);
    });
  }
  handleChange({ target: t34 }) {
    this.selected = t34.checkbox.checked || t34.checkbox.indeterminate;
  }
  render() {
    return x`
            <slot
                @sorted=${this.handleSorted}
                @change=${this.handleChange}
            ></slot>
        `;
  }
};
d19([n4({ reflect: true })], TableHead.prototype, "role", 2), d19([n4({ type: Boolean, reflect: true })], TableHead.prototype, "selected", 2);

// node_modules/@spectrum-web-components/table/sp-table-head.js
init_define_element();
defineElement("sp-table-head", TableHead);

// node_modules/@spectrum-web-components/table/src/TableHeadCell.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconArrow100.js
init_src();

// node_modules/@spectrum-web-components/icons-ui/src/icons-s2/Arrow100.js
var Arrow100Icon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Arrow100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="M9.7 4.387 6.623 1.262a.875.875 0 1 0-1.247 1.226l1.61 1.637H.925a.875.875 0 0 0 0 1.75h6.062l-1.61 1.637a.875.875 0 1 0 1.247 1.226l3.075-3.125a.874.874 0 0 0 0-1.226z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/icons/Arrow100.js
var Arrow100Icon2 = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Arrow100" } = {}) => tag2`<svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 10 10"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
    width="${t34}"
    height="${e36}"
  >
    <path
      d="M9.7 4.387 6.623 1.262a.875.875 0 1 0-1.247 1.226l1.61 1.637H.925a.875.875 0 0 0 0 1.75h6.062l-1.61 1.637a.875.875 0 1 0 1.247 1.226l3.075-3.125a.874.874 0 0 0 0-1.226z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-ui/src/elements/IconArrow100.js
var IconArrow100 = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag2(x), this.spectrumVersion === 2 ? Arrow100Icon({ hidden: !this.label, title: this.label }) : Arrow100Icon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-ui/icons/sp-icon-arrow100.js
init_define_element();
defineElement("sp-icon-arrow100", IconArrow100);

// node_modules/@spectrum-web-components/table/src/table-head-cell.css.js
init_src();
var t32 = i`
    .sortedIcon{vertical-align:initial;transition:transform var(--highcontrast-table-transition-duration,var(--mod-table-transition-duration,var(--spectrum-table-transition-duration)))ease-in-out;margin-inline-start:var(--mod-table-sort-icon-inline-start-spacing,0);margin-inline-end:var(--mod-table-sort-icon-inline-end-spacing,var(--mod-table-icon-to-text,var(--spectrum-table-icon-to-text)));display:none}:host{--spectrum-table-icon-color:var(--highcontrast-table-icon-color,var(--mod-table-icon-color-default,var(--spectrum-table-icon-color-default)));box-sizing:border-box;text-align:start;vertical-align:var(--mod-table-header-vertical-align,var(--spectrum-table-header-vertical-align));font-family:var(--mod-table-header-font-family,var(--spectrum-table-row-font-family));font-size:var(--mod-table-header-font-size,var(--spectrum-table-row-font-size));font-weight:var(--mod-table-header-font-weight,var(--spectrum-table-header-font-weight));line-height:var(--mod-table-header-line-height,var(--spectrum-table-row-line-height));text-transform:none;text-transform:var(--mod-table-header-text-transform,none);block-size:var(--mod-table-min-header-height,var(--spectrum-table-min-header-height));padding-block:var(--mod-table-header-top-to-text,var(--spectrum-table-header-top-to-text))var(--mod-table-header-bottom-to-text,var(--spectrum-table-header-bottom-to-text));padding-inline:var(--mod-table-cell-inline-space,var(--spectrum-table-cell-inline-space));color:var(--mod-table-header-text-color,var(--spectrum-table-header-text-color));background-color:var(--mod-table-header-background-color,var(--spectrum-table-header-background-color));transition:color var(--highcontrast-table-transition-duration,var(--mod-table-transition-duration,var(--spectrum-table-transition-duration)))ease-in-out;cursor:auto;cursor:var(--mod-table-cursor-header-default,initial);border-radius:0;outline:0}.spectrum-Table-menuIcon,.sortedIcon{color:var(--spectrum-table-icon-color)}:host([sortable]){cursor:pointer;cursor:var(--mod-table-cursor-header-sortable,pointer)}:host([sortable][active]){--spectrum-table-icon-color:var(--highcontrast-table-icon-color-focus,var(--mod-table-icon-color-active,var(--spectrum-table-icon-color-active)))}:host([sortable]:focus){--spectrum-table-icon-color:var(--highcontrast-table-icon-color-focus,var(--mod-table-icon-color-focus,var(--spectrum-table-icon-color-focus)))}:host([sortable]) .is-keyboardFocused,:host([sortable]:focus-visible){--spectrum-table-icon-color:var(--highcontrast-table-icon-color-focus,var(--mod-table-icon-color-key-focus,var(--spectrum-table-icon-color-key-focus)))}:host([sort-direction=asc]) .sortedIcon,:host([sort-direction=desc]) .sortedIcon{display:inline-block}:host([sort-direction=asc]) .sortedIcon{transform:rotate(-90deg)}:host{display:table-cell;position:relative}:host([focused]),:host(:focus-visible){outline-width:var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness));outline-style:solid;outline-color:var(--highcontrast-table-cell-focus-indicator-color,var(--highcontrast-table-focus-indicator-color,var(--mod-table-focus-indicator-color,var(--spectrum-table-focus-indicator-color))));outline-offset:calc(var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness))*-1);outline-offset:calc(var(--mod-table-focus-indicator-thickness,var(--spectrum-table-focus-indicator-thickness))*-1 - var(--highcontrast-table-cell-focus-extra-offset,0px))}:host .spectrum-Table-checkboxCell .spectrum-Table-checkbox{margin-block-start:calc(var(--mod-table-header-checkbox-block-spacing,var(--spectrum-table-header-checkbox-block-spacing)) - var(--mod-table-border-width,var(--spectrum-table-border-width)));margin-block-end:var(--mod-table-header-checkbox-block-spacing,var(--spectrum-table-header-checkbox-block-spacing))}:host .spectrum-Table-scroller{border-block-end:var(--mod-table-border-width,var(--spectrum-table-border-width))solid var(--highcontrast-table-border-color,var(--mod-table-border-color,var(--spectrum-table-border-color)))}@media (hover:hover){:host([sortable]:hover){--spectrum-table-icon-color:var(--highcontrast-table-icon-color-focus,var(--mod-table-icon-color-hover,var(--spectrum-table-icon-color-hover)))}:host([sortable]:focus):hover{--spectrum-table-icon-color:var(--highcontrast-table-icon-color-focus,var(--mod-table-icon-color-focus-hover,var(--spectrum-table-icon-color-focus-hover)))}}:host{flex:1;block-size:auto;display:block}
`;
var table_head_cell_css_default = t32;

// node_modules/@spectrum-web-components/icon/src/spectrum-icon-arrow.css.js
init_src();
var o48 = i`
    .spectrum-UIIcon-ArrowRight75{--spectrum-icon-size:var(--spectrum-arrow-icon-size-75)}.spectrum-UIIcon-ArrowRight100{--spectrum-icon-size:var(--spectrum-arrow-icon-size-100)}.spectrum-UIIcon-ArrowRight200{--spectrum-icon-size:var(--spectrum-arrow-icon-size-200)}.spectrum-UIIcon-ArrowRight300{--spectrum-icon-size:var(--spectrum-arrow-icon-size-300)}.spectrum-UIIcon-ArrowRight400{--spectrum-icon-size:var(--spectrum-arrow-icon-size-400)}.spectrum-UIIcon-ArrowRight500{--spectrum-icon-size:var(--spectrum-arrow-icon-size-500)}.spectrum-UIIcon-ArrowRight600{--spectrum-icon-size:var(--spectrum-arrow-icon-size-600)}.spectrum-UIIcon-ArrowDown75{--spectrum-icon-size:var(--spectrum-arrow-icon-size-75);transform:rotate(90deg)}.spectrum-UIIcon-ArrowDown100{--spectrum-icon-size:var(--spectrum-arrow-icon-size-100);transform:rotate(90deg)}.spectrum-UIIcon-ArrowDown200{--spectrum-icon-size:var(--spectrum-arrow-icon-size-200);transform:rotate(90deg)}.spectrum-UIIcon-ArrowDown300{--spectrum-icon-size:var(--spectrum-arrow-icon-size-300);transform:rotate(90deg)}.spectrum-UIIcon-ArrowDown400{--spectrum-icon-size:var(--spectrum-arrow-icon-size-400);transform:rotate(90deg)}.spectrum-UIIcon-ArrowDown500{--spectrum-icon-size:var(--spectrum-arrow-icon-size-500);transform:rotate(90deg)}.spectrum-UIIcon-ArrowDown600{--spectrum-icon-size:var(--spectrum-arrow-icon-size-600);transform:rotate(90deg)}.spectrum-UIIcon-ArrowLeft75{--spectrum-icon-size:var(--spectrum-arrow-icon-size-75);transform:rotate(180deg)}.spectrum-UIIcon-ArrowLeft100{--spectrum-icon-size:var(--spectrum-arrow-icon-size-100);transform:rotate(180deg)}.spectrum-UIIcon-ArrowLeft200{--spectrum-icon-size:var(--spectrum-arrow-icon-size-200);transform:rotate(180deg)}.spectrum-UIIcon-ArrowLeft300{--spectrum-icon-size:var(--spectrum-arrow-icon-size-300);transform:rotate(180deg)}.spectrum-UIIcon-ArrowLeft400{--spectrum-icon-size:var(--spectrum-arrow-icon-size-400);transform:rotate(180deg)}.spectrum-UIIcon-ArrowLeft500{--spectrum-icon-size:var(--spectrum-arrow-icon-size-500);transform:rotate(180deg)}.spectrum-UIIcon-ArrowLeft600{--spectrum-icon-size:var(--spectrum-arrow-icon-size-600);transform:rotate(180deg)}.spectrum-UIIcon-ArrowUp75{--spectrum-icon-size:var(--spectrum-arrow-icon-size-75);transform:rotate(270deg)}.spectrum-UIIcon-ArrowUp100{--spectrum-icon-size:var(--spectrum-arrow-icon-size-100);transform:rotate(270deg)}.spectrum-UIIcon-ArrowUp200{--spectrum-icon-size:var(--spectrum-arrow-icon-size-200);transform:rotate(270deg)}.spectrum-UIIcon-ArrowUp300{--spectrum-icon-size:var(--spectrum-arrow-icon-size-300);transform:rotate(270deg)}.spectrum-UIIcon-ArrowUp400{--spectrum-icon-size:var(--spectrum-arrow-icon-size-400);transform:rotate(270deg)}.spectrum-UIIcon-ArrowUp500{--spectrum-icon-size:var(--spectrum-arrow-icon-size-500);transform:rotate(270deg)}.spectrum-UIIcon-ArrowUp600{--spectrum-icon-size:var(--spectrum-arrow-icon-size-600);transform:rotate(270deg)}
`;
var spectrum_icon_arrow_css_default = o48;

// node_modules/@spectrum-web-components/table/src/TableHeadCell.js
var l14 = Object.defineProperty;
var p26 = Object.getOwnPropertyDescriptor;
var i19 = (o52, s19, e36, t34) => {
  for (var r25 = t34 > 1 ? void 0 : t34 ? p26(s19, e36) : s19, a23 = o52.length - 1, n25; a23 >= 0; a23--) (n25 = o52[a23]) && (r25 = (t34 ? n25(s19, e36, r25) : n25(r25)) || r25);
  return t34 && r25 && l14(s19, e36, r25), r25;
};
var b10 = (o52) => ({ asc: "ascending", desc: "descending" })[o52] || "none";
var TableHeadCell = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.role = "columnheader";
    this.sortable = false;
    this.sortKey = "";
  }
  static get styles() {
    return [table_head_cell_css_default, spectrum_icon_arrow_css_default];
  }
  handleKeydown(e36) {
    const { code: t34 } = e36;
    switch (t34) {
      case "Space":
        e36.preventDefault(), this.addEventListener("keyup", this.handleKeyup), this.active = true;
        break;
      default:
        break;
    }
  }
  handleKeypress(e36) {
    const { code: t34 } = e36;
    switch (t34) {
      case "Enter":
      case "NumpadEnter":
        this.click();
        break;
      default:
        break;
    }
  }
  handleKeyup(e36) {
    const { code: t34 } = e36;
    switch (t34) {
      case "Space":
        this.active = false, this.removeEventListener("keyup", this.handleKeyup), this.click();
        break;
      default:
        break;
    }
  }
  handleClick() {
    this.sortable && (this.sortDirection ? this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc" : this.sortDirection = "asc", this.dispatchEvent(new CustomEvent("sorted", { bubbles: true, detail: { sortDirection: this.sortDirection, sortKey: this.sortKey } })));
  }
  render() {
    const e36 = this.sortable && !!this.sortDirection;
    return x`
            ${e36 ? x`
                      <sp-icon-arrow100
                          class="sortedIcon spectrum-UIIcon-ArrowDown100"
                      ></sp-icon-arrow100>
                  ` : E}
            <slot></slot>
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.addEventListener("click", this.handleClick), this.addEventListener("keydown", this.handleKeydown), this.addEventListener("keypress", this.handleKeypress);
  }
  update(e36) {
    e36.has("sortDirection") && this.setAttribute("aria-sort", b10(this.sortDirection)), e36.has("sortable") && (this.tabIndex = this.sortable ? 0 : -1), super.update(e36);
  }
};
i19([n4({ type: Boolean, reflect: true })], TableHeadCell.prototype, "active", 2), i19([n4({ reflect: true })], TableHeadCell.prototype, "role", 2), i19([n4({ type: Boolean, reflect: true })], TableHeadCell.prototype, "sortable", 2), i19([n4({ reflect: true, attribute: "sort-direction" })], TableHeadCell.prototype, "sortDirection", 2), i19([n4({ attribute: "sort-key" })], TableHeadCell.prototype, "sortKey", 2);

// node_modules/@spectrum-web-components/table/sp-table-head-cell.js
init_define_element();
defineElement("sp-table-head-cell", TableHeadCell);

// src/features/home-gallery/ee-share-manager.js
var ROLE_PRESETS = {
  view: ["read"],
  comment: ["read", "comment"],
  edit: ["read", "comment", "edit"],
  publish: ["read", "comment", "edit", "publish", "unpublish"]
};
var ADDED_DATE_FORMATTER = new Intl.DateTimeFormat(void 0, {
  dateStyle: "medium",
  timeStyle: "short"
});
var EEShareManager = class extends i4 {
  static styles = i`
    :host {
      display: contents;
    }

    .share-content {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-200);
      width: 1000px;
      max-height: 900px;
    }

    .undo-banner {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--spectrum-global-dimension-size-200);
      padding: var(--spectrum-global-dimension-size-150)
        var(--spectrum-global-dimension-size-200);
      background: var(--spectrum-global-color-green-50);
      color: var(--spectrum-global-color-green-900);
      border-radius: var(--spectrum-alias-border-radius-regular, 6px);
    }

    .share-panel {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-150);
      padding: var(--spectrum-global-dimension-size-200);
      border: 1px solid var(--spectrum-global-color-gray-300);
      border-radius: var(--spectrum-alias-border-radius-regular, 6px);
      background: var(--spectrum-global-color-gray-50);
    }

    .share-form {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: var(--spectrum-global-dimension-size-150);
      align-items: start;
    }

    .share-form-field {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-150);
    }

    .share-form-field--identifier {
      min-width: 0;
    }

    .share-form-actions {
      display: flex;
      justify-content: flex-end;
      grid-column: 1 / -1;
    }

    .suggestion-container {
      position: relative;
    }

    .suggestion-popover {
      position: absolute;
      top: calc(100% + var(--spectrum-global-dimension-size-75));
      left: 0;
      width: 100%;
      z-index: 10;
      padding: 0;
    }

    .share-add-spinner {
      position: absolute;
      top: 50%;
      right: var(--spectrum-global-dimension-size-150);
      transform: translateY(-50%);
      pointer-events: none;
    }

    .suggestion-menu {
      max-height: 220px;
      overflow: auto;
    }

    .suggestion-item {
      display: flex;
      align-items: center;
      gap: var(--spectrum-global-dimension-size-150);
    }

    .suggestion-text {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-50);
      min-width: 0;
    }

    .suggestion-secondary {
      font-size: 12px;
      color: var(--spectrum-global-color-gray-600);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .extra-help {
      font-size: 12px;
      color: var(--spectrum-global-color-gray-700);
    }

    .share-list {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-150);
      min-height: 0;
      flex: 1 1 auto;
      overflow: hidden;
    }

    .share-list-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--spectrum-global-dimension-size-200);
      justify-content: space-between;
    }

    .share-filters {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--spectrum-global-dimension-size-150);
    }

    .share-list-content {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-150);
      min-height: 0;
      flex: 1 1 auto;
      overflow-y: auto;
      padding-right: var(--spectrum-global-dimension-size-150);
    }

    .inherited-summary {
      display: flex;
      align-items: center;
      gap: var(--spectrum-global-dimension-size-100);
      font-size: 12px;
      color: var(--spectrum-global-color-gray-600);
    }

    .inherited-summary sp-icon-info-circle {
      color: var(--spectrum-global-color-gray-600);
    }

    .share-rows {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-150);
    }

    .share-table-container {
      overflow-x: auto;
    }

    .share-table-container sp-table {
      width: 100%;
    }

    sp-table-head-cell {
      font-size: 12px;
      font-weight: 600;
      color: var(--spectrum-global-color-gray-700);
    }

    sp-table-row:hover {
      background: var(--spectrum-global-color-gray-75);
    }

    sp-table-cell {
      padding: var(--spectrum-global-dimension-size-150);
      vertical-align: top;
    }

    .share-table-cell-primary {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-50);
    }

    .share-table-primary {
      font-weight: 600;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .share-table-secondary {
      font-size: 12px;
      color: var(--spectrum-global-color-gray-600);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .org-summary {
      display: flex;
      align-items: center;
      gap: var(--spectrum-global-dimension-size-150);
      min-height: var(--spectrum-global-dimension-size-350);
      padding: var(--spectrum-global-dimension-size-75) 0;
      color: var(--spectrum-global-color-gray-800);
    }

    .org-summary-id {
      font-weight: 600;
      color: var(--spectrum-global-color-gray-900);
    }

    .share-table-meta {
      font-size: 12px;
      color: var(--spectrum-global-color-gray-600);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .share-table-scope {
      display: flex;
      flex-direction: column;
      gap: var(--spectrum-global-dimension-size-75);
    }

    .share-row-actions {
      display: inline-flex;
      align-items: center;
      gap: var(--spectrum-global-dimension-size-100);
      flex-wrap: wrap;
    }

    .share-row-access {
      font-size: 12px;
      font-weight: 600;
      color: var(--spectrum-global-color-gray-800);
    }

    .empty-filter-note {
      font-size: 13px;
      color: var(--spectrum-global-color-gray-700);
    }

    .backrefs-title {
      margin-top: var(--spectrum-global-dimension-size-200);
      margin-bottom: var(--spectrum-global-dimension-size-75);
      font-size: 12px;
      color: var(--spectrum-alias-label-text-color, var(--spectrum-global-color-gray-800));
    }
    .backrefs-loading {
      margin-top: var(--spectrum-global-dimension-size-200);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .backrefs-list {
      height: 200px;
      overflow: auto;
      border: 1px solid var(--spectrum-alias-border-color);
      border-radius: var(--spectrum-alias-border-radius-regular, 6px);
      background: var(--spectrum-alias-background-color-secondary);
      padding: var(--spectrum-global-dimension-size-75);
    }
  `;
  static get properties() {
    return {
      store: { type: Object, observe: true },
      documentStore: { type: Object, observe: true },
      shareDialogOpen: { type: Boolean, converter: booleanConverter },
      shareDialogUrn: { type: String },
      shareError: { type: String },
      newShareUser: { type: String },
      newSharePerms: { type: Array },
      newSharePrincipalType: { type: String },
      newShareUserDisplay: { type: String },
      newShareRole: { type: String },
      principalResults: { type: Array },
      isSearchingPrincipals: { type: Boolean, converter: booleanConverter },
      suggestionIndex: { type: Number },
      selectedPrincipal: { type: Object },
      isAddingShare: { type: Boolean, converter: booleanConverter },
      undoShare: { type: Object },
      shareFilterText: { type: String },
      shareTypeFilter: { type: String },
      pendingShareKeys: { type: Object },
      confirmDeleteOpen: { type: Boolean, converter: booleanConverter },
      deleteUsages: { type: Array },
      isLoadingDeleteUsages: { type: Boolean, converter: booleanConverter }
    };
  }
  constructor() {
    super();
    this.store = null;
    this.shareDialogOpen = false;
    this.shareDialogUrn = null;
    this.shareError = "";
    this.newShareUser = "";
    this.newSharePerms = [...ROLE_PRESETS.view];
    this.newSharePrincipalType = "user";
    this.newShareUserDisplay = "";
    this.newShareRole = "view";
    this.principalResults = [];
    this.isSearchingPrincipals = false;
    this.suggestionIndex = -1;
    this.selectedPrincipal = null;
    this.isAddingShare = false;
    this.undoShare = null;
    this.shareFilterText = "";
    this.shareTypeFilter = "all";
    this.pendingShareKeys = /* @__PURE__ */ new Set();
    this.confirmDeleteOpen = false;
    this.deleteUsages = [];
    this.isLoadingDeleteUsages = false;
  }
  #pendingBulkUrns = null;
  #searchDebounceHandle = 0;
  #searchRequestToken = 0;
  #suggestionBlurHandle = 0;
  #undoTimer = 0;
  disconnectedCallback() {
    super.disconnectedCallback();
    this.#pendingBulkUrns = null;
    this.principalResults = [];
    if (this.#searchDebounceHandle) {
      clearTimeout(this.#searchDebounceHandle);
      this.#searchDebounceHandle = 0;
    }
    if (this.#suggestionBlurHandle) {
      clearTimeout(this.#suggestionBlurHandle);
      this.#suggestionBlurHandle = 0;
    }
    if (this.#undoTimer) {
      clearTimeout(this.#undoTimer);
      this.#undoTimer = 0;
    }
    this.undoShare = null;
  }
  render() {
    return x`
      ${this.#shareDialogTemplate}
      ${this.#deleteConfirmTemplate}
    `;
  }
  get #shareDialogTemplate() {
    if (!this.shareDialogOpen) return E;
    const ds2 = this.store?.documentStore;
    const items = ds2?.sharesByUrn?.get?.(this.shareDialogUrn) || [];
    const sortedItems = items.slice().sort((a23, b12) => this.#compareShares(a23, b12));
    const inheritedShares = sortedItems.filter((share) => this.#shareScope(share) !== "direct");
    const filteredShares = this.#applyShareFilters(sortedItems);
    const totalShares = sortedItems.length;
    const totalFiltered = filteredShares.length;
    const filtersActive = (this.shareFilterText || "").trim().length > 0 || this.shareTypeFilter !== "all";
    const shareType = this.newSharePrincipalType;
    const identifierPlaceholder = this.#sharePlaceholder(shareType);
    const helperText = this.#shareHelpText(shareType);
    const isOrgShare = shareType === "org";
    const orgPrincipalId = isOrgShare ? this.#organizationPrincipalId() : "";
    const orgDisplayLabel = isOrgShare ? this.newShareUserDisplay || this.#organizationShareDisplay(orgPrincipalId) : "";
    const newShareValue = this.newShareUserDisplay || this.newShareUser;
    return x`
      <sp-dialog-wrapper
        open
        underlay
        dismissable
        mode="modal"
        size="xl"
        headline="Share"
        id="share-dialog"
        cancel-label="Cancel"
        @cancel=${() => this.shareDialogOpen = false}
        @close=${() => this.shareDialogOpen = false}
      >
        <div class="share-content" id="share-content">
          ${this.undoShare ? this.#undoBannerTemplate : E}
          <section
            class="share-panel share-form"
            role="region"
            aria-labelledby="share-form-section"
          >
            <sp-field-group class="share-form-field share-form-field--type">
              <sp-field-label id="share-form-section">Share type</sp-field-label>
              <sp-radio-group
                direction="horizontal"
                selected=${shareType}
                @change=${this.#onShareTypeChange}
                ?disabled=${this.isAddingShare}
              >
                <sp-radio value="user">User</sp-radio>
                <sp-radio value="group">Group</sp-radio>
                <sp-radio value="org">Organization</sp-radio>
              </sp-radio-group>
              <sp-help-text>
                ${this.#shareTypeDescription(shareType)}
                <sp-link quiet target="_blank" href="https://experience-elements.adobe.com/docs/sharing">
                  Learn more
                </sp-link>
              </sp-help-text>
            </sp-field-group>
            ${isOrgShare ? x`<sp-field-group class="share-form-field share-form-field--identifier">
                  <sp-field-label>${this.#shareFieldLabel(shareType)}</sp-field-label>
                  <div class="org-summary" id="share-identifier" role="group" aria-live="polite">
                    <span>${orgDisplayLabel}</span>
                    ${this.#shouldShowOrgId(orgDisplayLabel, orgPrincipalId) ? x`<span class="org-summary-id">${orgPrincipalId}</span>` : E}
                  </div>
                  ${this.shareError ? x`<sp-help-text validation-state="negative" role="alert"
                        >${this.shareError}</sp-help-text
                      >` : helperText ? x`<sp-help-text>${helperText}</sp-help-text>` : E}
                </sp-field-group>` : x`<sp-field-group class="share-form-field share-form-field--identifier">
                  <sp-field-label for="share-identifier"
                    >${this.#shareFieldLabel(shareType)}</sp-field-label
                  >
                  <div class="suggestion-container">
                    <sp-textfield
                      id="share-identifier"
                      .placeholder=${identifierPlaceholder}
                      .value=${newShareValue}
                      autocomplete="off"
                      spellcheck="false"
                      autocapitalize="none"
                      ?disabled=${this.isAddingShare}
                      @input=${this.#handlePrincipalInput}
                      @keydown=${this.#handlePrincipalKeydown}
                      @blur=${this.#handlePrincipalBlur}
                      @focus=${this.#handlePrincipalFocus}
                    ></sp-textfield>
                    ${this.isAddingShare ? x`<sp-progress-circle size="s" indeterminate class="share-add-spinner"></sp-progress-circle>` : E}
                    ${this.#principalSuggestionsTemplate}
                  </div>
                  ${this.shareError ? x`<sp-help-text validation-state="negative" role="alert"
                        >${this.shareError}</sp-help-text
                      >` : helperText ? x`<sp-help-text>${helperText}</sp-help-text>` : E}
                </sp-field-group>`}
            <sp-field-group class="share-form-field share-form-field--access">
              <sp-field-label>Access level</sp-field-label>
              <sp-radio-group
                direction="horizontal"
                selected=${this.newShareRole}
                @change=${this.#onNewShareRoleChange}
                ?disabled=${this.isAddingShare}
              >
                <sp-radio value="view">Read only</sp-radio>
                <sp-radio value="comment">Can comment</sp-radio>
                <sp-radio value="edit">Can edit</sp-radio>
                <sp-radio value="publish">Can publish</sp-radio>
              </sp-radio-group>
            </sp-field-group>
            <div class="share-form-actions">
              <sp-button
                variant="accent"
                size="m"
                ?disabled=${this.isAddingShare}
                @click=${this.#onConfirmAddShare}
              >
                Share
              </sp-button>
            </div>
          </section>
          <section
            class="share-panel share-list"
            role="region"
            aria-labelledby="share-list-section"
          >
            <div class="share-list-controls">
              <div class="share-filters">
                <sp-action-group quiet>
                  ${this.#shareFilterButtons}
                </sp-action-group>
                ${filtersActive ? x`<span class="extra-help"
                      >Showing ${totalFiltered} of ${totalShares || 0}</span
                    >` : E}
              </div>
              <sp-search
                size="m"
                placeholder="Search by name, email, or ID"
                value=${this.shareFilterText}
                @input=${this.#onFilterSearch}
              ></sp-search>
            </div>
            ${ds2?.isLoadingShares ? x`<div class="section-loading">
                  <sp-progress-circle indeterminate size="s"></sp-progress-circle>
                </div>` : totalShares === 0 ? x`<sp-illustrated-message
                  heading="No shares"
                  description="No principals have explicit access yet."
                ></sp-illustrated-message>` : totalFiltered === 0 ? x`<div class="empty-filter-note">No entries match your filters.</div>` : this.#renderShareList(
      filteredShares,
      this.#renderInheritedSummary(inheritedShares)
    )}
          </section>
        </div>
      </sp-dialog-wrapper>
    `;
  }
  get #undoBannerTemplate() {
    if (!this.undoShare) return E;
    return x`<div class="undo-banner" role="status">
      Share removed.
      <sp-action-button size="s" variant="primary" @click=${this.#restoreRemovedShare}
        >Undo</sp-action-button
      >
    </div>`;
  }
  get #shareFilterButtons() {
    const options = [
      { value: "all", label: "All" },
      { value: "direct", label: "Direct access" },
      { value: "inherited", label: "Inherited access" }
    ];
    return options.map(
      (option) => x`<sp-action-button
        value=${option.value}
        ?selected=${this.shareTypeFilter === option.value}
        @click=${() => this.#onFilterSelect(option.value)}
      >
        ${option.label}
      </sp-action-button>`
    );
  }
  #onFilterSelect(value) {
    if (!value) return;
    if (this.shareTypeFilter === value) return;
    this.shareTypeFilter = value;
  }
  #onFilterSearch(event) {
    const value = event?.target?.value ?? "";
    this.shareFilterText = value;
  }
  #shareTypeDescription(type) {
    switch (type) {
      case "group":
        return "Grant access to everyone in a directory group.";
      case "org":
        return "Share with every member of your organization automatically.";
      default:
        return "Invite individual users by name, email, or ID.";
    }
  }
  #applyShareFilters(list) {
    const text = (this.shareFilterText || "").trim().toLowerCase();
    const filter = this.shareTypeFilter;
    if (!Array.isArray(list) || list.length === 0) {
      return [];
    }
    return list.filter((share) => {
      const scope = this.#shareScope(share);
      if (filter === "direct") {
        if (scope !== "direct") return false;
      } else if (filter === "inherited") {
        if (scope === "direct") return false;
      }
      if (!text) return true;
      const haystack = [
        share?.name,
        share?.email,
        share?.principalId || share?.principal_id,
        share?.sourceName || share?.source_name,
        share?.createdByName || share?.created_by_name,
        share?.createdByEmail || share?.created_by_email
      ].filter(Boolean).join(" ").toLowerCase();
      return haystack.includes(text);
    });
  }
  #renderShareList(shares, inheritedSummary) {
    return x`<div class="share-list-content">
      ${inheritedSummary}
      <div class="share-table-container">
        ${Array.isArray(shares) && shares.length ? x`
              <sp-table role="grid">
                <sp-table-head>
                  <sp-table-head-cell style="width: 30%">Name</sp-table-head-cell>
                  <sp-table-head-cell style="width: 35%">Type</sp-table-head-cell>
                  <sp-table-head-cell style="width: 20%">Scope</sp-table-head-cell>
                  <sp-table-head-cell>Access</sp-table-head-cell>
                </sp-table-head>
                <sp-table-body>
                  ${shares.map((share) => this.#renderShareRowCells(share))}
                </sp-table-body>
              </sp-table>
            ` : x`<div class="empty-filter-note">No entries match your filters.</div>`}
      </div>
    </div>`;
  }
  #renderInheritedSummary(inheritedShares) {
    if (!Array.isArray(inheritedShares) || inheritedShares.length === 0 || this.shareTypeFilter === "inherited") {
      return E;
    }
    const sourceMap = /* @__PURE__ */ new Map();
    inheritedShares.forEach((share) => {
      const sourceName = this.#shareSourceDetail(share);
      if (!sourceName) return;
      const key = sourceName.toLowerCase();
      sourceMap.set(key, sourceName);
    });
    if (sourceMap.size === 0) {
      return E;
    }
    const sources = Array.from(sourceMap.values());
    const maxPreview = 3;
    const preview = sources.slice(0, maxPreview);
    const remaining = sources.length - preview.length;
    const summaryText = remaining > 0 ? `${preview.join(", ")} and ${remaining} more` : preview.join(", ");
    return x`<div class="inherited-summary">
      <sp-icon-info-circle></sp-icon-info-circle>
      <span>Access also inherited from ${summaryText}.</span>
    </div>`;
  }
  #shareScope(share) {
    const raw = share?.scope ?? share?.scope_type ?? "";
    const normalized = typeof raw === "string" ? raw.trim().toLowerCase() : "";
    if (normalized && normalized.includes("inherit")) {
      return "inherited";
    }
    if (normalized && normalized.includes("direct")) {
      return "direct";
    }
    return "direct";
  }
  #renderShareRowCells(share) {
    const info = this.#formatShareLabel(share);
    const key = this.#shareKey(share);
    const roleValue = this.#roleFromPerms(share?.perms || []);
    const scope = this.#shareScope(share);
    const scopeLabel = scope === "direct" ? "Direct" : "Inherited";
    const roleLabel = this.#roleLabel(roleValue);
    const sourceDetail = scope === "inherited" ? this.#shareSourceDetail(share) : "";
    const addedLine = this.#formatAddedLine(share);
    const pending = this.pendingShareKeys instanceof Set && this.pendingShareKeys.has(key);
    const disableRemoval = pending || scope !== "direct";
    return x`<sp-table-row role="row">
      <sp-table-cell>
        <div class="share-table-cell-primary">
          <span class="share-table-primary">${info.primaryLabel}</span>
          ${info.secondaryLabel ? x`<span class="share-table-secondary">${info.secondaryLabel}</span>` : E}
          ${addedLine ? x`<span class="share-table-meta">${addedLine}</span>` : E}
        </div>
      </sp-table-cell>
      <sp-table-cell>${this.#typeLabel(info.type)}</sp-table-cell>
      <sp-table-cell>
        <div class="share-table-scope">
          <span>${scopeLabel}</span>
          ${sourceDetail ? x`<span class="share-table-meta">${sourceDetail}</span>` : E}
        </div>
      </sp-table-cell>
      <sp-table-cell>
        <div class="share-row-actions">
          <span class="share-row-access">${roleLabel}</span>
          <sp-action-button
            variant="negative"
            size="s"
            ?disabled=${disableRemoval}
            @click=${() => this.#onRemoveShare(share)}
          >
            Remove
          </sp-action-button>
          ${pending ? x`<sp-progress-circle size="s" indeterminate></sp-progress-circle>` : E}
        </div>
      </sp-table-cell>
    </sp-table-row>`;
  }
  #shareKey(share) {
    const type = (share?.principalType || share?.principal_type || "user").toLowerCase();
    const id = String(share?.principalId || share?.principal_id || "");
    return `${type}:${id}`;
  }
  get #principalSuggestionsTemplate() {
    const options = this.#currentSuggestionOptions();
    if (!this.isSearchingPrincipals && options.length === 0) {
      return E;
    }
    return x`<sp-popover class="suggestion-popover" open>
      ${this.isSearchingPrincipals ? x`<div class="section-loading">
            <sp-progress-circle indeterminate size="s"></sp-progress-circle>
          </div>` : options.length === 0 ? x`<div class="suggestion-menu empty-filter-note">No matches found.</div>` : x`<sp-menu class="suggestion-menu" selects="single">
            ${options.map(
      (result, index) => x`<sp-menu-item
                value=${result.id}
                ?selected=${this.suggestionIndex === index}
                @pointerdown=${(event) => event.preventDefault()}
                @click=${() => this.#onSelectPrincipal(result)}
              >
                ${this.#renderSuggestionOption(result)}
              </sp-menu-item>`
    )}
          </sp-menu>`}
    </sp-popover>`;
  }
  #currentSuggestionOptions() {
    const list = Array.isArray(this.principalResults) ? [...this.principalResults] : [];
    const manual = this.#manualPrincipalOption();
    if (manual) {
      list.push(manual);
    }
    return list;
  }
  #renderSuggestionOption(result) {
    if (result?.manual) {
      const typeLabel2 = this.#typeLabel(result.type || this.newSharePrincipalType);
      return x`<div class="suggestion-item">
        <div class="suggestion-text">
          <span>Add ${typeLabel2.toLowerCase()} "${result.id}"</span>
        </div>
      </div>`;
    }
    const typeLabel = this.#typeLabel(result?.type || this.newSharePrincipalType);
    const primary = result?.name || result?.email || result?.id;
    const secondarySource = result?.email && result.email !== primary ? result.email : result?.id;
    return x`<div class="suggestion-item">
      ${this.#renderAvatar(primary)}
      <div class="suggestion-text">
        <span>${primary}</span>
        ${secondarySource && secondarySource !== primary ? x`<span class="suggestion-secondary">${secondarySource}</span>` : E}
      </div>
      <sp-tag size="s">${typeLabel}</sp-tag>
    </div>`;
  }
  #manualPrincipalOption() {
    const value = (this.newShareUserDisplay || "").trim();
    if (!value) {
      return null;
    }
    const normalizedValue = value.toLowerCase();
    if (Array.isArray(this.principalResults)) {
      const duplicate = this.principalResults.some((result) => {
        const id = String(result?.id || "").toLowerCase();
        return id === normalizedValue;
      });
      if (duplicate) {
        return null;
      }
    }
    return {
      type: this.newSharePrincipalType,
      id: value,
      name: value,
      manual: true
    };
  }
  #handlePrincipalInput(event) {
    const value = event?.target?.value ?? "";
    this.newShareUserDisplay = value;
    this.newShareUser = value;
    this.selectedPrincipal = null;
    this.shareError = "";
    this.suggestionIndex = -1;
    this.#schedulePrincipalSearch(value);
  }
  #handlePrincipalKeydown(event) {
    const key = event?.key;
    if (!key) return;
    if (key === "ArrowDown") {
      event.preventDefault();
      this.#moveSuggestion(1);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      this.#moveSuggestion(-1);
    } else if (key === "Enter") {
      const options = this.#currentSuggestionOptions();
      if (this.suggestionIndex >= 0 && options[this.suggestionIndex]) {
        event.preventDefault();
        this.#onSelectPrincipal(options[this.suggestionIndex]);
      } else {
        event.preventDefault();
        this.#onConfirmAddShare(event);
      }
    } else if (key === "Escape") {
      this.#clearSuggestions();
    }
  }
  #moveSuggestion(delta) {
    const options = this.#currentSuggestionOptions();
    if (!options.length) {
      return;
    }
    let nextIndex = this.suggestionIndex + delta;
    if (nextIndex < 0) {
      nextIndex = options.length - 1;
    } else if (nextIndex >= options.length) {
      nextIndex = 0;
    }
    this.suggestionIndex = nextIndex;
  }
  #handlePrincipalBlur() {
    if (this.#suggestionBlurHandle) {
      clearTimeout(this.#suggestionBlurHandle);
    }
    this.#suggestionBlurHandle = window.setTimeout(() => {
      this.#clearSuggestions();
      this.#suggestionBlurHandle = 0;
    }, 150);
  }
  #handlePrincipalFocus() {
    if (this.#suggestionBlurHandle) {
      clearTimeout(this.#suggestionBlurHandle);
      this.#suggestionBlurHandle = 0;
    }
  }
  #clearSuggestions() {
    this.principalResults = [];
    this.isSearchingPrincipals = false;
    this.suggestionIndex = -1;
  }
  #onSelectPrincipal(result) {
    if (!result) return;
    if (result.type && result.type !== this.newSharePrincipalType) {
      this.newSharePrincipalType = result.type;
    }
    this.selectedPrincipal = result;
    this.newShareUser = result.id;
    this.newShareUserDisplay = result.name || result.email || result.id;
    this.shareError = "";
    this.suggestionIndex = -1;
    this.principalResults = [];
    this.isSearchingPrincipals = false;
  }
  #schedulePrincipalSearch(rawValue) {
    if (this.#searchDebounceHandle) {
      clearTimeout(this.#searchDebounceHandle);
      this.#searchDebounceHandle = 0;
    }
    const query = (rawValue || "").trim();
    const type = this.newSharePrincipalType;
    if (type === "org") {
      this.#clearSuggestions();
      return;
    }
    const minLength = type === "group" ? 1 : type === "org" ? 0 : 2;
    if (query.length < minLength) {
      this.#clearSuggestions();
      return;
    }
    this.#searchDebounceHandle = window.setTimeout(() => {
      this.#performPrincipalSearch(query, type);
    }, 200);
  }
  async #performPrincipalSearch(query, type) {
    const ds2 = this.store?.documentStore;
    if (type === "org") {
      this.#clearSuggestions();
      return;
    }
    const token = ++this.#searchRequestToken;
    this.isSearchingPrincipals = true;
    try {
      const results = await ds2.searchPrincipals(type, query);
      if (token !== this.#searchRequestToken) {
        return;
      }
      this.principalResults = Array.isArray(results) ? results : [];
      this.suggestionIndex = -1;
    } catch (error) {
      if (token === this.#searchRequestToken) {
        this.principalResults = [];
        this.suggestionIndex = -1;
        this.shareError = error?.message || "Unable to search principals";
      }
    } finally {
      if (token === this.#searchRequestToken) {
        this.isSearchingPrincipals = false;
      }
    }
  }
  #roleFromPerms(perms) {
    const set = new Set(
      Array.isArray(perms) ? perms.map((perm) => String(perm || "").toLowerCase()) : []
    );
    if (set.has("publish")) return "publish";
    if (set.has("edit")) return "edit";
    if (set.has("comment")) return "comment";
    return "view";
  }
  #combinePermsForRole(role) {
    const base2 = ROLE_PRESETS[role] ? [...ROLE_PRESETS[role]] : [...ROLE_PRESETS.view];
    return this.#normalizePerms(base2);
  }
  #shareSourceDetail(share) {
    const name = share?.sourceName || share?.source_name || "";
    const urn = share?.sourceUrn || share?.source_urn || "";
    return name || urn;
  }
  #formatAddedLine(share) {
    const created = share?.created instanceof Date ? share.created : null;
    const updated = share?.updated instanceof Date ? share.updated : null;
    const createdBy = share?.createdByName || share?.createdByEmail || share?.createdBy || "";
    const updatedBy = share?.updatedByName || share?.updatedByEmail || share?.updatedBy || "";
    if (updated && (!created || updated.getTime() > created.getTime()) && updatedBy) {
      return `Updated by ${updatedBy} on ${ADDED_DATE_FORMATTER.format(updated)}`;
    }
    if (created && createdBy) {
      return `Added by ${createdBy} on ${ADDED_DATE_FORMATTER.format(created)}`;
    }
    if (createdBy) {
      return `Added by ${createdBy}`;
    }
    return "";
  }
  #renderAvatar(label) {
    const safeLabel = label || "Principal";
    const initials = this.#initialsForLabel(safeLabel);
    return x`<sp-avatar size="s" label=${safeLabel} initials=${initials}></sp-avatar>`;
  }
  #initialsForLabel(label) {
    if (!label) return "";
    const cleaned = String(label).trim();
    if (!cleaned) return "";
    const parts = cleaned.split(/\s+/).slice(0, 2);
    const letters = parts.map((part) => part.charAt(0)).join("");
    return letters.toUpperCase();
  }
  #onNewShareRoleChange(event) {
    const value = event?.target?.selected;
    if (!value || !ROLE_PRESETS[value]) {
      return;
    }
    this.newShareRole = value;
    this.newSharePerms = this.#combinePermsForRole(value);
  }
  #setPendingShare(key, pending) {
    const current = this.pendingShareKeys instanceof Set ? this.pendingShareKeys : /* @__PURE__ */ new Set();
    const next = new Set(current);
    if (pending) {
      next.add(key);
    } else {
      next.delete(key);
    }
    this.pendingShareKeys = next;
  }
  get #deleteConfirmTemplate() {
    if (!this.confirmDeleteOpen) return E;
    const count = this.#pendingBulkUrns?.length ?? this.store?.selectedUrns?.size ?? 0;
    return x`
      <sp-dialog-wrapper
        open
        underlay
        dismissable
        mode="modal"
        size="s"
        headline="Delete ${count} item${count === 1 ? "" : "s"}?"
        confirm-label="Delete"
        cancel-label="Cancel"
        @close=${this.#closeDeleteDialog}
        @cancel=${this.#closeDeleteDialog}
        @confirm=${this.#confirmBulkDelete}
      >
        <div>
          <div>This action cannot be undone.</div>
          ${this.isLoadingDeleteUsages ? x`<div class="backrefs-loading">
                <sp-progress-circle indeterminate size="s"></sp-progress-circle>
              </div>` : this.deleteUsages.length ? x`<div class="backrefs-title">Used In</div>
                <div class="backrefs-list">
                  <sp-sidenav>
                    ${this.deleteUsages.map(
      (usage) => x`<sp-sidenav-item
                        value=${usage.urn}
                        label=${usage.name || usage.urn}
                        @click=${() => this.#openUsage(usage.urn)}
                      ></sp-sidenav-item>`
    )}
                  </sp-sidenav>
                </div>` : E}
        </div>
      </sp-dialog-wrapper>
    `;
  }
  openShareForSelection() {
    const selected = Array.from(this.store?.selectedUrns || []);
    if (selected.length !== 1) return;
    this.openShareDialog(selected[0]);
  }
  async openShareDialog(urn) {
    if (!urn) return;
    this.shareDialogUrn = urn;
    this.shareDialogOpen = true;
    this.shareError = "";
    this.newShareUser = "";
    this.newSharePerms = [];
    this.newShareRole = "view";
    this.newSharePrincipalType = "user";
    await this.#loadShares();
  }
  async #loadShares() {
    this.shareError = "";
    await this.store?.documentStore?.getShares?.(this.shareDialogUrn);
  }
  async #onConfirmAddShare(event) {
    if (event?.preventDefault) {
      event.preventDefault();
    }
    if (this.isAddingShare) {
      return;
    }
    const added = await this.#addShareFromInput();
    if (added) {
      await this.#loadShares();
      this.newShareUser = "";
      this.newShareUserDisplay = "";
      this.selectedPrincipal = null;
      this.principalResults = [];
      this.suggestionIndex = -1;
      this.shareError = "";
    }
  }
  async #addShareFromInput() {
    this.shareError = "";
    const principalType = this.selectedPrincipal?.type || this.newSharePrincipalType || "user";
    let principalId = (this.newShareUser || "").trim();
    if (principalType === "org" && this.selectedPrincipal?.id) {
      principalId = this.selectedPrincipal.id;
    }
    if (!principalId) {
      this.shareError = this.#shareMissingValueMessage(principalType);
      return false;
    }
    const role = this.newShareRole || "view";
    const perms = this.#combinePermsForRole(role);
    this.isAddingShare = true;
    try {
      await this.store?.documentStore?.upsertShare?.(
        this.shareDialogUrn,
        principalType,
        principalId,
        perms
      );
      this.#clearSuggestions();
      return true;
    } catch (error) {
      this.shareError = error?.message || "Unable to add share";
      return false;
    } finally {
      this.isAddingShare = false;
    }
  }
  async #onRemoveShare(share) {
    if (!share) return;
    const ds2 = this.store?.documentStore;
    if (!ds2) return;
    const scope = this.#shareScope(share);
    if (scope !== "direct") {
      return;
    }
    const snapshot = {
      principalType: share?.principalType || share?.principal_type,
      principalId: share?.principalId || share?.principal_id,
      perms: Array.isArray(share?.perms) ? [...share.perms] : []
    };
    if (!snapshot.principalType || !snapshot.principalId) {
      return;
    }
    const key = this.#shareKey(share);
    this.#setPendingShare(key, true);
    try {
      await ds2.deleteShare(this.shareDialogUrn, snapshot.principalType, snapshot.principalId);
      this.shareError = "";
      this.#clearUndo();
      this.undoShare = { share: snapshot };
      this.#undoTimer = window.setTimeout(() => {
        this.undoShare = null;
        this.#undoTimer = 0;
      }, 8e3);
    } catch (error) {
      this.shareError = error?.message || "Unable to remove share";
    } finally {
      this.#setPendingShare(key, false);
    }
  }
  async #restoreRemovedShare() {
    const saved = this.undoShare?.share;
    const ds2 = this.store?.documentStore;
    if (!saved || !ds2) {
      return;
    }
    const key = `${saved.principalType}:${saved.principalId}`;
    this.#clearUndo();
    this.#setPendingShare(key, true);
    try {
      await ds2.upsertShare(this.shareDialogUrn, saved.principalType, saved.principalId, saved.perms);
      this.shareError = "";
    } catch (error) {
      this.shareError = error?.message || "Unable to restore share";
    } finally {
      this.#setPendingShare(key, false);
    }
  }
  #clearUndo() {
    if (this.#undoTimer) {
      clearTimeout(this.#undoTimer);
      this.#undoTimer = 0;
    }
    this.undoShare = null;
  }
  openConfirmDelete() {
    this.#pendingBulkUrns = Array.from(this.store?.selectedUrns || []);
    this.confirmDeleteOpen = true;
    this.#loadSelectionUsages(this.#pendingBulkUrns);
  }
  async #confirmBulkDelete() {
    this.confirmDeleteOpen = false;
    const urns = Array.from(this.#pendingBulkUrns || []);
    await this.#bulkDeleteSelected(urns);
    this.#pendingBulkUrns = null;
  }
  async #openUsage(urn) {
    if (!urn) return;
    this.confirmDeleteOpen = false;
    await this.store?.openElement?.(urn);
  }
  #closeDeleteDialog() {
    this.confirmDeleteOpen = false;
    this.#pendingBulkUrns = null;
  }
  #onShareTypeChange(event) {
    const group = event?.currentTarget;
    const detailValue = event?.detail?.value;
    const selectedValue = group?.selected ?? group?.value;
    const fallbackValue = event?.target?.value;
    const value = detailValue ?? selectedValue ?? fallbackValue;
    if (!value) {
      return;
    }
    this.newSharePrincipalType = value;
    this.newShareUser = "";
    this.newShareUserDisplay = "";
    this.selectedPrincipal = null;
    this.suggestionIndex = -1;
    if (value === "org") {
      const orgId = this.#organizationPrincipalId();
      const display = this.#organizationShareDisplay(orgId);
      if (orgId) {
        this.newShareUser = orgId;
      }
      this.newShareUserDisplay = display;
      this.selectedPrincipal = orgId ? { id: orgId, type: "org", name: display, implicit: true } : null;
    }
    this.newSharePerms = this.#combinePermsForRole(this.newShareRole);
    this.shareError = "";
    this.#clearSuggestions();
  }
  #formatShareLabel(share) {
    const type = share?.principalType || share?.principal_type || "user";
    const id = String(share?.principalId || share?.principal_id || "");
    const email = share?.email ? String(share.email) : "";
    const name = share?.name ? String(share.name).trim() : "";
    let primaryLabel = "";
    let secondaryLabel = "";
    if (type === "user") {
      primaryLabel = name || email || id || "User";
      if (email && email !== primaryLabel) {
        secondaryLabel = email;
      } else if (id && id !== primaryLabel) {
        secondaryLabel = id;
      }
    } else if (type === "group") {
      primaryLabel = id || "Group";
    } else if (type === "org") {
      const explicitName = typeof share?.name === "string" ? share.name.trim() : "";
      primaryLabel = explicitName || this.#organizationShareDisplay(id) || "Organization";
    } else {
      primaryLabel = id || "Share";
    }
    const avatarLabel = primaryLabel || secondaryLabel || id || type;
    return { type, id, primaryLabel, secondaryLabel, avatarLabel };
  }
  #compareShares(a23, b12) {
    const infoA = this.#formatShareLabel(a23);
    const infoB = this.#formatShareLabel(b12);
    if (infoA.type !== infoB.type) {
      return infoA.type.localeCompare(infoB.type);
    }
    return infoA.primaryLabel.localeCompare(infoB.primaryLabel, void 0, {
      sensitivity: "base"
    });
  }
  #organizationPrincipalId() {
    if (this.shareDialogUrn) {
      const parsed = this.#extractOrgIdFromUrn(this.shareDialogUrn);
      if (parsed) {
        return parsed;
      }
    }
    const fallback = this.store?.documentStore?.currentOrgId || this.store?.documentStore?.orgId;
    if (!fallback) {
      return "";
    }
    const normalized = fallback.trim ? fallback.trim() : fallback;
    return this.#decodeOrgId(normalized);
  }
  #organizationShareDisplay(orgId) {
    const ownerOrg = this.store?.userStore?.currentUser?.ownerOrg;
    const trimmed = ownerOrg && ownerOrg.trim ? ownerOrg.trim() : "";
    if (trimmed) {
      return trimmed;
    }
    if (orgId) {
      return `Organization ${orgId}`;
    }
    return "Organization";
  }
  #shouldShowOrgId(displayLabel, orgId) {
    if (!orgId) {
      return false;
    }
    const trimmed = displayLabel && displayLabel.trim ? displayLabel.trim() : "";
    if (!trimmed) {
      return true;
    }
    return false;
  }
  #extractOrgIdFromUrn(urn) {
    if (typeof urn !== "string") {
      return "";
    }
    const trimmed = urn.trim();
    if (!trimmed.startsWith("urn:")) {
      return "";
    }
    const segments = trimmed.split(":");
    if (segments.length >= 3) {
      return this.#decodeOrgId(segments[2] || "");
    }
    return "";
  }
  #decodeOrgId(value) {
    const raw = (value || "").trim();
    if (!raw) return "";
    if (/^\d+$/.test(raw)) {
      return raw;
    }
    const alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let acc = 0n;
    for (const ch of raw) {
      const idx = alphabet.indexOf(ch);
      if (idx === -1) {
        return raw;
      }
      acc = acc * 62n + BigInt(idx);
    }
    return acc.toString();
  }
  #shareFieldLabel(type) {
    switch (type) {
      case "group":
        return "Add a group";
      case "org":
        return "Share with your organization";
      default:
        return "Add people";
    }
  }
  #sharePlaceholder(type) {
    switch (type) {
      case "group":
        return "Search groups by name or group ID";
      case "org":
        return "Your organization";
      default:
        return "Search by name or email";
    }
  }
  #shareHelpText(type) {
    switch (type) {
      case "group":
        return "Share with directory groups by searching for their name or group ID.";
      case "org":
        return "Everyone in your organization will receive the selected access automatically.";
      default:
        return "Start typing a name, email, or ID to find a person.";
    }
  }
  #shareMissingValueMessage(type) {
    switch (type) {
      case "group":
        return "Choose a group to share with";
      case "org":
        return "Unable to determine your organization identifier";
      default:
        return "Choose a user to share with";
    }
  }
  #typeLabel(type) {
    switch (type) {
      case "group":
        return "Group";
      case "org":
        return "Organization";
      default:
        return "User";
    }
  }
  #roleLabel(role) {
    switch (role) {
      case "publish":
        return "Publish";
      case "edit":
        return "Edit";
      case "comment":
        return "Comment";
      default:
        return "Read";
    }
  }
  #normalizePerms(perms) {
    const allowed = /* @__PURE__ */ new Set([
      "read",
      "comment",
      "edit",
      "publish",
      "unpublish",
      "delete",
      "share"
    ]);
    const set = new Set(
      Array.isArray(perms) ? perms.map((perm) => String(perm || "").toLowerCase()).filter((perm) => allowed.has(perm)) : []
    );
    if (set.has("publish") || set.has("unpublish")) {
      set.add("publish");
      set.add("unpublish");
      set.add("edit");
      set.add("comment");
    }
    if (set.has("delete")) {
      set.add("edit");
      set.add("comment");
    }
    if (set.has("edit")) {
      set.add("comment");
    }
    if (set.has("comment") || set.has("share")) {
      set.add("read");
    }
    set.add("read");
    if (set.has("publish")) {
      set.add("unpublish");
    } else {
      set.delete("unpublish");
    }
    return Array.from(set);
  }
  async #bulkDeleteSelected(urns) {
    const list = Array.isArray(urns) ? urns : Array.from(this.store?.selectedUrns || []);
    if (!list.length) return;
    for (const urn of list) {
      await this.store?.documentStore?.deleteDocument?.(urn);
    }
    this.store?.clearSelection?.();
    this.store?.setSelectionMode?.(false);
    this.dispatchEvent(new CustomEvent("show-toast", {
      detail: { label: "Deleted", variant: "positive" },
      bubbles: true,
      composed: true
    }));
  }
  async #loadSelectionUsages(urnsArg) {
    const urns = Array.isArray(urnsArg) ? urnsArg : Array.from(this.store?.selectedUrns || []);
    if (!urns.length || !this.store?.documentStore?.getDocumentReferrers) {
      this.deleteUsages = [];
      return;
    }
    this.isLoadingDeleteUsages = true;
    const seen = /* @__PURE__ */ new Map();
    for (const urn of urns) {
      const [direct, recursive] = await Promise.all([
        this.store.documentStore.getDocumentReferrers(urn, false, null),
        this.store.documentStore.getDocumentReferrers(urn, true, null)
      ]);
      const pushRefs = (items, assumedDistance) => {
        const arr = Array.isArray(items) ? items : [];
        for (const ref of arr) {
          const refUrn = String(
            ref.urn || ref.id || ref.target || ref.target_urn || ref.source || ref.source_urn || ""
          );
          if (!refUrn) continue;
          if (urns.includes(refUrn)) continue;
          if (ref.is_folder || ref.isFolder) continue;
          let distance = Number(ref.distance);
          if (!Number.isFinite(distance)) distance = Number(ref.depth);
          if (!Number.isFinite(distance)) distance = Number(ref.hops);
          if (!Number.isFinite(distance) && Array.isArray(ref.path)) {
            distance = ref.path.length;
          }
          if (!Number.isFinite(distance)) distance = assumedDistance;
          const name = ref.name != null ? String(ref.name) : "Untitled";
          const existing = seen.get(refUrn);
          if (!existing || distance < existing.distance) {
            seen.set(refUrn, { urn: refUrn, name, distance });
          }
        }
      };
      pushRefs(recursive, 2);
      pushRefs(direct, 1);
    }
    const list = Array.from(seen.values()).sort((a23, b12) => {
      const da = Number.isFinite(a23.distance) ? a23.distance : 9999;
      const db = Number.isFinite(b12.distance) ? b12.distance : 9999;
      if (da !== db) return da - db;
      return compareByName(a23, b12);
    });
    this.deleteUsages = list;
    this.isLoadingDeleteUsages = false;
  }
};
customElements.define("ee-share-manager", makeLitObserver(EEShareManager));

// src/features/home-gallery/creation-dialog-mixin.js
init_lit();
var LIBRARY_LEVEL_LABELS = {
  [LibraryLevel.SYSTEM]: "System Library",
  [LibraryLevel.TEAM]: "Team Library",
  [LibraryLevel.INDIVIDUAL]: "My Library"
};
var CreationDialogMixin = (Base) => {
  return class extends Base {
    #templateObserver = null;
    #requestedTemplatePreviews = /* @__PURE__ */ new Set();
    #templatePreviewWrappers = /* @__PURE__ */ new Map();
    openCreationDialog(tab = "templates") {
      const category = tab === "blank" ? "blank" : "templates";
      this.store?.setShowCreationDialog?.(true);
      this.store?.setCreationDialogCategory?.(category);
      this.searchQuery = "";
      requestAnimationFrame(() => {
        this.setupTemplateObserver();
        requestAnimationFrame(() => {
          const dialog = this.shadowRoot.getElementById("create-dialog");
          const search = this.shadowRoot.getElementById("dialog-search");
          if (dialog && search) {
            if (typeof search.focus === "function") {
              search.focus();
            }
            setTimeout(() => {
              if (typeof search.focus === "function") {
                search.focus();
              }
            }, 100);
          }
        });
      });
    }
    closeCreationDialog() {
      this.store?.setShowCreationDialog?.(false);
      this.searchQuery = "";
      if (this.#templateObserver) {
        this.#templateObserver.disconnect();
        this.#templateObserver = null;
      }
      this.#disposeTemplatePreviewWrappers();
    }
    get creationDialogTemplate() {
      const templates = this.templateStore?.templates || [];
      const searchValue = (this.searchQuery || "").trim().toLowerCase();
      const filteredTemplates = searchValue ? templates.filter((entry) => {
        const [title] = this.#getTemplateEntryTuple(entry);
        return title.toLowerCase().includes(searchValue);
      }) : templates;
      const libraryGroups = this.getLibraryGroups(searchValue);
      const totalBlankCount = libraryGroups.reduce(
        (sum, group) => sum + group.elements.length,
        0
      );
      return x`
        <sp-dialog-wrapper
          id="create-dialog"
          open
          size="xl"
          dismiss-label="Cancel"
          dismissable
          underlay
          mode="modal"
          @close=${() => this.closeCreationDialog()}
        >
          <div class="create-dialog-body">
            <div id="dialog-header">
              <h2 id="dialog-title">Create New Element</h2>
              <sp-search
                id="dialog-search"
                placeholder="Search..."
                .value=${this.searchQuery}
                @input=${(event) => this.searchQuery = event.target.value}
                size="m"
              ></sp-search>
            </div>

            <div id="dialog-content-wrapper">
              <sp-accordion allow-multiple>
                ${templates.length ? x`
                      <sp-accordion-item
                        label="Templates (${templates.length})"
                        ?open=${this.store.creationDialogCategory === "templates"}
                      >
                        ${filteredTemplates.length ? x`
                              <div class="templates-grid">
                                ${filteredTemplates.map((entry) => {
        const [title, url] = this.#getTemplateEntryTuple(entry);
        return this.renderTemplateCard(title, url);
      })}
                              </div>
                            ` : x`
                              <sp-illustrated-message
                                heading="No templates found"
                                description="${this.searchQuery ? `No templates match '${this.searchQuery}'` : "No templates loaded"}"
                              ></sp-illustrated-message>
                            `}
                      </sp-accordion-item>
                    ` : E}
                <sp-accordion-item
                  label="Blank Elements (${totalBlankCount})"
                  ?open=${this.store.creationDialogCategory === "blank"}
                >
                  ${totalBlankCount ? x`
                        <div class="library-section-list">
                          ${libraryGroups.map(
        (group) => this.renderLibraryGroup(group)
      )}
                        </div>
                      ` : x`
                        <sp-illustrated-message
                          heading="No elements found"
                          description="${this.searchQuery ? `No elements match '${this.searchQuery}'` : "No authorable elements are registered."}"
                        ></sp-illustrated-message>
                      `}
                </sp-accordion-item>
              </sp-accordion>
            </div>
          </div>
        </sp-dialog-wrapper>
      `;
    }
    getLibraryGroups(searchValue) {
      const query = (searchValue || "").trim();
      return libraryManager.libraries.map((library) => {
        const items = libraryManager.getElementsForLibrary(library.id).filter((entry) => {
          const hasSchemaApiCreate = entry.ee?.create;
          const ctor = customElements.get(entry.tag);
          const hasConstructorCreate = ctor?.ee?.create;
          const hasCustomCreate = hasSchemaApiCreate || hasConstructorCreate;
          if (!hasCustomCreate) return false;
          if (!query) return true;
          const haystack = [
            entry.displayName,
            entry.description,
            entry.tag,
            ...entry.keywords || []
          ].filter(Boolean).join(" ").toLowerCase();
          return haystack.includes(query);
        });
        return { library, elements: items };
      }).filter((group) => group.elements.length > 0);
    }
    renderLibraryGroup(group) {
      const { library, elements } = group;
      return x`
        <section class="library-section" id="library-${library.id}">
          <div class="library-section-header">
            <h3 class="library-section-title">${library.name}</h3>
            <sp-badge size="s">${this.getLibraryLevelLabel(library.level)}</sp-badge>
          </div>
          ${library.description ? x`<p class="library-section-description">
                ${library.description}
              </p>` : E}
          <div class="elements-grid">
            ${elements.map((entry) => this.renderLibraryElementCard(entry))}
          </div>
        </section>
      `;
    }
    renderLibraryElementCard(entry) {
      const description = entry.description || "";
      const heading = entry.displayName || entry.tag;
      const cardDescription = description.trim();
      const hasDescription = !!cardDescription;
      return x`
        <div
          class="element-card"
          role="button"
          tabindex="0"
          id="element-${entry.tag}-card"
          @click=${() => this.selectBlankElement(entry.tag)}
          @keydown=${(event) => this.handleLibraryCardKeydown(event, entry.tag)}
        >
          <div class="element-card-header">
            <div class="element-title">${heading}</div>
            ${hasDescription ? x`<div class="element-description">${cardDescription}</div>` : E}
          </div>
          <div class="element-preview">
            ${this.renderPreview(entry.tag, entry.create)}
          </div>
        </div>
      `;
    }
    renderTemplateCard(title, url) {
      const preview = this.renderTemplatePreview(title, url);
      const cardId = this.#templateCardId(url);
      return x`
        <div
          class="element-card template-card"
          role="button"
          tabindex="0"
          id="${cardId}"
          data-template-id="${url}"
          @click=${() => this.selectTemplate(url)}
          @keydown=${(event) => this.handleTemplateCardKeydown(event, url)}
        >
          <div class="element-card-header">
            <div class="element-title">${title}</div>
          </div>
          <div class="element-preview template-preview">${preview}</div>
        </div>
      `;
    }
    createElementInstance(tag3) {
      const ctor = customElements.get(tag3);
      const create = ctor?.ee?.create;
      if (create) {
        return create();
      }
      return document.createElement(tag3);
    }
    getLibraryLevelLabel(level) {
      return LIBRARY_LEVEL_LABELS[level] || "Library";
    }
    handleLibraryCardKeydown(event, tag3) {
      const key = event.key;
      if (key === "Enter" || key === " ") {
        event.preventDefault();
        this.selectBlankElement(tag3);
      }
    }
    handleTemplateCardKeydown(event, url) {
      const key = event.key;
      if (key === "Enter" || key === " ") {
        event.preventDefault();
        this.selectTemplate(url);
      }
    }
    #templateCardId(url) {
      const raw = typeof url === "string" ? url : String(url || "");
      if (!raw) {
        return "template-card";
      }
      return `template-card-${raw.replace(/[^a-z0-9]+/gi, "-")}`.replace(/-$/u, "");
    }
    renderPreview(tag3, factory) {
      const element = factory ? factory() : this.createElementInstance(tag3);
      if (!(element instanceof HTMLElement)) return E;
      element.setAttribute("aria-hidden", "true");
      element.removeAttribute("id");
      element.style.pointerEvents = "none";
      element.style.boxSizing = "border-box";
      element.tabIndex = -1;
      return this.#wrapPreviewElement(element, "element");
    }
    renderTemplatePreview(_title, url) {
      const cached = this.templateStore?.getTemplatePreview?.(url);
      const wrapper = this.#getTemplatePreviewWrapper(url);
      if (!cached) {
        if (typeof window === "undefined" || !("IntersectionObserver" in window)) {
          this.#ensureTemplatePreviewRequest(url);
        }
        return wrapper;
      }
      const previewMarkup = this.#getTemplatePreviewMarkup(cached);
      const container = wrapper._eePreviewContainer;
      const currentMarkup = wrapper._eePreviewMarkup || "";
      if (container && previewMarkup !== currentMarkup) {
        container.innerHTML = previewMarkup;
        this.#markPreviewNodes(container);
        wrapper._eePreviewMarkup = previewMarkup;
        const scaler = wrapper._eePreviewScaler;
        if (scaler) {
          const resize = () => this.#autoScalePreview(wrapper, scaler, container);
          requestAnimationFrame(resize);
        }
      }
      return wrapper;
    }
    #ensureTemplatePreviewRequest(url) {
      const normalized = typeof url === "string" ? url : String(url || "");
      if (!normalized || this.#requestedTemplatePreviews.has(normalized)) {
        return;
      }
      this.#requestedTemplatePreviews.add(normalized);
      this.templateStore?.fetchTemplateContent?.(normalized);
    }
    #getTemplatePreviewMarkup(htmlText) {
      if (!htmlText || typeof htmlText !== "string") {
        return "";
      }
      if (typeof DOMParser === "undefined") {
        const temp = document.createElement("div");
        temp.innerHTML = htmlText;
        const first = temp.firstElementChild;
        if (!first) return "";
        const clone2 = first.cloneNode(true);
        this.#stripIds(clone2);
        return clone2.outerHTML;
      }
      const parser = new DOMParser();
      const doc3 = parser.parseFromString(htmlText, "text/html");
      const element = doc3.body.firstElementChild;
      if (!element) return "";
      const clone = element.cloneNode(true);
      this.#stripIds(clone);
      return clone.outerHTML;
    }
    #stripIds(element) {
      if (!element?.removeAttribute) return;
      element.removeAttribute("id");
      if (element.querySelectorAll) {
        element.querySelectorAll("[id]").forEach((node) => node.removeAttribute("id"));
      }
    }
    #wrapTemplatePreview(htmlText) {
      const wrapper = document.createElement("div");
      wrapper.className = "preview-wrapper";
      const scaler = document.createElement("div");
      scaler.className = "preview-scaler";
      scaler.classList.add("preview-scaler-template");
      const previewContainer = document.createElement("div");
      previewContainer.className = "template-preview-html";
      previewContainer.setAttribute("data-ee-preview", "");
      previewContainer.style.transformOrigin = "top center";
      previewContainer.style.willChange = "transform";
      previewContainer.style.position = "relative";
      previewContainer.style.pointerEvents = "none";
      if (htmlText) {
        previewContainer.innerHTML = htmlText;
        this.#markPreviewNodes(previewContainer);
      }
      scaler.append(previewContainer);
      wrapper.append(scaler);
      wrapper._eePreviewContainer = previewContainer;
      wrapper._eePreviewMarkup = htmlText || "";
      wrapper._eePreviewScaler = scaler;
      const resize = () => this.#autoScalePreview(wrapper, scaler, previewContainer);
      requestAnimationFrame(resize);
      const observer = new ResizeObserver(resize);
      observer.observe(wrapper);
      observer.observe(previewContainer);
      wrapper._eeResizeObserver = observer;
      return wrapper;
    }
    #wrapPreviewElement(element, kind) {
      const wrapper = document.createElement("div");
      wrapper.className = "preview-wrapper";
      const scaler = document.createElement("div");
      scaler.className = "preview-scaler";
      scaler.style.transformOrigin = "top center";
      if (kind === "template") scaler.classList.add("preview-scaler-template");
      scaler.append(element);
      wrapper.append(scaler);
      const resize = () => this.#autoScalePreview(wrapper, scaler, element);
      requestAnimationFrame(resize);
      const observer = new ResizeObserver(resize);
      observer.observe(wrapper);
      observer.observe(element);
      wrapper._eeResizeObserver = observer;
      this.#markPreviewNodes(element);
      return wrapper;
    }
    #autoScalePreview(wrapper, scaler, element) {
      if (!wrapper || !scaler || !element) return;
      scaler.style.transform = "scale(1)";
      const containerWidth = wrapper.clientWidth || 0;
      if (!containerWidth) return;
      const rect = element.getBoundingClientRect();
      const contentWidth = Math.max(
        rect?.width || 0,
        element.scrollWidth || 0,
        element.offsetWidth || 0
      );
      if (!contentWidth) return;
      const maxWidth = Math.max(0, containerWidth - 8);
      const scale = Math.min(1, maxWidth / contentWidth);
      scaler.style.transform = `scale(${scale})`;
    }
    #markPreviewNodes(root) {
      if (!root) return;
      const elements = root instanceof Element ? [root, ...root.querySelectorAll("*")] : [];
      elements.forEach((el) => {
        if (!el.hasAttribute("data-ee-preview")) {
          el.setAttribute("data-ee-preview", "true");
        }
      });
    }
    #getTemplatePreviewWrapper(url) {
      const key = typeof url === "string" ? url : String(url || "");
      if (!key) {
        return this.#wrapTemplatePreview("");
      }
      let wrapper = this.#templatePreviewWrappers.get(key);
      if (!wrapper) {
        wrapper = this.#wrapTemplatePreview("");
        this.#templatePreviewWrappers.set(key, wrapper);
      }
      return wrapper;
    }
    #disposeTemplatePreviewWrappers() {
      this.#templatePreviewWrappers.forEach((wrapper) => {
        const observer = wrapper?._eeResizeObserver;
        if (observer) {
          observer.disconnect();
        }
      });
      this.#templatePreviewWrappers.clear();
    }
    #getTemplateEntryTuple(entry) {
      if (Array.isArray(entry)) {
        const title = typeof entry[0] === "string" ? entry[0] : String(entry[0] || "");
        const url = typeof entry[1] === "string" ? entry[1] : String(entry[1] || "");
        return [title, url];
      }
      if (entry && typeof entry === "object") {
        const title = typeof entry.title === "string" ? entry.title : String(entry.title || "");
        const url = typeof entry.url === "string" ? entry.url : String(entry.url || "");
        return [title, url];
      }
      return ["", ""];
    }
    async selectBlankElement(elementName) {
      this.closeCreationDialog();
      await this.createNewElement(elementName);
    }
    async selectTemplate(url) {
      this.closeCreationDialog();
      const htmlContent = await this.templateStore.fetchTemplateContent(url);
      if (htmlContent) {
        const templateEntry = this.templateStore.templates.find((entry) => {
          const [, templateUrl] = this.#getTemplateEntryTuple(entry);
          return templateUrl === url;
        });
        const [title] = this.#getTemplateEntryTuple(templateEntry);
        await this.createFromHTML(htmlContent, title);
      }
    }
    async createElementOfType(elementType) {
      const template = this.elementTypeTemplates[elementType];
      if (template?.url) {
        const content = await this.templateStore.fetchTemplateContent(
          template.url
        );
        if (content) {
          await this.createFromHTML(content, template.title || "New Element");
          return;
        }
      }
      await this.createNewElement(elementType);
    }
    setupTemplateObserver() {
      if (this.#templateObserver) {
        this.#templateObserver.disconnect();
      }
      this.#templateObserver = new IntersectionObserver(
        async (entries) => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              const card = entry.target;
              const templateId = card.dataset.templateId;
              if (templateId && !card.classList.contains("loaded") && !card.dataset.loading) {
                card.dataset.loading = "1";
                this.#loadTemplatePreview(card, templateId).catch((err) => {
                  console.error("Failed to load template preview:", err);
                  delete card.dataset.loading;
                });
              }
            }
          }
        },
        {
          root: null,
          rootMargin: "0px",
          // Only load when actually visible
          threshold: 0.01
        }
      );
      setTimeout(() => {
        requestAnimationFrame(() => {
          const cards = Array.from(
            this.shadowRoot.querySelectorAll(
              ".template-card[data-template-id]"
            )
          );
          if (cards.length === 0) return;
          const batchSize = 3;
          let currentIndex = 0;
          const observeNextBatch = () => {
            if (!this.#templateObserver) return;
            const batch = cards.slice(currentIndex, currentIndex + batchSize);
            batch.forEach((card) => this.#templateObserver.observe(card));
            currentIndex += batchSize;
            if (currentIndex < cards.length) {
              setTimeout(() => {
                requestAnimationFrame(observeNextBatch);
              }, 200);
            }
          };
          observeNextBatch();
        });
      }, 150);
    }
    async #loadTemplatePreview(card, templateId) {
      this.#ensureTemplatePreviewRequest(templateId);
      await this.templateStore.fetchTemplateContent(templateId);
      card.classList.add("loaded");
      delete card.dataset.loading;
    }
    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
      this.#templateObserver?.disconnect();
      this.#templateObserver = null;
      this.#disposeTemplatePreviewWrappers();
    }
  };
};

// src/features/home-gallery/toast-utils.js
var ToastController = class {
  #activeToast = null;
  #timerId = null;
  /**
   * Show a toast message, replacing any existing one.
   * @param {string} label
   * @param {import("@spectrum-web-components/toast").ToastVariants} [variant]
   */
  show(label, variant = "info") {
    this.clear();
    const toast = document.createElement("sp-toast");
    toast.variant = variant;
    toast.open = true;
    toast.textContent = String(label ?? "");
    toast.style.position = "fixed";
    toast.style.right = "16px";
    toast.style.bottom = "16px";
    toast.style.zIndex = "9999";
    document.body.appendChild(toast);
    this.#activeToast = toast;
    this.#timerId = window.setTimeout(() => this.clear(), 3e3);
  }
  /**
   * Clear any active toast immediately.
   */
  clear() {
    if (this.#timerId) {
      clearTimeout(this.#timerId);
      this.#timerId = null;
    }
    if (this.#activeToast) {
      this.#activeToast.remove();
      this.#activeToast = null;
    }
  }
  /**
   * Disconnect controller and clear resources.
   */
  disconnect() {
    this.clear();
  }
};

// src/features/home-gallery/workspace-keyboard.js
var WorkspaceKeyboardController = class {
  #options;
  #listener;
  /**
   * @param {object} options
   * @param {() => boolean} options.isCreationDialogOpen
   * @param {() => void} options.closeCreationDialog
   * @param {() => boolean} options.isShareDialogOpen
   * @param {() => void} options.closeShareDialog
   * @param {() => boolean} options.isConfirmDeleteOpen
   * @param {() => boolean} options.isSelectionMode
   * @param {() => void} options.exitSelectionMode
   * @param {() => void} options.openCreationDialog
   */
  constructor(options) {
    this.#options = options;
    this.#listener = (event) => this.#onKeyDown(event);
  }
  connect() {
    window.addEventListener("keydown", this.#listener, { capture: true });
  }
  disconnect() {
    window.removeEventListener("keydown", this.#listener, { capture: true });
  }
  #onKeyDown(event) {
    const { key } = event;
    const isCtrlOrCmd = event.ctrlKey || event.metaKey;
    if (key === "Escape") {
      if (this.#options.isCreationDialogOpen()) {
        event.preventDefault();
        this.#options.closeCreationDialog();
        return;
      }
      if (this.#options.isShareDialogOpen()) {
        event.preventDefault();
        this.#options.closeShareDialog();
        return;
      }
      if (this.#options.isConfirmDeleteOpen()) {
        return;
      }
      if (this.#options.isSelectionMode()) {
        event.preventDefault();
        this.#options.exitSelectionMode();
        return;
      }
    }
    if (key === "n" && isCtrlOrCmd) {
      event.preventDefault();
      this.#options.openCreationDialog();
    }
  }
};

// src/custom-elements/upw/paywall-container.js
init_lit();

// src/custom-elements/upw/paywall-container.css.js
init_lit();
var paywallContainerStyles = i`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-400);
    padding: var(--spectrum-global-dimension-size-500) var(--spectrum-global-dimension-size-750);
    background: #ffffff;
    background-image: 
      radial-gradient(circle at 45% 60%, rgba(166, 166, 249, 0.15) 0%, transparent 50%),
      radial-gradient(circle at 85% 63%, rgba(150, 197, 251, 0.15) 0%, transparent 50%),
      radial-gradient(circle at 9% 68%, rgba(224, 162, 235, 0.15) 0%, transparent 50%);
    border-radius: var(--spectrum-global-dimension-size-500);
    box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.12),
      0px 2px 6px 0px rgba(0, 0, 0, 0.04),
      0px 4px 12px 0px rgba(0, 0, 0, 0.08);
    width: 100%;
    max-width: 1100px;
    overflow: hidden;
  }

  :host([theme="light"]),
  :host(:not([theme])) {
    background: #ffffff;
    background-image: 
      radial-gradient(circle at 45% 60%, rgba(166, 166, 249, 0.15) 0%, transparent 50%),
      radial-gradient(circle at 85% 63%, rgba(150, 197, 251, 0.15) 0%, transparent 50%),
      radial-gradient(circle at 9% 68%, rgba(224, 162, 235, 0.15) 0%, transparent 50%);
  }

  :host([theme="dark"]) {
    background: linear-gradient(
      to bottom,
      rgba(15, 12, 28, 0.95) 0%,
      rgba(18, 20, 32, 0.95) 50%,
      rgba(28, 18, 32, 0.95) 100%
    );
    box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.36),
      0px 2px 6px 0px rgba(0, 0, 0, 0.12),
      0px 4px 12px 0px rgba(0, 0, 0, 0.24);
  }

  :host([theme="dark"]) slot[name='heading']::slotted(*) {
    color: var(--spectrum-global-color-gray-25, #ffffff);
  }

  :host([theme="dark"]) slot[name='footer-link']::slotted(*) {
    color: var(--spectrum-global-color-gray-25, #ffffff);
  }

  :host([theme="dark"]) slot[name='footer-disclaimer']::slotted(*) {
    color: var(--spectrum-global-color-gray-600, #8a8a8a);
  }

  :host([hidden]) {
    display: none !important;
  }

  slot[name='heading'] {
    display: block;
    width: 100%;
    text-align: center;
  }

  slot[name='heading']::slotted(*) {
    font-family: 'Adobe Clean', sans-serif;
    font-weight: 900;
    font-size: 36px;
    line-height: 42px;
    color: var(--spectrum-global-color-gray-900, #131313);
    margin: 0;
  }

  slot[name='toggle'] {
    display: flex;
    justify-content: center;
    width: 100%;
  }

  .cards-grid {
    display: grid;
    grid-template-columns: repeat(var(--card-count, 3), 320px);
    column-gap: 24px;
    row-gap: 24px;
    width: 100%;
    max-width: 1112px;
    padding-top: var(--spectrum-global-dimension-size-450);
    align-items: stretch;
    justify-content: center;
  }

  @media (max-width: 1200px) {
    .cards-grid {
      grid-template-columns: repeat(min(var(--card-count, 3), 2), 350px);
    }
  }

  @media (max-width: 768px) {
    .cards-grid {
      grid-template-columns: 350px;
    }
  }

  .cards-grid::slotted(paywall-card) {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  slot[name='footer-link'] {
    display: block;
    width: 100%;
    text-align: center;
    margin-top: var(--spectrum-global-dimension-size-400);
  }

  slot[name='footer-link']::slotted(*) {
    font-family: 'Adobe Clean', sans-serif;
    font-weight: 700;
    font-size: 12px;
    line-height: 16px;
    color: var(--spectrum-global-color-gray-900, #292929);
  }

  slot[name='footer-disclaimer'] {
    display: block;
    width: 100%;
    text-align: center;
  }

  slot[name='footer-disclaimer']::slotted(*) {
    font-family: 'Adobe Clean', sans-serif;
    font-size: 12px;
    line-height: 16px;
    color: var(--spectrum-global-color-gray-600, #717171);
    margin: 0;
  }
`;

// src/custom-elements/upw/paywall-card.js
init_lit();

// src/custom-elements/upw/paywall-card-badge.js
init_lit();
var PaywallCardBadge = class extends i4 {
  static styles = i`
    :host {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8.912px;
      height: 36px;
      min-height: 36px;
      max-height: 36px;
      padding: var(--spectrum-global-dimension-size-100) 11.459px var(--spectrum-global-dimension-size-100) 0;
      border-radius: 12.73px 12.73px 0 0;
      background: linear-gradient(90deg, var(--spectrum-global-color-static-red-500, #ef4a2a) 0%, var(--spectrum-global-color-static-purple-500, #8b84ff) 100%);
      color: #fff;
      font-family: var(--font-family-sans-serif, 'Adobe Clean', 'Adobe_Clean_Spectrum_VF', sans-serif);
      font-size: 12px;
      font-weight: 800;
      line-height: 1.5;
      letter-spacing: 1.2732px;
      text-transform: uppercase;
      white-space: nowrap;
      box-sizing: border-box;
      width: 100%;
      max-width: 362px;
    }
  `;
  firstUpdated() {
    super.firstUpdated();
    const parent = this.parentElement;
    if (parent && !parent.hasAttribute("has-badge")) {
      parent.requestUpdate();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    const parent = this.parentElement;
    if (parent && parent.hasAttribute("has-badge")) {
      parent.requestUpdate();
    }
  }
  render() {
    return x`
      <slot></slot>
    `;
  }
};
customElements.define("paywall-card-badge", PaywallCardBadge);

// src/custom-elements/upw/paywall-card.css.js
init_lit();
var paywallCardStyles = i`
  :host {
    display: inline-block;
    color: inherit;
    position: relative;
  }

  :host([hidden]) {
    display: none !important;
  }

  slot[name='badge'] {
    display: block;
    min-height: var(--badge-height, 36px);
  }

  slot[name='badge']::slotted(paywall-card-badge) {
    position: absolute;
    left: -1px;
    width: calc(100% + 2px);
    z-index: 1;
  }

  :host([has-badge]) [part='card'] {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    border-top: none;
    border-radius: 0 0 var(--spectrum-global-dimension-size-400) var(--spectrum-global-dimension-size-400);
    border: none;
    position: relative;
    isolation: isolate;
  }

  :host([has-badge]) [part='card']::before {
    content: '';
    position: absolute;
    inset: -1px;
    top: 0;
    border-radius: 0 0 var(--spectrum-global-dimension-size-400) var(--spectrum-global-dimension-size-400);
    background: linear-gradient(90deg, var(--spectrum-global-color-static-red-500, #ef4a2a) 0%, var(--spectrum-global-color-static-purple-500, #8b84ff) 100%);
    z-index: -1;
  }

  :host([has-badge]) [part='card']::after {
    content: '';
    position: absolute;
    inset: 0;
    top: 0;
    border-radius: 0 0 var(--spectrum-global-dimension-size-400) var(--spectrum-global-dimension-size-400);
    background: var(--spectrum-alias-background-color-primary);
    z-index: -1;
  }

  [part='card'] {
    background: var(--spectrum-alias-background-color-primary);
    color: var(--spectrum-alias-text-color);
    border-radius: var(--spectrum-global-dimension-size-400);
    padding: var(--spectrum-global-dimension-size-400);
    border: 1px solid var(--spectrum-global-color-gray-800);
    box-shadow: 0 40px 80px rgba(0, 0, 0, 0.35);
    max-width: 360px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
  }

  [part='header'] {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: var(--spectrum-global-dimension-size-200);
  }

  [part='heading'] {
    flex: 1;
  }

  slot[name='header-badge']::slotted(*) {
    margin-left: auto;
  }

  slot[name='plan-name'] {
    display: block;
    min-height: var(--plan-name-height, auto);
  }

  slot[name='plan-name']::slotted(*),
  [part='plan-title'] {
    margin: 0;
    font-family: 'Adobe Clean', sans-serif;
    font-weight: 900;
    font-size: 20px;
    line-height: 130%;
    letter-spacing: 0;
    color: var(--spectrum-alias-heading-text-color);
  }

  slot[name='plan-description'] {
    display: block;
    min-height: var(--plan-description-height, auto);
  }

  slot[name='plan-description']::slotted(*),
  [part='plan-description'] {
    margin: var(--spectrum-global-dimension-size-125) 0 0;
    font-family: 'Adobe Clean', sans-serif;
    font-weight: 400;
    font-style: normal;
    font-size: var(--spectrum-global-dimension-size-225);
    line-height: 100%;
    letter-spacing: normal;
    color: var(--spectrum-global-color-gray-500);
  }

  slot[name='price'],
  slot[name='price-M2M'],
  slot[name='price-ABM'],
  slot[name='price-PUF'],
  [part='price'] {
    display: block;
    width: 100%;
    margin-top: var(--spectrum-global-dimension-size-500);
  }

  slot[name='price-M2M'] {
    min-height: var(--price-M2M-height, auto);
  }

  slot[name='price-ABM'] {
    min-height: var(--price-ABM-height, auto);
  }

  slot[name='price-PUF'] {
    min-height: var(--price-PUF-height, auto);
  }

  slot[name='price']::slotted(*),
  [part='price'] inline-price {
    width: 100%;
    display: block;
  }

  slot[name='terms'],
  [part='terms'] {
    display: block;
    margin: var(--spectrum-global-dimension-size-200) 0
      var(--spectrum-global-dimension-size-400);
    font-size: var(--spectrum-global-dimension-size-200);
    color: var(--spectrum-global-color-gray-500);
    min-height: var(--terms-height, auto);
  }

  slot[name='terms']::slotted(*) {
    display: inline-flex;
    gap: var(--spectrum-global-dimension-size-100);
    align-items: center;
  }

  [part='terms'] sp-icon-info {
    margin-right: var(--spectrum-global-dimension-size-100);
    vertical-align: middle;
  }

  slot[name='cta'],
  [part='cta'] {
    display: block;
    width: 100%;
    margin-bottom: var(--spectrum-global-dimension-size-400);
    min-height: var(--cta-height, auto);
  }

  slot[name='cta']::slotted(*) {
    width: 100%;
    display: inline-flex;
    min-height: var(--cta-height, auto);
  }

  /* Apply badge gradient to CTA elements when badge is present */
  :host([has-badge]) slot[name='cta']::slotted(*) {
    background: linear-gradient(90deg, var(--spectrum-global-color-static-red-500, #ef4a2a) 0%, var(--spectrum-global-color-static-purple-500, #8b84ff) 100%);
    color: #fff;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    backface-visibility: hidden;
    transform: translateZ(0);
  }

  /* For Spectrum buttons, apply gradient directly and ensure transparent borders */
  :host([has-badge]) slot[name='cta']::slotted(checkout-button),
  :host([has-badge]) slot[name='cta']::slotted(sp-button) {
    background: linear-gradient(90deg, var(--spectrum-global-color-static-red-500, #ef4a2a) 0%, var(--spectrum-global-color-static-purple-500, #8b84ff) 100%);
    --spectrum-button-accent-border-color: transparent;
    --spectrum-button-accent-border-color-hover: transparent;
    --spectrum-button-accent-border-color-down: transparent;
    --spectrum-button-accent-border-color-key-focus: transparent;
    --spectrum-button-accent-border-width: 0;
    --spectrum-button-accent-content-color: #fff;
    --spectrum-button-accent-content-color-hover: #fff;
    --spectrum-button-accent-content-color-down: #fff;
    --spectrum-button-accent-content-color-key-focus: #fff;
    background-clip: border-box;
    background-origin: border-box;
    border: none;
    border-width: 0;
    border-color: transparent;
    outline: none;
    box-shadow: none;
    color: #fff;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    backface-visibility: hidden;
    transform: translateZ(0);
  }

  slot[name='generative-credits'],
  [part='stat'] {
    display: block;
    margin-bottom: var(--spectrum-global-dimension-size-400);
    min-height: var(--generative-credits-height, auto);
  }

  slot[name='generative-credits']::slotted(*),
  [part='stat'] div {
    display: flex;
    gap: var(--spectrum-global-dimension-size-200);
    font-size: var(--spectrum-global-dimension-size-200);
    color: var(--spectrum-global-color-gray-500);
    font-weight: 500;
  }

  [part='stat-value'] {
    font-weight: 600;
  }

  [part='stat-label'] {
    font-weight: 400;
  }

  [part='mnemonics-container'] {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-150);
    margin: var(--spectrum-global-dimension-size-400) 0
      var(--spectrum-global-dimension-size-300);
  }

  slot[name='mnemonics'],
  [part='mnemonics'] {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spectrum-global-dimension-size-150);
    align-items: flex-start;
    min-height: var(--mnemonics-height, auto);
  }

  slot[name='mnemonics']::slotted(*) {
    display: inline-flex;
    flex-shrink: 0;
    border: 2px solid #FFFFFF33;
    border-radius: 6px;
    overflow: hidden;
    align-items: center;
    justify-content: center;
  }

  slot[name='disclaimer'],
  [part='disclaimer'] {
    display: block;
    min-height: var(--disclaimer-height, auto);
  }

  slot[name='disclaimer']::slotted(*) {
    margin: 0;
    font-size: var(--spectrum-global-dimension-size-150);
    font-style: italic;
    color: var(--spectrum-global-color-gray-600);
    line-height: normal;
  }

  [part='divider'] {
    border: none;
    border-top: 1px solid var(--paywall-card-divider);
    margin: var(--spectrum-global-dimension-size-400) 0;
  }

  slot[name='features'] {
    display: block;
    min-height: var(--features-height, auto);
  }

  slot[name='features']::slotted(ee-list) {
    margin-top: var(--spectrum-global-dimension-size-400);
    color: var(--paywall-card-text-regular);
  }

  slot[name='footer'] {
    display: block;
    min-height: var(--footer-height, auto);
  }

  slot[name='footer']::slotted(*) {
    display: block;
    margin-top: var(--spectrum-global-dimension-size-400);
    font-size: var(--spectrum-global-dimension-size-150);
    color: var(--paywall-card-text-muted);
  }
`;

// src/custom-elements/shared/id-utils.js
function ensureId(element, prefix = "ee") {
  if (!element.id) {
    const randomId = `${prefix}-${Math.random().toString(36).slice(2, 8)}`;
    element.id = randomId;
    element.setAttribute("id", randomId);
  }
  return element.id;
}

// src/custom-elements/upw/paywall-card.js
var VALID_PLAN_TYPES = /* @__PURE__ */ new Set(["M2M", "ABM", "PUF", ""]);
var PaywallCard = class extends i4 {
  static properties = {
    planType: { type: String, attribute: "plan-type", reflect: true }
  };
  static styles = [paywallCardStyles];
  #planNameSlot;
  #onPlanSlotChange;
  #badgeSlot;
  #onBadgeSlotChange;
  constructor() {
    super();
    this.planType = "";
    this.#planNameSlot = null;
    this.#onPlanSlotChange = () => this.#syncHeadingLabel();
    this.#badgeSlot = null;
    this.#onBadgeSlotChange = () => this.#checkBadge();
    ensureId(this, "paywall-card");
  }
  get #baseId() {
    return this.id;
  }
  get #headingId() {
    return `${this.#baseId}-heading`;
  }
  connectedCallback() {
    super.connectedCallback();
    this.#ensurePlanType();
  }
  willUpdate(changed) {
    if (changed.has("planType")) {
      this.#ensurePlanType();
    }
  }
  updated(changed) {
    if (changed.has("planType")) {
      this.#renderInlinePriceChildren();
    }
    this.updateSlotHeights();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#planNameSlot) {
      this.#planNameSlot.removeEventListener("slotchange", this.#onPlanSlotChange);
      this.#planNameSlot = null;
    }
    if (this.#badgeSlot) {
      this.#badgeSlot.removeEventListener("slotchange", this.#onBadgeSlotChange);
      this.#badgeSlot = null;
    }
  }
  firstUpdated() {
    this.#planNameSlot = this.renderRoot?.querySelector('slot[name="plan-name"]') || null;
    if (this.#planNameSlot) {
      this.#planNameSlot.addEventListener("slotchange", this.#onPlanSlotChange);
    }
    this.#badgeSlot = this.renderRoot?.querySelector('slot[name="badge"]') || null;
    if (this.#badgeSlot) {
      this.#badgeSlot.addEventListener("slotchange", this.#onBadgeSlotChange);
    }
    this.#syncHeadingLabel();
    this.#checkBadge();
    this.updateSlotHeights();
  }
  #ensurePlanType() {
    if (!VALID_PLAN_TYPES.has(this.planType)) {
      this.planType = "";
    }
  }
  #checkBadge() {
    if (!this.#badgeSlot) {
      this.removeAttribute("has-badge");
      return;
    }
    const assigned = this.#badgeSlot.assignedElements({ flatten: true });
    const badge = assigned.find((el) => el.tagName === "PAYWALL-CARD-BADGE");
    if (badge) {
      this.setAttribute("has-badge", "");
    } else {
      this.removeAttribute("has-badge");
    }
  }
  #syncHeadingLabel() {
    const assigned = this.#planNameSlot?.assignedElements({ flatten: true }) || [];
    const candidate = assigned.find((node) => node.nodeType === Node.ELEMENT_NODE) || this.renderRoot?.querySelector("#default-plan-heading");
    if (!candidate) return;
    if (!candidate.id || candidate.id.includes("paywall-card-")) {
      candidate.id = this.#headingId;
    }
    this.setAttribute("aria-labelledby", candidate.id);
  }
  #renderInlinePriceChildren() {
    if (!this.renderRoot) return;
    const inlinePrices = this.renderRoot.querySelectorAll("inline-price");
    inlinePrices.forEach((price) => {
      if (typeof price.render === "function") {
        price.render();
      }
    });
    const priceSlotNames = ["price-M2M", "price-ABM", "price-PUF"];
    priceSlotNames.forEach((slotName) => {
      const slot = this.renderRoot.querySelector(`slot[name="${slotName}"]`);
      if (slot) {
        const assigned = slot.assignedElements({ flatten: true });
        assigned.forEach((el) => {
          if (el.tagName === "INLINE-PRICE" && typeof el.render === "function") {
            el.render();
          }
          const descendants = el.querySelectorAll?.("inline-price");
          if (descendants) {
            descendants.forEach((price) => {
              if (typeof price.render === "function") {
                price.render();
              }
            });
          }
        });
      }
    });
  }
  render() {
    return x`
      <slot name="badge"></slot>
      <article part="card" id=${this.#baseId} aria-labelledby=${this.#headingId}>
        ${this.#header}
        ${this.#planTypePriceSlot}
        <slot name="terms" part="terms">
        </slot>
        <slot name="cta" part="cta">
        </slot>
        <slot name="generative-credits" part="stat">
          </div>
        </slot>
          ${this.#mnemonicsSection}
        <sp-divider static-color="black"></sp-divider>
        <slot name="features">
        </slot>
        <slot name="footer"></slot>
      </article>
    `;
  }
  get #header() {
    return x`
      <header part="header">
        <div part="heading">
          <slot name="plan-name">
          </slot>
          <slot name="plan-description">
            <p part="plan-description">
              Essential tools to create standout content
            </p>
          </slot>
        </div>
        <slot name="header-badge"></slot>
      </header>
    `;
  }
  get #mnemonicsSection() {
    return x`
      <div part="mnemonics-container">
        <slot name="mnemonics" part="mnemonics"></slot>
        <slot name="disclaimer" part="disclaimer"></slot>
      </div>
    `;
  }
  get #planTypePriceSlot() {
    if (this.planType === "M2M") {
      return x`<slot name="price-M2M" part="price"></slot>`;
    }
    if (this.planType === "ABM") {
      return x`<slot name="price-ABM" part="price"></slot>`;
    }
    if (this.planType === "PUF") {
      return x`<slot name="price-PUF" part="price"></slot>`;
    }
    return E;
  }
  updateSlotHeights() {
    let container = this.closest("paywall-container");
    while (container && container.tagName !== "PAYWALL-CONTAINER") {
      container = container.parentElement;
      if (!container || container === document.body) {
        return;
      }
    }
    if (!container) return;
    const slots = [
      "plan-name",
      "plan-description",
      "price-M2M",
      "price-ABM",
      "price-PUF",
      "terms",
      "cta",
      "generative-credits",
      "mnemonics",
      "disclaimer",
      "features",
      "footer"
    ];
    slots.forEach((slotName) => {
      const slot = this.renderRoot?.querySelector(`slot[name="${slotName}"]`);
      if (!slot) return;
      const slotRect = slot.getBoundingClientRect();
      const slotHeight = slotRect.height;
      if (slotHeight > 0) {
        const varName = `--${slotName}-height`;
        const currentValue = parseFloat(container.style.getPropertyValue(varName)) || 0;
        if (slotHeight > currentValue) {
          container.style.setProperty(varName, `${slotHeight}px`);
        }
      }
    });
  }
};
customElements.define("paywall-card", PaywallCard);

// src/custom-elements/upw/paywall-container.js
var PaywallContainer = class extends i4 {
  static styles = [paywallContainerStyles];
  static properties = {
    theme: { type: String, reflect: true }
  };
  constructor() {
    super();
    this.theme = "light";
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("change", this.#handleToggleChange);
    let themeElement = this.closest("sp-theme");
    let node = this;
    while (!themeElement && node) {
      const root = node.getRootNode?.();
      node = root?.host;
      themeElement = node?.closest?.("sp-theme");
    }
    this.theme = themeElement?.getAttribute("color") || document.querySelector("sp-theme")?.getAttribute("color") || "light";
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("change", this.#handleToggleChange);
  }
  firstUpdated() {
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    if (slot) {
      slot.addEventListener("slotchange", () => {
        this.updateChildCards();
      });
    }
    this.updateChildCards();
  }
  willUpdate() {
    this.clearCSSVariables();
  }
  updated(changedProperties) {
    this.updateChildCards();
  }
  clearCSSVariables() {
    const styles12 = this.style;
    const cssText = styles12.cssText;
    const varPattern = /--[\w-]+(?:-\d+)?-height/g;
    const matches3 = cssText.match(varPattern) || [];
    matches3.forEach((varName) => {
      styles12.removeProperty(varName);
    });
  }
  updateChildCards() {
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    if (!slot) return;
    const cards = slot.assignedElements().filter((el) => el.tagName === "PAYWALL-CARD");
    const cardCount = Math.min(cards.length, 3);
    this.style.setProperty("--card-count", cardCount || 1);
    cards.forEach((card) => {
      if (card.requestUpdate) {
        card.requestUpdate();
      }
    });
  }
  #handleToggleChange = (event) => {
    const toggle = event.target.closest("spectrum-toggle");
    if (!toggle) return;
    const value = event.detail?.value;
    if (!value) return;
    const planType = value.toUpperCase();
    const validPlanTypes = ["M2M", "ABM", "PUF"];
    if (!validPlanTypes.includes(planType)) return;
    const cards = this.querySelectorAll("paywall-card");
    cards.forEach((card) => {
      card.setAttribute("plan-type", planType);
    });
  };
  render() {
    return x`
      <slot name="heading" part="heading"></slot>
      <slot name="toggle" part="toggle"></slot>
      <div class="cards-grid">
        <slot part="cards"></slot>
      </div>
      <slot name="footer-link" part="footer-link"></slot>
      <slot name="footer-disclaimer" part="footer-disclaimer"></slot>
    `;
  }
};
customElements.define("paywall-container", PaywallContainer);

// src/custom-elements/acom/acom-faq.js
init_lit();

// node_modules/@spectrum-web-components/accordion/src/Accordion.js
init_src();
init_decorators2();

// node_modules/@spectrum-web-components/accordion/src/accordion.css.js
init_src();
var e33 = i`
    :host{--spectrum-accordion-item-height:var(--spectrum-component-height-200);--spectrum-accordion-item-width:var(--spectrum-accordion-minimum-width);--spectrum-accordion-disclosure-indicator-height:var(--spectrum-component-height-100);--spectrum-accordion-disclosure-indicator-to-text-space:var(--spectrum-accordion-disclosure-indicator-to-text);--spectrum-accordion-edge-to-disclosure-indicator-space:var(--spectrum-accordion-edge-to-disclosure-indicator);--spectrum-accordion-edge-to-text-space:var(--spectrum-accordion-edge-to-text);--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-regular-medium);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-regular-medium);--spectrum-accordion-focus-indicator-gap:var(--spectrum-focus-indicator-gap);--spectrum-accordion-focus-indicator-thickness:var(--spectrum-focus-indicator-thickness);--spectrum-accordion-corner-radius:var(--spectrum-corner-radius-100);--spectrum-accordion-item-content-area-top-to-content:var(--spectrum-accordion-content-area-top-to-content);--spectrum-accordion-item-content-area-bottom-to-content:var(--spectrum-accordion-content-area-bottom-to-content);--spectrum-accordion-component-edge-to-text:var(--spectrum-component-edge-to-text-75);--spectrum-accordion-item-header-font:var(--spectrum-sans-font-family-stack);--spectrum-accordion-item-header-font-weight:var(--spectrum-bold-font-weight);--spectrum-accordion-item-header-font-style:var(--spectrum-default-font-style);--spectrum-accordion-item-header-font-size:var(--spectrum-font-size-300);--spectrum-accordion-item-header-line-height:1.25;--spectrum-accordion-item-content-font:var(--spectrum-sans-font-family-stack);--spectrum-accordion-item-content-font-weight:var(--spectrum-body-sans-serif-font-weight);--spectrum-accordion-item-content-font-style:var(--spectrum-body-sans-serif-font-style);--spectrum-accordion-item-content-font-size:var(--spectrum-body-size-s);--spectrum-accordion-item-content-line-height:var(--spectrum-line-height-100);--spectrum-accordion-background-color-default:rgba(var(--spectrum-gray-900-rgb),var(--spectrum-background-opacity-default));--spectrum-accordion-background-color-hover:rgba(var(--spectrum-gray-900-rgb),var(--spectrum-background-opacity-hover));--spectrum-accordion-background-color-down:rgba(var(--spectrum-gray-900-rgb),var(--spectrum-background-opacity-down));--spectrum-accordion-background-color-key-focus:rgba(var(--spectrum-gray-900-rgb),var(--spectrum-background-opacity-key-focus));--spectrum-accordion-item-header-color-default:var(--spectrum-neutral-content-color-default);--spectrum-accordion-item-header-color-hover:var(--spectrum-neutral-content-color-hover);--spectrum-accordion-item-header-color-down:var(--spectrum-neutral-content-color-down);--spectrum-accordion-item-header-color-key-focus:var(--spectrum-neutral-content-color-key-focus);--spectrum-accordion-item-header-disabled-color:var(--spectrum-disabled-content-color);--spectrum-accordion-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-accordion-min-block-size:max(var(--mod-accordion-item-height,var(--spectrum-accordion-item-height)),calc(var(--mod-accordion-item-header-top-to-text-space,var(--spectrum-accordion-item-header-top-to-text-space)) + var(--mod-accordion-item-header-bottom-to-text-space,var(--spectrum-accordion-item-header-bottom-to-text-space)) + var(--mod-accordion-item-header-font-size,var(--spectrum-accordion-item-header-font-size))*var(--mod-accordion-item-header-line-height,var(--spectrum-accordion-item-header-line-height))))}:host:dir(rtl),:host([dir=rtl]){--spectrum-logical-rotation:matrix(-1,0,0,1,0,0)}:host:lang(ja),:host:lang(ko),:host:lang(zh){--spectrum-accordion-item-header-line-height:var(--spectrum-cjk-line-height-100);--spectrum-accordion-item-content-line-height:var(--spectrum-cjk-line-height-100)}:host([density=compact]){--spectrum-accordion-item-height:var(--spectrum-component-height-100);--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-compact-medium);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-compact-medium)}:host([density=compact][size=s]){--spectrum-accordion-item-height:var(--spectrum-component-height-75);--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-compact-small);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-compact-small)}:host([density=compact][size=l]){--spectrum-accordion-item-height:var(--spectrum-component-height-200);--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-compact-large);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-compact-large)}:host([density=compact][size=xl]){--spectrum-accordion-item-height:var(--spectrum-component-height-300);--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-compact-extra-large);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-compact-extra-large)}:host([density=spacious]){--spectrum-accordion-item-header-line-height:1.278;--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-spacious-medium);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-spacious-medium)}:host([density=spacious][size=s]){--spectrum-accordion-item-header-line-height:1.25;--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-small-top-to-text-spacious);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-spacious-small)}:host([density=spacious][size=l]){--spectrum-accordion-item-header-line-height:1.273;--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-spacious-large);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-spacious-large)}:host([density=spacious][size=xl]){--spectrum-accordion-item-header-line-height:1.25;--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-spacious-extra-large);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-spacious-extra-large)}:host([size=s]){--spectrum-accordion-item-height:var(--spectrum-component-height-100);--spectrum-accordion-disclosure-indicator-height:var(--spectrum-component-height-75);--spectrum-accordion-component-edge-to-text:var(--spectrum-component-edge-to-text-50);--spectrum-accordion-item-header-font-size:var(--spectrum-font-size-200);--spectrum-accordion-item-content-font-size:var(--spectrum-body-size-xs);--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-regular-small);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-regular-small)}:host([size=l]){--spectrum-accordion-item-height:var(--spectrum-component-height-300);--spectrum-accordion-disclosure-indicator-height:var(--spectrum-component-height-200);--spectrum-accordion-component-edge-to-text:var(--spectrum-component-edge-to-text-100);--spectrum-accordion-item-header-font-size:var(--spectrum-font-size-500);--spectrum-accordion-item-content-font-size:var(--spectrum-body-size-m);--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-regular-large);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-regular-large)}:host([size=xl]){--spectrum-accordion-item-height:var(--spectrum-component-height-400);--spectrum-accordion-disclosure-indicator-height:var(--spectrum-component-height-300);--spectrum-accordion-component-edge-to-text:var(--spectrum-component-edge-to-text-200);--spectrum-accordion-item-header-font-size:var(--spectrum-font-size-700);--spectrum-accordion-item-content-font-size:var(--spectrum-body-size-l);--spectrum-accordion-item-header-top-to-text-space:var(--spectrum-accordion-top-to-text-regular-extra-large);--spectrum-accordion-item-header-bottom-to-text-space:var(--spectrum-accordion-bottom-to-text-regular-extra-large)}:host{--spectrum-accordion-divider-color:var(--system-accordion-divider-color);--spectrum-accordion-item-content-disabled-color:var(--system-accordion-item-content-disabled-color);--spectrum-accordion-item-content-color:var(--system-accordion-item-content-color);margin:0;padding:0;list-style:none;display:block}:host{--spectrum-logical-rotation: }
`;
var accordion_css_default = e33;

// node_modules/@spectrum-web-components/accordion/src/Accordion.js
var n23 = Object.defineProperty;
var u34 = Object.getOwnPropertyDescriptor;
var s17 = (l16, i21, e36, o52) => {
  for (var t34 = o52 > 1 ? void 0 : o52 ? u34(i21, e36) : i21, r25 = l16.length - 1, a23; r25 >= 0; r25--) (a23 = l16[r25]) && (t34 = (o52 ? a23(i21, e36, t34) : a23(t34)) || t34);
  return o52 && t34 && n23(i21, e36, t34), t34;
};
var Accordion = class extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.allowMultiple = false;
    this.focusGroupController = new FocusGroupController(this, { direction: "vertical", elements: () => this.items, isFocusableElement: (e36) => !e36.disabled });
  }
  static get styles() {
    return [accordion_css_default];
  }
  get items() {
    return [...this.defaultNodes || []].filter((e36) => typeof e36.tagName != "undefined");
  }
  focus() {
    this.focusGroupController.focus();
  }
  async onToggle(e36) {
    const o52 = e36.target;
    if (await 0, this.allowMultiple || e36.defaultPrevented) return;
    const t34 = [...this.items];
    t34 && !t34.length || t34.forEach((r25) => {
      r25 !== o52 && (r25.open = false);
    });
  }
  handleSlotchange() {
    this.focusGroupController.clearElementCache(), this.items.forEach((e36) => {
      e36.size = this.size;
    });
  }
  updated(e36) {
    super.updated(e36), e36.has("size") && (e36.get("size") || this.size !== "m") && this.items.forEach((o52) => {
      o52.size = this.size;
    });
  }
  render() {
    return x`
            <slot
                @slotchange=${this.handleSlotchange}
                @sp-accordion-item-toggle=${this.onToggle}
            ></slot>
        `;
  }
};
s17([n4({ type: Boolean, reflect: true, attribute: "allow-multiple" })], Accordion.prototype, "allowMultiple", 2), s17([n4({ type: String, reflect: true })], Accordion.prototype, "density", 2), s17([n5()], Accordion.prototype, "defaultNodes", 2);

// node_modules/@spectrum-web-components/accordion/sp-accordion.js
init_define_element();
defineElement("sp-accordion", Accordion);

// node_modules/@spectrum-web-components/accordion/src/AccordionItem.js
init_src();
init_decorators2();
init_focusable();
init_directives();

// node_modules/@spectrum-web-components/accordion/src/accordion-item.css.js
init_src();
var r23 = i`
    :host{z-index:inherit;min-block-size:var(--mod-accordion-item-height,var(--spectrum-accordion-item-height));min-inline-size:var(--mod-accordion-item-width,var(--spectrum-accordion-item-width));border-block-end:1px solid #0000;border-color:var(--mod-accordion-divider-color,var(--spectrum-accordion-divider-color));border-width:var(--mod-accordion-divider-thickness,var(--spectrum-divider-thickness-small));margin:0;position:relative}:host(:first-child){border-block-start:1px solid #0000;border-color:var(--mod-accordion-divider-color,var(--spectrum-accordion-divider-color));border-width:var(--mod-accordion-divider-thickness,var(--spectrum-divider-thickness-small))}#heading{box-sizing:border-box;margin:0;position:relative}.iconContainer{inline-size:var(--mod-accordion-disclosure-indicator-height,var(--spectrum-accordion-disclosure-indicator-height));block-size:var(--mod-accordion-disclosure-indicator-height,var(--spectrum-accordion-disclosure-indicator-height));color:var(--mod-accordion-item-header-color-default,var(--spectrum-accordion-item-header-color-default));justify-content:center;align-items:center;padding-inline-start:var(--mod-accordion-edge-to-disclosure-indicator-space,var(--spectrum-accordion-edge-to-disclosure-indicator-space));display:flex;position:absolute;inset-block-start:max(0px,calc((var(--mod-accordion-min-block-size,var(--spectrum-accordion-min-block-size)) - var(--mod-accordion-disclosure-indicator-height,var(--spectrum-accordion-disclosure-indicator-height)))/2))}.iconContainer:dir(rtl),:host([dir=rtl]) .iconContainer{transform:scaleX(-1)}#content{padding-block:var(--mod-accordion-item-content-area-top-to-content,var(--spectrum-accordion-item-content-area-top-to-content))var(--mod-accordion-item-content-area-bottom-to-content,var(--spectrum-accordion-item-content-area-bottom-to-content));padding-inline:var(--mod-accordion-component-edge-to-text,var(--spectrum-accordion-component-edge-to-text))var(--mod-accordion-component-edge-to-text,var(--spectrum-accordion-component-edge-to-text));color:var(--mod-accordion-item-content-color,var(--spectrum-accordion-item-content-color));font-weight:var(--mod-accordion-item-content-font-weight,var(--spectrum-accordion-item-content-font-weight));font-style:var(--mod-accordion-item-content-font-style,var(--spectrum-accordion-item-content-font-style));font-size:var(--mod-accordion-item-content-font-size,var(--spectrum-accordion-item-content-font-size));font-family:var(--mod-accordion-item-content-font,var(--spectrum-accordion-item-content-font));line-height:var(--mod-accordion-item-content-line-height,var(--spectrum-accordion-item-content-line-height));display:none}#header{box-sizing:border-box;padding-block:var(--mod-accordion-item-header-top-to-text-space,var(--spectrum-accordion-item-header-top-to-text-space))var(--mod-accordion-item-header-bottom-to-text-space,var(--spectrum-accordion-item-header-bottom-to-text-space));min-block-size:var(--mod-accordion-min-block-size,var(--spectrum-accordion-min-block-size));line-height:var(--mod-accordion-item-header-line-height,var(--spectrum-accordion-item-header-line-height));text-overflow:ellipsis;cursor:pointer;font-size:var(--mod-accordion-item-header-font-size,var(--spectrum-accordion-item-header-font-size));font-weight:var(--mod-accordion-item-header-font-weight,var(--spectrum-accordion-item-header-font-weight));font-style:var(--mod-accordion-item-header-font-style,var(--spectrum-accordion-item-header-font-style));font-family:var(--mod-accordion-item-header-font,var(--spectrum-accordion-item-header-font));appearance:none;text-align:start;inline-size:100%;color:var(--mod-accordion-item-header-color-default,var(--spectrum-accordion-item-header-color-default));background-color:var(--mod-accordion-background-color-default,var(--spectrum-accordion-background-color-default));border:0;justify-content:flex-start;align-items:center;padding-inline-start:calc(var(--mod-accordion-disclosure-indicator-to-text-space,var(--spectrum-accordion-disclosure-indicator-to-text-space)) + var(--mod-accordion-disclosure-indicator-height,var(--spectrum-accordion-disclosure-indicator-height)));padding-inline-end:var(--mod-accordion-edge-to-text-space,var(--spectrum-accordion-edge-to-text-space));display:flex;position:relative}#header:focus{outline:none}#header:focus:after{content:"";position:absolute;inset-inline-start:0}#header:focus-visible{border-radius:var(--mod-accordion-corner-radius,var(--spectrum-accordion-corner-radius));outline:var(--mod-accordion-focus-indicator-thickness,var(--spectrum-accordion-focus-indicator-thickness))solid var(--mod-accordion-focus-indicator-color,var(--spectrum-accordion-focus-indicator-color));background-color:var(--mod-accordion-background-color-key-focus,var(--spectrum-accordion-background-color-key-focus));color:var(--mod-accordion-item-header-color-key-focus,var(--spectrum-accordion-item-header-color-key-focus));outline-offset:calc(var(--mod-accordion-focus-indicator-gap,var(--spectrum-accordion-focus-indicator-gap))*-1)}#header:active{background-color:var(--mod-accordion-background-color-down,var(--spectrum-accordion-background-color-down));color:var(--mod-accordion-item-header-color-down,var(--spectrum-accordion-item-header-color-down))}:host([disabled]) #header,:host([disabled]) #header:focus-visible{color:var(--mod-accordion-item-header-disabled-color,var(--spectrum-accordion-item-header-disabled-color));background-color:initial}@media (hover:hover){#header:hover{background-color:var(--mod-accordion-background-color-hover,var(--spectrum-accordion-background-color-hover))}#header:hover,#header:hover+.iconContainer{color:var(--mod-accordion-item-header-color-hover,var(--spectrum-accordion-item-header-color-hover))}:host([open]) #header:hover{background-color:var(--mod-accordion-background-color-hover,var(--spectrum-accordion-background-color-hover))}:host([disabled]) #header:hover{color:var(--mod-accordion-item-header-disabled-color,var(--spectrum-accordion-item-header-disabled-color));background-color:initial}}:host([disabled]) #header+.iconContainer{color:var(--mod-accordion-item-header-disabled-color,var(--spectrum-accordion-item-header-disabled-color))}:host([disabled]) #content{color:var(--mod-accordion-item-content-disabled-color,var(--spectrum-accordion-item-content-disabled-color))}@media (forced-colors:active){#header:after{forced-color-adjust:none;content:"";position:absolute;inset-inline-start:0}}:host([open])>#heading>.iconContainer>.indicator,:host([open])>.iconContainer>.indicator{transform:rotate(90deg);transform:var(--spectrum-logical-rotation,)rotate(90deg)}:host([open])>#content{display:block}:host([disabled]) #header{cursor:default}:host{display:block}#heading{height:auto;position:relative}:host([disabled]) #heading .indicator{color:var(--mod-accordion-item-header-disabled-color,var(--spectrum-accordion-item-header-disabled-color))}
`;
var accordion_item_css_default = r23;

// node_modules/@spectrum-web-components/accordion/src/AccordionItem.js
var p27 = Object.defineProperty;
var d20 = Object.getOwnPropertyDescriptor;
var s18 = (n25, o52, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? d20(o52, e36) : o52, l16 = n25.length - 1, a23; l16 >= 0; l16--) (a23 = n25[l16]) && (t34 = (i21 ? a23(o52, e36, t34) : a23(t34)) || t34);
  return i21 && t34 && p27(o52, e36, t34), t34;
};
var f9 = { s: () => x`
        <span class="iconContainer">
            <sp-icon-chevron100
                class="indicator spectrum-UIIcon-ChevronRight75"
                slot="icon"
            ></sp-icon-chevron100>
        </span>
    `, m: () => x`
        <span class="iconContainer">
            <sp-icon-chevron100
                class="indicator spectrum-UIIcon-ChevronRight100"
                slot="icon"
            ></sp-icon-chevron100>
        </span>
    `, l: () => x`
        <span class="iconContainer">
            <sp-icon-chevron100
                class="indicator spectrum-UIIcon-ChevronRight200"
                slot="icon"
            ></sp-icon-chevron100>
        </span>
    `, xl: () => x`
        <span class="iconContainer">
            <sp-icon-chevron100
                class="indicator spectrum-UIIcon-ChevronRight300"
                slot="icon"
            ></sp-icon-chevron100>
        </span>
    ` };
var AccordionItem = class extends SizedMixin(Focusable, { noDefaultSize: true }) {
  constructor() {
    super(...arguments);
    this.open = false;
    this.label = "";
    this.disabled = false;
    this.renderChevronIcon = () => f9[this.size || "m"]();
  }
  static get styles() {
    return [accordion_item_css_default, spectrum_icon_chevron_css_default];
  }
  get focusElement() {
    return this.shadowRoot.querySelector("#header");
  }
  onClick() {
    this.disabled || this.toggle();
  }
  toggle() {
    this.open = !this.open, this.dispatchEvent(new CustomEvent("sp-accordion-item-toggle", { bubbles: true, composed: true, cancelable: true })) || (this.open = !this.open);
  }
  render() {
    return x`
            <h3 id="heading">
                ${n9(this.size, this.renderChevronIcon)}
                <button
                    id="header"
                    @click=${this.onClick}
                    aria-expanded=${this.open}
                    aria-controls="content"
                    ?disabled=${this.disabled}
                >
                    ${this.label}
                </button>
            </h3>
            <div id="content" role="region" aria-labelledby="header">
                <slot></slot>
            </div>
        `;
  }
  updated(e36) {
    super.updated(e36), e36.has("disabled") && (this.disabled ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled"));
  }
};
s18([n4({ type: Boolean, reflect: true })], AccordionItem.prototype, "open", 2), s18([n4({ type: String, reflect: true })], AccordionItem.prototype, "label", 2), s18([n4({ type: Boolean, reflect: true })], AccordionItem.prototype, "disabled", 2);

// node_modules/@spectrum-web-components/accordion/sp-accordion-item.js
init_define_element();
defineElement("sp-accordion-item", AccordionItem);

// src/custom-elements/acom/acom-faq.css.js
init_lit();
var acomFaqStyleSheet = i`
  :host {
    display: block;
    box-sizing: border-box;
    width: 100%;
    background: var(--acom-faq-background, transparent);
    border-radius: var(--spectrum-global-dimension-size-100);
  }

  :host([hidden]) {
    display: none !important;
  }

  sp-theme {
    display: block;
    border-radius: inherit;
  }

  .faq {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-500);
    padding: var(--spectrum-global-dimension-size-900)
      var(--spectrum-global-dimension-size-400);
    color: var(--spectrum-body-color);
  }

  .faq-header {
    display: grid;
    gap: var(--spectrum-global-dimension-size-200);
    text-align: center;
    justify-items: center;
    margin: 0 auto;
  }

  slot[name='heading']::slotted(*) {
    margin: 0;
    font-size: var(--spectrum-global-dimension-font-size-600);
    line-height: 1.2;
    color: inherit;
  }

  slot[name='description']::slotted(*) {
    margin: 0;
    font-size: var(--spectrum-alias-body-text-size-m);
    line-height: 1.6;
    color: inherit;
  }

  .faq-accordion-wrapper {
    width: 100%;
    margin: 0 auto;
  }

  .faq-accordion {
    width: 100%;
  }

  slot:not([name]) {
    display: contents !important;
  }
  
  slot:not([name])::slotted(acom-faq-item) {
    display: block;
  }
`;

// src/custom-elements/acom/acom-schema-utils.js
var scriptRefs = /* @__PURE__ */ new WeakMap();
function normalizeBackgroundValue(value, fallback = "transparent") {
  const raw = typeof value === "string" ? value.trim() : "";
  if (!raw) return fallback;
  const lower = raw.toLowerCase();
  if (lower.startsWith("var(") || lower.includes("gradient(") || lower.startsWith("url(") || /^[a-z-]+\(/.test(lower)) {
    return raw;
  }
  if (/^#[0-9a-f]{3,8}$/i.test(raw)) {
    return raw;
  }
  if (/^(rgb|rgba|hsl|hsla|color|lab|lch)\(/i.test(raw)) {
    return raw;
  }
  if (raw.startsWith("--")) {
    return `var(${raw})`;
  }
  return raw;
}
function observeSlots(host, slotNames, callback) {
  const records = [];
  const names = Array.isArray(slotNames) ? slotNames : [slotNames];
  names.forEach((name) => {
    const selector = name ? `slot[name="${name}"]` : "slot:not([name])";
    const slot = host.shadowRoot?.querySelector(selector);
    if (!slot) return;
    slot.addEventListener("slotchange", callback);
    records.push({ slot, callback });
  });
  return records;
}
function disconnectSlotObservers(records) {
  if (!Array.isArray(records)) return;
  records.forEach(({ slot, callback }) => {
    slot?.removeEventListener?.("slotchange", callback);
  });
  records.length = 0;
}
function shouldEmitJsonLd(element) {
  if (!element) return false;
  let current = element;
  while (current) {
    if (current.hasAttribute && current.hasAttribute("data-ee-preview")) {
      return false;
    }
    current = current.parentElement;
  }
  return true;
}
function setJsonLd(element, data, key = "acom") {
  if (!element) return;
  const existingScripts = Array.from(element.children).filter(
    (child) => child.tagName === "SCRIPT" && (child.type === "application/ld+json" || child.hasAttribute("data-ee-jsonld"))
  );
  existingScripts.forEach((script2) => {
    const trackedScript = scriptRefs.get(element);
    if (script2 !== trackedScript) {
      script2.remove();
    }
  });
  let script = scriptRefs.get(element);
  if (!script) {
    script = document.createElement("script");
    script.type = "application/ld+json";
    script.dataset.eeJsonld = key;
    scriptRefs.set(element, script);
    if (element.isConnected) {
      element.appendChild(script);
    }
  } else {
    if (script.dataset.eeJsonld !== key) {
      script.dataset.eeJsonld = key;
    }
    if (!script.isConnected && element.isConnected && !element.contains(script)) {
      element.appendChild(script);
    }
  }
  if (!shouldEmitJsonLd(element) || !data) {
    if (script.textContent) {
      script.textContent = "";
    }
    return;
  }
  try {
    const scriptText = JSON.stringify(data);
    if (scriptText.length > 268435440) {
      console.warn("JSON-LD string too large, skipping", { key, element: element.tagName });
      if (script.textContent) {
        script.textContent = "";
      }
      return;
    }
    if (script.textContent !== scriptText) {
      script.textContent = scriptText;
    }
  } catch (error) {
    if (error instanceof RangeError && error.message.includes("Invalid string length")) {
      console.warn("JSON-LD string too large, skipping", { key, element: element.tagName });
      if (script.textContent) {
        script.textContent = "";
      }
    } else {
      console.error("Failed to set JSON-LD", error, { key, element: element.tagName });
    }
  }
}
function collectSlotText(element, slotName = "") {
  if (!element) return "";
  const isPreview = element.closest && element.closest("[data-ee-preview]");
  const maxLength = isPreview ? 500 : Infinity;
  let nodes2 = [];
  if (!slotName) {
    nodes2 = Array.from(element.childNodes).filter((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.tagName === "SCRIPT") return false;
        return !node.hasAttribute("slot");
      }
      if (node.nodeType === Node.TEXT_NODE) {
        return Boolean(node.textContent && node.textContent.trim());
      }
      return false;
    });
  } else {
    nodes2 = Array.from(element.querySelectorAll(`[slot="${slotName}"]`));
  }
  const text = nodes2.map((node) => (node.textContent || "").trim()).filter(Boolean).join(" ").replace(/\s+/g, " ").trim();
  if (isPreview && text.length > maxLength) {
    return text.substring(0, maxLength) + "...";
  }
  return text;
}
function ensureHeadingId(element, slotName, prefix) {
  if (!element) return null;
  const selector = slotName ? `[slot="${slotName}"]` : ":scope > *:not([slot])";
  let heading = element.querySelector(selector);
  if (!heading && slotName) {
    const slotEl = element.shadowRoot?.querySelector(`slot[name="${slotName}"]`);
    if (slotEl) {
      const assigned = slotEl.assignedNodes({ flatten: true });
      const textNodes = assigned.filter(
        (node) => node.nodeType === Node.TEXT_NODE && node.textContent && node.textContent.trim()
      );
      if (textNodes.length) {
        const wrapper = document.createElement("span");
        wrapper.setAttribute("slot", slotName);
        wrapper.textContent = textNodes.map((node) => node.textContent || "").join(" ").replace(/\s+/g, " ").trim();
        const ref = textNodes[0];
        element.insertBefore(wrapper, ref);
        textNodes.forEach((node) => node.remove());
        heading = wrapper;
      }
    }
  }
  if (!heading && !slotName) {
    const defaultNodes = Array.from(element.childNodes).filter(
      (node) => node.nodeType === Node.TEXT_NODE && node.textContent && node.textContent.trim()
    );
    if (defaultNodes.length) {
      const wrapper = document.createElement("span");
      wrapper.textContent = defaultNodes.map((node) => node.textContent || "").join(" ").replace(/\s+/g, " ").trim();
      element.insertBefore(wrapper, defaultNodes[0]);
      defaultNodes.forEach((node) => node.remove());
      heading = wrapper;
    }
  }
  if (!heading) return null;
  ensureId(heading, prefix);
  return heading.id;
}
function updateRegionAccessibility({
  host,
  container,
  headingSlot = "heading",
  fallbackLabel = "Section",
  idPrefix
}) {
  if (!host) return null;
  const headingId = ensureHeadingId(host, headingSlot, idPrefix);
  if (!container) return headingId;
  if (headingId) {
    container.setAttribute("aria-labelledby", headingId);
    container.removeAttribute("aria-label");
  } else {
    const label = collectSlotText(host, headingSlot) || fallbackLabel;
    container.setAttribute("aria-label", label);
    container.removeAttribute("aria-labelledby");
  }
  return headingId;
}
function emitCreativeWorkJsonLd(host, options) {
  if (!host) return;
  const {
    key,
    type = "CreativeWork",
    headingSlot = "heading",
    descriptionSlots = [],
    actionSlot = "actions",
    priceSelector = "inline-price",
    mediaSlot,
    aboutSlot
  } = options || {};
  const nameOverride = options?.name;
  const name = nameOverride || collectSlotText(host, headingSlot);
  if (!name) {
    setJsonLd(host, null, key);
    return;
  }
  const descriptionOverride = options?.description;
  const description = [descriptionSlots].flat(1).map((slot) => collectSlotText(host, slot)).filter(Boolean).join(" ").trim();
  const finalDescription = [descriptionOverride, description].filter(Boolean).join(" ").trim();
  const actions = actionSlot ? findActionCandidates(host, actionSlot).filter((action) => action.url).map((action) => ({
    "@type": "Action",
    name: action.label || action.url,
    target: {
      "@type": "EntryPoint",
      urlTemplate: action.url
    }
  })) : [];
  const primaryUrl = actions[0]?.target?.urlTemplate || "";
  const priceEl = priceSelector ? host.querySelector(priceSelector) : null;
  const offer = priceSelector ? buildOfferFromInlinePrice(priceEl, primaryUrl) : null;
  const mediaNodes = mediaSlot ? getAssignedNodes(host, mediaSlot) : [];
  const image = mediaSlot ? findFirstImageUrl(mediaNodes) : null;
  const aboutName = aboutSlot ? collectSlotText(host, aboutSlot) : "";
  const json = {
    "@context": "https://schema.org",
    "@type": type,
    name,
    ...finalDescription ? { description: finalDescription } : {},
    ...image ? { image } : {},
    ...actions.length ? { potentialAction: actions } : {},
    ...offer ? { offers: offer } : {},
    ...aboutName ? {
      about: {
        "@type": "Thing",
        name: aboutName
      }
    } : {},
    ...options?.url ? { url: options.url } : {}
  };
  if (options?.includeHeadline !== false && type === "CreativeWork") {
    json.headline = name;
  }
  setJsonLd(host, json, key || type.toLowerCase());
}
function emitItemListJsonLd(host, key, items) {
  if (!host) return;
  const filtered = (items || []).filter((item) => item && item.name);
  if (!filtered.length) {
    setJsonLd(host, null, key);
    return;
  }
  const json = {
    "@context": "https://schema.org",
    "@type": "ItemList",
    itemListElement: filtered.map((item, index) => ({
      "@type": "CreativeWork",
      position: item.position ?? index + 1,
      name: item.name,
      ...item.description ? { description: item.description } : {},
      ...item.url ? { url: item.url } : {}
    }))
  };
  setJsonLd(host, json, key || "item-list");
}
function findFirstImageUrl(nodes2) {
  for (const node of nodes2) {
    if (node.nodeType !== Node.ELEMENT_NODE) continue;
    if (node.tagName === "IMG" && node.getAttribute("src")) {
      return node.getAttribute("src");
    }
    const img = node.querySelector("img[src]");
    if (img) return img.getAttribute("src");
  }
  return null;
}
function getAssignedNodes(element, slotName) {
  if (!element?.shadowRoot) return [];
  const selector = slotName ? `slot[name="${slotName}"]` : "slot:not([name])";
  const slot = element.shadowRoot.querySelector(selector);
  if (!slot) return [];
  return slot.assignedNodes({ flatten: true });
}
function findActionCandidates(element, slotName = "actions") {
  const selector = slotName ? `[slot="${slotName}"]` : ":scope > *:not([slot])";
  const nodes2 = Array.from(element.querySelectorAll(selector));
  return nodes2.flatMap((node) => {
    if (node.tagName === "CHECKOUT-BUTTON") {
      const label = (node.textContent || "").replace(/\s+/g, " ").trim();
      const url = node.getAttribute("href") || "";
      return [{ label, url }];
    }
    if (node.tagName === "A") {
      const label = (node.textContent || "").replace(/\s+/g, " ").trim();
      const url = node.getAttribute("href") || "";
      return [{ label, url }];
    }
    const links = Array.from(node.querySelectorAll("a[href]")).map((anchor) => ({
      label: (anchor.textContent || "").replace(/\s+/g, " ").trim(),
      url: anchor.getAttribute("href") || ""
    }));
    return links;
  });
}
function buildOfferFromInlinePrice(priceEl, url) {
  if (!priceEl) return null;
  const price = priceEl.getAttribute("value");
  if (!price) return null;
  const currencyRaw = priceEl.getAttribute("currency") || "";
  const currency = currencyRaw.replace(/[^\p{L}]/gu, "").toUpperCase() || "USD";
  const offer = {
    "@type": "Offer",
    price,
    priceCurrency: currency
  };
  if (url) offer.url = url;
  return offer;
}

// src/utils/theme-helpers.js
var VALID_THEMES = /* @__PURE__ */ new Set(["light", "dark"]);
function normalizeTheme(theme) {
  if (!theme || !VALID_THEMES.has(theme)) {
    return void 0;
  }
  return theme;
}

// src/custom-elements/acom/acom-faq.js
var AcomFaq = class extends i4 {
  static styles = [acomFaqStyleSheet];
  static properties = {
    backgroundColor: { type: String, attribute: "background-color" },
    ariaLabel: { type: String, attribute: "aria-label" },
    theme: { type: String, reflect: true },
    expandAll: {
      type: Boolean,
      attribute: "expand-all",
      converter: booleanConverter
    }
  };
  #slotObservers;
  #onFaqItemUpdated;
  #itemsSlot = null;
  #jsonLdUpdateScheduled = false;
  #normalizeTheme() {
    this.theme = normalizeTheme(this.theme);
  }
  #applyBackgroundColor() {
    const backgroundValue = normalizeBackgroundValue(this.backgroundColor, "");
    this.style.setProperty("--acom-faq-background", backgroundValue || "");
  }
  constructor() {
    super();
    this.backgroundColor = "";
    this.expandAll = false;
    this.theme = "";
    this.#slotObservers = [];
    this.#onFaqItemUpdated = () => {
      this.#scheduleJsonLdUpdate();
    };
    ensureId(this, "acom-faq");
  }
  connectedCallback() {
    super.connectedCallback();
    this.#applyBackgroundColor();
    this.addEventListener("acom-faq-item-updated", this.#onFaqItemUpdated);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    disconnectSlotObservers(this.#slotObservers);
    this.removeEventListener("acom-faq-item-updated", this.#onFaqItemUpdated);
    setJsonLd(this, null, "acom-faq");
  }
  firstUpdated() {
    this.#slotObservers = observeSlots(this, ["heading"], () => this.#updateAccessibility());
    this.#updateAccessibility();
    this.#itemsSlot = this.shadowRoot?.querySelector(`#${this.id}-items-slot`);
    this.#scheduleJsonLdUpdate();
  }
  updated(changedProperties) {
    if (changedProperties.has("ariaLabel")) {
      this.#updateAccessibility();
    }
    if (changedProperties.has("theme")) {
      this.#normalizeTheme();
    }
    if (changedProperties.has("backgroundColor")) {
      this.#applyBackgroundColor();
    }
    if (changedProperties.has("expandAll")) {
      if (this.expandAll) {
        this.#expandAllItems();
      } else {
        this.#collapseAllItems();
      }
    }
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback?.(name, oldValue, newValue);
    if (name === "expand-all") {
      if (newValue === "true") {
        this.#expandAllItems();
      } else {
        this.#collapseAllItems();
      }
    }
  }
  #expandAllItems() {
    const slot = this.#itemsSlot || this.shadowRoot?.querySelector(`#${this.id}-items-slot`);
    if (!slot) return;
    const items = slot.assignedElements({ flatten: true }).filter((el) => el.tagName === "ACOM-FAQ-ITEM");
    items.forEach((item) => {
      if (item.openState === "inherit") {
        item.open = true;
        item.setAttribute("open", "");
      } else if (item.openState === "true") {
        item.open = true;
        item.setAttribute("open", "");
      }
    });
  }
  #collapseAllItems() {
    const slot = this.#itemsSlot || this.shadowRoot?.querySelector(`#${this.id}-items-slot`);
    if (!slot) return;
    const items = slot.assignedElements({ flatten: true }).filter((el) => el.tagName === "ACOM-FAQ-ITEM");
    items.forEach((item) => {
      if (item.openState === "inherit") {
        item.removeAttribute("open");
        item.open = false;
      } else if (item.openState === "false") {
        item.removeAttribute("open");
        item.open = false;
      }
    });
  }
  render() {
    const faqContent = x`
      <section
        id="${this.id}-section"
        class="faq"
        role="region"
      >
        <div class="faq-header">
          <slot name="heading"></slot>
          <slot name="description"></slot>
        </div>
        <div class="faq-accordion-wrapper">
          <sp-accordion
            class="faq-accordion"
            id="${this.id}-accordion"
            size="l"
            allow-multiple
          >
            <slot
              id="${this.id}-items-slot"
              @slotchange=${this.#handleSlotChange}
            ></slot>
          </sp-accordion>
        </div>
      </section>
    `;
    if (this.theme === "dark" || this.theme === "light") {
      return x`
        <sp-theme color="${this.theme}" scale="medium" system="spectrum-two">
          ${faqContent}
        </sp-theme>
      `;
    }
    return faqContent;
  }
  #updateAccessibility() {
    const container = this.shadowRoot?.getElementById(`${this.id}-section`);
    updateRegionAccessibility({
      host: this,
      container,
      headingSlot: "heading",
      fallbackLabel: this.ariaLabel || "Frequently asked questions",
      idPrefix: `${this.id}-heading`
    });
  }
  #handleSlotChange(event) {
    this.#scheduleJsonLdUpdate();
  }
  #scheduleJsonLdUpdate() {
    if (this.#jsonLdUpdateScheduled) return;
    this.#jsonLdUpdateScheduled = true;
    requestAnimationFrame(() => {
      this.#updateJsonLd();
      this.#jsonLdUpdateScheduled = false;
    });
  }
  #updateJsonLd() {
    const slot = this.#itemsSlot || this.shadowRoot?.querySelector(`#${this.id}-items-slot`);
    if (!slot) {
      setJsonLd(this, null, "acom-faq");
      return;
    }
    const items = slot.assignedElements({ flatten: true }).filter((el) => el.tagName === "ACOM-FAQ-ITEM");
    if (!items.length) {
      setJsonLd(this, null, "acom-faq");
      return;
    }
    const mainEntity = items.map((item, index) => {
      const question = this.#getItemQuestion(item, index, false);
      const answer = this.#getItemAnswer(item);
      if (!question || !answer) return null;
      return {
        "@type": "Question",
        name: question,
        acceptedAnswer: {
          "@type": "Answer",
          text: answer
        }
      };
    }).filter(Boolean);
    if (!mainEntity.length) {
      setJsonLd(this, null, "acom-faq");
      return;
    }
    const json = {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      mainEntity
    };
    setJsonLd(this, json, "acom-faq");
  }
  #getItemQuestion(item, index, withFallback = true) {
    if (!item) {
      return withFallback ? `Question ${index + 1}` : "";
    }
    const hasDescription = this.#itemHasDescription(item);
    const slotText = hasDescription ? collectSlotText(item, "title") : null;
    const attrValue = item.getAttribute("question") || item.question || "";
    const raw = hasDescription ? slotText || attrValue : attrValue || collectSlotText(item, "title");
    const normalized = String(raw || "").replace(/\s+/g, " ").trim();
    if (normalized) return normalized;
    return withFallback ? `Question ${index + 1}` : "";
  }
  #getItemAnswer(item) {
    if (!item) return "";
    const hasDescription = this.#itemHasDescription(item);
    if (hasDescription) {
      const text = collectSlotText(item, "description");
      return String(text || "").replace(/\s+/g, " ").trim();
    }
    const fallback = collectSlotText(item, "title");
    return String(fallback || "").replace(/\s+/g, " ").trim();
  }
  #itemHasDescription(item) {
    if (!item) return false;
    if (item.hasAttribute("has-description")) return true;
    if (typeof item.querySelector === "function") {
      return !!item.querySelector(':scope > [slot="description"]');
    }
    return false;
  }
};
customElements.define("acom-faq", AcomFaq);

// src/experience-elements-home-new.js
init_sp_progress_circle();

// node_modules/@spectrum-web-components/tabs/src/Tabs.js
init_src();
init_decorators2();
init_directives();

// node_modules/@lit-labs/observers/intersection-controller.js
var t33 = class {
  constructor(t34, { target: s19, config: i21, callback: h16, skipInitial: e36 }) {
    this.t = /* @__PURE__ */ new Set(), this.o = false, this.i = false, this.h = t34, null !== s19 && this.t.add(s19 ?? t34), this.o = e36 ?? this.o, this.callback = h16, window.IntersectionObserver ? (this.u = new IntersectionObserver((t35) => {
      const s20 = this.i;
      this.i = false, this.o && s20 || (this.handleChanges(t35), this.h.requestUpdate());
    }, i21), t34.addController(this)) : console.warn("IntersectionController error: browser does not support IntersectionObserver.");
  }
  handleChanges(t34) {
    this.value = this.callback?.(t34, this.u);
  }
  hostConnected() {
    for (const t34 of this.t) this.observe(t34);
  }
  hostDisconnected() {
    this.disconnect();
  }
  async hostUpdated() {
    const t34 = this.u.takeRecords();
    t34.length && this.handleChanges(t34);
  }
  observe(t34) {
    this.t.add(t34), this.u.observe(t34), this.i = true;
  }
  unobserve(t34) {
    this.t.delete(t34), this.u.unobserve(t34);
  }
  disconnect() {
    this.u.disconnect();
  }
};

// node_modules/@spectrum-web-components/tabs/src/Tabs.js
init_src2();

// node_modules/@spectrum-web-components/tabs/src/tabs.css.js
init_src();
var o49 = i`
    #list{--spectrum-tabs-item-height:var(--spectrum-tab-item-height-medium);--spectrum-tabs-item-horizontal-spacing:var(--spectrum-tab-item-to-tab-item-horizontal-medium);--spectrum-tabs-item-vertical-spacing:var(--spectrum-tab-item-to-tab-item-vertical-medium);--spectrum-tabs-start-to-edge:var(--spectrum-tab-item-start-to-edge-medium);--spectrum-tabs-top-to-text:var(--spectrum-tab-item-top-to-text-medium);--spectrum-tabs-bottom-to-text:var(--spectrum-tab-item-bottom-to-text-medium);--spectrum-tabs-icon-size:var(--spectrum-workflow-icon-size-75);--spectrum-tabs-icon-to-text:var(--spectrum-text-to-visual-100);--spectrum-tabs-top-to-icon:var(--spectrum-tab-item-top-to-workflow-icon-medium);--spectrum-tabs-color:var(--spectrum-neutral-subdued-content-color-default);--spectrum-tabs-color-selected:var(--spectrum-neutral-subdued-content-color-down);--spectrum-tabs-color-hover:var(--spectrum-neutral-subdued-content-color-hover);--spectrum-tabs-color-key-focus:var(--spectrum-neutral-subdued-content-color-key-focus);--spectrum-tabs-color-disabled:var(--spectrum-gray-500);--spectrum-tabs-font-family:var(--spectrum-sans-font-family-stack);--spectrum-tabs-font-style:var(--spectrum-default-font-style);--spectrum-tabs-font-size:var(--spectrum-font-size-100);--spectrum-tabs-line-height:var(--spectrum-line-height-100);--spectrum-tabs-focus-indicator-width:var(--spectrum-focus-indicator-thickness);--spectrum-tabs-focus-indicator-border-radius:var(--spectrum-corner-radius-100);--spectrum-tabs-focus-indicator-gap:var(--spectrum-tab-item-focus-indicator-gap-medium);--spectrum-tabs-focus-indicator-color:var(--spectrum-focus-indicator-color);--spectrum-tabs-selection-indicator-color:var(--spectrum-neutral-subdued-content-color-down);--spectrum-tabs-list-background-direction:top;--spectrum-tabs-divider-size:var(--spectrum-border-width-200);--spectrum-tabs-divider-border-radius:1px;--spectrum-tabs-animation-duration:var(--spectrum-animation-duration-100);--spectrum-tabs-animation-ease:var(--spectrum-animation-ease-in-out)}:host([emphasized]) #list{--mod-tabs-color-selected:var(--mod-tabs-color-selected-emphasized,var(--spectrum-accent-content-color-default));--mod-tabs-color-hover:var(--mod-tabs-color-hover-emphasized,var(--spectrum-accent-content-color-hover));--mod-tabs-color-key-focus:var(--mod-tabs-color-key-focus-emphasized,var(--spectrum-accent-content-color-key-focus));--mod-tabs-selection-indicator-color:var(--mod-tabs-selection-indicator-color-emphasized,var(--spectrum-accent-content-color-default))}:host([direction^=vertical]) #list{--mod-tabs-list-background-direction:var(--mod-tabs-list-background-direction-vertical,right)}:host([direction^=vertical-right]) #list{--mod-tabs-list-background-direction:var(--mod-tabs-list-background-direction-vertical-right,left)}:host([direction^=vertical]) #list:dir(rtl),:host([dir=rtl][direction^=vertical]) #list{--mod-tabs-list-background-direction:var(--mod-tabs-list-background-direction-vertical,left)}:host([direction^=vertical-right]) #list:dir(rtl),:host([dir=rtl][direction^=vertical-right]) #list{--mod-tabs-list-background-direction:var(--mod-tabs-list-background-direction-vertical,right)}:host([compact]) #list{--mod-tabs-item-height:var(--mod-tabs-item-height-compact,var(--spectrum-tab-item-compact-height-medium));--mod-tabs-top-to-text:var(--mod-tabs-top-to-text-compact,var(--spectrum-tab-item-top-to-text-compact-medium));--mod-tabs-bottom-to-text:var(--mod-tabs-bottom-to-text-compact,var(--spectrum-tab-item-top-to-text-compact-medium));--mod-tabs-top-to-icon:var(--mod-tabs-top-to-icon-compact,var(--spectrum-tab-item-top-to-workflow-icon-compact-medium))}#list{z-index:0;vertical-align:top;background:linear-gradient(to var(--mod-tabs-list-background-direction,var(--spectrum-tabs-list-background-direction)),var(--highcontrast-tabs-divider-background-color,var(--mod-tabs-divider-background-color,var(--spectrum-tabs-divider-background-color)))0 var(--mod-tabs-divider-size,var(--spectrum-tabs-divider-size)),transparent var(--mod-tabs-divider-size,var(--spectrum-tabs-divider-size)));margin:0;padding-block:0;display:flex;position:relative}::slotted([selected]:not([slot])){color:var(--highcontrast-tabs-color-selected,var(--mod-tabs-color-selected,var(--spectrum-tabs-color-selected)))}::slotted([disabled]:not([slot])){cursor:default;color:var(--highcontrast-tabs-color-disabled,var(--mod-tabs-color-disabled,var(--spectrum-tabs-color-disabled)))}#selection-indicator{background-color:var(--highcontrast-tabs-selection-indicator-color,var(--mod-tabs-selection-indicator-color,var(--spectrum-tabs-selection-indicator-color)));z-index:0;transition:transform var(--mod-tabs-animation-duration,var(--spectrum-tabs-animation-duration))var(--mod-tabs-animation-ease,var(--spectrum-tabs-animation-ease));transform-origin:0 0;border-radius:var(--mod-tabs-divider-border-radius,var(--spectrum-tabs-divider-border-radius));position:absolute;inset-inline-start:0}:host([direction^=horizontal]) #list{align-items:center}:host([direction^=horizontal]) #list ::slotted(:not([slot])){vertical-align:top}:host([direction^=horizontal]) ::slotted(:not(:first-child)){margin-inline-start:var(--mod-tabs-item-horizontal-spacing,var(--spectrum-tabs-item-horizontal-spacing))}:host([direction^=horizontal]) #list #selection-indicator{block-size:var(--mod-tabs-divider-size,var(--spectrum-tabs-divider-size));position:absolute;inset-block-end:0}:host([direction^=horizontal][compact]) #list{box-sizing:initial;align-items:end}:host([quiet]) #list{background:0 0;border-color:#0000;display:inline-flex}:host([quiet]) #selection-indicator{padding-inline-start:var(--mod-tabs-start-to-item-quiet)}:host([direction^=vertical]) #list,:host([direction^=vertical-right]) #list{flex-direction:column;padding:0;display:inline-flex}:host([direction^=vertical-right][quiet]) #list,:host([direction^=vertical][quiet]) #list{border-color:#0000}:host([direction^=vertical]) #list ::slotted(:not([slot])),:host([direction^=vertical-right]) #list ::slotted(:not([slot])){block-size:var(--mod-tabs-item-height,var(--spectrum-tabs-item-height));line-height:var(--mod-tabs-item-height,var(--spectrum-tabs-item-height));margin-block-end:var(--mod-tabs-item-vertical-spacing,var(--spectrum-tabs-item-vertical-spacing));margin-inline-start:var(--mod-tabs-start-to-edge,var(--spectrum-tabs-start-to-edge));margin-inline-end:var(--mod-tabs-start-to-edge,var(--spectrum-tabs-start-to-edge));padding-block:0}:host([direction^=vertical]) #list ::slotted(:not([slot])):before,:host([direction^=vertical-right]) #list ::slotted(:not([slot])):before{inset-inline-start:calc(var(--mod-tabs-focus-indicator-gap,var(--spectrum-tabs-focus-indicator-gap))*-1)}:host([direction^=vertical]) #list #selection-indicator,:host([direction^=vertical-right]) #list #selection-indicator{inline-size:var(--mod-tabs-divider-size,var(--spectrum-tabs-divider-size));position:absolute;inset-block-start:0;inset-inline-start:0}:host([direction^=vertical-right]) #list #selection-indicator{inset-inline:auto 0}@media (forced-colors:active){#list{--highcontrast-tabs-divider-background-color:var(--spectrum-gray-500);--highcontrast-tabs-selection-indicator-color:Highlight;--highcontrast-tabs-focus-indicator-color:CanvasText;--highcontrast-tabs-focus-indicator-background-color:Highlight;--highcontrast-tabs-color:ButtonText;--highcontrast-tabs-color-hover:ButtonText;--highcontrast-tabs-color-selected:HighlightText;--highcontrast-tabs-color-key-focus:ButtonText;--highcontrast-tabs-color-disabled:GrayText;forced-color-adjust:none}#list ::slotted([selected]:not([slot])):before{background-color:var(--highcontrast-tabs-focus-indicator-background-color)}:host([direction^=vertical][compact]) #list #list ::slotted(:not([slot])):before{block-size:100%;inset-block-start:0}:host([quiet]) #list{background:linear-gradient(to var(--mod-tabs-list-background-direction,var(--spectrum-tabs-list-background-direction)),var(--highcontrast-tabs-divider-background-color,var(--mod-tabs-divider-background-color,var(--spectrum-tabs-divider-background-color)))0 var(--mod-tabs-divider-size,var(--spectrum-tabs-divider-size)),transparent var(--mod-tabs-divider-size,var(--spectrum-tabs-divider-size)))}}#list{--spectrum-tabs-font-weight:var(--system-tabs-font-weight);--spectrum-tabs-divider-background-color:var(--system-tabs-divider-background-color)}:host{grid-template-columns:100%;display:grid;position:relative}:host(:not([direction^=vertical])){grid-template-rows:auto 1fr}:host([direction^=vertical]){grid-template-columns:auto 1fr}:host([dir=rtl]) #selection-indicator{left:0;right:auto}:host([direction=vertical-right]) #list #selection-indicator{inset-inline:auto 0}#list{justify-content:var(--swc-tabs-list-justify-content)}:host([disabled]) #list{pointer-events:none}:host([disabled]) #list #selection-indicator{background-color:var(--mod-tabs-color-disabled,var(--spectrum-tabs-color-disabled))}:host([disabled]) ::slotted(sp-tab){color:var(--mod-tabs-color-disabled,var(--spectrum-tabs-color-disabled))}:host([direction=vertical-right]) #list #selection-indicator,:host([direction=vertical]) #list #selection-indicator{inset-block-start:0}#selection-indicator.first-position{transition:none}:host([dir][direction=horizontal]) #list.scroll{scrollbar-width:none;overflow:auto hidden}:host([dir][direction=horizontal]) #list.scroll::-webkit-scrollbar{display:none}
`;
var tabs_css_default = o49;

// node_modules/@spectrum-web-components/tabs/src/tabs-sizes.css.js
init_src();
var a22 = i`
    :host([size=s]) #list{--spectrum-tabs-item-height:var(--spectrum-tab-item-height-small);--spectrum-tabs-item-horizontal-spacing:var(--spectrum-tab-item-to-tab-item-horizontal-small);--spectrum-tabs-item-vertical-spacing:var(--spectrum-tab-item-to-tab-item-vertical-small);--spectrum-tabs-start-to-edge:var(--spectrum-tab-item-start-to-edge-small);--spectrum-tabs-top-to-text:var(--spectrum-tab-item-top-to-text-small);--spectrum-tabs-bottom-to-text:var(--spectrum-tab-item-bottom-to-text-small);--spectrum-tabs-icon-size:var(--spectrum-workflow-icon-size-50);--spectrum-tabs-icon-to-text:var(--spectrum-text-to-visual-75);--spectrum-tabs-top-to-icon:var(--spectrum-tab-item-top-to-workflow-icon-small);--spectrum-tabs-focus-indicator-gap:var(--spectrum-tab-item-focus-indicator-gap-small);--spectrum-tabs-font-size:var(--spectrum-font-size-75)}:host([size=l]) #list{--spectrum-tabs-item-height:var(--spectrum-tab-item-height-large);--spectrum-tabs-item-horizontal-spacing:var(--spectrum-tab-item-to-tab-item-horizontal-large);--spectrum-tabs-item-vertical-spacing:var(--spectrum-tab-item-to-tab-item-vertical-large);--spectrum-tabs-start-to-edge:var(--spectrum-tab-item-start-to-edge-large);--spectrum-tabs-top-to-text:var(--spectrum-tab-item-top-to-text-large);--spectrum-tabs-bottom-to-text:var(--spectrum-tab-item-bottom-to-text-large);--spectrum-tabs-icon-size:var(--spectrum-workflow-icon-size-100);--spectrum-tabs-icon-to-text:var(--spectrum-text-to-visual-200);--spectrum-tabs-top-to-icon:var(--spectrum-tab-item-top-to-workflow-icon-large);--spectrum-tabs-focus-indicator-gap:var(--spectrum-tab-item-focus-indicator-gap-large);--spectrum-tabs-font-size:var(--spectrum-font-size-200)}:host([size=xl]) #list{--spectrum-tabs-item-height:var(--spectrum-tab-item-height-extra-large);--spectrum-tabs-item-horizontal-spacing:var(--spectrum-tab-item-to-tab-item-horizontal-extra-large);--spectrum-tabs-item-vertical-spacing:var(--spectrum-tab-item-to-tab-item-vertical-extra-large);--spectrum-tabs-start-to-edge:var(--spectrum-tab-item-start-to-edge-extra-large);--spectrum-tabs-top-to-text:var(--spectrum-tab-item-top-to-text-extra-large);--spectrum-tabs-bottom-to-text:var(--spectrum-tab-item-bottom-to-text-extra-large);--spectrum-tabs-icon-size:var(--spectrum-workflow-icon-size-200);--spectrum-tabs-icon-to-text:var(--spectrum-text-to-visual-300);--spectrum-tabs-top-to-icon:var(--spectrum-tab-item-top-to-workflow-icon-extra-large);--spectrum-tabs-focus-indicator-gap:var(--spectrum-tab-item-focus-indicator-gap-extra-large);--spectrum-tabs-font-size:var(--spectrum-font-size-300)}:host([size=s]) #list.spectrum-Tabs--compact{--mod-tabs-item-height:var(--mod-tabs-item-height-compact,var(--spectrum-tab-item-compact-height-small));--mod-tabs-top-to-text:var(--mod-tabs-top-to-text-compact,var(--spectrum-tab-item-top-to-text-compact-small));--mod-tabs-bottom-to-text:var(--mod-tabs-bottom-to-text-compact,var(--spectrum-tab-item-top-to-text-compact-small));--mod-tabs-top-to-icon:var(--mod-tabs-top-to-icon-compact,var(--spectrum-tab-item-top-to-workflow-icon-compact-small))}:host([size=l]) #list.spectrum-Tabs--compact{--mod-tabs-item-height:var(--mod-tabs-item-height-compact,var(--spectrum-tab-item-compact-height-large));--mod-tabs-top-to-text:var(--mod-tabs-top-to-text-compact,var(--spectrum-tab-item-top-to-text-compact-large));--mod-tabs-bottom-to-text:var(--mod-tabs-bottom-to-text-compact,var(--spectrum-tab-item-top-to-text-compact-large));--mod-tabs-top-to-icon:var(--mod-tabs-top-to-icon-compact,var(--spectrum-tab-item-top-to-workflow-icon-compact-large))}:host([size=xl]) #list.spectrum-Tabs--compact{--mod-tabs-item-height:var(--mod-tabs-item-height-compact,var(--spectrum-tab-item-compact-height-extra-large));--mod-tabs-top-to-text:var(--mod-tabs-top-to-text-compact,var(--spectrum-tab-item-top-to-text-compact-extra-large));--mod-tabs-bottom-to-text:var(--mod-tabs-bottom-to-text-compact,var(--spectrum-tab-item-top-to-text-compact-extra-large));--mod-tabs-top-to-icon:var(--mod-tabs-top-to-icon-compact,var(--spectrum-tab-item-top-to-workflow-icon-compact-extra-large))}
`;
var tabs_sizes_css_default = a22;

// node_modules/@spectrum-web-components/tabs/src/Tabs.js
var f10 = Object.defineProperty;
var p28 = Object.getOwnPropertyDescriptor;
var o50 = (a23, l16, t34, e36) => {
  for (var i21 = e36 > 1 ? void 0 : e36 ? p28(l16, t34) : l16, s19 = a23.length - 1, r25; s19 >= 0; s19--) (r25 = a23[s19]) && (i21 = (e36 ? r25(l16, t34, i21) : r25(i21)) || i21);
  return e36 && i21 && f10(l16, t34, i21), i21;
};
var ScaledIndicator = { baseSize: 100, noSelectionStyle: "transform: translateX(0px) scaleX(0) scaleY(0)", transformX(a23, l16) {
  const t34 = l16 / this.baseSize;
  return `transform: translateX(${a23}px) scaleX(${t34});`;
}, transformY(a23, l16) {
  const t34 = l16 / this.baseSize;
  return `transform: translateY(${a23}px) scaleY(${t34});`;
}, baseStyles() {
  return i`
            :host([direction='vertical-right']) #selection-indicator,
            :host([direction='vertical']) #selection-indicator {
                height: ${this.baseSize}px;
            }
            :host([dir][direction='horizontal']) #selection-indicator {
                width: ${this.baseSize}px;
            }
        `;
} };
function calculateScrollTargetForRightSide(a23, l16, t34, e36) {
  const i21 = a23 + (l16 === "rtl" ? -1 : 1), s19 = t34[i21], r25 = e36.scrollLeft + e36.offsetWidth;
  return s19 ? s19.offsetLeft - e36.offsetWidth : r25;
}
function calculateScrollTargetForLeftSide(a23, l16, t34, e36) {
  const i21 = a23 + (l16 === "rtl" ? 1 : -1), s19 = t34[i21], r25 = l16 === "rtl" ? -e36.offsetWidth : 0;
  return s19 ? s19.offsetLeft + s19.offsetWidth : r25;
}
var Tabs = class extends SizedMixin(Focusable, { noDefaultSize: true }) {
  constructor() {
    super();
    this.auto = false;
    this.compact = false;
    this.direction = "horizontal";
    this.emphasized = false;
    this.label = "";
    this.enableTabsScroll = false;
    this.quiet = false;
    this.selectionIndicatorStyle = ScaledIndicator.noSelectionStyle;
    this.shouldAnimate = false;
    this.selected = "";
    this._tabs = [];
    this.resizeController = new s12(this, { callback: () => {
      this.updateSelectionIndicator();
    } });
    this.rovingTabindexController = new RovingTabindexController(this, { focusInIndex: (t34) => {
      let e36 = 0;
      return t34.find((s19, r25) => {
        const c33 = this.selected ? s19.value === this.selected : !s19.disabled;
        return e36 = r25, c33;
      }) ? e36 : -1;
    }, direction: () => "both", elementEnterAction: (t34) => {
      this.auto && (this.shouldAnimate = true, this.selectTarget(t34));
    }, elements: () => this.tabs, isFocusableElement: (t34) => !this.disabled && !t34.disabled, listenerScope: () => this.tabList });
    this.onTabsScroll = () => {
      this.dispatchEvent(new Event("sp-tabs-scroll", { bubbles: true, composed: true }));
    };
    this.onClick = (t34) => {
      if (this.disabled) return;
      const e36 = t34.composedPath().find((i21) => i21.parentElement === this);
      !e36 || e36.disabled || (this.shouldAnimate = true, this.selectTarget(e36));
    };
    this.onKeyDown = (t34) => {
      if (t34.code === "Enter" || t34.code === "Space") {
        t34.preventDefault();
        const e36 = t34.target;
        e36 && this.selectTarget(e36);
      }
    };
    this.updateCheckedState = () => {
      if (this.tabs.forEach((t34) => {
        t34.removeAttribute("selected");
      }), this.selected) {
        const t34 = this.tabs.find((e36) => e36.value === this.selected);
        t34 ? t34.selected = true : this.selected = "";
      } else {
        const t34 = this.tabs[0];
        t34 && t34.setAttribute("tabindex", "0");
      }
      this.updateSelectionIndicator();
    };
    this.updateSelectionIndicator = async () => {
      const t34 = this.tabs.find((s19) => s19.selected);
      if (!t34) {
        this.selectionIndicatorStyle = ScaledIndicator.noSelectionStyle;
        return;
      }
      await Promise.all([t34.updateComplete, document.fonts ? document.fonts.ready : Promise.resolve()]);
      const { width: e36, height: i21 } = t34.getBoundingClientRect();
      this.selectionIndicatorStyle = this.direction === "horizontal" ? ScaledIndicator.transformX(t34.offsetLeft, e36) : ScaledIndicator.transformY(t34.offsetTop, i21);
    };
    new t33(this, { config: { root: null, rootMargin: "0px", threshold: [0, 1] }, callback: () => {
      this.updateSelectionIndicator();
    } });
  }
  static get styles() {
    return [tabs_sizes_css_default, tabs_css_default, ScaledIndicator.baseStyles()];
  }
  set tabs(t34) {
    t34 !== this.tabs && (this._tabs.forEach((e36) => {
      this.resizeController.unobserve(e36);
    }), t34.forEach((e36) => {
      this.resizeController.observe(e36);
    }), this._tabs = t34, this.rovingTabindexController.clearElementCache());
  }
  get tabs() {
    return this._tabs;
  }
  get focusElement() {
    return this.rovingTabindexController.focusInElement || this;
  }
  limitDeltaToInterval(t34, e36) {
    return (i21) => i21 < t34 ? t34 : i21 > e36 ? e36 : i21;
  }
  scrollTabs(t34, e36 = "smooth") {
    var d22;
    if (t34 === 0) return;
    const { scrollLeft: i21, clientWidth: s19, scrollWidth: r25 } = this.tabList, c33 = r25 - s19 - Math.abs(i21), b12 = this.dir === "ltr" ? this.limitDeltaToInterval(-i21, c33) : this.limitDeltaToInterval(-c33, Math.abs(i21));
    (d22 = this.tabList) == null || d22.scrollBy({ left: b12(t34), top: 0, behavior: e36 });
  }
  get scrollState() {
    if (this.tabList) {
      const { scrollLeft: t34, clientWidth: e36, scrollWidth: i21 } = this.tabList, s19 = Math.abs(t34) > 0, r25 = Math.ceil(Math.abs(t34)) < i21 - e36;
      return { canScrollLeft: this.dir === "ltr" ? s19 : r25, canScrollRight: this.dir === "ltr" ? r25 : s19 };
    }
    return {};
  }
  async getUpdateComplete() {
    const t34 = await super.getUpdateComplete(), i21 = [...this.children].map((s19) => typeof s19.updateComplete != "undefined" ? s19.updateComplete : Promise.resolve(true));
    return await Promise.all(i21), t34;
  }
  getNecessaryAutoScroll(t34) {
    const e36 = this.tabs[t34], i21 = e36.offsetLeft + e36.offsetWidth, s19 = this.tabList.scrollLeft + this.tabList.offsetWidth, r25 = e36.offsetLeft, c33 = this.tabList.scrollLeft;
    return i21 > s19 ? calculateScrollTargetForRightSide(t34, this.dir, this.tabs, this.tabList) : r25 < c33 ? calculateScrollTargetForLeftSide(t34, this.dir, this.tabs, this.tabList) : -1;
  }
  async scrollToSelection() {
    if (!this.enableTabsScroll || !this.selected) return;
    await this.updateComplete;
    const t34 = this.tabs.findIndex((e36) => e36.value === this.selected);
    if (t34 !== -1 && this.tabList) {
      const e36 = this.getNecessaryAutoScroll(t34);
      e36 !== -1 && this.tabList.scrollTo({ left: e36 });
    }
  }
  updated(t34) {
    super.updated(t34), t34.has("selected") && this.scrollToSelection();
  }
  managePanels({ target: t34 }) {
    t34.assignedElements().map((i21) => {
      const { value: s19, id: r25 } = i21, c33 = this.querySelector(`[role="tab"][value="${s19}"]`);
      c33 && (c33.setAttribute("aria-controls", r25), i21.setAttribute("aria-labelledby", c33.id)), i21.selected = s19 === this.selected;
    });
  }
  render() {
    return x`
            <div
                class=${e10({ scroll: this.enableTabsScroll })}
                aria-label=${o9(this.label ? this.label : void 0)}
                @click=${this.onClick}
                @keydown=${this.onKeyDown}
                @scroll=${this.onTabsScroll}
                id="list"
                role="tablist"
                part="tablist"
            >
                <slot @slotchange=${this.onSlotChange}></slot>
                <div
                    id="selection-indicator"
                    class=${o9(this.shouldAnimate ? void 0 : "first-position")}
                    style=${this.selectionIndicatorStyle}
                    role="presentation"
                ></div>
            </div>
            <slot name="tab-panel" @slotchange=${this.managePanels}></slot>
        `;
  }
  willUpdate(t34) {
    if (!this.hasUpdated) {
      const e36 = this.querySelector(":scope > [selected]");
      e36 && this.selectTarget(e36);
    }
    if (super.willUpdate(t34), t34.has("selected")) {
      if (this.tabs.length && this.updateCheckedState(), t34.get("selected")) {
        const i21 = this.querySelector(`[role="tabpanel"][value="${t34.get("selected")}"]`);
        i21 && (i21.selected = false);
      }
      const e36 = this.querySelector(`[role="tabpanel"][value="${this.selected}"]`);
      e36 && (e36.selected = true);
    }
    t34.has("direction") && (this.direction === "horizontal" ? this.removeAttribute("aria-orientation") : this.setAttribute("aria-orientation", "vertical")), t34.has("dir") && this.updateSelectionIndicator(), t34.has("disabled") && (this.disabled ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled")), !this.shouldAnimate && typeof t34.get("shouldAnimate") != "undefined" && (this.shouldAnimate = true);
  }
  selectTarget(t34) {
    const e36 = t34.getAttribute("value");
    if (e36) {
      const i21 = this.selected;
      this.selected = e36, this.dispatchEvent(new Event("change", { cancelable: true })) || (this.selected = i21);
    }
  }
  onSlotChange() {
    this.tabs = this.slotEl.assignedElements().filter((t34) => t34.getAttribute("role") === "tab"), this.updateCheckedState();
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("resize", this.updateSelectionIndicator), "fonts" in document && document.fonts.addEventListener("loadingdone", this.updateSelectionIndicator);
  }
  disconnectedCallback() {
    window.removeEventListener("resize", this.updateSelectionIndicator), "fonts" in document && document.fonts.removeEventListener("loadingdone", this.updateSelectionIndicator), super.disconnectedCallback();
  }
};
o50([n4({ type: Boolean })], Tabs.prototype, "auto", 2), o50([n4({ type: Boolean, reflect: true })], Tabs.prototype, "compact", 2), o50([n4({ reflect: true })], Tabs.prototype, "dir", 2), o50([n4({ reflect: true })], Tabs.prototype, "direction", 2), o50([n4({ type: Boolean, reflect: true })], Tabs.prototype, "emphasized", 2), o50([n4()], Tabs.prototype, "label", 2), o50([n4({ type: Boolean })], Tabs.prototype, "enableTabsScroll", 2), o50([n4({ type: Boolean, reflect: true })], Tabs.prototype, "quiet", 2), o50([n4({ attribute: false })], Tabs.prototype, "selectionIndicatorStyle", 2), o50([n4({ attribute: false })], Tabs.prototype, "shouldAnimate", 2), o50([e5("slot")], Tabs.prototype, "slotEl", 2), o50([e5("#list")], Tabs.prototype, "tabList", 2), o50([n4({ reflect: true })], Tabs.prototype, "selected", 2);

// node_modules/@spectrum-web-components/tabs/sp-tabs.js
init_define_element();
defineElement("sp-tabs", Tabs);

// node_modules/@spectrum-web-components/tabs/src/Tab.js
init_src();
init_decorators2();
init_focus_visible();
init_observe_slot_presence();
init_observe_slot_text();
init_random_id();

// node_modules/@spectrum-web-components/tabs/src/tab.css.js
init_src();
var o51 = i`
    :host{box-sizing:border-box;block-size:calc(var(--mod-tabs-item-height,var(--spectrum-tabs-item-height)) - var(--mod-tabs-divider-size,var(--spectrum-tabs-divider-size)));z-index:1;white-space:nowrap;color:var(--highcontrast-tabs-color,var(--mod-tabs-color,var(--spectrum-tabs-color)));transition:color var(--mod-tabs-animation-duration,var(--spectrum-tabs-animation-duration))ease-out;cursor:pointer;outline:none;-webkit-text-decoration:none;text-decoration:none;position:relative}::slotted([slot=icon]){block-size:var(--mod-tabs-icon-size,var(--spectrum-tabs-icon-size));inline-size:var(--mod-tabs-icon-size,var(--spectrum-tabs-icon-size));margin-block-start:var(--mod-tabs-top-to-icon,var(--spectrum-tabs-top-to-icon))}[name=icon]+#item-label{margin-inline-start:var(--mod-tabs-icon-to-text,var(--spectrum-tabs-icon-to-text))}:host:before{content:"";box-sizing:border-box;block-size:calc(100% - var(--mod-tabs-top-to-text,var(--spectrum-tabs-top-to-text)));inline-size:calc(100% + var(--mod-tabs-focus-indicator-gap,var(--spectrum-tabs-focus-indicator-gap))*2);border:var(--mod-tabs-focus-indicator-width,var(--spectrum-tabs-focus-indicator-width))solid transparent;border-radius:var(--mod-tabs-focus-indicator-border-radius,var(--spectrum-tabs-focus-indicator-border-radius));pointer-events:none;position:absolute;inset-block-start:calc(var(--mod-tabs-top-to-text,var(--spectrum-tabs-top-to-text))/2);inset-inline-start:calc(var(--mod-tabs-focus-indicator-gap,var(--spectrum-tabs-focus-indicator-gap))*-1);inset-inline-end:calc(var(--mod-tabs-focus-indicator-gap,var(--spectrum-tabs-focus-indicator-gap))*-1)}@media (hover:hover){:host(:hover){color:var(--highcontrast-tabs-color-hover,var(--mod-tabs-color-hover,var(--spectrum-tabs-color-hover)))}}:host([selected]){color:var(--highcontrast-tabs-color-selected,var(--mod-tabs-color-selected,var(--spectrum-tabs-color-selected)))}:host([disabled]){cursor:default;color:var(--highcontrast-tabs-color-disabled,var(--mod-tabs-color-disabled,var(--spectrum-tabs-color-disabled)))}:host([disabled]) #item-label{cursor:default}:host(:focus-visible){color:var(--highcontrast-tabs-color-key-focus,var(--mod-tabs-color-key-focus,var(--spectrum-tabs-color-key-focus)))}:host(:focus-visible):before{border-color:var(--highcontrast-tabs-focus-indicator-color,var(--mod-tabs-focus-indicator-color,var(--spectrum-tabs-focus-indicator-color)))}#item-label{cursor:pointer;vertical-align:top;font-family:var(--mod-tabs-font-family,var(--spectrum-tabs-font-family));font-style:var(--mod-tabs-font-style,var(--spectrum-tabs-font-style));font-size:var(--mod-tabs-font-size,var(--spectrum-tabs-font-size));font-weight:var(--mod-tabs-font-weight,var(--spectrum-tabs-font-weight));line-height:var(--mod-tabs-line-height,var(--spectrum-tabs-line-height));margin-block-start:var(--mod-tabs-top-to-text,var(--spectrum-tabs-top-to-text));margin-block-end:var(--mod-tabs-bottom-to-text,var(--spectrum-tabs-bottom-to-text));-webkit-text-decoration:none;text-decoration:none;display:inline-block}#item-label:empty{display:none}:host{scroll-margin-inline:var(--mod-tabs-item-horizontal-spacing,var(--spectrum-tabs-item-horizontal-spacing))}:host([disabled]){pointer-events:none}#item-label[hidden]{display:none}@media (forced-colors:active){:host:before{background-color:buttonface}:host ::slotted([slot=icon]){z-index:1;color:inherit;position:relative}#item-label{z-index:1;position:relative}:host([selected]),:host([selected]) ::slotted([slot=icon]),:host([selected]) #item-label{color:highlighttext}}:host([vertical]){flex-direction:column;justify-content:center;align-items:center;height:auto;display:flex}:host([dir][vertical]) slot[name=icon]+#item-label{margin-inline-start:0;margin-block:calc(var(--mod-tabs-top-to-text,var(--spectrum-tabs-top-to-text))/2)calc(var(--mod-tabs-bottom-to-text,var(--spectrum-tabs-bottom-to-text))/2)}:host([vertical]) ::slotted([slot=icon]){margin-block-start:calc(var(--mod-tabs-top-to-icon,var(--spectrum-tabs-top-to-icon))/2)}
`;
var tab_css_default = o51;

// node_modules/@spectrum-web-components/tabs/src/Tab.js
var b11 = Object.defineProperty;
var n24 = Object.getOwnPropertyDescriptor;
var r24 = (o52, l16, e36, i21) => {
  for (var t34 = i21 > 1 ? void 0 : i21 ? n24(l16, e36) : l16, a23 = o52.length - 1, d22; a23 >= 0; a23--) (d22 = o52[a23]) && (t34 = (i21 ? d22(l16, e36, t34) : d22(t34)) || t34);
  return i21 && t34 && b11(l16, e36, t34), t34;
};
var Tab = class extends FocusVisiblePolyfillMixin(ObserveSlotText(ObserveSlotPresence(SpectrumElement, '[slot="icon"]'), "")) {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.label = "";
    this.selected = false;
    this.vertical = false;
    this.value = "";
  }
  static get styles() {
    return [tab_css_default];
  }
  get hasIcon() {
    return this.slotContentIsPresent;
  }
  get hasLabel() {
    return !!this.label || this.slotHasContent;
  }
  render() {
    return x`
            ${this.hasIcon ? x`
                      <slot name="icon"></slot>
                  ` : E}
            <label id="item-label" ?hidden=${!this.hasLabel}>
                ${this.slotHasContent ? E : this.label}
                <slot>${this.label}</slot>
            </label>
        `;
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.setAttribute("role", "tab"), this.hasAttribute("id") || (this.id = `sp-tab-${randomID()}`);
  }
  updated(e36) {
    super.updated(e36), e36.has("selected") && (this.setAttribute("aria-selected", this.selected ? "true" : "false"), this.setAttribute("tabindex", this.selected ? "0" : "-1")), e36.has("disabled") && (this.disabled ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled"));
  }
};
r24([n4({ type: Boolean, reflect: true })], Tab.prototype, "disabled", 2), r24([n4({ reflect: true })], Tab.prototype, "label", 2), r24([n4({ type: Boolean, reflect: true })], Tab.prototype, "selected", 2), r24([n4({ type: Boolean, reflect: true })], Tab.prototype, "vertical", 2), r24([n4({ type: String, reflect: true })], Tab.prototype, "value", 2);

// node_modules/@spectrum-web-components/tabs/sp-tab.js
init_define_element();
defineElement("sp-tab", Tab);

// node_modules/@spectrum-web-components/tabs/src/TabPanel.js
init_src();
init_decorators2();
init_random_id();

// node_modules/@spectrum-web-components/tabs/src/tab-panel.css.js
init_src();
var e34 = i`
    :host{display:inline-flex}:host(:not([selected])){display:none}
`;
var tab_panel_css_default = e34;

// node_modules/@spectrum-web-components/tabs/src/TabPanel.js
var p29 = Object.defineProperty;
var u35 = Object.getOwnPropertyDescriptor;
var l15 = (s19, t34, i21, r25) => {
  for (var e36 = r25 > 1 ? void 0 : r25 ? u35(t34, i21) : t34, o52 = s19.length - 1, d22; o52 >= 0; o52--) (d22 = s19[o52]) && (e36 = (r25 ? d22(t34, i21, e36) : d22(e36)) || e36);
  return r25 && e36 && p29(t34, i21, e36), e36;
};
var TabPanel = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.selected = false;
    this.value = "";
  }
  handleFocusin() {
    this.removeAttribute("tabindex");
  }
  handleFocusout() {
    this.tabIndex = this.selected ? 0 : -1;
  }
  render() {
    return x`
            <slot
                @focusin=${this.handleFocusin}
                @focusout=${this.handleFocusout}
            ></slot>
        `;
  }
  firstUpdated() {
    this.slot = "tab-panel", this.setAttribute("role", "tabpanel"), this.tabIndex = 0, this.hasAttribute("id") || (this.id = `sp-tab-panel-${randomID()}`);
  }
  updated(i21) {
    i21.has("selected") && (this.selected ? (this.removeAttribute("aria-hidden"), this.tabIndex = 0) : (this.setAttribute("aria-hidden", "true"), this.tabIndex = -1));
  }
};
TabPanel.styles = [tab_panel_css_default], l15([n4({ type: Boolean, reflect: true })], TabPanel.prototype, "selected", 2), l15([n4({ type: String, reflect: true })], TabPanel.prototype, "value", 2);

// node_modules/@spectrum-web-components/tabs/sp-tab-panel.js
init_define_element();
defineElement("sp-tab-panel", TabPanel);

// src/custom-elements/commerce/checkout-button.js
var ButtonElement = customElements.get("sp-button");
var CheckoutButton = class extends ButtonElement {
  static get properties() {
    return {
      ...super.properties,
      href: { type: String }
    };
  }
  constructor() {
    super();
    this.variant = "accent";
    this.treatment = "fill";
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.handleClick.bind(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.handleClick.bind(this));
  }
  handleClick(e36) {
    const href = this.getAttribute("href");
    if (this.disabled) {
      e36.preventDefault();
      e36.stopPropagation();
      return;
    }
    if (href && !e36.defaultPrevented) {
      e36.preventDefault();
      window.open(href, "_blank");
    }
  }
};
customElements.define("checkout-button", CheckoutButton);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconShoppingCart.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/ShoppingCart.js
var ShoppingCartIcon = ({ width: t34 = 24, height: l16 = 24, hidden: e36 = false, title: r25 = "Shopping Cart" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m17.18028,4.80859c-.42871-.51367-1.05811-.80859-1.72754-.80859H5.08659l-.14069-.86133c-.17822-1.09473-1.1123-1.88867-2.2207-1.88867h-1.72461c-.41406,0-.75.33594-.75.75s.33594.75.75.75h1.72461c.36963,0,.68066.26465.74023.62988l1.58936,9.73145c.17822,1.09473,1.1123,1.88867,2.2207,1.88867h8.72461c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75H7.27549c-.36963,0-.68066-.26465-.74023-.62988l-.30542-1.87012h8.76831c1.08789,0,2.01904-.77637,2.21387-1.84766l.45459-2.5c.11963-.6582-.05762-1.33008-.48633-1.84375Zm-.98926,1.57617l-.45459,2.49902c-.06494.35742-.37549.61621-.73828.61621H5.98484l-.65326-4h10.12115c.30566,0,.49219.16895.57617.26953s.2168.31445.16211.61523Zm-1.19082,12.86533c-.69036,0-1.25-.55964-1.25-1.25s.55964-1.25,1.25-1.25,1.25.55964,1.25,1.25-.55964,1.25-1.25,1.25Zm-7.99892,0c-.69036,0-1.25-.55964-1.25-1.25s.55964-1.25,1.25-1.25,1.25.55964,1.25,1.25-.55964,1.25-1.25,1.25Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ShoppingCart.js
var ShoppingCartIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Shopping Cart" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <ellipse cx="10.445" cy="31.143" rx="2.667" ry="2.917" />
    <ellipse cx="25.778" cy="31.143" rx="2.667" ry="2.917" />
    <path
      d="M29.326 24H10.469l.762-2.6H28a1.331 1.331 0 0 0 1.307-1.071L33.974 7.66a1.334 1.334 0 0 0-1.308-1.595h-.126v-.03H6.5l-1.289-3.5A1.335 1.335 0 0 0 3.889 1.4H1.333a1.334 1.334 0 0 0 0 2.667h1.406L8.667 20l-1.294 5.075A1.569 1.569 0 0 0 8.667 27h20.666a1.589 1.589 0 0 0 1.334-1.6 1.4 1.4 0 0 0-1.341-1.4ZM7.529 8.835H30.6l-3.693 9.9H11.174Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconShoppingCart.js
var IconShoppingCart = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? ShoppingCartIcon({ hidden: !this.label, title: this.label }) : ShoppingCartIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-shopping-cart.js
init_define_element();
defineElement("sp-icon-shopping-cart", IconShoppingCart);

// src/custom-elements/commerce/checkout-button.author.js
CheckoutButton.ee = {
  getElementIcon(html) {
    return html`<sp-icon-shopping-cart></sp-icon-shopping-cart>`;
  },
  getSchema(element) {
    return {
      schemaVersion: 1,
      element: {
        label: "Checkout Button",
        description: "Call-to-action button for checkout and purchase flows"
      },
      attributes: {
        variant: {
          type: "enum",
          options: ["accent", "primary", "secondary", "negative"],
          default: "accent",
          label: "Button Variant",
          description: "Visual style variant for the button (typically secondary or accent in card footers)"
        },
        size: {
          type: "popover",
          default: "m",
          label: "Button Size",
          description: "Size of the button",
          render: ({ html, value }) => html`<spectrum-size-palette
            .size=${value}
            .sizes=${["s", "m", "l", "xl"]}
            attr="size"
          ></spectrum-size-palette>`
        },
        treatment: {
          type: "enum",
          options: ["fill", "outline"],
          default: "fill",
          label: "Button Treatment",
          description: "Fill or outline style"
        },
        href: {
          type: "text",
          default: "",
          label: "Link URL",
          description: "URL to open when button is clicked",
          placeholder: "https://checkout.adobe.com/..."
        },
        disabled: {
          type: "boolean",
          default: false,
          label: "Disabled",
          description: "Disable button interaction"
        }
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Checkout button Label",
            placeholder: "Save now",
            inlineEditable: true,
            allowPaste: false,
            allowedStyles: [],
            allowedFormats: [],
            multiline: false,
            plain: true,
            allowLinks: false
          }
        }
      }
    };
  },
  // Sanitize before saving
  sanitize(el) {
    if (!el) return;
    const texts = [];
    Array.from(el.childNodes).forEach((n25) => {
      if (n25.nodeType === Node.TEXT_NODE) {
        const t34 = n25.textContent.replace(/^\s+|\s+$/g, "");
        if (t34) texts.push(t34);
        n25.remove();
      }
    });
    if (texts.length) {
      el.textContent = texts.join(" ");
    }
    const variantOpts = ["secondary", "accent", "primary", "negative"];
    const sizeOpts = ["s", "m", "l", "xl"];
    if (el.hasAttribute("variant") && !variantOpts.includes(el.getAttribute("variant"))) {
      el.setAttribute("variant", "accent");
    }
    if (el.hasAttribute("size") && !sizeOpts.includes(el.getAttribute("size"))) {
      el.setAttribute("size", "m");
    }
    if (el.getAttribute("href") === "") el.removeAttribute("href");
  },
  // Serialize element to JSON, aware of default content (text and inline formatting)
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// node_modules/mas/web-components/dist/commerce.min.js
window.masPriceLiterals = {
  "total": 38,
  "offset": 0,
  "limit": 38,
  "data": [
    {
      "lang": "ar",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u0627\u0644\u0634\u0647\u0631} YEAR {/\u0627\u0644\u0639\u0627\u0645} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u0643\u0644 \u0634\u0647\u0631} YEAR {\u0643\u0644 \u0639\u0627\u0645} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u0644\u0643\u0644 \u062A\u0631\u062E\u064A\u0635} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u0644\u0643\u0644 \u062A\u0631\u062E\u064A\u0635} other {}}",
      "freeLabel": "\u0645\u062C\u0627\u0646\u064B\u0627",
      "freeAriaLabel": "\u0645\u062C\u0627\u0646\u064B\u0627",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "\u0623\u0648 \u0628\u062F\u0644\u0627\u064B \u0645\u0646 \u0630\u0644\u0643 \u0628\u0642\u064A\u0645\u0629 {alternativePrice}",
      "strikethroughAriaLabel": "\u0628\u0634\u0643\u0644 \u0645\u0646\u062A\u0638\u0645 \u0628\u0642\u064A\u0645\u0629 {strikethroughPrice}"
    },
    {
      "lang": "bg",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u043C\u0435\u0441.} YEAR {/\u0433\u043E\u0434.} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u043D\u0430 \u043C\u0435\u0441\u0435\u0446} YEAR {\u043D\u0430 \u0433\u043E\u0434\u0438\u043D\u0430} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u043D\u0430 \u043B\u0438\u0446\u0435\u043D\u0437} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u043D\u0430 \u043B\u0438\u0446\u0435\u043D\u0437} other {}}",
      "freeLabel": "\u0411\u0435\u0437\u043F\u043B\u0430\u0442\u043D\u043E",
      "freeAriaLabel": "\u0411\u0435\u0437\u043F\u043B\u0430\u0442\u043D\u043E",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "\u0410\u043B\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u043D\u043E \u043D\u0430 {alternativePrice}",
      "strikethroughAriaLabel": "\u0420\u0435\u0434\u043E\u0432\u043D\u043E \u043D\u0430 {strikethroughPrice}"
    },
    {
      "lang": "cs",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/m\u011Bs\xEDc} YEAR {/rok} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {za m\u011Bs\xEDc} YEAR {za rok} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {za licenci} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {za licenci} other {}}",
      "freeLabel": "Zdarma",
      "freeAriaLabel": "Zdarma",
      "taxExclusiveLabel": "{taxTerm, select, GST {bez dan\u011B ze zbo\u017E\xED a slu\u017Eeb} VAT {bez DPH} TAX {bez dan\u011B} IVA {bez IVA} SST {bez SST} KDV {bez KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {v\u010Detn\u011B dan\u011B ze zbo\u017E\xED a slu\u017Eeb} VAT {v\u010Detn\u011B DPH} TAX {v\u010Detn\u011B dan\u011B} IVA {v\u010Detn\u011B IVA} SST {v\u010Detn\u011B SST} KDV {v\u010Detn\u011B KDV} other {}}",
      "alternativePriceAriaLabel": "P\u0159\xEDpadn\u011B za {alternativePrice}",
      "strikethroughAriaLabel": "Pravideln\u011B za {strikethroughPrice}"
    },
    {
      "lang": "da",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/md} YEAR {/\xE5r} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {pr. m\xE5ned} YEAR {pr. \xE5r} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {pr. licens} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {pr. licens} other {}}",
      "freeLabel": "Gratis",
      "freeAriaLabel": "Gratis",
      "taxExclusiveLabel": "{taxTerm, select, GST {ekskl. GST} VAT {ekskl. moms} TAX {ekskl. skat} IVA {ekskl. IVA} SST {ekskl. SST} KDV {ekskl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {inkl. GST} VAT {inkl. moms} TAX {inkl. skat} IVA {inkl. IVA} SST {inkl. SST} KDV {inkl. KDV} other {}}",
      "alternativePriceAriaLabel": "Alternativt til {alternativePrice}",
      "strikethroughAriaLabel": "Normalpris {strikethroughPrice}"
    },
    {
      "lang": "de",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/Monat} YEAR {/Jahr} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {pro Monat} YEAR {pro Jahr} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {pro Lizenz} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {pro Lizenz} other {}}",
      "freeLabel": "Kostenlos",
      "freeAriaLabel": "Kostenlos",
      "taxExclusiveLabel": "{taxTerm, select, GST {zzgl. GST} VAT {zzgl. MwSt.} TAX {zzgl. Steuern} IVA {zzgl. IVA} SST {zzgl. SST} KDV {zzgl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {inkl. GST} VAT {inkl. MwSt.} TAX {inkl. Steuern} IVA {inkl. IVA} SST {inkl. SST} KDV {inkl. KDV} other {}}",
      "alternativePriceAriaLabel": "Alternativ: {alternativePrice}",
      "strikethroughAriaLabel": "Regul\xE4r: {strikethroughPrice}"
    },
    {
      "lang": "en",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mo} YEAR {/yr} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per month} YEAR {per year} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {per license} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {per license} other {}}",
      "freeLabel": "Free",
      "freeAriaLabel": "Free",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "Alternatively at {alternativePrice}",
      "strikethroughAriaLabel": "Regularly at {strikethroughPrice}"
    },
    {
      "lang": "et",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {kuus} YEAR {aastas} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {kuus} YEAR {aastas} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {litsentsi kohta} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {litsentsi kohta} other {}}",
      "freeLabel": "Tasuta",
      "freeAriaLabel": "Tasuta",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "Teise v\xF5imalusena hinnaga {alternativePrice}",
      "strikethroughAriaLabel": "Tavahind {strikethroughPrice}"
    },
    {
      "lang": "fi",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/kk} YEAR {/v} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {kuukausittain} YEAR {vuosittain} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {k\xE4ytt\xF6oikeutta kohti} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {k\xE4ytt\xF6oikeutta kohti} other {}}",
      "freeLabel": "Maksuton",
      "freeAriaLabel": "Maksuton",
      "taxExclusiveLabel": "{taxTerm, select, GST {ilman GST:t\xE4} VAT {ilman ALV:t\xE4} TAX {ilman veroja} IVA {ilman IVA:ta} SST {ilman SST:t\xE4} KDV {ilman KDV:t\xE4} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {sis. GST:n} VAT {sis. ALV:n} TAX {sis. verot} IVA {sis. IVA:n} SST {sis. SST:n} KDV {sis. KDV:n} other {}}",
      "alternativePriceAriaLabel": "Vaihtoehtoisesti hintaan {alternativePrice}",
      "strikethroughAriaLabel": "S\xE4\xE4nn\xF6llisesti hintaan {strikethroughPrice}"
    },
    {
      "lang": "fr",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mois} YEAR {/an} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {par mois} YEAR {par an} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {par licence} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {par licence} other {}}",
      "freeLabel": "Gratuit",
      "freeAriaLabel": "Gratuit",
      "taxExclusiveLabel": "{taxTerm, select, GST {hors TPS} VAT {hors TVA} TAX {hors taxes} IVA {hors IVA} SST {hors SST} KDV {hors KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {TPS comprise} VAT {TVA comprise} TAX {taxes comprises} IVA {IVA comprise} SST {SST comprise} KDV {KDV comprise} other {}}",
      "alternativePriceAriaLabel": "Autre prix {alternativePrice}",
      "strikethroughAriaLabel": "Prix habituel {strikethroughPrice}"
    },
    {
      "lang": "he",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u05D7\u05D5\u05D3\u05E9} YEAR {/\u05E9\u05E0\u05D4} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u05DC\u05D7\u05D5\u05D3\u05E9} YEAR {\u05DC\u05E9\u05E0\u05D4} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u05DC\u05E8\u05D9\u05E9\u05D9\u05D5\u05DF} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u05DC\u05E8\u05D9\u05E9\u05D9\u05D5\u05DF} other {}}",
      "freeLabel": "\u05D7\u05D9\u05E0\u05DD",
      "freeAriaLabel": "\u05D7\u05D9\u05E0\u05DD",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "\u05DC\u05D7\u05DC\u05D5\u05E4\u05D9\u05DF \u05D1-{alternativePrice}",
      "strikethroughAriaLabel": "\u05D1\u05D0\u05D5\u05E4\u05DF \u05E7\u05D1\u05D5\u05E2 \u05D1-{strikethroughPrice}"
    },
    {
      "lang": "hu",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/h\xF3} YEAR {/\xE9v} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {havonta} YEAR {\xE9vente} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {licencenk\xE9nt} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {licencenk\xE9nt} other {}}",
      "freeLabel": "Ingyenes",
      "freeAriaLabel": "Ingyenes",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "M\xE1sik lehet\u0151s\xE9g: {alternativePrice}",
      "strikethroughAriaLabel": "\xC1ltal\xE1ban {strikethroughPrice} \xE1ron"
    },
    {
      "lang": "it",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mese} YEAR {/anno} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {al mese} YEAR {all'anno} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {per licenza} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {per licenza} other {}}",
      "freeLabel": "Gratuito",
      "freeAriaLabel": "Gratuito",
      "taxExclusiveLabel": "{taxTerm, select, GST {escl. GST} VAT {escl. IVA.} TAX {escl. imposte} IVA {escl. IVA} SST {escl. SST} KDV {escl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. IVA} TAX {incl. imposte} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "In alternativa a {alternativePrice}",
      "strikethroughAriaLabel": "Regolarmente a {strikethroughPrice}"
    },
    {
      "lang": "ja",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u6708} YEAR {/\u5E74} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u6BCE\u6708} YEAR {\u6BCE\u5E74} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u30E9\u30A4\u30BB\u30F3\u30B9\u3054\u3068} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u30E9\u30A4\u30BB\u30F3\u30B9\u3054\u3068} other {}}",
      "freeLabel": "\u7121\u6599",
      "freeAriaLabel": "\u7121\u6599",
      "taxExclusiveLabel": "{taxTerm, select, GST {GST \u5225} VAT {VAT \u5225} TAX {\u7A0E\u5225} IVA {IVA \u5225} SST {SST \u5225} KDV {KDV \u5225} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {GST \u8FBC} VAT {VAT \u8FBC} TAX {\u7A0E\u8FBC} IVA {IVA \u8FBC} SST {SST \u8FBC} KDV {KDV \u8FBC} other {}}",
      "alternativePriceAriaLabel": "\u7279\u5225\u4FA1\u683C : {alternativePrice}",
      "strikethroughAriaLabel": "\u901A\u5E38\u4FA1\u683C : {strikethroughPrice}"
    },
    {
      "lang": "ko",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\uC6D4} YEAR {/\uB144} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\uC6D4\uAC04} YEAR {\uC5F0\uAC04} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\uB77C\uC774\uC120\uC2A4\uB2F9} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\uB77C\uC774\uC120\uC2A4\uB2F9} other {}}",
      "freeLabel": "\uBB34\uB8CC",
      "freeAriaLabel": "\uBB34\uB8CC",
      "taxExclusiveLabel": "{taxTerm, select, GST {GST \uC81C\uC678} VAT {VAT \uC81C\uC678} TAX {\uC138\uAE08 \uC81C\uC678} IVA {IVA \uC81C\uC678} SST {SST \uC81C\uC678} KDV {KDV \uC81C\uC678} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {GST \uD3EC\uD568} VAT {VAT \uD3EC\uD568} TAX {\uC138\uAE08 \uD3EC\uD568} IVA {IVA \uD3EC\uD568} SST {SST \uD3EC\uD568} KDV {KDV \uD3EC\uD568} other {}}",
      "alternativePriceAriaLabel": "\uB610\uB294 {alternativePrice}\uC5D0",
      "strikethroughAriaLabel": "\uB610\uB294 {alternativePrice}\uC5D0"
    },
    {
      "lang": "lt",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH { per m\u0117n.} YEAR { per metus} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per m\u0117n.} YEAR {per metus} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {u\u017E licencij\u0105} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {u\u017E licencij\u0105} other {}}",
      "freeLabel": "Nemokamai",
      "freeAriaLabel": "Nemokamai",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "Arba u\u017E {alternativePrice}",
      "strikethroughAriaLabel": "Normaliai u\u017E {strikethroughPrice}"
    },
    {
      "lang": "lv",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {m\u0113nes\u012B} YEAR {gad\u0101} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {m\u0113nes\u012B} YEAR {gad\u0101} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {vienai licencei} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {vienai licencei} other {}}",
      "freeLabel": "Bezmaksas",
      "freeAriaLabel": "Bezmaksas",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "Alternat\u012Bvi par {alternativePrice}",
      "strikethroughAriaLabel": "Regul\u0101ri par {strikethroughPrice}"
    },
    {
      "lang": "nb",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mnd.} YEAR {/\xE5r} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per m\xE5ned} YEAR {per \xE5r} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {per lisens} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {per lisens} other {}}",
      "freeLabel": "Fri",
      "freeAriaLabel": "Fri",
      "taxExclusiveLabel": "{taxTerm, select, GST {ekskl. GST} VAT {ekskl. moms} TAX {ekskl. avgift} IVA {ekskl. IVA} SST {ekskl. SST} KDV {ekskl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {inkl. GST} VAT {inkl. moms} TAX {inkl. avgift} IVA {inkl. IVA} SST {inkl. SST} KDV {inkl. KDV} other {}}",
      "alternativePriceAriaLabel": "Alternativt til {alternativePrice}",
      "strikethroughAriaLabel": "Regelmessig til {strikethroughPrice}"
    },
    {
      "lang": "nl",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mnd} YEAR {/jr} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per maand} YEAR {per jaar} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {per licentie} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {per licentie} other {}}",
      "freeLabel": "Gratis",
      "freeAriaLabel": "Gratis",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. btw} TAX {excl. belasting} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. btw} TAX {incl. belasting} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "Nu {alternativePrice}",
      "strikethroughAriaLabel": "Normaal {strikethroughPrice}"
    },
    {
      "lang": "pl",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH { / mies.} YEAR { / rok} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH { / miesi\u0105c} YEAR { / rok} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {za licencj\u0119} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {za licencj\u0119} other {}}",
      "freeLabel": "Bezp\u0142atne",
      "freeAriaLabel": "Bezp\u0142atne",
      "taxExclusiveLabel": "{taxTerm, select, GST {bez GST} VAT {bez VAT} TAX {netto} IVA {bez IVA} SST {bez SST} KDV {bez KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {z GST} VAT {z VAT} TAX {brutto} IVA {z IVA} SST {z SST} KDV {z KDV} other {}}",
      "alternativePriceAriaLabel": "Lub za {alternativePrice}",
      "strikethroughAriaLabel": "Cena zwyk\u0142a: {strikethroughPrice}"
    },
    {
      "lang": "pt",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/m\xEAs} YEAR {/ano} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {por m\xEAs} YEAR {por ano} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {por licen\xE7a} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {por licen\xE7a} other {}}",
      "freeLabel": "Gratuito",
      "freeAriaLabel": "Gratuito",
      "taxExclusiveLabel": "{taxTerm, select, GST {ICMS n\xE3o incluso} VAT {IVA n\xE3o incluso} TAX {impostos n\xE3o inclusos} IVA {IVA n\xE3o incluso} SST { SST n\xE3o incluso} KDV {KDV n\xE3o incluso} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {ICMS incluso} VAT {IVA incluso} TAX {impostos inclusos} IVA {IVA incluso} SST {SST incluso} KDV {KDV incluso} other {}}",
      "alternativePriceAriaLabel": "Ou a {alternativePrice}",
      "strikethroughAriaLabel": "Pre\xE7o normal: {strikethroughPrice}"
    },
    {
      "lang": "ro",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/lun\u0103} YEAR {/an} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {pe lun\u0103} YEAR {pe an} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {pe licen\u021B\u0103} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {pe licen\u021B\u0103} other {}}",
      "freeLabel": "Gratuit",
      "freeAriaLabel": "Gratuit",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "Alternativ, la {alternativePrice}",
      "strikethroughAriaLabel": "\xCEn mod normal, la {strikethroughPrice}"
    },
    {
      "lang": "ru",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u043C\u0435\u0441.} YEAR {/\u0433.} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u0432 \u043C\u0435\u0441\u044F\u0446} YEAR {\u0432 \u0433\u043E\u0434} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u0437\u0430 \u043B\u0438\u0446\u0435\u043D\u0437\u0438\u044E} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u0437\u0430 \u043B\u0438\u0446\u0435\u043D\u0437\u0438\u044E} other {}}",
      "freeLabel": "\u0411\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u043E",
      "freeAriaLabel": "\u0411\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u043E",
      "taxExclusiveLabel": "{taxTerm, select, GST {\u0438\u0441\u043A\u043B. \u043D\u0430\u043B\u043E\u0433 \u043D\u0430 \u0442\u043E\u0432\u0430\u0440\u044B \u0438 \u0443\u0441\u043B\u0443\u0433\u0438} VAT {\u0438\u0441\u043A\u043B. \u041D\u0414\u0421} TAX {\u0438\u0441\u043A\u043B. \u043D\u0430\u043B\u043E\u0433} IVA {\u0438\u0441\u043A\u043B. \u0418\u0412\u0410} SST {\u0438\u0441\u043A\u043B. SST} KDV {\u0438\u0441\u043A\u043B. \u041A\u0414\u0412} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {\u0432\u043A\u043B. \u043D\u0430\u043B\u043E\u0433 \u043D\u0430 \u0442\u043E\u0432\u0430\u0440\u044B \u0438 \u0443\u0441\u043B\u0443\u0433\u0438} VAT {\u0432\u043A\u043B. \u041D\u0414\u0421} TAX {\u0432\u043A\u043B. \u043D\u0430\u043B\u043E\u0433} IVA {\u0432\u043A\u043B. \u0418\u0412\u0410} SST {\u0432\u043A\u043B. SST} KDV {\u0432\u043A\u043B. \u041A\u0414\u0412} other {}}",
      "alternativePriceAriaLabel": "\u0410\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442 \u0437\u0430 {alternativePrice}",
      "strikethroughAriaLabel": "\u0420\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u043E \u043F\u043E \u0446\u0435\u043D\u0435 {strikethroughPrice}"
    },
    {
      "lang": "sk",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mesiac} YEAR {/rok} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {za mesiac} YEAR {za rok} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {za licenciu} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {za licenciu} other {}}",
      "freeLabel": "Zadarmo",
      "freeAriaLabel": "Zadarmo",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "Pr\xEDpadne za {alternativePrice}",
      "strikethroughAriaLabel": "Pravidelne za {strikethroughPrice}"
    },
    {
      "lang": "sl",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mesec} YEAR {/leto} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {na mesec} YEAR {na leto} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {na licenco} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {na licenco} other {}}",
      "freeLabel": "Brezpla\u010Dno",
      "freeAriaLabel": "Brezpla\u010Dno",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "Druga mo\u017Enost je: {alternativePrice}",
      "strikethroughAriaLabel": "Redno po {strikethroughPrice}"
    },
    {
      "lang": "sv",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/m\xE5n} YEAR {/\xE5r} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per m\xE5nad} YEAR {per \xE5r} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {per licens} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {per licens} other {}}",
      "freeLabel": "Kostnadsfritt",
      "freeAriaLabel": "Kostnadsfritt",
      "taxExclusiveLabel": "{taxTerm, select, GST {exkl. GST} VAT {exkl. moms} TAX {exkl. skatt} IVA {exkl. IVA} SST {exkl. SST} KDV {exkl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {inkl. GST} VAT {inkl. moms} TAX {inkl. skatt} IVA {inkl. IVA} SST {inkl. SST} KDV {inkl. KDV} other {}}",
      "alternativePriceAriaLabel": "Alternativt f\xF6r {alternativePrice}",
      "strikethroughAriaLabel": "Normalpris {strikethroughPrice}"
    },
    {
      "lang": "tr",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/ay} YEAR {/y\u0131l} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {(ayl\u0131k)} YEAR {(y\u0131ll\u0131k)} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {(lisans ba\u015F\u0131na)} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {(lisans ba\u015F\u0131na)} other {}}",
      "freeLabel": "\xDCcretsiz",
      "freeAriaLabel": "\xDCcretsiz",
      "taxExclusiveLabel": "{taxTerm, select, GST {GST hari\xE7} VAT {KDV hari\xE7} TAX {vergi hari\xE7} IVA {IVA hari\xE7} SST {SST hari\xE7} KDV {KDV hari\xE7} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {GST dahil} VAT {KDV dahil} TAX {vergi dahil} IVA {IVA dahil} SST {SST dahil} KDV {KDV dahil} other {}}",
      "alternativePriceAriaLabel": "Ya da {alternativePrice}",
      "strikethroughAriaLabel": "Standart fiyat: {strikethroughPrice}"
    },
    {
      "lang": "uk",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u043C\u0456\u0441.} YEAR {/\u0440\u0456\u043A} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u043D\u0430 \u043C\u0456\u0441\u044F\u0446\u044C} YEAR {\u043D\u0430 \u0440\u0456\u043A} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u0437\u0430 \u043B\u0456\u0446\u0435\u043D\u0437\u0456\u044E} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u0437\u0430 \u043B\u0456\u0446\u0435\u043D\u0437\u0456\u044E} other {}}",
      "freeLabel": "\u0411\u0435\u0437\u043A\u043E\u0448\u0442\u043E\u0432\u043D\u043E",
      "freeAriaLabel": "\u0411\u0435\u0437\u043A\u043E\u0448\u0442\u043E\u0432\u043D\u043E",
      "taxExclusiveLabel": "{taxTerm, select, GST {\u0431\u0435\u0437 GST} VAT {\u0431\u0435\u0437 \u041F\u0414\u0412} TAX {\u0431\u0435\u0437 \u043F\u043E\u0434\u0430\u0442\u043A\u0443} IVA {\u0431\u0435\u0437 IVA} SST {\u0431\u0435\u0437 SST} KDV {\u0431\u0435\u0437 KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {\u0440\u0430\u0437\u043E\u043C \u0456\u0437 GST} VAT {\u0440\u0430\u0437\u043E\u043C \u0456\u0437 \u041F\u0414\u0412} TAX {\u0440\u0430\u0437\u043E\u043C \u0456\u0437 \u043F\u043E\u0434\u0430\u0442\u043A\u043E\u043C} IVA {\u0440\u0430\u0437\u043E\u043C \u0437 IVA} SST {\u0440\u0430\u0437\u043E\u043C \u0456\u0437 SST} KDV {\u0440\u0430\u0437\u043E\u043C \u0456\u0437 KDV} other {}}",
      "alternativePriceAriaLabel": "\u0410\u0431\u043E \u0437\u0430 {alternativePrice}",
      "strikethroughAriaLabel": "\u0417\u0432\u0438\u0447\u0430\u0439\u043D\u0430 \u0446\u0456\u043D\u0430 {strikethroughPrice}"
    },
    {
      "lang": "zh-hans",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u6708} YEAR {/\u5E74} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u6BCF\u6708} YEAR {\u6BCF\u5E74} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u6BCF\u4E2A\u8BB8\u53EF\u8BC1} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u6BCF\u4E2A\u8BB8\u53EF\u8BC1} other {}}",
      "freeLabel": "\u514D\u8D39",
      "freeAriaLabel": "\u514D\u8D39",
      "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
      "alternativePriceAriaLabel": "\u6216\u5B9A\u4EF7 {alternativePrice}",
      "strikethroughAriaLabel": "\u6B63\u5E38\u4EF7 {strikethroughPrice}"
    },
    {
      "lang": "zh-hant",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u6708} YEAR {/\u5E74} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u6BCF\u6708} YEAR {\u6BCF\u5E74} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u6BCF\u500B\u6388\u6B0A} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u6BCF\u500B\u6388\u6B0A} other {}}",
      "freeLabel": "\u514D\u8CBB",
      "freeAriaLabel": "\u514D\u8CBB",
      "taxExclusiveLabel": "{taxTerm, select, GST {\u4E0D\u542B GST} VAT {\u4E0D\u542B VAT} TAX {\u4E0D\u542B\u7A05} IVA {\u4E0D\u542B IVA} SST {\u4E0D\u542B SST} KDV {\u4E0D\u542B KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {\u542B GST} VAT {\u542B VAT} TAX {\u542B\u7A05} IVA {\u542B IVA} SST {\u542B SST} KDV {\u542B KDV} other {}}",
      "alternativePriceAriaLabel": "\u6216\u8005\u5728 {alternativePrice}",
      "strikethroughAriaLabel": "\u6A19\u6E96\u50F9\u683C\u70BA {strikethroughPrice}"
    },
    {
      "lang": "es",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mes} YEAR {/a\xF1o} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {al mes} YEAR {al a\xF1o} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {por licencia} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {por licencia} other {}}",
      "freeLabel": "Gratuito",
      "freeAriaLabel": "Gratuito",
      "taxExclusiveLabel": "{taxTerm, select, GST {GST no incluido} VAT {IVA no incluido} TAX {Impuestos no incluidos} IVA {IVA no incluido} SST {SST no incluido} KDV {KDV no incluido} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {GST incluido} VAT {IVA incluido} TAX {Impuestos incluidos} IVA {IVA incluido} SST {SST incluido} KDV {KDV incluido} other {}}",
      "alternativePriceAriaLabel": "Alternativamente por {alternativePrice}",
      "strikethroughAriaLabel": "Normalmente a {strikethroughPrice}"
    },
    {
      "lang": "in",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/bulan} YEAR {/tahun} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per bulan} YEAR {per tahun} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {per lisensi} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {per lisensi} other {}}",
      "freeLabel": "Gratis",
      "freeAriaLabel": "Gratis",
      "taxExclusiveLabel": "{taxTerm, select, GST {tidak termasuk PBJ} VAT {tidak termasuk PPN} TAX {tidak termasuk pajak} IVA {tidak termasuk IVA} SST {tidak termasuk SST} KDV {tidak termasuk KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {termasuk PBJ} VAT {termasuk PPN} TAX {termasuk pajak} IVA {termasuk IVA} SST {termasuk SST} KDV {termasuk KDV} other {}}",
      "alternativePriceAriaLabel": "Atau seharga {alternativePrice}",
      "strikethroughAriaLabel": "Normalnya seharga {strikethroughPrice}"
    },
    {
      "lang": "vi",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/th\xE1ng} YEAR {/n\u0103m} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {m\u1ED7i th\xE1ng} YEAR {m\u1ED7i n\u0103m} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {m\u1ED7i gi\u1EA5y ph\xE9p} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {m\u1ED7i gi\u1EA5y ph\xE9p} other {}}",
      "freeLabel": "Mi\u1EC5n ph\xED",
      "freeAriaLabel": "Mi\u1EC5n ph\xED",
      "taxExclusiveLabel": "{taxTerm, select, GST {ch\u01B0a bao g\u1ED3m thu\u1EBF h\xE0ng h\xF3a v\xE0 d\u1ECBch v\u1EE5} VAT {ch\u01B0a bao g\u1ED3m thu\u1EBF GTGT} TAX {ch\u01B0a bao g\u1ED3m thu\u1EBF} IVA {ch\u01B0a bao g\u1ED3m IVA} SST {ch\u01B0a bao g\u1ED3m SST} KDV {ch\u01B0a bao g\u1ED3m KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {(\u0111\xE3 bao g\u1ED3m thu\u1EBF h\xE0ng h\xF3a v\xE0 d\u1ECBch v\u1EE5)} VAT {(\u0111\xE3 bao g\u1ED3m thu\u1EBF GTGT)} TAX {(\u0111\xE3 bao g\u1ED3m thu\u1EBF)} IVA {(\u0111\xE3 bao g\u1ED3m IVA)} SST {(\u0111\xE3 bao g\u1ED3m SST)} KDV {(\u0111\xE3 bao g\u1ED3m KDV)} other {}}",
      "alternativePriceAriaLabel": "Gi\xE1 \u01B0u \u0111\xE3i {alternativePrice}",
      "strikethroughAriaLabel": "Gi\xE1 th\xF4ng th\u01B0\u1EDDng {strikethroughPrice}"
    },
    {
      "lang": "th",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u0E40\u0E14\u0E37\u0E2D\u0E19} YEAR {/\u0E1B\u0E35} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u0E15\u0E48\u0E2D\u0E40\u0E14\u0E37\u0E2D\u0E19} YEAR {\u0E15\u0E48\u0E2D\u0E1B\u0E35} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u0E15\u0E48\u0E2D\u0E2A\u0E34\u0E17\u0E18\u0E34\u0E4C\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u0E15\u0E48\u0E2D\u0E2A\u0E34\u0E17\u0E18\u0E34\u0E4C\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19} other {}}",
      "freeLabel": "\u0E1F\u0E23\u0E35",
      "freeAriaLabel": "\u0E1F\u0E23\u0E35",
      "taxExclusiveLabel": "{taxTerm, select, GST {\u0E44\u0E21\u0E48\u0E23\u0E27\u0E21\u0E20\u0E32\u0E29\u0E35 GST} VAT {\u0E44\u0E21\u0E48\u0E23\u0E27\u0E21 VAT} TAX {\u0E44\u0E21\u0E48\u0E23\u0E27\u0E21\u0E20\u0E32\u0E29\u0E35} IVA {\u0E44\u0E21\u0E48\u0E23\u0E27\u0E21 IVA} SST {\u0E44\u0E21\u0E48\u0E23\u0E27\u0E21 SST} KDV {\u0E44\u0E21\u0E48\u0E23\u0E27\u0E21 KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {\u0E23\u0E27\u0E21\u0E20\u0E32\u0E29\u0E35 GST} VAT {\u0E23\u0E27\u0E21 VAT} TAX {\u0E23\u0E27\u0E21\u0E20\u0E32\u0E29\u0E35} IVA {\u0E23\u0E27\u0E21 IVA} SST {\u0E23\u0E27\u0E21 SST} KDV {\u0E23\u0E27\u0E21 KDV} other {}}",
      "alternativePriceAriaLabel": "\u0E23\u0E32\u0E04\u0E32\u0E1E\u0E34\u0E40\u0E28\u0E29 {alternativePrice}",
      "strikethroughAriaLabel": "\u0E23\u0E32\u0E04\u0E32\u0E1B\u0E01\u0E15\u0E34 {strikethroughPrice}"
    },
    {
      "lang": "el",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u03BC\u03AE\u03BD\u03B1} YEAR {/\u03AD\u03C4\u03BF\u03C2} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u03BA\u03AC\u03B8\u03B5 \u03BC\u03AE\u03BD\u03B1} YEAR {\u03B1\u03BD\u03AC \u03AD\u03C4\u03BF\u03C2} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u03B1\u03BD\u03AC \u03AC\u03B4\u03B5\u03B9\u03B1 \u03C7\u03C1\u03AE\u03C3\u03B7\u03C2} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u03B1\u03BD\u03AC \u03AC\u03B4\u03B5\u03B9\u03B1 \u03C7\u03C1\u03AE\u03C3\u03B7\u03C2} other {}}",
      "freeLabel": "\u0394\u03C9\u03C1\u03B5\u03AC\u03BD",
      "freeAriaLabel": "\u0394\u03C9\u03C1\u03B5\u03AC\u03BD",
      "taxExclusiveLabel": "{taxTerm, select, GST {(\u03BC\u03B7 \u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 GST)} VAT {(\u03BC\u03B7 \u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 \u03A6\u03A0\u0391)} TAX {(\u03BC\u03B7 \u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C6\u03CC\u03C1\u03BF)} IVA {(\u03BC\u03B7 \u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 IVA)} SST {(\u03BC\u03B7 \u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 SST)} KDV {(\u03BC\u03B7 \u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 KDV)} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {(\u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C4\u03BF\u03C5 GST)} VAT {(\u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 \u03A6\u03A0\u0391)} TAX {(\u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C4\u03BF\u03C5 \u03C6\u03CC\u03C1\u03BF\u03C5)} IVA {(\u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C4\u03BF\u03C5 IVA)} SST {(\u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C4\u03BF\u03C5 SST)} KDV {(\u03C3\u03C5\u03BC\u03C0\u03B5\u03C1\u03B9\u03BB\u03B1\u03BC\u03B2\u03B1\u03BD\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 \u03C4\u03BF\u03C5 KDV)} other {}}",
      "alternativePriceAriaLabel": "\u0394\u03B9\u03B1\u03C6\u03BF\u03C1\u03B5\u03C4\u03B9\u03BA\u03AC, {alternativePrice}",
      "strikethroughAriaLabel": "\u039A\u03B1\u03BD\u03BF\u03BD\u03B9\u03BA\u03AE \u03C4\u03B9\u03BC\u03AE {strikethroughPrice}"
    },
    {
      "lang": "fil",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/buwan} YEAR {/taon} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per buwan} YEAR {per taon} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {kada lisensya} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {kada lisensya} other {}}",
      "freeLabel": "Libre",
      "freeAriaLabel": "Libre",
      "taxExclusiveLabel": "{taxTerm, select, GST {hindi kasama ang GST} VAT {hindi kasama ang VAT} TAX {hindi kasama ang Buwis} IVA {hindi kasama ang IVA} SST {hindi kasama ang SST} KDV {hindi kasama ang KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {kasama ang GST} VAT {kasama ang VAT} TAX {kasama ang Buwis} IVA {kasama ang IVA} SST {kasama ang SST} KDV {kasama ang KDV} other {}}",
      "alternativePriceAriaLabel": "Alternatibong nasa halagang {alternativePrice}",
      "strikethroughAriaLabel": "Regular na nasa halagang {strikethroughPrice}"
    },
    {
      "lang": "ms",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/bulan} YEAR {/tahun} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per bulan} YEAR {per tahun} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {setiap lesen} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {setiap lesen} other {}}",
      "freeLabel": "Percuma",
      "freeAriaLabel": "Percuma",
      "taxExclusiveLabel": "{taxTerm, select, GST {kecuali GST} VAT {kecuali VAT} TAX {kecuali Cukai} IVA {kecuali IVA} SST {kecuali SST} KDV {kecuali KDV} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {termasuk GST} VAT {termasuk VAT} TAX {termasuk Cukai} IVA {termasuk IVA} SST {termasuk SST} KDV {termasuk KDV} other {}}",
      "alternativePriceAriaLabel": "Secara alternatif pada {alternativePrice}",
      "strikethroughAriaLabel": "Biasanya pada {strikethroughPrice}"
    },
    {
      "lang": "hi",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u092E\u093E\u0939} YEAR {/\u0935\u0930\u094D\u0937} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per \u092E\u093E\u0939} YEAR {per \u0935\u0930\u094D\u0937} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u092A\u094D\u0930\u0924\u093F \u0932\u093E\u0907\u0938\u0947\u0902\u0938} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u092A\u094D\u0930\u0924\u093F \u0932\u093E\u0907\u0938\u0947\u0902\u0938} other {}}",
      "freeLabel": "\u092B\u093C\u094D\u0930\u0940",
      "freeAriaLabel": "\u092B\u093C\u094D\u0930\u0940",
      "taxExclusiveLabel": "{taxTerm, select, GST {GST \u0905\u0924\u093F\u0930\u093F\u0915\u094D\u0924} VAT {VAT \u0905\u0924\u093F\u0930\u093F\u0915\u094D\u0924} TAX {\u0915\u0930 \u0905\u0924\u093F\u0930\u093F\u0915\u094D\u0924} IVA {IVA \u0905\u0924\u093F\u0930\u093F\u0915\u094D\u0924} SST {SST \u0905\u0924\u093F\u0930\u093F\u0915\u094D\u0924} KDV {KDV \u0905\u0924\u093F\u0930\u093F\u0915\u094D\u0924} other {}}",
      "taxInclusiveLabel": "{taxTerm, select, GST {GST \u0938\u0939\u093F\u0924} VAT {VAT \u0938\u0939\u093F\u0924} TAX {\u0915\u0930 \u0938\u0939\u093F\u0924} IVA {IVA \u0938\u0939\u093F\u0924} SST {SST \u0938\u0939\u093F\u0924} KDV {KDV \u0938\u0939\u093F\u0924} other {}}",
      "alternativePriceAriaLabel": "\u0935\u0948\u0915\u0932\u094D\u092A\u093F\u0915 \u0930\u0942\u092A \u0938\u0947 \u0907\u0938 \u092A\u0930 {alternativePrice}",
      "strikethroughAriaLabel": "\u0928\u093F\u092F\u092E\u093F\u0924 \u0930\u0942\u092A \u0938\u0947 \u0907\u0938 \u092A\u0930 {strikethroughPrice}"
    },
    {
      "lang": "iw",
      "recurrenceLabel": "{recurrenceTerm, select, MONTH {/\u05D7\u05D5\u05D3\u05E9} YEAR {/\u05E9\u05E0\u05D4} other {}}",
      "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {\u05DC\u05D7\u05D5\u05D3\u05E9} YEAR {\u05DC\u05E9\u05E0\u05D4} other {}}",
      "perUnitLabel": "{perUnit, select, LICENSE {\u05DC\u05E8\u05D9\u05E9\u05D9\u05D5\u05DF} other {}}",
      "perUnitAriaLabel": "{perUnit, select, LICENSE {\u05DC\u05E8\u05D9\u05E9\u05D9\u05D5\u05DF} other {}}",
      "freeLabel": "\u05D7\u05D9\u05E0\u05DD",
      "freeAriaLabel": "\u05D7\u05D9\u05E0\u05DD",
      "taxExclusiveLabel": '{taxTerm, select, GST {\u05DC\u05DC\u05D0 GST} VAT {\u05DC\u05DC\u05D0 \u05DE\u05E2"\u05DE} TAX {\u05DC\u05DC\u05D0 \u05DE\u05E1} IVA {\u05DC\u05DC\u05D0 IVA} SST {\u05DC\u05DC\u05D0 SST} KDV {\u05DC\u05DC\u05D0 KDV} other {}}',
      "taxInclusiveLabel": '{taxTerm, select, GST {\u05DB\u05D5\u05DC\u05DC GST} VAT {\u05DB\u05D5\u05DC\u05DC \u05DE\u05E2"\u05DE} TAX {\u05DB\u05D5\u05DC\u05DC \u05DE\u05E1} IVA {\u05DB\u05D5\u05DC\u05DC IVA} SST {\u05DB\u05D5\u05DC\u05DC SST} KDV {\u05DB\u05D5\u05DC\u05DC KDV} other {}}',
      "alternativePriceAriaLabel": "\u05DC\u05D7\u05DC\u05D5\u05E4\u05D9\u05DF \u05D1-{alternativePrice}",
      "strikethroughAriaLabel": "\u05D1\u05D0\u05D5\u05E4\u05DF \u05E7\u05D1\u05D5\u05E2 \u05D1-{strikethroughPrice}"
    }
  ],
  ":type": "sheet"
}.data;
var dr = Object.defineProperty;
var gr = (e36) => {
  throw TypeError(e36);
};
var Ai = (e36, t34, r25) => t34 in e36 ? dr(e36, t34, { enumerable: true, configurable: true, writable: true, value: r25 }) : e36[t34] = r25;
var yi = (e36, t34) => {
  for (var r25 in t34) dr(e36, r25, { get: t34[r25], enumerable: true });
};
var O = (e36, t34, r25) => Ai(e36, typeof t34 != "symbol" ? t34 + "" : t34, r25);
var lt = (e36, t34, r25) => t34.has(e36) || gr("Cannot " + r25);
var ne = (e36, t34, r25) => (lt(e36, t34, "read from private field"), r25 ? r25.call(e36) : t34.get(e36));
var pe = (e36, t34, r25) => t34.has(e36) ? gr("Cannot add the same private member more than once") : t34 instanceof WeakSet ? t34.add(e36) : t34.set(e36, r25);
var Te = (e36, t34, r25, n25) => (lt(e36, t34, "write to private field"), n25 ? n25.call(e36, r25) : t34.set(e36, r25), r25);
var xr = (e36, t34, r25) => (lt(e36, t34, "access private method"), r25);
var Rt = {};
yi(Rt, { CLASS_NAME_FAILED: () => ht, CLASS_NAME_HIDDEN: () => bi, CLASS_NAME_PENDING: () => ft, CLASS_NAME_RESOLVED: () => pt, CheckoutWorkflow: () => br, CheckoutWorkflowStep: () => B2, Commitment: () => ie3, ERROR_MESSAGE_BAD_REQUEST: () => mt, ERROR_MESSAGE_MISSING_LITERALS_URL: () => $i, ERROR_MESSAGE_OFFER_NOT_FOUND: () => Et, EVENT_AEM_ERROR: () => Gi, EVENT_AEM_LOAD: () => Fi, EVENT_MAS_ERROR: () => Yi, EVENT_MAS_READY: () => Vi, EVENT_MERCH_ADDON_AND_QUANTITY_UPDATE: () => Ii, EVENT_MERCH_CARD_ACTION_MENU_TOGGLE: () => Ri, EVENT_MERCH_CARD_COLLECTION_LITERALS_CHANGED: () => Di, EVENT_MERCH_CARD_COLLECTION_SHOWMORE: () => Bi, EVENT_MERCH_CARD_COLLECTION_SIDENAV_ATTACHED: () => Ui, EVENT_MERCH_CARD_COLLECTION_SORT: () => Mi, EVENT_MERCH_CARD_QUANTITY_CHANGE: () => Oi, EVENT_MERCH_OFFER_READY: () => Pi, EVENT_MERCH_OFFER_SELECT_READY: () => vi, EVENT_MERCH_QUANTITY_SELECTOR_CHANGE: () => wi, EVENT_MERCH_SEARCH_CHANGE: () => Hi, EVENT_MERCH_SIDENAV_SELECT: () => ki, EVENT_MERCH_STOCK_CHANGE: () => Li, EVENT_MERCH_STORAGE_CHANGE: () => Ni, EVENT_OFFER_SELECTED: () => Ci, EVENT_TYPE_FAILED: () => dt, EVENT_TYPE_READY: () => be, EVENT_TYPE_RESOLVED: () => gt, Env: () => q2, FF_DEFAULTS: () => me, HEADER_X_REQUEST_ID: () => Se, LOG_NAMESPACE: () => xt, Landscape: () => te, MARK_DURATION_SUFFIX: () => vt, MARK_START_SUFFIX: () => Pt, MODAL_TYPE_3_IN_1: () => oe, NAMESPACE: () => Ti, PARAM_AOS_API_KEY: () => Wi, PARAM_ENV: () => yt, PARAM_LANDSCAPE: () => Tt, PARAM_MAS_PREVIEW: () => At, PARAM_WCS_API_KEY: () => ji, PROVIDER_ENVIRONMENT: () => _t, SELECTOR_MAS_CHECKOUT_LINK: () => yr, SELECTOR_MAS_ELEMENT: () => ut, SELECTOR_MAS_INLINE_PRICE: () => Ar, SELECTOR_MAS_SP_BUTTON: () => _i, SELECTOR_MAS_UPT_LINK: () => Tr, SORT_ORDER: () => Ki, STATE_FAILED: () => z2, STATE_PENDING: () => ee, STATE_RESOLVED: () => Q, TAG_NAME_SERVICE: () => Si, TEMPLATE_PRICE: () => Xi, TEMPLATE_PRICE_ANNUAL: () => zi, TEMPLATE_PRICE_LEGAL: () => Qi, TEMPLATE_PRICE_STRIKETHROUGH: () => qi, Term: () => $3, WCS_PROD_URL: () => bt, WCS_STAGE_URL: () => St });
var ie3 = Object.freeze({ MONTH: "MONTH", YEAR: "YEAR", TWO_YEARS: "TWO_YEARS", THREE_YEARS: "THREE_YEARS", PERPETUAL: "PERPETUAL", TERM_LICENSE: "TERM_LICENSE", ACCESS_PASS: "ACCESS_PASS", THREE_MONTHS: "THREE_MONTHS", SIX_MONTHS: "SIX_MONTHS" });
var $3 = Object.freeze({ ANNUAL: "ANNUAL", MONTHLY: "MONTHLY", TWO_YEARS: "TWO_YEARS", THREE_YEARS: "THREE_YEARS", P1D: "P1D", P1Y: "P1Y", P3Y: "P3Y", P10Y: "P10Y", P15Y: "P15Y", P3D: "P3D", P7D: "P7D", P30D: "P30D", HALF_YEARLY: "HALF_YEARLY", QUARTERLY: "QUARTERLY" });
var Ti = "merch";
var bi = "hidden";
var be = "wcms:commerce:ready";
var Si = "mas-commerce-service";
var Ar = 'span[is="inline-price"][data-wcs-osi]';
var yr = 'a[is="checkout-link"][data-wcs-osi],button[is="checkout-button"][data-wcs-osi]';
var _i = "sp-button[data-wcs-osi]";
var Tr = 'a[is="upt-link"]';
var ut = `${Ar},${yr},${Tr}`;
var Pi = "merch-offer:ready";
var vi = "merch-offer-select:ready";
var Ri = "merch-card:action-menu-toggle";
var Ci = "merch-offer:selected";
var Li = "merch-stock:change";
var Ni = "merch-storage:change";
var wi = "merch-quantity-selector:change";
var Oi = "merch-card-quantity:change";
var Ii = "merch-modal:addon-and-quantity-update";
var Hi = "merch-search:change";
var Mi = "merch-card-collection:sort";
var Di = "merch-card-collection:literals-changed";
var Ui = "merch-card-collection:sidenav-attached";
var Bi = "merch-card-collection:showmore";
var ki = "merch-sidenav:select";
var Fi = "aem:load";
var Gi = "aem:error";
var Vi = "mas:ready";
var Yi = "mas:error";
var ht = "placeholder-failed";
var ft = "placeholder-pending";
var pt = "placeholder-resolved";
var mt = "Bad WCS request";
var Et = "Commerce offer not found";
var $i = "Literals URL not provided";
var dt = "mas:failed";
var gt = "mas:resolved";
var xt = "mas/commerce";
var At = "mas.preview";
var yt = "commerce.env";
var Tt = "commerce.landscape";
var Wi = "commerce.aosKey";
var ji = "commerce.wcsKey";
var bt = "https://www.adobe.com/web_commerce_artifact";
var St = "https://www.stage.adobe.com/web_commerce_artifact_stage";
var z2 = "failed";
var ee = "pending";
var Q = "resolved";
var te = { DRAFT: "DRAFT", PUBLISHED: "PUBLISHED" };
var Se = "X-Request-Id";
var B2 = Object.freeze({ SEGMENTATION: "segmentation", BUNDLE: "bundle", COMMITMENT: "commitment", RECOMMENDATION: "recommendation", EMAIL: "email", PAYMENT: "payment", CHANGE_PLAN_TEAM_PLANS: "change-plan/team-upgrade/plans", CHANGE_PLAN_TEAM_PAYMENT: "change-plan/team-upgrade/payment" });
var br = "UCv3";
var q2 = Object.freeze({ STAGE: "STAGE", PRODUCTION: "PRODUCTION", LOCAL: "LOCAL" });
var _t = { PRODUCTION: "PRODUCTION" };
var oe = { TWP: "twp", D2P: "d2p", CRM: "crm" };
var Pt = ":start";
var vt = ":duration";
var Xi = "price";
var qi = "price-strikethrough";
var zi = "annual";
var Qi = "legal";
var me = "mas-ff-defaults";
var Ki = { alphabetical: "alphabetical", authored: "authored" };
var Sr = "tacocat.js";
var Ct = (e36, t34) => String(e36 ?? "").toLowerCase() == String(t34 ?? "").toLowerCase();
var _r = (e36) => `${e36 ?? ""}`.replace(/[&<>'"]/g, (t34) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" })[t34] ?? t34) ?? "";
function L2(e36, t34 = {}, { metadata: r25 = true, search: n25 = true, storage: i21 = true } = {}) {
  let o52;
  if (n25 && o52 == null) {
    let s19 = new URLSearchParams(window.location.search), a23 = Ee(n25) ? n25 : e36;
    o52 = s19.get(a23);
  }
  if (i21 && o52 == null) {
    let s19 = Ee(i21) ? i21 : e36;
    o52 = window.sessionStorage.getItem(s19) ?? window.localStorage.getItem(s19);
  }
  if (r25 && o52 == null) {
    let s19 = Ji(Ee(r25) ? r25 : e36);
    o52 = document.documentElement.querySelector(`meta[name="${s19}"]`)?.content;
  }
  return o52 ?? t34[e36];
}
var Zi = (e36) => typeof e36 == "boolean";
var Fe = (e36) => typeof e36 == "function";
var Ge = (e36) => typeof e36 == "number";
var Pr = (e36) => e36 != null && typeof e36 == "object";
var Ee = (e36) => typeof e36 == "string";
var vr = (e36) => Ee(e36) && e36;
var _e = (e36) => Ge(e36) && Number.isFinite(e36) && e36 > 0;
function Ve(e36, t34 = (r25) => r25 == null || r25 === "") {
  return e36 != null && Object.entries(e36).forEach(([r25, n25]) => {
    t34(n25) && delete e36[r25];
  }), e36;
}
function g7(e36, t34) {
  if (Zi(e36)) return e36;
  let r25 = String(e36);
  return r25 === "1" || r25 === "true" ? true : r25 === "0" || r25 === "false" ? false : t34;
}
function Pe(e36, t34, r25) {
  let n25 = Object.values(t34);
  return n25.find((i21) => Ct(i21, e36)) ?? r25 ?? n25[0];
}
function Ji(e36 = "") {
  return String(e36).replace(/(\p{Lowercase_Letter})(\p{Uppercase_Letter})/gu, (t34, r25, n25) => `${r25}-${n25}`).replace(/\W+/gu, "-").toLowerCase();
}
function Rr(e36, t34 = 1) {
  return Ge(e36) || (e36 = Number.parseInt(e36, 10)), !Number.isNaN(e36) && e36 > 0 && Number.isFinite(e36) ? e36 : t34;
}
var eo = Date.now();
var Lt = () => `(+${Date.now() - eo}ms)`;
var Ye = /* @__PURE__ */ new Set();
var to = g7(L2("tacocat.debug", {}, { metadata: false }), false);
function Cr(e36) {
  let t34 = `[${Sr}/${e36}]`, r25 = (s19, a23, ...c33) => s19 ? true : (i21(a23, ...c33), false), n25 = to ? (s19, ...a23) => {
    console.debug(`${t34} ${s19}`, ...a23, Lt());
  } : () => {
  }, i21 = (s19, ...a23) => {
    let c33 = `${t34} ${s19}`;
    Ye.forEach(([u36]) => u36(c33, ...a23));
  };
  return { assert: r25, debug: n25, error: i21, warn: (s19, ...a23) => {
    let c33 = `${t34} ${s19}`;
    Ye.forEach(([, u36]) => u36(c33, ...a23));
  } };
}
function ro(e36, t34) {
  let r25 = [e36, t34];
  return Ye.add(r25), () => {
    Ye.delete(r25);
  };
}
ro((e36, ...t34) => {
  console.error(e36, ...t34, Lt());
}, (e36, ...t34) => {
  console.warn(e36, ...t34, Lt());
});
var no = "no promo";
var Lr = "promo-tag";
var io = "yellow";
var oo = "neutral";
var so = (e36, t34, r25) => {
  let n25 = (o52) => o52 || no, i21 = r25 ? ` (was "${n25(t34)}")` : "";
  return `${n25(e36)}${i21}`;
};
var ao = "cancel-context";
var $e = (e36, t34) => {
  let r25 = e36 === ao, n25 = !r25 && e36?.length > 0, i21 = (n25 || r25) && (t34 && t34 != e36 || !t34 && !r25), o52 = i21 && n25 || !i21 && !!t34, s19 = o52 ? e36 || t34 : void 0;
  return { effectivePromoCode: s19, overridenPromoCode: e36, className: o52 ? Lr : `${Lr} no-promo`, text: so(s19, t34, i21), variant: o52 ? io : oo, isOverriden: i21 };
};
var Nt;
(function(e36) {
  e36.BASE = "BASE", e36.TRIAL = "TRIAL", e36.PROMOTION = "PROMOTION";
})(Nt || (Nt = {}));
var G;
(function(e36) {
  e36.MONTH = "MONTH", e36.YEAR = "YEAR", e36.TWO_YEARS = "TWO_YEARS", e36.THREE_YEARS = "THREE_YEARS", e36.PERPETUAL = "PERPETUAL", e36.TERM_LICENSE = "TERM_LICENSE", e36.ACCESS_PASS = "ACCESS_PASS", e36.THREE_MONTHS = "THREE_MONTHS", e36.SIX_MONTHS = "SIX_MONTHS";
})(G || (G = {}));
var W;
(function(e36) {
  e36.ANNUAL = "ANNUAL", e36.MONTHLY = "MONTHLY", e36.TWO_YEARS = "TWO_YEARS", e36.THREE_YEARS = "THREE_YEARS", e36.P1D = "P1D", e36.P1Y = "P1Y", e36.P3Y = "P3Y", e36.P10Y = "P10Y", e36.P15Y = "P15Y", e36.P3D = "P3D", e36.P7D = "P7D", e36.P30D = "P30D", e36.HALF_YEARLY = "HALF_YEARLY", e36.QUARTERLY = "QUARTERLY";
})(W || (W = {}));
var wt;
(function(e36) {
  e36.INDIVIDUAL = "INDIVIDUAL", e36.TEAM = "TEAM", e36.ENTERPRISE = "ENTERPRISE";
})(wt || (wt = {}));
var Ot;
(function(e36) {
  e36.COM = "COM", e36.EDU = "EDU", e36.GOV = "GOV";
})(Ot || (Ot = {}));
var It;
(function(e36) {
  e36.DIRECT = "DIRECT", e36.INDIRECT = "INDIRECT";
})(It || (It = {}));
var Ht;
(function(e36) {
  e36.ENTERPRISE_PRODUCT = "ENTERPRISE_PRODUCT", e36.ETLA = "ETLA", e36.RETAIL = "RETAIL", e36.VIP = "VIP", e36.VIPMP = "VIPMP", e36.FREE = "FREE";
})(Ht || (Ht = {}));
var Mt = "ABM";
var Dt = "PUF";
var Ut = "M2M";
var Bt = "PERPETUAL";
var kt = "P3Y";
var co = "TAX_INCLUSIVE_DETAILS";
var lo = "TAX_EXCLUSIVE";
var Nr = { ABM: Mt, PUF: Dt, M2M: Ut, PERPETUAL: Bt, P3Y: kt };
var Gs = { [Mt]: { commitment: G.YEAR, term: W.MONTHLY }, [Dt]: { commitment: G.YEAR, term: W.ANNUAL }, [Ut]: { commitment: G.MONTH, term: W.MONTHLY }, [Bt]: { commitment: G.PERPETUAL, term: void 0 }, [kt]: { commitment: G.THREE_MONTHS, term: W.P3Y } };
var wr = "Value is not an offer";
var ve = (e36) => {
  if (typeof e36 != "object") return wr;
  let { commitment: t34, term: r25 } = e36, n25 = uo(t34, r25);
  return { ...e36, planType: n25 };
};
var uo = (e36, t34) => {
  switch (e36) {
    case void 0:
      return wr;
    case "":
      return "";
    case G.YEAR:
      return t34 === W.MONTHLY ? Mt : t34 === W.ANNUAL ? Dt : "";
    case G.MONTH:
      return t34 === W.MONTHLY ? Ut : "";
    case G.PERPETUAL:
      return Bt;
    case G.TERM_LICENSE:
      return t34 === W.P3Y ? kt : "";
    default:
      return "";
  }
};
function Or(e36) {
  let { priceDetails: t34 } = e36, { price: r25, priceWithoutDiscount: n25, priceWithoutTax: i21, priceWithoutDiscountAndTax: o52, taxDisplay: s19 } = t34;
  if (s19 !== co) return e36;
  let a23 = { ...e36, priceDetails: { ...t34, price: i21 ?? r25, priceWithoutDiscount: o52 ?? n25, taxDisplay: lo } };
  return a23.offerType === "TRIAL" && a23.priceDetails.price === 0 && (a23.priceDetails.price = a23.priceDetails.priceWithoutDiscount), a23;
}
var ho = "mas-commerce-service";
var fo = { requestId: Se, etag: "Etag", lastModified: "Last-Modified", serverTiming: "server-timing" };
function Ft(e36, { country: t34, forceTaxExclusive: r25 }) {
  let n25;
  if (e36.length < 2) n25 = e36;
  else {
    let i21 = t34 === "GB" ? "EN" : "MULT";
    e36.sort((o52, s19) => o52.language === i21 ? -1 : s19.language === i21 ? 1 : 0), e36.sort((o52, s19) => !o52.term && s19.term ? -1 : o52.term && !s19.term ? 1 : 0), n25 = [e36[0]];
  }
  return r25 && (n25 = n25.map(Or)), n25;
}
var We = (e36) => window.setTimeout(e36);
function de(e36, t34 = 1) {
  if (e36 == null) return [t34];
  let r25 = (Array.isArray(e36) ? e36 : String(e36).split(",")).map(Rr).filter(_e);
  return r25.length || (r25 = [t34]), r25;
}
function Re(e36) {
  return e36 == null ? [] : (Array.isArray(e36) ? e36 : String(e36).split(",")).filter(vr);
}
function j2() {
  return document.getElementsByTagName(ho)?.[0];
}
function Ir(e36) {
  let t34 = {};
  if (!e36?.headers) return t34;
  let r25 = e36.headers;
  for (let [n25, i21] of Object.entries(fo)) {
    let o52 = r25.get(i21);
    o52 && (o52 = o52.replace(/[,;]/g, "|"), o52 = o52.replace(/[| ]+/g, "|"), t34[n25] = o52);
  }
  return t34;
}
var se = { clientId: "merch-at-scale", delimiter: "\xB6", ignoredProperties: ["analytics", "literals", "element"], serializableTypes: ["Array", "Object"], sampleRate: 1, tags: "acom", isProdDomain: false };
var Hr = 1e3;
function po(e36) {
  return e36 instanceof Error || typeof e36?.originatingRequest == "string";
}
function Mr(e36) {
  if (e36 == null) return;
  let t34 = typeof e36;
  if (t34 === "function") return e36.name ? `function ${e36.name}` : "function";
  if (t34 === "object") {
    if (e36 instanceof Error) return e36.message;
    if (typeof e36.originatingRequest == "string") {
      let { message: n25, originatingRequest: i21, status: o52 } = e36;
      return [n25, o52, i21].filter(Boolean).join(" ");
    }
    let r25 = e36[Symbol.toStringTag] ?? Object.getPrototypeOf(e36).constructor.name;
    if (!se.serializableTypes.includes(r25)) return r25;
  }
  return e36;
}
function mo(e36, t34) {
  if (!se.ignoredProperties.includes(e36)) return Mr(t34);
}
var Gt = { append(e36) {
  if (e36.level !== "error") return;
  let { message: t34, params: r25 } = e36, n25 = [], i21 = [], o52 = t34;
  r25.forEach((u36) => {
    u36 != null && (po(u36) ? n25 : i21).push(u36);
  }), n25.length && (o52 += " " + n25.map(Mr).join(" "));
  let { pathname: s19, search: a23 } = window.location, c33 = `${se.delimiter}page=${s19}${a23}`;
  c33.length > Hr && (c33 = `${c33.slice(0, Hr)}<trunc>`), o52 += c33, i21.length && (o52 += `${se.delimiter}facts=`, o52 += JSON.stringify(i21, mo)), window.lana?.log(o52, se);
} };
function je(e36) {
  Object.assign(se, Object.fromEntries(Object.entries(e36).filter(([t34, r25]) => t34 in se && r25 !== "" && r25 !== null && r25 !== void 0 && !Number.isNaN(r25))));
}
var Dr = { LOCAL: "local", PROD: "prod", STAGE: "stage" };
var Vt = { DEBUG: "debug", ERROR: "error", INFO: "info", WARN: "warn" };
var Yt = /* @__PURE__ */ new Set();
var $t = /* @__PURE__ */ new Set();
var Ur = /* @__PURE__ */ new Map();
var Br = { append({ level: e36, message: t34, params: r25, timestamp: n25, source: i21 }) {
  console[e36](`${n25}ms [${i21}] %c${t34}`, "font-weight: bold;", ...r25);
} };
var kr = { filter: ({ level: e36 }) => e36 !== Vt.DEBUG };
var Eo = { filter: () => false };
function go(e36, t34, r25, n25, i21) {
  return { level: e36, message: t34, namespace: r25, get params() {
    return n25.length === 1 && Fe(n25[0]) && (n25 = n25[0](), Array.isArray(n25) || (n25 = [n25])), n25;
  }, source: i21, timestamp: performance.now().toFixed(3) };
}
function xo(e36) {
  [...$t].every((t34) => t34(e36)) && Yt.forEach((t34) => t34(e36));
}
function Fr(e36) {
  let t34 = (Ur.get(e36) ?? 0) + 1;
  Ur.set(e36, t34);
  let r25 = `${e36} #${t34}`, n25 = { id: r25, namespace: e36, module: (i21) => Fr(`${n25.namespace}/${i21}`), updateConfig: je };
  return Object.values(Vt).forEach((i21) => {
    n25[i21] = (o52, ...s19) => xo(go(i21, o52, e36, s19, r25));
  }), Object.seal(n25);
}
function Xe(...e36) {
  e36.forEach((t34) => {
    let { append: r25, filter: n25 } = t34;
    Fe(n25) && $t.add(n25), Fe(r25) && Yt.add(r25);
  });
}
function Ao(e36 = {}) {
  let { name: t34 } = e36, r25 = g7(L2("commerce.debug", { search: true, storage: true }), t34 === Dr.LOCAL);
  return Xe(r25 ? Br : kr), t34 === Dr.PROD && Xe(Gt), V2;
}
function yo() {
  Yt.clear(), $t.clear();
}
var V2 = { ...Fr(xt), Level: Vt, Plugins: { consoleAppender: Br, debugFilter: kr, quietFilter: Eo, lanaAppender: Gt }, init: Ao, reset: yo, use: Xe };
var ge = class e35 extends Error {
  constructor(t34, r25, n25) {
    if (super(t34, { cause: n25 }), this.name = "MasError", r25.response) {
      let i21 = r25.response.headers?.get(Se);
      i21 && (r25.requestId = i21), r25.response.status && (r25.status = r25.response.status, r25.statusText = r25.response.statusText), r25.response.url && (r25.url = r25.response.url);
    }
    delete r25.response, this.context = r25, Error.captureStackTrace && Error.captureStackTrace(this, e35);
  }
  toString() {
    let t34 = Object.entries(this.context || {}).map(([n25, i21]) => `${n25}: ${JSON.stringify(i21)}`).join(", "), r25 = `${this.name}: ${this.message}`;
    return t34 && (r25 += ` (${t34})`), this.cause && (r25 += `
Caused by: ${this.cause}`), r25;
  }
};
var To = { [z2]: ht, [ee]: ft, [Q]: pt };
var bo = { [z2]: dt, [Q]: gt };
var Ce;
var qe = class {
  constructor(t34) {
    pe(this, Ce);
    O(this, "changes", /* @__PURE__ */ new Map());
    O(this, "connected", false);
    O(this, "error");
    O(this, "log");
    O(this, "options");
    O(this, "promises", []);
    O(this, "state", ee);
    O(this, "timer", null);
    O(this, "value");
    O(this, "version", 0);
    O(this, "wrapperElement");
    this.wrapperElement = t34, this.log = V2.module("mas-element");
  }
  update() {
    [z2, ee, Q].forEach((t34) => {
      this.wrapperElement.classList.toggle(To[t34], t34 === this.state);
    });
  }
  notify() {
    (this.state === Q || this.state === z2) && (this.state === Q ? this.promises.forEach(({ resolve: r25 }) => r25(this.wrapperElement)) : this.state === z2 && this.promises.forEach(({ reject: r25 }) => r25(this.error)), this.promises = []);
    let t34 = this.error;
    this.error instanceof ge && (t34 = { message: this.error.message, ...this.error.context }), this.wrapperElement.dispatchEvent(new CustomEvent(bo[this.state], { bubbles: true, detail: t34 }));
  }
  attributeChangedCallback(t34, r25, n25) {
    this.changes.set(t34, n25), this.requestUpdate();
  }
  connectedCallback() {
    Te(this, Ce, j2()), this.requestUpdate(true);
  }
  disconnectedCallback() {
    this.connected && (this.connected = false, this.log?.debug("Disconnected:", { element: this.wrapperElement }));
  }
  onceSettled() {
    let { error: t34, promises: r25, state: n25 } = this;
    return Q === n25 ? Promise.resolve(this.wrapperElement) : z2 === n25 ? Promise.reject(t34) : new Promise((i21, o52) => {
      r25.push({ resolve: i21, reject: o52 });
    });
  }
  toggleResolved(t34, r25, n25) {
    return t34 !== this.version ? false : (n25 !== void 0 && (this.options = n25), this.state = Q, this.value = r25, this.update(), this.log?.debug("Resolved:", { element: this.wrapperElement, value: r25 }), We(() => this.notify()), true);
  }
  toggleFailed(t34, r25, n25) {
    if (t34 !== this.version) return false;
    n25 !== void 0 && (this.options = n25), this.error = r25, this.state = z2, this.update();
    let i21 = this.wrapperElement.getAttribute("is");
    return this.log?.error(`${i21}: Failed to render: ${r25.message}`, { element: this.wrapperElement, ...r25.context, ...ne(this, Ce)?.duration }), We(() => this.notify()), true;
  }
  togglePending(t34) {
    return this.version++, t34 && (this.options = t34), this.state = ee, this.update(), this.log?.debug("Pending:", { osi: this.wrapperElement?.options?.wcsOsi }), this.version;
  }
  requestUpdate(t34 = false) {
    if (!this.wrapperElement.isConnected || !j2() || this.timer) return;
    let { error: r25, options: n25, state: i21, value: o52, version: s19 } = this;
    this.state = ee, this.timer = We(async () => {
      this.timer = null;
      let a23 = null;
      if (this.changes.size && (a23 = Object.fromEntries(this.changes.entries()), this.changes.clear()), this.connected ? this.log?.debug("Updated:", { element: this.wrapperElement, changes: a23 }) : (this.connected = true, this.log?.debug("Connected:", { element: this.wrapperElement, changes: a23 })), a23 || t34) try {
        await this.wrapperElement.render?.() === false && this.state === ee && this.version === s19 && (this.state = i21, this.error = r25, this.value = o52, this.update(), this.notify());
      } catch (c33) {
        this.toggleFailed(this.version, c33, n25);
      }
    });
  }
};
Ce = /* @__PURE__ */ new WeakMap();
function Gr(e36 = {}) {
  return Object.entries(e36).forEach(([t34, r25]) => {
    (r25 == null || r25 === "" || r25?.length === 0) && delete e36[t34];
  }), e36;
}
function Vr(e36, t34 = {}) {
  let { tag: r25, is: n25 } = e36, i21 = document.createElement(r25, { is: n25 });
  return i21.setAttribute("is", n25), Object.assign(i21.dataset, Gr(t34)), i21;
}
function Yr(e36, t34 = {}) {
  return e36 instanceof HTMLElement ? (Object.assign(e36.dataset, Gr(t34)), e36) : null;
}
var $r = "download";
var Wr = "upgrade";
var jr = { e: "EDU", t: "TEAM" };
function Xr(e36, t34 = {}, r25 = "") {
  let n25 = j2();
  if (!n25) return null;
  let { checkoutMarketSegment: i21, checkoutWorkflow: o52, checkoutWorkflowStep: s19, entitlement: a23, upgrade: c33, modal: u36, perpetual: l16, promotionCode: p30, quantity: f11, wcsOsi: h16, extraOptions: E3, analyticsId: m18 } = n25.collectCheckoutOptions(t34), y5 = Vr(e36, { checkoutMarketSegment: i21, checkoutWorkflow: o52, checkoutWorkflowStep: s19, entitlement: a23, upgrade: c33, modal: u36, perpetual: l16, promotionCode: p30, quantity: f11, wcsOsi: h16, extraOptions: E3, analyticsId: m18 });
  return r25 && (y5.innerHTML = `<span style="pointer-events: none;">${r25}</span>`), y5;
}
function qr(e36) {
  return class extends e36 {
    constructor() {
      super(...arguments);
      O(this, "checkoutActionHandler");
      O(this, "masElement", new qe(this));
    }
    attributeChangedCallback(n25, i21, o52) {
      this.masElement.attributeChangedCallback(n25, i21, o52);
    }
    connectedCallback() {
      this.masElement.connectedCallback(), this.addEventListener("click", this.clickHandler);
    }
    disconnectedCallback() {
      this.masElement.disconnectedCallback(), this.removeEventListener("click", this.clickHandler);
    }
    onceSettled() {
      return this.masElement.onceSettled();
    }
    get value() {
      return this.masElement.value;
    }
    get options() {
      return this.masElement.options;
    }
    get marketSegment() {
      let n25 = this.options?.ms ?? this.value?.[0].marketSegments?.[0];
      return jr[n25] ?? n25;
    }
    get customerSegment() {
      let n25 = this.options?.cs ?? this.value?.[0]?.customerSegment;
      return jr[n25] ?? n25;
    }
    get is3in1Modal() {
      return Object.values(oe).includes(this.getAttribute("data-modal"));
    }
    get isOpen3in1Modal() {
      let n25 = document.querySelector("meta[name=mas-ff-3in1]");
      return this.is3in1Modal && (!n25 || n25.content !== "off");
    }
    requestUpdate(n25 = false) {
      return this.masElement.requestUpdate(n25);
    }
    static get observedAttributes() {
      return ["data-checkout-workflow", "data-checkout-workflow-step", "data-extra-options", "data-ims-country", "data-perpetual", "data-promotion-code", "data-quantity", "data-template", "data-wcs-osi", "data-entitlement", "data-upgrade", "data-modal"];
    }
    async render(n25 = {}) {
      let i21 = j2();
      if (!i21) return false;
      this.dataset.imsCountry || i21.imsCountryPromise.then((p30) => {
        p30 && (this.dataset.imsCountry = p30);
      }), n25.imsCountry = null;
      let o52 = i21.collectCheckoutOptions(n25, this);
      if (!o52.wcsOsi.length) return false;
      let s19;
      try {
        s19 = JSON.parse(o52.extraOptions ?? "{}");
      } catch (p30) {
        this.masElement.log?.error("cannot parse exta checkout options", p30);
      }
      let a23 = this.masElement.togglePending(o52);
      this.setCheckoutUrl("");
      let c33 = i21.resolveOfferSelectors(o52), u36 = await Promise.all(c33);
      u36 = u36.map((p30) => Ft(p30, o52)), o52.country = this.dataset.imsCountry || o52.country;
      let l16 = await i21.buildCheckoutAction?.(u36.flat(), { ...s19, ...o52 }, this);
      return this.renderOffers(u36.flat(), o52, {}, l16, a23);
    }
    renderOffers(n25, i21, o52 = {}, s19 = void 0, a23 = void 0) {
      let c33 = j2();
      if (!c33) return false;
      if (i21 = { ...JSON.parse(this.dataset.extraOptions ?? "{}"), ...i21, ...o52 }, a23 ?? (a23 = this.masElement.togglePending(i21)), this.checkoutActionHandler && (this.checkoutActionHandler = void 0), s19) {
        this.classList.remove($r, Wr), this.masElement.toggleResolved(a23, n25, i21);
        let { url: l16, text: p30, className: f11, handler: h16 } = s19;
        l16 && this.setCheckoutUrl(l16), p30 && (this.firstElementChild.innerHTML = p30), f11 && this.classList.add(...f11.split(" ")), h16 && (this.setCheckoutUrl("#"), this.checkoutActionHandler = h16.bind(this));
      }
      if (n25.length) {
        if (this.masElement.toggleResolved(a23, n25, i21)) {
          if (!this.classList.contains($r) && !this.classList.contains(Wr)) {
            let l16 = c33.buildCheckoutURL(n25, i21);
            this.setCheckoutUrl(i21.modal === "true" ? "#" : l16);
          }
          return true;
        }
      } else {
        let l16 = new Error(`Not provided: ${i21?.wcsOsi ?? "-"}`);
        if (this.masElement.toggleFailed(a23, l16, i21)) return this.setCheckoutUrl("#"), true;
      }
    }
    setCheckoutUrl() {
    }
    clickHandler(n25) {
    }
    updateOptions(n25 = {}) {
      let i21 = j2();
      if (!i21) return false;
      let { checkoutMarketSegment: o52, checkoutWorkflow: s19, checkoutWorkflowStep: a23, entitlement: c33, upgrade: u36, modal: l16, perpetual: p30, promotionCode: f11, quantity: h16, wcsOsi: E3 } = i21.collectCheckoutOptions(n25);
      return Yr(this, { checkoutMarketSegment: o52, checkoutWorkflow: s19, checkoutWorkflowStep: a23, entitlement: c33, upgrade: u36, modal: l16, perpetual: p30, promotionCode: f11, quantity: h16, wcsOsi: E3 }), true;
    }
  };
}
var Le = class Le2 extends qr(HTMLAnchorElement) {
  static createCheckoutLink(t34 = {}, r25 = "") {
    return Xr(Le2, t34, r25);
  }
  setCheckoutUrl(t34) {
    this.setAttribute("href", t34);
  }
  get isCheckoutLink() {
    return true;
  }
  clickHandler(t34) {
    if (this.checkoutActionHandler) {
      this.checkoutActionHandler?.(t34);
      return;
    }
  }
};
O(Le, "is", "checkout-link"), O(Le, "tag", "a");
var K = Le;
window.customElements.get(K.is) || window.customElements.define(K.is, K, { extends: K.tag });
var So = "p_draft_landscape";
var _o = "/store/";
var Po = /* @__PURE__ */ new Map([["countrySpecific", "cs"], ["customerSegment", "cs"], ["quantity", "q"], ["authCode", "code"], ["checkoutPromoCode", "apc"], ["rurl", "rUrl"], ["curl", "cUrl"], ["ctxrturl", "ctxRtUrl"], ["country", "co"], ["language", "lang"], ["clientId", "cli"], ["context", "ctx"], ["productArrangementCode", "pa"], ["addonProductArrangementCode", "ao"], ["offerType", "ot"], ["marketSegment", "ms"]]);
var Wt = /* @__PURE__ */ new Set(["af", "ai", "ao", "apc", "appctxid", "cli", "co", "cs", "csm", "ctx", "ctxRtUrl", "DCWATC", "dp", "fr", "gsp", "ijt", "lang", "lo", "mal", "ms", "mv", "mv2", "nglwfdata", "ot", "otac", "pa", "pcid", "promoid", "q", "rf", "sc", "scl", "sdid", "sid", "spint", "svar", "th", "thm", "trackingid", "usid", "workflowid", "context.guid", "so.ca", "so.su", "so.tr", "so.va"]);
var vo = ["env", "workflowStep", "clientId", "country"];
var zr = (e36) => Po.get(e36) ?? e36;
function jt(e36, t34, r25) {
  for (let [n25, i21] of Object.entries(e36)) {
    let o52 = zr(n25);
    i21 != null && r25.has(o52) && t34.set(o52, i21);
  }
}
function Ro(e36) {
  switch (e36) {
    case _t.PRODUCTION:
      return "https://commerce.adobe.com";
    default:
      return "https://commerce-stg.adobe.com";
  }
}
function Co(e36, t34) {
  for (let r25 in e36) {
    let n25 = e36[r25];
    for (let [i21, o52] of Object.entries(n25)) {
      if (o52 == null) continue;
      let s19 = zr(i21);
      t34.set(`items[${r25}][${s19}]`, o52);
    }
  }
}
function Lo({ url: e36, modal: t34, is3in1: r25 }) {
  if (!r25 || !e36?.searchParams) return e36;
  e36.searchParams.set("rtc", "t"), e36.searchParams.set("lo", "sl");
  let n25 = e36.searchParams.get("af");
  return e36.searchParams.set("af", [n25, "uc_new_user_iframe", "uc_new_system_close"].filter(Boolean).join(",")), e36.searchParams.get("cli") !== "doc_cloud" && e36.searchParams.set("cli", t34 === oe.CRM ? "creative" : "mini_plans"), e36;
}
function Qr(e36) {
  No(e36);
  let { env: t34, items: r25, workflowStep: n25, marketSegment: i21, customerSegment: o52, offerType: s19, productArrangementCode: a23, landscape: c33, modal: u36, is3in1: l16, preselectPlan: p30, ...f11 } = e36, h16 = new URL(Ro(t34));
  if (h16.pathname = `${_o}${n25}`, n25 !== B2.SEGMENTATION && n25 !== B2.CHANGE_PLAN_TEAM_PLANS && Co(r25, h16.searchParams), jt({ ...f11 }, h16.searchParams, Wt), c33 === te.DRAFT && jt({ af: So }, h16.searchParams, Wt), n25 === B2.SEGMENTATION) {
    let E3 = { marketSegment: i21, offerType: s19, customerSegment: o52, productArrangementCode: a23, quantity: r25?.[0]?.quantity, addonProductArrangementCode: a23 ? r25?.find((m18) => m18.productArrangementCode !== a23)?.productArrangementCode : r25?.[1]?.productArrangementCode };
    p30?.toLowerCase() === "edu" ? h16.searchParams.set("ms", "EDU") : p30?.toLowerCase() === "team" && h16.searchParams.set("cs", "TEAM"), jt(E3, h16.searchParams, Wt), h16.searchParams.get("ot") === "PROMOTION" && h16.searchParams.delete("ot"), h16 = Lo({ url: h16, modal: u36, is3in1: l16 });
  }
  return h16.toString();
}
function No(e36) {
  for (let t34 of vo) if (!e36[t34]) throw new Error('Argument "checkoutData" is not valid, missing: ' + t34);
  if (e36.workflowStep !== B2.SEGMENTATION && e36.workflowStep !== B2.CHANGE_PLAN_TEAM_PLANS && !e36.items) throw new Error('Argument "checkoutData" is not valid, missing: items');
  return true;
}
var P3 = Object.freeze({ checkoutClientId: "adobe_com", checkoutWorkflowStep: B2.EMAIL, country: "US", displayOldPrice: false, displayPerUnit: false, displayRecurrence: true, displayTax: false, displayPlanType: false, env: q2.PRODUCTION, forceTaxExclusive: false, language: "en", entitlement: false, extraOptions: {}, modal: false, promotionCode: "", quantity: 1, alternativePrice: false, wcsApiKey: "wcms-commerce-ims-ro-user-milo", wcsURL: "https://www.adobe.com/web_commerce_artifact", landscape: te.PUBLISHED });
function Kr({ settings: e36, providers: t34 }) {
  function r25(o52, s19) {
    let { checkoutClientId: a23, checkoutWorkflowStep: c33, country: u36, language: l16, promotionCode: p30, quantity: f11, preselectPlan: h16, env: E3 } = e36, m18 = { checkoutClientId: a23, checkoutWorkflowStep: c33, country: u36, language: l16, promotionCode: p30, quantity: f11, preselectPlan: h16, env: E3 };
    if (s19) for (let ue of t34.checkout) ue(s19, m18);
    let { checkoutMarketSegment: y5, checkoutWorkflowStep: _2 = c33, imsCountry: b12, country: T5 = b12 ?? u36, language: S4 = l16, quantity: v6 = f11, entitlement: w3, upgrade: H2, modal: k2, perpetual: N2, promotionCode: R2 = p30, wcsOsi: D, extraOptions: Y, ...J } = Object.assign(m18, s19?.dataset ?? {}, o52 ?? {}), X = Pe(_2, B2, P3.checkoutWorkflowStep);
    return m18 = Ve({ ...J, extraOptions: Y, checkoutClientId: a23, checkoutMarketSegment: y5, country: T5, quantity: de(v6, P3.quantity), checkoutWorkflowStep: X, language: S4, entitlement: g7(w3), upgrade: g7(H2), modal: k2, perpetual: g7(N2), promotionCode: $e(R2).effectivePromoCode, wcsOsi: Re(D), preselectPlan: h16 }), m18;
  }
  function n25(o52, s19) {
    if (!Array.isArray(o52) || !o52.length || !s19) return "";
    let { env: a23, landscape: c33 } = e36, { checkoutClientId: u36, checkoutMarketSegment: l16, checkoutWorkflowStep: p30, country: f11, promotionCode: h16, quantity: E3, preselectPlan: m18, ms: y5, cs: _2, ...b12 } = r25(s19), T5 = document.querySelector("meta[name=mas-ff-3in1]"), S4 = Object.values(oe).includes(s19.modal) && (!T5 || T5.content !== "off"), v6 = window.frameElement || S4 ? "if" : "fp", [{ productArrangementCode: w3, marketSegments: [H2], customerSegment: k2, offerType: N2 }] = o52, R2 = y5 ?? H2 ?? l16, D = _2 ?? k2;
    m18?.toLowerCase() === "edu" ? R2 = "EDU" : m18?.toLowerCase() === "team" && (D = "TEAM");
    let Y = { is3in1: S4, checkoutPromoCode: h16, clientId: u36, context: v6, country: f11, env: a23, items: [], marketSegment: R2, customerSegment: D, offerType: N2, productArrangementCode: w3, workflowStep: p30, landscape: c33, ...b12 }, J = E3[0] > 1 ? E3[0] : void 0;
    if (o52.length === 1) {
      let { offerId: X } = o52[0];
      Y.items.push({ id: X, quantity: J });
    } else Y.items.push(...o52.map(({ offerId: X, productArrangementCode: ue }) => ({ id: X, quantity: J, ...S4 ? { productArrangementCode: ue } : {} })));
    return Qr(Y);
  }
  let { createCheckoutLink: i21 } = K;
  return { CheckoutLink: K, CheckoutWorkflowStep: B2, buildCheckoutURL: n25, collectCheckoutOptions: r25, createCheckoutLink: i21 };
}
function wo({ interval: e36 = 200, maxAttempts: t34 = 25 } = {}) {
  let r25 = V2.module("ims");
  return new Promise((n25) => {
    r25.debug("Waing for IMS to be ready");
    let i21 = 0;
    function o52() {
      window.adobeIMS?.initialized ? n25() : ++i21 > t34 ? (r25.debug("Timeout"), n25()) : setTimeout(o52, e36);
    }
    o52();
  });
}
function Oo(e36) {
  return e36.then(() => window.adobeIMS?.isSignedInUser() ?? false);
}
function Io(e36) {
  let t34 = V2.module("ims");
  return e36.then((r25) => r25 ? window.adobeIMS.getProfile().then(({ countryCode: n25 }) => (t34.debug("Got user country:", n25), n25), (n25) => {
    t34.error("Unable to get user country:", n25);
  }) : null);
}
function Zr({}) {
  let e36 = wo(), t34 = Oo(e36), r25 = Io(t34);
  return { imsReadyPromise: e36, imsSignedInPromise: t34, imsCountryPromise: r25 };
}
var Jr = window.masPriceLiterals;
function en(e36) {
  if (Array.isArray(Jr)) {
    let t34 = (n25) => Jr.find((i21) => Ct(i21.lang, n25)), r25 = t34(e36.language) ?? t34(P3.language);
    if (r25) return Object.freeze(r25);
  }
  return {};
}
var Xt = function(e36, t34) {
  return Xt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r25, n25) {
    r25.__proto__ = n25;
  } || function(r25, n25) {
    for (var i21 in n25) Object.prototype.hasOwnProperty.call(n25, i21) && (r25[i21] = n25[i21]);
  }, Xt(e36, t34);
};
function Ne(e36, t34) {
  if (typeof t34 != "function" && t34 !== null) throw new TypeError("Class extends value " + String(t34) + " is not a constructor or null");
  Xt(e36, t34);
  function r25() {
    this.constructor = e36;
  }
  e36.prototype = t34 === null ? Object.create(t34) : (r25.prototype = t34.prototype, new r25());
}
var x4 = function() {
  return x4 = Object.assign || function(t34) {
    for (var r25, n25 = 1, i21 = arguments.length; n25 < i21; n25++) {
      r25 = arguments[n25];
      for (var o52 in r25) Object.prototype.hasOwnProperty.call(r25, o52) && (t34[o52] = r25[o52]);
    }
    return t34;
  }, x4.apply(this, arguments);
};
function ze(e36, t34, r25) {
  if (r25 || arguments.length === 2) for (var n25 = 0, i21 = t34.length, o52; n25 < i21; n25++) (o52 || !(n25 in t34)) && (o52 || (o52 = Array.prototype.slice.call(t34, 0, n25)), o52[n25] = t34[n25]);
  return e36.concat(o52 || Array.prototype.slice.call(t34));
}
var d21;
(function(e36) {
  e36[e36.EXPECT_ARGUMENT_CLOSING_BRACE = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE", e36[e36.EMPTY_ARGUMENT = 2] = "EMPTY_ARGUMENT", e36[e36.MALFORMED_ARGUMENT = 3] = "MALFORMED_ARGUMENT", e36[e36.EXPECT_ARGUMENT_TYPE = 4] = "EXPECT_ARGUMENT_TYPE", e36[e36.INVALID_ARGUMENT_TYPE = 5] = "INVALID_ARGUMENT_TYPE", e36[e36.EXPECT_ARGUMENT_STYLE = 6] = "EXPECT_ARGUMENT_STYLE", e36[e36.INVALID_NUMBER_SKELETON = 7] = "INVALID_NUMBER_SKELETON", e36[e36.INVALID_DATE_TIME_SKELETON = 8] = "INVALID_DATE_TIME_SKELETON", e36[e36.EXPECT_NUMBER_SKELETON = 9] = "EXPECT_NUMBER_SKELETON", e36[e36.EXPECT_DATE_TIME_SKELETON = 10] = "EXPECT_DATE_TIME_SKELETON", e36[e36.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE", e36[e36.EXPECT_SELECT_ARGUMENT_OPTIONS = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS", e36[e36.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE", e36[e36.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE", e36[e36.EXPECT_SELECT_ARGUMENT_SELECTOR = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR", e36[e36.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR", e36[e36.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT", e36[e36.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT", e36[e36.INVALID_PLURAL_ARGUMENT_SELECTOR = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR", e36[e36.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR", e36[e36.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR", e36[e36.MISSING_OTHER_CLAUSE = 22] = "MISSING_OTHER_CLAUSE", e36[e36.INVALID_TAG = 23] = "INVALID_TAG", e36[e36.INVALID_TAG_NAME = 25] = "INVALID_TAG_NAME", e36[e36.UNMATCHED_CLOSING_TAG = 26] = "UNMATCHED_CLOSING_TAG", e36[e36.UNCLOSED_TAG = 27] = "UNCLOSED_TAG";
})(d21 || (d21 = {}));
var C5;
(function(e36) {
  e36[e36.literal = 0] = "literal", e36[e36.argument = 1] = "argument", e36[e36.number = 2] = "number", e36[e36.date = 3] = "date", e36[e36.time = 4] = "time", e36[e36.select = 5] = "select", e36[e36.plural = 6] = "plural", e36[e36.pound = 7] = "pound", e36[e36.tag = 8] = "tag";
})(C5 || (C5 = {}));
var ae;
(function(e36) {
  e36[e36.number = 0] = "number", e36[e36.dateTime = 1] = "dateTime";
})(ae || (ae = {}));
function qt(e36) {
  return e36.type === C5.literal;
}
function tn(e36) {
  return e36.type === C5.argument;
}
function Qe(e36) {
  return e36.type === C5.number;
}
function Ke(e36) {
  return e36.type === C5.date;
}
function Ze(e36) {
  return e36.type === C5.time;
}
function Je(e36) {
  return e36.type === C5.select;
}
function et(e36) {
  return e36.type === C5.plural;
}
function rn(e36) {
  return e36.type === C5.pound;
}
function tt(e36) {
  return e36.type === C5.tag;
}
function rt(e36) {
  return !!(e36 && typeof e36 == "object" && e36.type === ae.number);
}
function we(e36) {
  return !!(e36 && typeof e36 == "object" && e36.type === ae.dateTime);
}
var zt = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var Ho = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function nn(e36) {
  var t34 = {};
  return e36.replace(Ho, function(r25) {
    var n25 = r25.length;
    switch (r25[0]) {
      case "G":
        t34.era = n25 === 4 ? "long" : n25 === 5 ? "narrow" : "short";
        break;
      case "y":
        t34.year = n25 === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        t34.month = ["numeric", "2-digit", "short", "long", "narrow"][n25 - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        t34.day = ["numeric", "2-digit"][n25 - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        t34.weekday = n25 === 4 ? "short" : n25 === 5 ? "narrow" : "short";
        break;
      case "e":
        if (n25 < 4) throw new RangeError("`e..eee` (weekday) patterns are not supported");
        t34.weekday = ["short", "long", "narrow", "short"][n25 - 4];
        break;
      case "c":
        if (n25 < 4) throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        t34.weekday = ["short", "long", "narrow", "short"][n25 - 4];
        break;
      case "a":
        t34.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        t34.hourCycle = "h12", t34.hour = ["numeric", "2-digit"][n25 - 1];
        break;
      case "H":
        t34.hourCycle = "h23", t34.hour = ["numeric", "2-digit"][n25 - 1];
        break;
      case "K":
        t34.hourCycle = "h11", t34.hour = ["numeric", "2-digit"][n25 - 1];
        break;
      case "k":
        t34.hourCycle = "h24", t34.hour = ["numeric", "2-digit"][n25 - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        t34.minute = ["numeric", "2-digit"][n25 - 1];
        break;
      case "s":
        t34.second = ["numeric", "2-digit"][n25 - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        t34.timeZoneName = n25 < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  }), t34;
}
var on = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function ln(e36) {
  if (e36.length === 0) throw new Error("Number skeleton cannot be empty");
  for (var t34 = e36.split(on).filter(function(f11) {
    return f11.length > 0;
  }), r25 = [], n25 = 0, i21 = t34; n25 < i21.length; n25++) {
    var o52 = i21[n25], s19 = o52.split("/");
    if (s19.length === 0) throw new Error("Invalid number skeleton");
    for (var a23 = s19[0], c33 = s19.slice(1), u36 = 0, l16 = c33; u36 < l16.length; u36++) {
      var p30 = l16[u36];
      if (p30.length === 0) throw new Error("Invalid number skeleton");
    }
    r25.push({ stem: a23, options: c33 });
  }
  return r25;
}
function Mo(e36) {
  return e36.replace(/^(.*?)-/, "");
}
var sn = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var un = /^(@+)?(\+|#+)?[rs]?$/g;
var Do = /(\*)(0+)|(#+)(0+)|(0+)/g;
var hn = /^(0+)$/;
function an(e36) {
  var t34 = {};
  return e36[e36.length - 1] === "r" ? t34.roundingPriority = "morePrecision" : e36[e36.length - 1] === "s" && (t34.roundingPriority = "lessPrecision"), e36.replace(un, function(r25, n25, i21) {
    return typeof i21 != "string" ? (t34.minimumSignificantDigits = n25.length, t34.maximumSignificantDigits = n25.length) : i21 === "+" ? t34.minimumSignificantDigits = n25.length : n25[0] === "#" ? t34.maximumSignificantDigits = n25.length : (t34.minimumSignificantDigits = n25.length, t34.maximumSignificantDigits = n25.length + (typeof i21 == "string" ? i21.length : 0)), "";
  }), t34;
}
function fn(e36) {
  switch (e36) {
    case "sign-auto":
      return { signDisplay: "auto" };
    case "sign-accounting":
    case "()":
      return { currencySign: "accounting" };
    case "sign-always":
    case "+!":
      return { signDisplay: "always" };
    case "sign-accounting-always":
    case "()!":
      return { signDisplay: "always", currencySign: "accounting" };
    case "sign-except-zero":
    case "+?":
      return { signDisplay: "exceptZero" };
    case "sign-accounting-except-zero":
    case "()?":
      return { signDisplay: "exceptZero", currencySign: "accounting" };
    case "sign-never":
    case "+_":
      return { signDisplay: "never" };
  }
}
function Uo(e36) {
  var t34;
  if (e36[0] === "E" && e36[1] === "E" ? (t34 = { notation: "engineering" }, e36 = e36.slice(2)) : e36[0] === "E" && (t34 = { notation: "scientific" }, e36 = e36.slice(1)), t34) {
    var r25 = e36.slice(0, 2);
    if (r25 === "+!" ? (t34.signDisplay = "always", e36 = e36.slice(2)) : r25 === "+?" && (t34.signDisplay = "exceptZero", e36 = e36.slice(2)), !hn.test(e36)) throw new Error("Malformed concise eng/scientific notation");
    t34.minimumIntegerDigits = e36.length;
  }
  return t34;
}
function cn(e36) {
  var t34 = {}, r25 = fn(e36);
  return r25 || t34;
}
function pn(e36) {
  for (var t34 = {}, r25 = 0, n25 = e36; r25 < n25.length; r25++) {
    var i21 = n25[r25];
    switch (i21.stem) {
      case "percent":
      case "%":
        t34.style = "percent";
        continue;
      case "%x100":
        t34.style = "percent", t34.scale = 100;
        continue;
      case "currency":
        t34.style = "currency", t34.currency = i21.options[0];
        continue;
      case "group-off":
      case ",_":
        t34.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        t34.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        t34.style = "unit", t34.unit = Mo(i21.options[0]);
        continue;
      case "compact-short":
      case "K":
        t34.notation = "compact", t34.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        t34.notation = "compact", t34.compactDisplay = "long";
        continue;
      case "scientific":
        t34 = x4(x4(x4({}, t34), { notation: "scientific" }), i21.options.reduce(function(c33, u36) {
          return x4(x4({}, c33), cn(u36));
        }, {}));
        continue;
      case "engineering":
        t34 = x4(x4(x4({}, t34), { notation: "engineering" }), i21.options.reduce(function(c33, u36) {
          return x4(x4({}, c33), cn(u36));
        }, {}));
        continue;
      case "notation-simple":
        t34.notation = "standard";
        continue;
      case "unit-width-narrow":
        t34.currencyDisplay = "narrowSymbol", t34.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        t34.currencyDisplay = "code", t34.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        t34.currencyDisplay = "name", t34.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        t34.currencyDisplay = "symbol";
        continue;
      case "scale":
        t34.scale = parseFloat(i21.options[0]);
        continue;
      case "integer-width":
        if (i21.options.length > 1) throw new RangeError("integer-width stems only accept a single optional option");
        i21.options[0].replace(Do, function(c33, u36, l16, p30, f11, h16) {
          if (u36) t34.minimumIntegerDigits = l16.length;
          else {
            if (p30 && f11) throw new Error("We currently do not support maximum integer digits");
            if (h16) throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (hn.test(i21.stem)) {
      t34.minimumIntegerDigits = i21.stem.length;
      continue;
    }
    if (sn.test(i21.stem)) {
      if (i21.options.length > 1) throw new RangeError("Fraction-precision stems only accept a single optional option");
      i21.stem.replace(sn, function(c33, u36, l16, p30, f11, h16) {
        return l16 === "*" ? t34.minimumFractionDigits = u36.length : p30 && p30[0] === "#" ? t34.maximumFractionDigits = p30.length : f11 && h16 ? (t34.minimumFractionDigits = f11.length, t34.maximumFractionDigits = f11.length + h16.length) : (t34.minimumFractionDigits = u36.length, t34.maximumFractionDigits = u36.length), "";
      });
      var o52 = i21.options[0];
      o52 === "w" ? t34 = x4(x4({}, t34), { trailingZeroDisplay: "stripIfInteger" }) : o52 && (t34 = x4(x4({}, t34), an(o52)));
      continue;
    }
    if (un.test(i21.stem)) {
      t34 = x4(x4({}, t34), an(i21.stem));
      continue;
    }
    var s19 = fn(i21.stem);
    s19 && (t34 = x4(x4({}, t34), s19));
    var a23 = Uo(i21.stem);
    a23 && (t34 = x4(x4({}, t34), a23));
  }
  return t34;
}
var Oe = { AX: ["H"], BQ: ["H"], CP: ["H"], CZ: ["H"], DK: ["H"], FI: ["H"], ID: ["H"], IS: ["H"], ML: ["H"], NE: ["H"], RU: ["H"], SE: ["H"], SJ: ["H"], SK: ["H"], AS: ["h", "H"], BT: ["h", "H"], DJ: ["h", "H"], ER: ["h", "H"], GH: ["h", "H"], IN: ["h", "H"], LS: ["h", "H"], PG: ["h", "H"], PW: ["h", "H"], SO: ["h", "H"], TO: ["h", "H"], VU: ["h", "H"], WS: ["h", "H"], "001": ["H", "h"], AL: ["h", "H", "hB"], TD: ["h", "H", "hB"], "ca-ES": ["H", "h", "hB"], CF: ["H", "h", "hB"], CM: ["H", "h", "hB"], "fr-CA": ["H", "h", "hB"], "gl-ES": ["H", "h", "hB"], "it-CH": ["H", "h", "hB"], "it-IT": ["H", "h", "hB"], LU: ["H", "h", "hB"], NP: ["H", "h", "hB"], PF: ["H", "h", "hB"], SC: ["H", "h", "hB"], SM: ["H", "h", "hB"], SN: ["H", "h", "hB"], TF: ["H", "h", "hB"], VA: ["H", "h", "hB"], CY: ["h", "H", "hb", "hB"], GR: ["h", "H", "hb", "hB"], CO: ["h", "H", "hB", "hb"], DO: ["h", "H", "hB", "hb"], KP: ["h", "H", "hB", "hb"], KR: ["h", "H", "hB", "hb"], NA: ["h", "H", "hB", "hb"], PA: ["h", "H", "hB", "hb"], PR: ["h", "H", "hB", "hb"], VE: ["h", "H", "hB", "hb"], AC: ["H", "h", "hb", "hB"], AI: ["H", "h", "hb", "hB"], BW: ["H", "h", "hb", "hB"], BZ: ["H", "h", "hb", "hB"], CC: ["H", "h", "hb", "hB"], CK: ["H", "h", "hb", "hB"], CX: ["H", "h", "hb", "hB"], DG: ["H", "h", "hb", "hB"], FK: ["H", "h", "hb", "hB"], GB: ["H", "h", "hb", "hB"], GG: ["H", "h", "hb", "hB"], GI: ["H", "h", "hb", "hB"], IE: ["H", "h", "hb", "hB"], IM: ["H", "h", "hb", "hB"], IO: ["H", "h", "hb", "hB"], JE: ["H", "h", "hb", "hB"], LT: ["H", "h", "hb", "hB"], MK: ["H", "h", "hb", "hB"], MN: ["H", "h", "hb", "hB"], MS: ["H", "h", "hb", "hB"], NF: ["H", "h", "hb", "hB"], NG: ["H", "h", "hb", "hB"], NR: ["H", "h", "hb", "hB"], NU: ["H", "h", "hb", "hB"], PN: ["H", "h", "hb", "hB"], SH: ["H", "h", "hb", "hB"], SX: ["H", "h", "hb", "hB"], TA: ["H", "h", "hb", "hB"], ZA: ["H", "h", "hb", "hB"], "af-ZA": ["H", "h", "hB", "hb"], AR: ["H", "h", "hB", "hb"], CL: ["H", "h", "hB", "hb"], CR: ["H", "h", "hB", "hb"], CU: ["H", "h", "hB", "hb"], EA: ["H", "h", "hB", "hb"], "es-BO": ["H", "h", "hB", "hb"], "es-BR": ["H", "h", "hB", "hb"], "es-EC": ["H", "h", "hB", "hb"], "es-ES": ["H", "h", "hB", "hb"], "es-GQ": ["H", "h", "hB", "hb"], "es-PE": ["H", "h", "hB", "hb"], GT: ["H", "h", "hB", "hb"], HN: ["H", "h", "hB", "hb"], IC: ["H", "h", "hB", "hb"], KG: ["H", "h", "hB", "hb"], KM: ["H", "h", "hB", "hb"], LK: ["H", "h", "hB", "hb"], MA: ["H", "h", "hB", "hb"], MX: ["H", "h", "hB", "hb"], NI: ["H", "h", "hB", "hb"], PY: ["H", "h", "hB", "hb"], SV: ["H", "h", "hB", "hb"], UY: ["H", "h", "hB", "hb"], JP: ["H", "h", "K"], AD: ["H", "hB"], AM: ["H", "hB"], AO: ["H", "hB"], AT: ["H", "hB"], AW: ["H", "hB"], BE: ["H", "hB"], BF: ["H", "hB"], BJ: ["H", "hB"], BL: ["H", "hB"], BR: ["H", "hB"], CG: ["H", "hB"], CI: ["H", "hB"], CV: ["H", "hB"], DE: ["H", "hB"], EE: ["H", "hB"], FR: ["H", "hB"], GA: ["H", "hB"], GF: ["H", "hB"], GN: ["H", "hB"], GP: ["H", "hB"], GW: ["H", "hB"], HR: ["H", "hB"], IL: ["H", "hB"], IT: ["H", "hB"], KZ: ["H", "hB"], MC: ["H", "hB"], MD: ["H", "hB"], MF: ["H", "hB"], MQ: ["H", "hB"], MZ: ["H", "hB"], NC: ["H", "hB"], NL: ["H", "hB"], PM: ["H", "hB"], PT: ["H", "hB"], RE: ["H", "hB"], RO: ["H", "hB"], SI: ["H", "hB"], SR: ["H", "hB"], ST: ["H", "hB"], TG: ["H", "hB"], TR: ["H", "hB"], WF: ["H", "hB"], YT: ["H", "hB"], BD: ["h", "hB", "H"], PK: ["h", "hB", "H"], AZ: ["H", "hB", "h"], BA: ["H", "hB", "h"], BG: ["H", "hB", "h"], CH: ["H", "hB", "h"], GE: ["H", "hB", "h"], LI: ["H", "hB", "h"], ME: ["H", "hB", "h"], RS: ["H", "hB", "h"], UA: ["H", "hB", "h"], UZ: ["H", "hB", "h"], XK: ["H", "hB", "h"], AG: ["h", "hb", "H", "hB"], AU: ["h", "hb", "H", "hB"], BB: ["h", "hb", "H", "hB"], BM: ["h", "hb", "H", "hB"], BS: ["h", "hb", "H", "hB"], CA: ["h", "hb", "H", "hB"], DM: ["h", "hb", "H", "hB"], "en-001": ["h", "hb", "H", "hB"], FJ: ["h", "hb", "H", "hB"], FM: ["h", "hb", "H", "hB"], GD: ["h", "hb", "H", "hB"], GM: ["h", "hb", "H", "hB"], GU: ["h", "hb", "H", "hB"], GY: ["h", "hb", "H", "hB"], JM: ["h", "hb", "H", "hB"], KI: ["h", "hb", "H", "hB"], KN: ["h", "hb", "H", "hB"], KY: ["h", "hb", "H", "hB"], LC: ["h", "hb", "H", "hB"], LR: ["h", "hb", "H", "hB"], MH: ["h", "hb", "H", "hB"], MP: ["h", "hb", "H", "hB"], MW: ["h", "hb", "H", "hB"], NZ: ["h", "hb", "H", "hB"], SB: ["h", "hb", "H", "hB"], SG: ["h", "hb", "H", "hB"], SL: ["h", "hb", "H", "hB"], SS: ["h", "hb", "H", "hB"], SZ: ["h", "hb", "H", "hB"], TC: ["h", "hb", "H", "hB"], TT: ["h", "hb", "H", "hB"], UM: ["h", "hb", "H", "hB"], US: ["h", "hb", "H", "hB"], VC: ["h", "hb", "H", "hB"], VG: ["h", "hb", "H", "hB"], VI: ["h", "hb", "H", "hB"], ZM: ["h", "hb", "H", "hB"], BO: ["H", "hB", "h", "hb"], EC: ["H", "hB", "h", "hb"], ES: ["H", "hB", "h", "hb"], GQ: ["H", "hB", "h", "hb"], PE: ["H", "hB", "h", "hb"], AE: ["h", "hB", "hb", "H"], "ar-001": ["h", "hB", "hb", "H"], BH: ["h", "hB", "hb", "H"], DZ: ["h", "hB", "hb", "H"], EG: ["h", "hB", "hb", "H"], EH: ["h", "hB", "hb", "H"], HK: ["h", "hB", "hb", "H"], IQ: ["h", "hB", "hb", "H"], JO: ["h", "hB", "hb", "H"], KW: ["h", "hB", "hb", "H"], LB: ["h", "hB", "hb", "H"], LY: ["h", "hB", "hb", "H"], MO: ["h", "hB", "hb", "H"], MR: ["h", "hB", "hb", "H"], OM: ["h", "hB", "hb", "H"], PH: ["h", "hB", "hb", "H"], PS: ["h", "hB", "hb", "H"], QA: ["h", "hB", "hb", "H"], SA: ["h", "hB", "hb", "H"], SD: ["h", "hB", "hb", "H"], SY: ["h", "hB", "hb", "H"], TN: ["h", "hB", "hb", "H"], YE: ["h", "hB", "hb", "H"], AF: ["H", "hb", "hB", "h"], LA: ["H", "hb", "hB", "h"], CN: ["H", "hB", "hb", "h"], LV: ["H", "hB", "hb", "h"], TL: ["H", "hB", "hb", "h"], "zu-ZA": ["H", "hB", "hb", "h"], CD: ["hB", "H"], IR: ["hB", "H"], "hi-IN": ["hB", "h", "H"], "kn-IN": ["hB", "h", "H"], "ml-IN": ["hB", "h", "H"], "te-IN": ["hB", "h", "H"], KH: ["hB", "h", "H", "hb"], "ta-IN": ["hB", "h", "hb", "H"], BN: ["hb", "hB", "h", "H"], MY: ["hb", "hB", "h", "H"], ET: ["hB", "hb", "h", "H"], "gu-IN": ["hB", "hb", "h", "H"], "mr-IN": ["hB", "hb", "h", "H"], "pa-IN": ["hB", "hb", "h", "H"], TW: ["hB", "hb", "h", "H"], KE: ["hB", "hb", "H", "h"], MM: ["hB", "hb", "H", "h"], TZ: ["hB", "hb", "H", "h"], UG: ["hB", "hb", "H", "h"] };
function mn(e36, t34) {
  for (var r25 = "", n25 = 0; n25 < e36.length; n25++) {
    var i21 = e36.charAt(n25);
    if (i21 === "j") {
      for (var o52 = 0; n25 + 1 < e36.length && e36.charAt(n25 + 1) === i21; ) o52++, n25++;
      var s19 = 1 + (o52 & 1), a23 = o52 < 2 ? 1 : 3 + (o52 >> 1), c33 = "a", u36 = Bo(t34);
      for ((u36 == "H" || u36 == "k") && (a23 = 0); a23-- > 0; ) r25 += c33;
      for (; s19-- > 0; ) r25 = u36 + r25;
    } else i21 === "J" ? r25 += "H" : r25 += i21;
  }
  return r25;
}
function Bo(e36) {
  var t34 = e36.hourCycle;
  if (t34 === void 0 && e36.hourCycles && e36.hourCycles.length && (t34 = e36.hourCycles[0]), t34) switch (t34) {
    case "h24":
      return "k";
    case "h23":
      return "H";
    case "h12":
      return "h";
    case "h11":
      return "K";
    default:
      throw new Error("Invalid hourCycle");
  }
  var r25 = e36.language, n25;
  r25 !== "root" && (n25 = e36.maximize().region);
  var i21 = Oe[n25 || ""] || Oe[r25 || ""] || Oe["".concat(r25, "-001")] || Oe["001"];
  return i21[0];
}
var Qt;
var ko = new RegExp("^".concat(zt.source, "*"));
var Fo = new RegExp("".concat(zt.source, "*$"));
function A2(e36, t34) {
  return { start: e36, end: t34 };
}
var Go = !!String.prototype.startsWith;
var Vo = !!String.fromCodePoint;
var Yo = !!Object.fromEntries;
var $o = !!String.prototype.codePointAt;
var Wo = !!String.prototype.trimStart;
var jo = !!String.prototype.trimEnd;
var Xo = !!Number.isSafeInteger;
var qo = Xo ? Number.isSafeInteger : function(e36) {
  return typeof e36 == "number" && isFinite(e36) && Math.floor(e36) === e36 && Math.abs(e36) <= 9007199254740991;
};
var Zt = true;
try {
  En = An("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu"), Zt = ((Qt = En.exec("a")) === null || Qt === void 0 ? void 0 : Qt[0]) === "a";
} catch {
  Zt = false;
}
var En;
var dn = Go ? function(t34, r25, n25) {
  return t34.startsWith(r25, n25);
} : function(t34, r25, n25) {
  return t34.slice(n25, n25 + r25.length) === r25;
};
var Jt = Vo ? String.fromCodePoint : function() {
  for (var t34 = [], r25 = 0; r25 < arguments.length; r25++) t34[r25] = arguments[r25];
  for (var n25 = "", i21 = t34.length, o52 = 0, s19; i21 > o52; ) {
    if (s19 = t34[o52++], s19 > 1114111) throw RangeError(s19 + " is not a valid code point");
    n25 += s19 < 65536 ? String.fromCharCode(s19) : String.fromCharCode(((s19 -= 65536) >> 10) + 55296, s19 % 1024 + 56320);
  }
  return n25;
};
var gn = Yo ? Object.fromEntries : function(t34) {
  for (var r25 = {}, n25 = 0, i21 = t34; n25 < i21.length; n25++) {
    var o52 = i21[n25], s19 = o52[0], a23 = o52[1];
    r25[s19] = a23;
  }
  return r25;
};
var xn = $o ? function(t34, r25) {
  return t34.codePointAt(r25);
} : function(t34, r25) {
  var n25 = t34.length;
  if (!(r25 < 0 || r25 >= n25)) {
    var i21 = t34.charCodeAt(r25), o52;
    return i21 < 55296 || i21 > 56319 || r25 + 1 === n25 || (o52 = t34.charCodeAt(r25 + 1)) < 56320 || o52 > 57343 ? i21 : (i21 - 55296 << 10) + (o52 - 56320) + 65536;
  }
};
var zo = Wo ? function(t34) {
  return t34.trimStart();
} : function(t34) {
  return t34.replace(ko, "");
};
var Qo = jo ? function(t34) {
  return t34.trimEnd();
} : function(t34) {
  return t34.replace(Fo, "");
};
function An(e36, t34) {
  return new RegExp(e36, t34);
}
var er;
Zt ? (Kt = An("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu"), er = function(t34, r25) {
  var n25;
  Kt.lastIndex = r25;
  var i21 = Kt.exec(t34);
  return (n25 = i21[1]) !== null && n25 !== void 0 ? n25 : "";
}) : er = function(t34, r25) {
  for (var n25 = []; ; ) {
    var i21 = xn(t34, r25);
    if (i21 === void 0 || Tn(i21) || Jo(i21)) break;
    n25.push(i21), r25 += i21 >= 65536 ? 2 : 1;
  }
  return Jt.apply(void 0, n25);
};
var Kt;
var yn = function() {
  function e36(t34, r25) {
    r25 === void 0 && (r25 = {}), this.message = t34, this.position = { offset: 0, line: 1, column: 1 }, this.ignoreTag = !!r25.ignoreTag, this.locale = r25.locale, this.requiresOtherClause = !!r25.requiresOtherClause, this.shouldParseSkeletons = !!r25.shouldParseSkeletons;
  }
  return e36.prototype.parse = function() {
    if (this.offset() !== 0) throw Error("parser can only be used once");
    return this.parseMessage(0, "", false);
  }, e36.prototype.parseMessage = function(t34, r25, n25) {
    for (var i21 = []; !this.isEOF(); ) {
      var o52 = this.char();
      if (o52 === 123) {
        var s19 = this.parseArgument(t34, n25);
        if (s19.err) return s19;
        i21.push(s19.val);
      } else {
        if (o52 === 125 && t34 > 0) break;
        if (o52 === 35 && (r25 === "plural" || r25 === "selectordinal")) {
          var a23 = this.clonePosition();
          this.bump(), i21.push({ type: C5.pound, location: A2(a23, this.clonePosition()) });
        } else if (o52 === 60 && !this.ignoreTag && this.peek() === 47) {
          if (n25) break;
          return this.error(d21.UNMATCHED_CLOSING_TAG, A2(this.clonePosition(), this.clonePosition()));
        } else if (o52 === 60 && !this.ignoreTag && tr(this.peek() || 0)) {
          var s19 = this.parseTag(t34, r25);
          if (s19.err) return s19;
          i21.push(s19.val);
        } else {
          var s19 = this.parseLiteral(t34, r25);
          if (s19.err) return s19;
          i21.push(s19.val);
        }
      }
    }
    return { val: i21, err: null };
  }, e36.prototype.parseTag = function(t34, r25) {
    var n25 = this.clonePosition();
    this.bump();
    var i21 = this.parseTagName();
    if (this.bumpSpace(), this.bumpIf("/>")) return { val: { type: C5.literal, value: "<".concat(i21, "/>"), location: A2(n25, this.clonePosition()) }, err: null };
    if (this.bumpIf(">")) {
      var o52 = this.parseMessage(t34 + 1, r25, true);
      if (o52.err) return o52;
      var s19 = o52.val, a23 = this.clonePosition();
      if (this.bumpIf("</")) {
        if (this.isEOF() || !tr(this.char())) return this.error(d21.INVALID_TAG, A2(a23, this.clonePosition()));
        var c33 = this.clonePosition(), u36 = this.parseTagName();
        return i21 !== u36 ? this.error(d21.UNMATCHED_CLOSING_TAG, A2(c33, this.clonePosition())) : (this.bumpSpace(), this.bumpIf(">") ? { val: { type: C5.tag, value: i21, children: s19, location: A2(n25, this.clonePosition()) }, err: null } : this.error(d21.INVALID_TAG, A2(a23, this.clonePosition())));
      } else return this.error(d21.UNCLOSED_TAG, A2(n25, this.clonePosition()));
    } else return this.error(d21.INVALID_TAG, A2(n25, this.clonePosition()));
  }, e36.prototype.parseTagName = function() {
    var t34 = this.offset();
    for (this.bump(); !this.isEOF() && Zo(this.char()); ) this.bump();
    return this.message.slice(t34, this.offset());
  }, e36.prototype.parseLiteral = function(t34, r25) {
    for (var n25 = this.clonePosition(), i21 = ""; ; ) {
      var o52 = this.tryParseQuote(r25);
      if (o52) {
        i21 += o52;
        continue;
      }
      var s19 = this.tryParseUnquoted(t34, r25);
      if (s19) {
        i21 += s19;
        continue;
      }
      var a23 = this.tryParseLeftAngleBracket();
      if (a23) {
        i21 += a23;
        continue;
      }
      break;
    }
    var c33 = A2(n25, this.clonePosition());
    return { val: { type: C5.literal, value: i21, location: c33 }, err: null };
  }, e36.prototype.tryParseLeftAngleBracket = function() {
    return !this.isEOF() && this.char() === 60 && (this.ignoreTag || !Ko(this.peek() || 0)) ? (this.bump(), "<") : null;
  }, e36.prototype.tryParseQuote = function(t34) {
    if (this.isEOF() || this.char() !== 39) return null;
    switch (this.peek()) {
      case 39:
        return this.bump(), this.bump(), "'";
      case 123:
      case 60:
      case 62:
      case 125:
        break;
      case 35:
        if (t34 === "plural" || t34 === "selectordinal") break;
        return null;
      default:
        return null;
    }
    this.bump();
    var r25 = [this.char()];
    for (this.bump(); !this.isEOF(); ) {
      var n25 = this.char();
      if (n25 === 39) if (this.peek() === 39) r25.push(39), this.bump();
      else {
        this.bump();
        break;
      }
      else r25.push(n25);
      this.bump();
    }
    return Jt.apply(void 0, r25);
  }, e36.prototype.tryParseUnquoted = function(t34, r25) {
    if (this.isEOF()) return null;
    var n25 = this.char();
    return n25 === 60 || n25 === 123 || n25 === 35 && (r25 === "plural" || r25 === "selectordinal") || n25 === 125 && t34 > 0 ? null : (this.bump(), Jt(n25));
  }, e36.prototype.parseArgument = function(t34, r25) {
    var n25 = this.clonePosition();
    if (this.bump(), this.bumpSpace(), this.isEOF()) return this.error(d21.EXPECT_ARGUMENT_CLOSING_BRACE, A2(n25, this.clonePosition()));
    if (this.char() === 125) return this.bump(), this.error(d21.EMPTY_ARGUMENT, A2(n25, this.clonePosition()));
    var i21 = this.parseIdentifierIfPossible().value;
    if (!i21) return this.error(d21.MALFORMED_ARGUMENT, A2(n25, this.clonePosition()));
    if (this.bumpSpace(), this.isEOF()) return this.error(d21.EXPECT_ARGUMENT_CLOSING_BRACE, A2(n25, this.clonePosition()));
    switch (this.char()) {
      case 125:
        return this.bump(), { val: { type: C5.argument, value: i21, location: A2(n25, this.clonePosition()) }, err: null };
      case 44:
        return this.bump(), this.bumpSpace(), this.isEOF() ? this.error(d21.EXPECT_ARGUMENT_CLOSING_BRACE, A2(n25, this.clonePosition())) : this.parseArgumentOptions(t34, r25, i21, n25);
      default:
        return this.error(d21.MALFORMED_ARGUMENT, A2(n25, this.clonePosition()));
    }
  }, e36.prototype.parseIdentifierIfPossible = function() {
    var t34 = this.clonePosition(), r25 = this.offset(), n25 = er(this.message, r25), i21 = r25 + n25.length;
    this.bumpTo(i21);
    var o52 = this.clonePosition(), s19 = A2(t34, o52);
    return { value: n25, location: s19 };
  }, e36.prototype.parseArgumentOptions = function(t34, r25, n25, i21) {
    var o52, s19 = this.clonePosition(), a23 = this.parseIdentifierIfPossible().value, c33 = this.clonePosition();
    switch (a23) {
      case "":
        return this.error(d21.EXPECT_ARGUMENT_TYPE, A2(s19, c33));
      case "number":
      case "date":
      case "time": {
        this.bumpSpace();
        var u36 = null;
        if (this.bumpIf(",")) {
          this.bumpSpace();
          var l16 = this.clonePosition(), p30 = this.parseSimpleArgStyleIfPossible();
          if (p30.err) return p30;
          var f11 = Qo(p30.val);
          if (f11.length === 0) return this.error(d21.EXPECT_ARGUMENT_STYLE, A2(this.clonePosition(), this.clonePosition()));
          var h16 = A2(l16, this.clonePosition());
          u36 = { style: f11, styleLocation: h16 };
        }
        var E3 = this.tryParseArgumentClose(i21);
        if (E3.err) return E3;
        var m18 = A2(i21, this.clonePosition());
        if (u36 && dn(u36?.style, "::", 0)) {
          var y5 = zo(u36.style.slice(2));
          if (a23 === "number") {
            var p30 = this.parseNumberSkeletonFromString(y5, u36.styleLocation);
            return p30.err ? p30 : { val: { type: C5.number, value: n25, location: m18, style: p30.val }, err: null };
          } else {
            if (y5.length === 0) return this.error(d21.EXPECT_DATE_TIME_SKELETON, m18);
            var _2 = y5;
            this.locale && (_2 = mn(y5, this.locale));
            var f11 = { type: ae.dateTime, pattern: _2, location: u36.styleLocation, parsedOptions: this.shouldParseSkeletons ? nn(_2) : {} }, b12 = a23 === "date" ? C5.date : C5.time;
            return { val: { type: b12, value: n25, location: m18, style: f11 }, err: null };
          }
        }
        return { val: { type: a23 === "number" ? C5.number : a23 === "date" ? C5.date : C5.time, value: n25, location: m18, style: (o52 = u36?.style) !== null && o52 !== void 0 ? o52 : null }, err: null };
      }
      case "plural":
      case "selectordinal":
      case "select": {
        var T5 = this.clonePosition();
        if (this.bumpSpace(), !this.bumpIf(",")) return this.error(d21.EXPECT_SELECT_ARGUMENT_OPTIONS, A2(T5, x4({}, T5)));
        this.bumpSpace();
        var S4 = this.parseIdentifierIfPossible(), v6 = 0;
        if (a23 !== "select" && S4.value === "offset") {
          if (!this.bumpIf(":")) return this.error(d21.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, A2(this.clonePosition(), this.clonePosition()));
          this.bumpSpace();
          var p30 = this.tryParseDecimalInteger(d21.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, d21.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
          if (p30.err) return p30;
          this.bumpSpace(), S4 = this.parseIdentifierIfPossible(), v6 = p30.val;
        }
        var w3 = this.tryParsePluralOrSelectOptions(t34, a23, r25, S4);
        if (w3.err) return w3;
        var E3 = this.tryParseArgumentClose(i21);
        if (E3.err) return E3;
        var H2 = A2(i21, this.clonePosition());
        return a23 === "select" ? { val: { type: C5.select, value: n25, options: gn(w3.val), location: H2 }, err: null } : { val: { type: C5.plural, value: n25, options: gn(w3.val), offset: v6, pluralType: a23 === "plural" ? "cardinal" : "ordinal", location: H2 }, err: null };
      }
      default:
        return this.error(d21.INVALID_ARGUMENT_TYPE, A2(s19, c33));
    }
  }, e36.prototype.tryParseArgumentClose = function(t34) {
    return this.isEOF() || this.char() !== 125 ? this.error(d21.EXPECT_ARGUMENT_CLOSING_BRACE, A2(t34, this.clonePosition())) : (this.bump(), { val: true, err: null });
  }, e36.prototype.parseSimpleArgStyleIfPossible = function() {
    for (var t34 = 0, r25 = this.clonePosition(); !this.isEOF(); ) {
      var n25 = this.char();
      switch (n25) {
        case 39: {
          this.bump();
          var i21 = this.clonePosition();
          if (!this.bumpUntil("'")) return this.error(d21.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, A2(i21, this.clonePosition()));
          this.bump();
          break;
        }
        case 123: {
          t34 += 1, this.bump();
          break;
        }
        case 125: {
          if (t34 > 0) t34 -= 1;
          else return { val: this.message.slice(r25.offset, this.offset()), err: null };
          break;
        }
        default:
          this.bump();
          break;
      }
    }
    return { val: this.message.slice(r25.offset, this.offset()), err: null };
  }, e36.prototype.parseNumberSkeletonFromString = function(t34, r25) {
    var n25 = [];
    try {
      n25 = ln(t34);
    } catch {
      return this.error(d21.INVALID_NUMBER_SKELETON, r25);
    }
    return { val: { type: ae.number, tokens: n25, location: r25, parsedOptions: this.shouldParseSkeletons ? pn(n25) : {} }, err: null };
  }, e36.prototype.tryParsePluralOrSelectOptions = function(t34, r25, n25, i21) {
    for (var o52, s19 = false, a23 = [], c33 = /* @__PURE__ */ new Set(), u36 = i21.value, l16 = i21.location; ; ) {
      if (u36.length === 0) {
        var p30 = this.clonePosition();
        if (r25 !== "select" && this.bumpIf("=")) {
          var f11 = this.tryParseDecimalInteger(d21.EXPECT_PLURAL_ARGUMENT_SELECTOR, d21.INVALID_PLURAL_ARGUMENT_SELECTOR);
          if (f11.err) return f11;
          l16 = A2(p30, this.clonePosition()), u36 = this.message.slice(p30.offset, this.offset());
        } else break;
      }
      if (c33.has(u36)) return this.error(r25 === "select" ? d21.DUPLICATE_SELECT_ARGUMENT_SELECTOR : d21.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, l16);
      u36 === "other" && (s19 = true), this.bumpSpace();
      var h16 = this.clonePosition();
      if (!this.bumpIf("{")) return this.error(r25 === "select" ? d21.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : d21.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, A2(this.clonePosition(), this.clonePosition()));
      var E3 = this.parseMessage(t34 + 1, r25, n25);
      if (E3.err) return E3;
      var m18 = this.tryParseArgumentClose(h16);
      if (m18.err) return m18;
      a23.push([u36, { value: E3.val, location: A2(h16, this.clonePosition()) }]), c33.add(u36), this.bumpSpace(), o52 = this.parseIdentifierIfPossible(), u36 = o52.value, l16 = o52.location;
    }
    return a23.length === 0 ? this.error(r25 === "select" ? d21.EXPECT_SELECT_ARGUMENT_SELECTOR : d21.EXPECT_PLURAL_ARGUMENT_SELECTOR, A2(this.clonePosition(), this.clonePosition())) : this.requiresOtherClause && !s19 ? this.error(d21.MISSING_OTHER_CLAUSE, A2(this.clonePosition(), this.clonePosition())) : { val: a23, err: null };
  }, e36.prototype.tryParseDecimalInteger = function(t34, r25) {
    var n25 = 1, i21 = this.clonePosition();
    this.bumpIf("+") || this.bumpIf("-") && (n25 = -1);
    for (var o52 = false, s19 = 0; !this.isEOF(); ) {
      var a23 = this.char();
      if (a23 >= 48 && a23 <= 57) o52 = true, s19 = s19 * 10 + (a23 - 48), this.bump();
      else break;
    }
    var c33 = A2(i21, this.clonePosition());
    return o52 ? (s19 *= n25, qo(s19) ? { val: s19, err: null } : this.error(r25, c33)) : this.error(t34, c33);
  }, e36.prototype.offset = function() {
    return this.position.offset;
  }, e36.prototype.isEOF = function() {
    return this.offset() === this.message.length;
  }, e36.prototype.clonePosition = function() {
    return { offset: this.position.offset, line: this.position.line, column: this.position.column };
  }, e36.prototype.char = function() {
    var t34 = this.position.offset;
    if (t34 >= this.message.length) throw Error("out of bound");
    var r25 = xn(this.message, t34);
    if (r25 === void 0) throw Error("Offset ".concat(t34, " is at invalid UTF-16 code unit boundary"));
    return r25;
  }, e36.prototype.error = function(t34, r25) {
    return { val: null, err: { kind: t34, message: this.message, location: r25 } };
  }, e36.prototype.bump = function() {
    if (!this.isEOF()) {
      var t34 = this.char();
      t34 === 10 ? (this.position.line += 1, this.position.column = 1, this.position.offset += 1) : (this.position.column += 1, this.position.offset += t34 < 65536 ? 1 : 2);
    }
  }, e36.prototype.bumpIf = function(t34) {
    if (dn(this.message, t34, this.offset())) {
      for (var r25 = 0; r25 < t34.length; r25++) this.bump();
      return true;
    }
    return false;
  }, e36.prototype.bumpUntil = function(t34) {
    var r25 = this.offset(), n25 = this.message.indexOf(t34, r25);
    return n25 >= 0 ? (this.bumpTo(n25), true) : (this.bumpTo(this.message.length), false);
  }, e36.prototype.bumpTo = function(t34) {
    if (this.offset() > t34) throw Error("targetOffset ".concat(t34, " must be greater than or equal to the current offset ").concat(this.offset()));
    for (t34 = Math.min(t34, this.message.length); ; ) {
      var r25 = this.offset();
      if (r25 === t34) break;
      if (r25 > t34) throw Error("targetOffset ".concat(t34, " is at invalid UTF-16 code unit boundary"));
      if (this.bump(), this.isEOF()) break;
    }
  }, e36.prototype.bumpSpace = function() {
    for (; !this.isEOF() && Tn(this.char()); ) this.bump();
  }, e36.prototype.peek = function() {
    if (this.isEOF()) return null;
    var t34 = this.char(), r25 = this.offset(), n25 = this.message.charCodeAt(r25 + (t34 >= 65536 ? 2 : 1));
    return n25 ?? null;
  }, e36;
}();
function tr(e36) {
  return e36 >= 97 && e36 <= 122 || e36 >= 65 && e36 <= 90;
}
function Ko(e36) {
  return tr(e36) || e36 === 47;
}
function Zo(e36) {
  return e36 === 45 || e36 === 46 || e36 >= 48 && e36 <= 57 || e36 === 95 || e36 >= 97 && e36 <= 122 || e36 >= 65 && e36 <= 90 || e36 == 183 || e36 >= 192 && e36 <= 214 || e36 >= 216 && e36 <= 246 || e36 >= 248 && e36 <= 893 || e36 >= 895 && e36 <= 8191 || e36 >= 8204 && e36 <= 8205 || e36 >= 8255 && e36 <= 8256 || e36 >= 8304 && e36 <= 8591 || e36 >= 11264 && e36 <= 12271 || e36 >= 12289 && e36 <= 55295 || e36 >= 63744 && e36 <= 64975 || e36 >= 65008 && e36 <= 65533 || e36 >= 65536 && e36 <= 983039;
}
function Tn(e36) {
  return e36 >= 9 && e36 <= 13 || e36 === 32 || e36 === 133 || e36 >= 8206 && e36 <= 8207 || e36 === 8232 || e36 === 8233;
}
function Jo(e36) {
  return e36 >= 33 && e36 <= 35 || e36 === 36 || e36 >= 37 && e36 <= 39 || e36 === 40 || e36 === 41 || e36 === 42 || e36 === 43 || e36 === 44 || e36 === 45 || e36 >= 46 && e36 <= 47 || e36 >= 58 && e36 <= 59 || e36 >= 60 && e36 <= 62 || e36 >= 63 && e36 <= 64 || e36 === 91 || e36 === 92 || e36 === 93 || e36 === 94 || e36 === 96 || e36 === 123 || e36 === 124 || e36 === 125 || e36 === 126 || e36 === 161 || e36 >= 162 && e36 <= 165 || e36 === 166 || e36 === 167 || e36 === 169 || e36 === 171 || e36 === 172 || e36 === 174 || e36 === 176 || e36 === 177 || e36 === 182 || e36 === 187 || e36 === 191 || e36 === 215 || e36 === 247 || e36 >= 8208 && e36 <= 8213 || e36 >= 8214 && e36 <= 8215 || e36 === 8216 || e36 === 8217 || e36 === 8218 || e36 >= 8219 && e36 <= 8220 || e36 === 8221 || e36 === 8222 || e36 === 8223 || e36 >= 8224 && e36 <= 8231 || e36 >= 8240 && e36 <= 8248 || e36 === 8249 || e36 === 8250 || e36 >= 8251 && e36 <= 8254 || e36 >= 8257 && e36 <= 8259 || e36 === 8260 || e36 === 8261 || e36 === 8262 || e36 >= 8263 && e36 <= 8273 || e36 === 8274 || e36 === 8275 || e36 >= 8277 && e36 <= 8286 || e36 >= 8592 && e36 <= 8596 || e36 >= 8597 && e36 <= 8601 || e36 >= 8602 && e36 <= 8603 || e36 >= 8604 && e36 <= 8607 || e36 === 8608 || e36 >= 8609 && e36 <= 8610 || e36 === 8611 || e36 >= 8612 && e36 <= 8613 || e36 === 8614 || e36 >= 8615 && e36 <= 8621 || e36 === 8622 || e36 >= 8623 && e36 <= 8653 || e36 >= 8654 && e36 <= 8655 || e36 >= 8656 && e36 <= 8657 || e36 === 8658 || e36 === 8659 || e36 === 8660 || e36 >= 8661 && e36 <= 8691 || e36 >= 8692 && e36 <= 8959 || e36 >= 8960 && e36 <= 8967 || e36 === 8968 || e36 === 8969 || e36 === 8970 || e36 === 8971 || e36 >= 8972 && e36 <= 8991 || e36 >= 8992 && e36 <= 8993 || e36 >= 8994 && e36 <= 9e3 || e36 === 9001 || e36 === 9002 || e36 >= 9003 && e36 <= 9083 || e36 === 9084 || e36 >= 9085 && e36 <= 9114 || e36 >= 9115 && e36 <= 9139 || e36 >= 9140 && e36 <= 9179 || e36 >= 9180 && e36 <= 9185 || e36 >= 9186 && e36 <= 9254 || e36 >= 9255 && e36 <= 9279 || e36 >= 9280 && e36 <= 9290 || e36 >= 9291 && e36 <= 9311 || e36 >= 9472 && e36 <= 9654 || e36 === 9655 || e36 >= 9656 && e36 <= 9664 || e36 === 9665 || e36 >= 9666 && e36 <= 9719 || e36 >= 9720 && e36 <= 9727 || e36 >= 9728 && e36 <= 9838 || e36 === 9839 || e36 >= 9840 && e36 <= 10087 || e36 === 10088 || e36 === 10089 || e36 === 10090 || e36 === 10091 || e36 === 10092 || e36 === 10093 || e36 === 10094 || e36 === 10095 || e36 === 10096 || e36 === 10097 || e36 === 10098 || e36 === 10099 || e36 === 10100 || e36 === 10101 || e36 >= 10132 && e36 <= 10175 || e36 >= 10176 && e36 <= 10180 || e36 === 10181 || e36 === 10182 || e36 >= 10183 && e36 <= 10213 || e36 === 10214 || e36 === 10215 || e36 === 10216 || e36 === 10217 || e36 === 10218 || e36 === 10219 || e36 === 10220 || e36 === 10221 || e36 === 10222 || e36 === 10223 || e36 >= 10224 && e36 <= 10239 || e36 >= 10240 && e36 <= 10495 || e36 >= 10496 && e36 <= 10626 || e36 === 10627 || e36 === 10628 || e36 === 10629 || e36 === 10630 || e36 === 10631 || e36 === 10632 || e36 === 10633 || e36 === 10634 || e36 === 10635 || e36 === 10636 || e36 === 10637 || e36 === 10638 || e36 === 10639 || e36 === 10640 || e36 === 10641 || e36 === 10642 || e36 === 10643 || e36 === 10644 || e36 === 10645 || e36 === 10646 || e36 === 10647 || e36 === 10648 || e36 >= 10649 && e36 <= 10711 || e36 === 10712 || e36 === 10713 || e36 === 10714 || e36 === 10715 || e36 >= 10716 && e36 <= 10747 || e36 === 10748 || e36 === 10749 || e36 >= 10750 && e36 <= 11007 || e36 >= 11008 && e36 <= 11055 || e36 >= 11056 && e36 <= 11076 || e36 >= 11077 && e36 <= 11078 || e36 >= 11079 && e36 <= 11084 || e36 >= 11085 && e36 <= 11123 || e36 >= 11124 && e36 <= 11125 || e36 >= 11126 && e36 <= 11157 || e36 === 11158 || e36 >= 11159 && e36 <= 11263 || e36 >= 11776 && e36 <= 11777 || e36 === 11778 || e36 === 11779 || e36 === 11780 || e36 === 11781 || e36 >= 11782 && e36 <= 11784 || e36 === 11785 || e36 === 11786 || e36 === 11787 || e36 === 11788 || e36 === 11789 || e36 >= 11790 && e36 <= 11798 || e36 === 11799 || e36 >= 11800 && e36 <= 11801 || e36 === 11802 || e36 === 11803 || e36 === 11804 || e36 === 11805 || e36 >= 11806 && e36 <= 11807 || e36 === 11808 || e36 === 11809 || e36 === 11810 || e36 === 11811 || e36 === 11812 || e36 === 11813 || e36 === 11814 || e36 === 11815 || e36 === 11816 || e36 === 11817 || e36 >= 11818 && e36 <= 11822 || e36 === 11823 || e36 >= 11824 && e36 <= 11833 || e36 >= 11834 && e36 <= 11835 || e36 >= 11836 && e36 <= 11839 || e36 === 11840 || e36 === 11841 || e36 === 11842 || e36 >= 11843 && e36 <= 11855 || e36 >= 11856 && e36 <= 11857 || e36 === 11858 || e36 >= 11859 && e36 <= 11903 || e36 >= 12289 && e36 <= 12291 || e36 === 12296 || e36 === 12297 || e36 === 12298 || e36 === 12299 || e36 === 12300 || e36 === 12301 || e36 === 12302 || e36 === 12303 || e36 === 12304 || e36 === 12305 || e36 >= 12306 && e36 <= 12307 || e36 === 12308 || e36 === 12309 || e36 === 12310 || e36 === 12311 || e36 === 12312 || e36 === 12313 || e36 === 12314 || e36 === 12315 || e36 === 12316 || e36 === 12317 || e36 >= 12318 && e36 <= 12319 || e36 === 12320 || e36 === 12336 || e36 === 64830 || e36 === 64831 || e36 >= 65093 && e36 <= 65094;
}
function rr(e36) {
  e36.forEach(function(t34) {
    if (delete t34.location, Je(t34) || et(t34)) for (var r25 in t34.options) delete t34.options[r25].location, rr(t34.options[r25].value);
    else Qe(t34) && rt(t34.style) || (Ke(t34) || Ze(t34)) && we(t34.style) ? delete t34.style.location : tt(t34) && rr(t34.children);
  });
}
function bn(e36, t34) {
  t34 === void 0 && (t34 = {}), t34 = x4({ shouldParseSkeletons: true, requiresOtherClause: true }, t34);
  var r25 = new yn(e36, t34).parse();
  if (r25.err) {
    var n25 = SyntaxError(d21[r25.err.kind]);
    throw n25.location = r25.err.location, n25.originalMessage = r25.err.message, n25;
  }
  return t34?.captureLocation || rr(r25.val), r25.val;
}
function Ie(e36, t34) {
  var r25 = t34 && t34.cache ? t34.cache : os2, n25 = t34 && t34.serializer ? t34.serializer : is, i21 = t34 && t34.strategy ? t34.strategy : ts;
  return i21(e36, { cache: r25, serializer: n25 });
}
function es(e36) {
  return e36 == null || typeof e36 == "number" || typeof e36 == "boolean";
}
function Sn(e36, t34, r25, n25) {
  var i21 = es(n25) ? n25 : r25(n25), o52 = t34.get(i21);
  return typeof o52 > "u" && (o52 = e36.call(this, n25), t34.set(i21, o52)), o52;
}
function _n(e36, t34, r25) {
  var n25 = Array.prototype.slice.call(arguments, 3), i21 = r25(n25), o52 = t34.get(i21);
  return typeof o52 > "u" && (o52 = e36.apply(this, n25), t34.set(i21, o52)), o52;
}
function nr(e36, t34, r25, n25, i21) {
  return r25.bind(t34, e36, n25, i21);
}
function ts(e36, t34) {
  var r25 = e36.length === 1 ? Sn : _n;
  return nr(e36, this, r25, t34.cache.create(), t34.serializer);
}
function rs(e36, t34) {
  return nr(e36, this, _n, t34.cache.create(), t34.serializer);
}
function ns(e36, t34) {
  return nr(e36, this, Sn, t34.cache.create(), t34.serializer);
}
var is = function() {
  return JSON.stringify(arguments);
};
function ir() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ir.prototype.get = function(e36) {
  return this.cache[e36];
};
ir.prototype.set = function(e36, t34) {
  this.cache[e36] = t34;
};
var os2 = { create: function() {
  return new ir();
} };
var nt = { variadic: rs, monadic: ns };
var ce;
(function(e36) {
  e36.MISSING_VALUE = "MISSING_VALUE", e36.INVALID_VALUE = "INVALID_VALUE", e36.MISSING_INTL_API = "MISSING_INTL_API";
})(ce || (ce = {}));
var He = function(e36) {
  Ne(t34, e36);
  function t34(r25, n25, i21) {
    var o52 = e36.call(this, r25) || this;
    return o52.code = n25, o52.originalMessage = i21, o52;
  }
  return t34.prototype.toString = function() {
    return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
  }, t34;
}(Error);
var or = function(e36) {
  Ne(t34, e36);
  function t34(r25, n25, i21, o52) {
    return e36.call(this, 'Invalid values for "'.concat(r25, '": "').concat(n25, '". Options are "').concat(Object.keys(i21).join('", "'), '"'), ce.INVALID_VALUE, o52) || this;
  }
  return t34;
}(He);
var Pn = function(e36) {
  Ne(t34, e36);
  function t34(r25, n25, i21) {
    return e36.call(this, 'Value for "'.concat(r25, '" must be of type ').concat(n25), ce.INVALID_VALUE, i21) || this;
  }
  return t34;
}(He);
var vn = function(e36) {
  Ne(t34, e36);
  function t34(r25, n25) {
    return e36.call(this, 'The intl string context variable "'.concat(r25, '" was not provided to the string "').concat(n25, '"'), ce.MISSING_VALUE, n25) || this;
  }
  return t34;
}(He);
var U;
(function(e36) {
  e36[e36.literal = 0] = "literal", e36[e36.object = 1] = "object";
})(U || (U = {}));
function ss(e36) {
  return e36.length < 2 ? e36 : e36.reduce(function(t34, r25) {
    var n25 = t34[t34.length - 1];
    return !n25 || n25.type !== U.literal || r25.type !== U.literal ? t34.push(r25) : n25.value += r25.value, t34;
  }, []);
}
function as(e36) {
  return typeof e36 == "function";
}
function Me(e36, t34, r25, n25, i21, o52, s19) {
  if (e36.length === 1 && qt(e36[0])) return [{ type: U.literal, value: e36[0].value }];
  for (var a23 = [], c33 = 0, u36 = e36; c33 < u36.length; c33++) {
    var l16 = u36[c33];
    if (qt(l16)) {
      a23.push({ type: U.literal, value: l16.value });
      continue;
    }
    if (rn(l16)) {
      typeof o52 == "number" && a23.push({ type: U.literal, value: r25.getNumberFormat(t34).format(o52) });
      continue;
    }
    var p30 = l16.value;
    if (!(i21 && p30 in i21)) throw new vn(p30, s19);
    var f11 = i21[p30];
    if (tn(l16)) {
      (!f11 || typeof f11 == "string" || typeof f11 == "number") && (f11 = typeof f11 == "string" || typeof f11 == "number" ? String(f11) : ""), a23.push({ type: typeof f11 == "string" ? U.literal : U.object, value: f11 });
      continue;
    }
    if (Ke(l16)) {
      var h16 = typeof l16.style == "string" ? n25.date[l16.style] : we(l16.style) ? l16.style.parsedOptions : void 0;
      a23.push({ type: U.literal, value: r25.getDateTimeFormat(t34, h16).format(f11) });
      continue;
    }
    if (Ze(l16)) {
      var h16 = typeof l16.style == "string" ? n25.time[l16.style] : we(l16.style) ? l16.style.parsedOptions : n25.time.medium;
      a23.push({ type: U.literal, value: r25.getDateTimeFormat(t34, h16).format(f11) });
      continue;
    }
    if (Qe(l16)) {
      var h16 = typeof l16.style == "string" ? n25.number[l16.style] : rt(l16.style) ? l16.style.parsedOptions : void 0;
      h16 && h16.scale && (f11 = f11 * (h16.scale || 1)), a23.push({ type: U.literal, value: r25.getNumberFormat(t34, h16).format(f11) });
      continue;
    }
    if (tt(l16)) {
      var E3 = l16.children, m18 = l16.value, y5 = i21[m18];
      if (!as(y5)) throw new Pn(m18, "function", s19);
      var _2 = Me(E3, t34, r25, n25, i21, o52), b12 = y5(_2.map(function(v6) {
        return v6.value;
      }));
      Array.isArray(b12) || (b12 = [b12]), a23.push.apply(a23, b12.map(function(v6) {
        return { type: typeof v6 == "string" ? U.literal : U.object, value: v6 };
      }));
    }
    if (Je(l16)) {
      var T5 = l16.options[f11] || l16.options.other;
      if (!T5) throw new or(l16.value, f11, Object.keys(l16.options), s19);
      a23.push.apply(a23, Me(T5.value, t34, r25, n25, i21));
      continue;
    }
    if (et(l16)) {
      var T5 = l16.options["=".concat(f11)];
      if (!T5) {
        if (!Intl.PluralRules) throw new He(`Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`, ce.MISSING_INTL_API, s19);
        var S4 = r25.getPluralRules(t34, { type: l16.pluralType }).select(f11 - (l16.offset || 0));
        T5 = l16.options[S4] || l16.options.other;
      }
      if (!T5) throw new or(l16.value, f11, Object.keys(l16.options), s19);
      a23.push.apply(a23, Me(T5.value, t34, r25, n25, i21, f11 - (l16.offset || 0)));
      continue;
    }
  }
  return ss(a23);
}
function cs(e36, t34) {
  return t34 ? x4(x4(x4({}, e36 || {}), t34 || {}), Object.keys(e36).reduce(function(r25, n25) {
    return r25[n25] = x4(x4({}, e36[n25]), t34[n25] || {}), r25;
  }, {})) : e36;
}
function ls(e36, t34) {
  return t34 ? Object.keys(e36).reduce(function(r25, n25) {
    return r25[n25] = cs(e36[n25], t34[n25]), r25;
  }, x4({}, e36)) : e36;
}
function sr(e36) {
  return { create: function() {
    return { get: function(t34) {
      return e36[t34];
    }, set: function(t34, r25) {
      e36[t34] = r25;
    } };
  } };
}
function us(e36) {
  return e36 === void 0 && (e36 = { number: {}, dateTime: {}, pluralRules: {} }), { getNumberFormat: Ie(function() {
    for (var t34, r25 = [], n25 = 0; n25 < arguments.length; n25++) r25[n25] = arguments[n25];
    return new ((t34 = Intl.NumberFormat).bind.apply(t34, ze([void 0], r25, false)))();
  }, { cache: sr(e36.number), strategy: nt.variadic }), getDateTimeFormat: Ie(function() {
    for (var t34, r25 = [], n25 = 0; n25 < arguments.length; n25++) r25[n25] = arguments[n25];
    return new ((t34 = Intl.DateTimeFormat).bind.apply(t34, ze([void 0], r25, false)))();
  }, { cache: sr(e36.dateTime), strategy: nt.variadic }), getPluralRules: Ie(function() {
    for (var t34, r25 = [], n25 = 0; n25 < arguments.length; n25++) r25[n25] = arguments[n25];
    return new ((t34 = Intl.PluralRules).bind.apply(t34, ze([void 0], r25, false)))();
  }, { cache: sr(e36.pluralRules), strategy: nt.variadic }) };
}
var Rn = function() {
  function e36(t34, r25, n25, i21) {
    var o52 = this;
    if (r25 === void 0 && (r25 = e36.defaultLocale), this.formatterCache = { number: {}, dateTime: {}, pluralRules: {} }, this.format = function(s19) {
      var a23 = o52.formatToParts(s19);
      if (a23.length === 1) return a23[0].value;
      var c33 = a23.reduce(function(u36, l16) {
        return !u36.length || l16.type !== U.literal || typeof u36[u36.length - 1] != "string" ? u36.push(l16.value) : u36[u36.length - 1] += l16.value, u36;
      }, []);
      return c33.length <= 1 ? c33[0] || "" : c33;
    }, this.formatToParts = function(s19) {
      return Me(o52.ast, o52.locales, o52.formatters, o52.formats, s19, void 0, o52.message);
    }, this.resolvedOptions = function() {
      return { locale: o52.resolvedLocale.toString() };
    }, this.getAst = function() {
      return o52.ast;
    }, this.locales = r25, this.resolvedLocale = e36.resolveLocale(r25), typeof t34 == "string") {
      if (this.message = t34, !e36.__parse) throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
      this.ast = e36.__parse(t34, { ignoreTag: i21?.ignoreTag, locale: this.resolvedLocale });
    } else this.ast = t34;
    if (!Array.isArray(this.ast)) throw new TypeError("A message must be provided as a String or AST.");
    this.formats = ls(e36.formats, n25), this.formatters = i21 && i21.formatters || us(this.formatterCache);
  }
  return Object.defineProperty(e36, "defaultLocale", { get: function() {
    return e36.memoizedDefaultLocale || (e36.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale), e36.memoizedDefaultLocale;
  }, enumerable: false, configurable: true }), e36.memoizedDefaultLocale = null, e36.resolveLocale = function(t34) {
    var r25 = Intl.NumberFormat.supportedLocalesOf(t34);
    return r25.length > 0 ? new Intl.Locale(r25[0]) : new Intl.Locale(typeof t34 == "string" ? t34 : t34[0]);
  }, e36.__parse = bn, e36.formats = { number: { integer: { maximumFractionDigits: 0 }, currency: { style: "currency" }, percent: { style: "percent" } }, date: { short: { month: "numeric", day: "numeric", year: "2-digit" }, medium: { month: "short", day: "numeric", year: "numeric" }, long: { month: "long", day: "numeric", year: "numeric" }, full: { weekday: "long", month: "long", day: "numeric", year: "numeric" } }, time: { short: { hour: "numeric", minute: "numeric" }, medium: { hour: "numeric", minute: "numeric", second: "numeric" }, long: { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" }, full: { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" } } }, e36;
}();
var Cn = Rn;
var hs = /[0-9\-+#]/;
var fs = /[^\d\-+#]/g;
function Ln(e36) {
  return e36.search(hs);
}
function ps(e36 = "#.##") {
  let t34 = {}, r25 = e36.length, n25 = Ln(e36);
  t34.prefix = n25 > 0 ? e36.substring(0, n25) : "";
  let i21 = Ln(e36.split("").reverse().join("")), o52 = r25 - i21, s19 = e36.substring(o52, o52 + 1), a23 = o52 + (s19 === "." || s19 === "," ? 1 : 0);
  t34.suffix = i21 > 0 ? e36.substring(a23, r25) : "", t34.mask = e36.substring(n25, a23), t34.maskHasNegativeSign = t34.mask.charAt(0) === "-", t34.maskHasPositiveSign = t34.mask.charAt(0) === "+";
  let c33 = t34.mask.match(fs);
  return t34.decimal = c33 && c33[c33.length - 1] || ".", t34.separator = c33 && c33[1] && c33[0] || ",", c33 = t34.mask.split(t34.decimal), t34.integer = c33[0], t34.fraction = c33[1], t34;
}
function ms(e36, t34, r25) {
  let n25 = false, i21 = { value: e36 };
  e36 < 0 && (n25 = true, i21.value = -i21.value), i21.sign = n25 ? "-" : "", i21.value = Number(i21.value).toFixed(t34.fraction && t34.fraction.length), i21.value = Number(i21.value).toString();
  let o52 = t34.fraction && t34.fraction.lastIndexOf("0"), [s19 = "0", a23 = ""] = i21.value.split(".");
  return (!a23 || a23 && a23.length <= o52) && (a23 = o52 < 0 ? "" : (+("0." + a23)).toFixed(o52 + 1).replace("0.", "")), i21.integer = s19, i21.fraction = a23, Es(i21, t34), (i21.result === "0" || i21.result === "") && (n25 = false, i21.sign = ""), !n25 && t34.maskHasPositiveSign ? i21.sign = "+" : n25 && t34.maskHasPositiveSign ? i21.sign = "-" : n25 && (i21.sign = r25 && r25.enforceMaskSign && !t34.maskHasNegativeSign ? "" : "-"), i21;
}
function Es(e36, t34) {
  e36.result = "";
  let r25 = t34.integer.split(t34.separator), n25 = r25.join(""), i21 = n25 && n25.indexOf("0");
  if (i21 > -1) for (; e36.integer.length < n25.length - i21; ) e36.integer = "0" + e36.integer;
  else Number(e36.integer) === 0 && (e36.integer = "");
  let o52 = r25[1] && r25[r25.length - 1].length;
  if (o52) {
    let s19 = e36.integer.length, a23 = s19 % o52;
    for (let c33 = 0; c33 < s19; c33++) e36.result += e36.integer.charAt(c33), !((c33 - a23 + 1) % o52) && c33 < s19 - o52 && (e36.result += t34.separator);
  } else e36.result = e36.integer;
  return e36.result += t34.fraction && e36.fraction ? t34.decimal + e36.fraction : "", e36;
}
function ds(e36, t34, r25 = {}) {
  if (!e36 || isNaN(Number(t34))) return t34;
  let n25 = ps(e36), i21 = ms(t34, n25, r25);
  return n25.prefix + i21.sign + i21.result + n25.suffix;
}
var Nn = ds;
var wn = ".";
var gs = ",";
var In = /^\s+/;
var Hn = /\s+$/;
var On = "&nbsp;";
var ar = (e36) => e36 * 12;
var Mn = (e36, t34) => {
  let { start: r25, end: n25, displaySummary: { amount: i21, duration: o52, minProductQuantity: s19, outcomeType: a23 } = {} } = e36;
  if (!(i21 && o52 && a23 && s19)) return false;
  let c33 = t34 ? new Date(t34) : /* @__PURE__ */ new Date();
  if (!r25 || !n25) return false;
  let u36 = new Date(r25), l16 = new Date(n25);
  return c33 >= u36 && c33 <= l16;
};
var le = { MONTH: "MONTH", YEAR: "YEAR" };
var xs = { [$3.ANNUAL]: 12, [$3.MONTHLY]: 1, [$3.THREE_YEARS]: 36, [$3.TWO_YEARS]: 24 };
var cr = (e36, t34) => ({ accept: e36, round: t34 });
var As = [cr(({ divisor: e36, price: t34 }) => t34 % e36 == 0, ({ divisor: e36, price: t34 }) => t34 / e36), cr(({ usePrecision: e36 }) => e36, ({ divisor: e36, price: t34 }) => Math.round(t34 / e36 * 100) / 100), cr(() => true, ({ divisor: e36, price: t34 }) => Math.ceil(Math.floor(t34 * 100 / e36) / 100))];
var lr = { [ie3.YEAR]: { [$3.MONTHLY]: le.MONTH, [$3.ANNUAL]: le.YEAR }, [ie3.MONTH]: { [$3.MONTHLY]: le.MONTH } };
var ys = (e36, t34) => e36.indexOf(`'${t34}'`) === 0;
var Ts = (e36, t34 = true) => {
  let r25 = e36.replace(/'.*?'/, "").trim(), n25 = Un(r25);
  return !!n25 ? t34 || (r25 = r25.replace(/[,\.]0+/, n25)) : r25 = r25.replace(/\s?(#.*0)(?!\s)?/, "$&" + Ss(e36)), r25;
};
var bs = (e36) => {
  let t34 = _s(e36), r25 = ys(e36, t34), n25 = e36.replace(/'.*?'/, ""), i21 = In.test(n25) || Hn.test(n25);
  return { currencySymbol: t34, isCurrencyFirst: r25, hasCurrencySpace: i21 };
};
var Dn = (e36) => e36.replace(In, On).replace(Hn, On);
var Ss = (e36) => e36.match(/#(.?)#/)?.[1] === wn ? gs : wn;
var _s = (e36) => e36.match(/'(.*?)'/)?.[1] ?? "";
var Un = (e36) => e36.match(/0(.?)0/)?.[1] ?? "";
function xe({ formatString: e36, price: t34, usePrecision: r25, isIndianPrice: n25 = false }, i21, o52 = (s19) => s19) {
  let { currencySymbol: s19, isCurrencyFirst: a23, hasCurrencySpace: c33 } = bs(e36), u36 = r25 ? Un(e36) : "", l16 = Ts(e36, r25), p30 = r25 ? 2 : 0, f11 = o52(t34, { currencySymbol: s19 }), h16 = n25 ? f11.toLocaleString("hi-IN", { minimumFractionDigits: p30, maximumFractionDigits: p30 }) : Nn(l16, f11), E3 = r25 ? h16.lastIndexOf(u36) : h16.length, m18 = h16.substring(0, E3), y5 = h16.substring(E3 + 1);
  return { accessiblePrice: e36.replace(/'.*?'/, "SYMBOL").replace(/#.*0/, h16).replace(/SYMBOL/, s19), currencySymbol: s19, decimals: y5, decimalsDelimiter: u36, hasCurrencySpace: c33, integer: m18, isCurrencyFirst: a23, recurrenceTerm: i21 };
}
var Bn = (e36) => {
  let { commitment: t34, term: r25, usePrecision: n25 } = e36, i21 = xs[r25] ?? 1;
  return xe(e36, i21 > 1 ? le.MONTH : lr[t34]?.[r25], (o52) => {
    let s19 = { divisor: i21, price: o52, usePrecision: n25 }, { round: a23 } = As.find(({ accept: c33 }) => c33(s19));
    if (!a23) throw new Error(`Missing rounding rule for: ${JSON.stringify(s19)}`);
    return a23(s19);
  });
};
var kn = ({ commitment: e36, term: t34, ...r25 }) => xe(r25, lr[e36]?.[t34]);
var Fn = (e36) => {
  let { commitment: t34, instant: r25, price: n25, originalPrice: i21, priceWithoutDiscount: o52, promotion: s19, quantity: a23 = 1, term: c33 } = e36;
  if (t34 === ie3.YEAR && c33 === $3.MONTHLY) {
    if (!s19) return xe(e36, le.YEAR, ar);
    let { displaySummary: { outcomeType: u36, duration: l16, minProductQuantity: p30 = 1 } = {} } = s19;
    switch (u36) {
      case "PERCENTAGE_DISCOUNT":
        if (a23 >= p30 && Mn(s19, r25)) {
          let f11 = parseInt(l16.replace("P", "").replace("M", ""));
          if (isNaN(f11)) return ar(n25);
          let h16 = a23 * i21 * f11, E3 = a23 * o52 * (12 - f11), m18 = Math.round((h16 + E3) * 100) / 100;
          return xe({ ...e36, price: m18 }, le.YEAR);
        }
      default:
        return xe(e36, le.YEAR, () => ar(o52 ?? n25));
    }
  }
  return xe(e36, lr[t34]?.[c33]);
};
var ur = { recurrenceLabel: "{recurrenceTerm, select, MONTH {/mo} YEAR {/yr} other {}}", recurrenceAriaLabel: "{recurrenceTerm, select, MONTH {per month} YEAR {per year} other {}}", perUnitLabel: "{perUnit, select, LICENSE {per license} other {}}", perUnitAriaLabel: "{perUnit, select, LICENSE {per license} other {}}", freeLabel: "Free", freeAriaLabel: "Free", taxExclusiveLabel: "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}", taxInclusiveLabel: "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}", alternativePriceAriaLabel: "Alternatively at", strikethroughAriaLabel: "Regularly at", planTypeLabel: "{planType, select, ABM {Annual, billed monthly} other {}}" };
var Ps = Cr("ConsonantTemplates/price");
var vs = /<\/?[^>]+(>|$)/g;
var I4 = { container: "price", containerOptical: "price-optical", containerStrikethrough: "price-strikethrough", containerAlternative: "price-alternative", containerAnnual: "price-annual", containerAnnualPrefix: "price-annual-prefix", containerAnnualSuffix: "price-annual-suffix", disabled: "disabled", currencySpace: "price-currency-space", currencySymbol: "price-currency-symbol", decimals: "price-decimals", decimalsDelimiter: "price-decimals-delimiter", integer: "price-integer", recurrence: "price-recurrence", taxInclusivity: "price-tax-inclusivity", unitType: "price-unit-type" };
var re = { perUnitLabel: "perUnitLabel", perUnitAriaLabel: "perUnitAriaLabel", recurrenceLabel: "recurrenceLabel", recurrenceAriaLabel: "recurrenceAriaLabel", taxExclusiveLabel: "taxExclusiveLabel", taxInclusiveLabel: "taxInclusiveLabel", strikethroughAriaLabel: "strikethroughAriaLabel", alternativePriceAriaLabel: "alternativePriceAriaLabel" };
var hr = "TAX_EXCLUSIVE";
var Rs = (e36) => Pr(e36) ? Object.entries(e36).filter(([, t34]) => Ee(t34) || Ge(t34) || t34 === true).reduce((t34, [r25, n25]) => t34 + ` ${r25}${n25 === true ? "" : '="' + _r(n25) + '"'}`, "") : "";
var M4 = (e36, t34, r25, n25 = false) => `<span class="${e36}${t34 ? "" : " " + I4.disabled}"${Rs(r25)}>${n25 ? Dn(t34) : t34 ?? ""}</span>`;
function Z2(e36, t34, r25, n25) {
  let i21 = e36[r25];
  if (i21 == null) return "";
  try {
    return new Cn(i21.replace(vs, ""), t34).format(n25);
  } catch {
    return Ps.error("Failed to format literal:", i21), "";
  }
}
function Cs(e36, { accessibleLabel: t34, altAccessibleLabel: r25, currencySymbol: n25, decimals: i21, decimalsDelimiter: o52, hasCurrencySpace: s19, integer: a23, isCurrencyFirst: c33, recurrenceLabel: u36, perUnitLabel: l16, taxInclusivityLabel: p30 }, f11 = {}) {
  let h16 = M4(I4.currencySymbol, n25), E3 = M4(I4.currencySpace, s19 ? "&nbsp;" : ""), m18 = "";
  return t34 ? m18 = `<sr-only class="strikethrough-aria-label">${t34}</sr-only>` : r25 && (m18 = `<sr-only class="alt-aria-label">${r25}</sr-only>`), c33 && (m18 += h16 + E3), m18 += M4(I4.integer, a23), m18 += M4(I4.decimalsDelimiter, o52), m18 += M4(I4.decimals, i21), c33 || (m18 += E3 + h16), m18 += M4(I4.recurrence, u36, null, true), m18 += M4(I4.unitType, l16, null, true), m18 += M4(I4.taxInclusivity, p30, true), M4(e36, m18, { ...f11 });
}
var F2 = ({ isAlternativePrice: e36 = false, displayOptical: t34 = false, displayStrikethrough: r25 = false, displayAnnual: n25 = false, instant: i21 = void 0 } = {}) => ({ country: o52, displayFormatted: s19 = true, displayRecurrence: a23 = true, displayPerUnit: c33 = false, displayTax: u36 = false, language: l16, literals: p30 = {}, quantity: f11 = 1, space: h16 = false } = {}, { commitment: E3, offerSelectorIds: m18, formatString: y5, price: _2, priceWithoutDiscount: b12, taxDisplay: T5, taxTerm: S4, term: v6, usePrecision: w3, promotion: H2 } = {}, k2 = {}) => {
  Object.entries({ country: o52, formatString: y5, language: l16, price: _2 }).forEach(([gi, xi]) => {
    if (xi == null) throw new Error(`Argument "${gi}" is missing for osi ${m18?.toString()}, country ${o52}, language ${l16}`);
  });
  let N2 = { ...ur, ...p30 }, R2 = `${l16.toLowerCase()}-${o52.toUpperCase()}`, D = r25 && b12 ? b12 : _2, Y = t34 ? Bn : kn;
  n25 && (Y = Fn);
  let { accessiblePrice: J, recurrenceTerm: X, ...ue } = Y({ commitment: E3, formatString: y5, instant: i21, isIndianPrice: o52 === "IN", originalPrice: _2, priceWithoutDiscount: b12, price: t34 ? _2 : D, promotion: H2, quantity: f11, term: v6, usePrecision: w3 }), st = "", at = "", ct = "";
  g7(a23) && X && (ct = Z2(N2, R2, re.recurrenceLabel, { recurrenceTerm: X }));
  let Be = "";
  g7(c33) && (h16 && (Be += " "), Be += Z2(N2, R2, re.perUnitLabel, { perUnit: "LICENSE" }));
  let ke = "";
  g7(u36) && S4 && (h16 && (ke += " "), ke += Z2(N2, R2, T5 === hr ? re.taxExclusiveLabel : re.taxInclusiveLabel, { taxTerm: S4 })), r25 && (st = Z2(N2, R2, re.strikethroughAriaLabel, { strikethroughPrice: st })), e36 && (at = Z2(N2, R2, re.alternativePriceAriaLabel, { alternativePrice: at }));
  let he = I4.container;
  if (t34 && (he += " " + I4.containerOptical), r25 && (he += " " + I4.containerStrikethrough), e36 && (he += " " + I4.containerAlternative), n25 && (he += " " + I4.containerAnnual), g7(s19)) return Cs(he, { ...ue, accessibleLabel: st, altAccessibleLabel: at, recurrenceLabel: ct, perUnitLabel: Be, taxInclusivityLabel: ke }, k2);
  let { currencySymbol: mr, decimals: fi, decimalsDelimiter: pi, hasCurrencySpace: Er, integer: mi, isCurrencyFirst: Ei } = ue, fe = [mi, pi, fi];
  Ei ? (fe.unshift(Er ? "\xA0" : ""), fe.unshift(mr)) : (fe.push(Er ? "\xA0" : ""), fe.push(mr)), fe.push(ct, Be, ke);
  let di = fe.join("");
  return M4(he, di, k2);
};
var Gn = () => (e36, t34, r25) => {
  let i21 = (e36.displayOldPrice === void 0 || g7(e36.displayOldPrice)) && t34.priceWithoutDiscount && t34.priceWithoutDiscount != t34.price;
  return `${i21 ? F2({ displayStrikethrough: true })(e36, t34, r25) + "&nbsp;" : ""}${F2({ isAlternativePrice: i21 })(e36, t34, r25)}`;
};
var Vn = () => (e36, t34, r25) => {
  let { instant: n25 } = e36;
  try {
    n25 || (n25 = new URLSearchParams(document.location.search).get("instant")), n25 && (n25 = new Date(n25));
  } catch {
    n25 = void 0;
  }
  let i21 = { ...e36, displayTax: false, displayPerUnit: false }, s19 = (e36.displayOldPrice === void 0 || g7(e36.displayOldPrice)) && t34.priceWithoutDiscount && t34.priceWithoutDiscount != t34.price;
  return `${s19 ? F2({ displayStrikethrough: true })(i21, t34, r25) + "&nbsp;" : ""}${F2({ isAlternativePrice: s19 })(e36, t34, r25)}${M4(I4.containerAnnualPrefix, "&nbsp;(")}${F2({ displayAnnual: true, instant: n25 })(i21, t34, r25)}${M4(I4.containerAnnualSuffix, ")")}`;
};
var Yn = () => (e36, t34, r25) => {
  let n25 = { ...e36, displayTax: false, displayPerUnit: false };
  return `${F2({ isAlternativePrice: e36.displayOldPrice })(e36, t34, r25)}${M4(I4.containerAnnualPrefix, "&nbsp;(")}${F2({ displayAnnual: true })(n25, t34, r25)}${M4(I4.containerAnnualSuffix, ")")}`;
};
var De = { ...I4, containerLegal: "price-legal", planType: "price-plan-type" };
var it = { ...re, planTypeLabel: "planTypeLabel" };
function Ls(e36, { perUnitLabel: t34, taxInclusivityLabel: r25, planTypeLabel: n25 }, i21 = {}) {
  let o52 = "";
  return o52 += M4(De.unitType, t34, null, true), r25 && n25 && (r25 += ". "), o52 += M4(De.taxInclusivity, r25, true), o52 += M4(De.planType, n25, null), M4(e36, o52, { ...i21 });
}
var $n = ({ country: e36, displayPerUnit: t34 = false, displayTax: r25 = false, displayPlanType: n25 = false, language: i21, literals: o52 = {} } = {}, { taxDisplay: s19, taxTerm: a23, planType: c33 } = {}, u36 = {}) => {
  let l16 = { ...ur, ...o52 }, p30 = `${i21.toLowerCase()}-${e36.toUpperCase()}`, f11 = "";
  g7(t34) && (f11 = Z2(l16, p30, it.perUnitLabel, { perUnit: "LICENSE" }));
  let h16 = "";
  e36 === "US" && i21 === "en" && (r25 = false), g7(r25) && a23 && (h16 = Z2(l16, p30, s19 === hr ? it.taxExclusiveLabel : it.taxInclusiveLabel, { taxTerm: a23 }));
  let E3 = "";
  g7(n25) && c33 && (E3 = Z2(l16, p30, it.planTypeLabel, { planType: c33 }));
  let m18 = De.container;
  return m18 += " " + De.containerLegal, Ls(m18, { perUnitLabel: f11, taxInclusivityLabel: h16, planTypeLabel: E3 }, u36);
};
var Wn = F2();
var jn = Gn();
var Xn = F2({ displayOptical: true });
var qn = F2({ displayStrikethrough: true });
var zn = F2({ displayAnnual: true });
var Qn = F2({ displayOptical: true, isAlternativePrice: true });
var Kn = F2({ isAlternativePrice: true });
var Zn = Yn();
var Jn = Vn();
var ei = $n;
var Ns = (e36, t34) => {
  if (!(!_e(e36) || !_e(t34))) return Math.floor((t34 - e36) / t34 * 100);
};
var ti = () => (e36, t34) => {
  let { price: r25, priceWithoutDiscount: n25 } = t34, i21 = Ns(r25, n25);
  return i21 === void 0 ? '<span class="no-discount"></span>' : `<span class="discount">${i21}%</span>`;
};
var ri = ti();
function ni({ literals: e36, providers: t34, settings: r25 }) {
  function n25(o52, s19 = null) {
    let a23 = { country: r25.country, language: r25.language, locale: r25.locale, literals: { ...e36.price } };
    if (s19 && t34?.price) for (let v6 of t34.price) v6(s19, a23);
    let { displayOldPrice: c33, displayPerUnit: u36, displayRecurrence: l16, displayTax: p30, displayPlanType: f11, forceTaxExclusive: h16, perpetual: E3, displayAnnual: m18, promotionCode: y5, quantity: _2, alternativePrice: b12, wcsOsi: T5, ...S4 } = Object.assign(a23, s19?.dataset ?? {}, o52 ?? {});
    return a23 = Ve(Object.assign({ ...a23, ...S4, displayOldPrice: g7(c33), displayPerUnit: g7(u36), displayRecurrence: g7(l16), displayTax: g7(p30), displayPlanType: g7(f11), forceTaxExclusive: g7(h16), perpetual: g7(E3), displayAnnual: g7(m18), promotionCode: $e(y5).effectivePromoCode, quantity: de(_2, P3.quantity), alternativePrice: g7(b12), wcsOsi: Re(T5) })), a23;
  }
  function i21(o52, s19) {
    if (!Array.isArray(o52) || !o52.length || !s19) return "";
    let { template: a23 } = s19, c33;
    switch (a23) {
      case "discount":
        c33 = ri;
        break;
      case "strikethrough":
        c33 = qn;
        break;
      case "annual":
        c33 = zn;
        break;
      case "legal":
        c33 = ei;
        break;
      default:
        s19.template === "optical" && s19.alternativePrice ? c33 = Qn : s19.template === "optical" ? c33 = Xn : s19.displayAnnual && o52[0].planType === "ABM" ? c33 = s19.promotionCode ? Jn : Zn : s19.alternativePrice ? c33 = Kn : c33 = s19.promotionCode ? jn : Wn;
    }
    let [u36] = o52;
    return u36 = { ...u36, ...u36.priceDetails }, c33({ ...r25, ...s19 }, u36);
  }
  return { buildPriceHTML: i21, collectPriceOptions: n25 };
}
function ws({ locale: e36 = void 0, country: t34 = void 0, language: r25 = void 0 } = {}) {
  return r25 ?? (r25 = e36?.split("_")?.[0] || P3.language), t34 ?? (t34 = e36?.split("_")?.[1] || P3.country), e36 ?? (e36 = `${r25}_${t34}`), { locale: e36, country: t34, language: r25 };
}
function ii(e36 = {}, t34) {
  let r25 = t34.featureFlags[me], { commerce: n25 = {} } = e36, i21 = q2.PRODUCTION, o52 = bt, s19 = L2("checkoutClientId", n25) ?? P3.checkoutClientId, a23 = Pe(L2("checkoutWorkflowStep", n25), B2, P3.checkoutWorkflowStep), c33 = P3.displayOldPrice, u36 = P3.displayPerUnit, l16 = g7(L2("displayRecurrence", n25), P3.displayRecurrence), p30 = g7(L2("displayTax", n25), P3.displayTax), f11 = g7(L2("displayPlanType", n25), P3.displayPlanType), h16 = g7(L2("entitlement", n25), P3.entitlement), E3 = g7(L2("modal", n25), P3.modal), m18 = g7(L2("forceTaxExclusive", n25), P3.forceTaxExclusive), y5 = L2("promotionCode", n25) ?? P3.promotionCode, _2 = de(L2("quantity", n25)), b12 = L2("wcsApiKey", n25) ?? P3.wcsApiKey, T5 = n25?.env === "stage", S4 = te.PUBLISHED;
  ["true", ""].includes(n25.allowOverride) && (T5 = (L2(yt, n25, { metadata: false })?.toLowerCase() ?? n25?.env) === "stage", S4 = Pe(L2(Tt, n25), te, S4)), T5 && (i21 = q2.STAGE, o52 = St);
  let w3 = L2(At) ?? e36.preview, H2 = typeof w3 < "u" && w3 !== "off" && w3 !== "false", k2 = {};
  H2 && (k2 = { preview: H2 });
  let N2 = L2("mas-io-url") ?? e36.masIOUrl ?? `https://www${i21 === q2.STAGE ? ".stage" : ""}.adobe.com/mas/io`, R2 = L2("preselect-plan") ?? void 0;
  return { ...ws(e36), ...k2, displayOldPrice: c33, checkoutClientId: s19, checkoutWorkflowStep: a23, displayPerUnit: u36, displayRecurrence: l16, displayTax: p30, displayPlanType: f11, entitlement: h16, extraOptions: P3.extraOptions, modal: E3, env: i21, forceTaxExclusive: m18, promotionCode: y5, quantity: _2, alternativePrice: P3.alternativePrice, wcsApiKey: b12, wcsURL: o52, landscape: S4, masIOUrl: N2, ...R2 && { preselectPlan: R2 } };
}
async function oi(e36, t34 = {}, r25 = 2, n25 = 100) {
  let i21;
  for (let o52 = 0; o52 <= r25; o52++) try {
    let s19 = await fetch(e36, t34);
    return s19.retryCount = o52, s19;
  } catch (s19) {
    if (i21 = s19, i21.retryCount = o52, o52 > r25) break;
    await new Promise((a23) => setTimeout(a23, n25 * (o52 + 1)));
  }
  throw i21;
}
function ot(e36) {
  return `startTime:${e36.startTime.toFixed(2)}|duration:${e36.duration.toFixed(2)}`;
}
var fr = "wcs";
function si({ settings: e36 }) {
  let t34 = V2.module(fr), { env: r25, wcsApiKey: n25 } = e36, i21 = /* @__PURE__ */ new Map(), o52 = /* @__PURE__ */ new Map(), s19, a23 = /* @__PURE__ */ new Map();
  async function c33(h16, E3, m18 = true) {
    let y5 = j2(), _2 = Et;
    t34.debug("Fetching:", h16);
    let b12 = "", T5;
    if (h16.offerSelectorIds.length > 1) throw new Error("Multiple OSIs are not supported anymore");
    let S4 = new Map(E3), [v6] = h16.offerSelectorIds, w3 = Date.now() + Math.random().toString(36).substring(2, 7), H2 = `${fr}:${v6}:${w3}${Pt}`, k2 = `${fr}:${v6}:${w3}${vt}`, N2;
    try {
      if (performance.mark(H2), b12 = new URL(e36.wcsURL), b12.searchParams.set("offer_selector_ids", v6), b12.searchParams.set("country", h16.country), b12.searchParams.set("locale", h16.locale), b12.searchParams.set("landscape", r25 === q2.STAGE ? "ALL" : e36.landscape), b12.searchParams.set("api_key", n25), h16.language && b12.searchParams.set("language", h16.language), h16.promotionCode && b12.searchParams.set("promotion_code", h16.promotionCode), h16.currency && b12.searchParams.set("currency", h16.currency), T5 = await oi(b12.toString(), { credentials: "omit" }), T5.ok) {
        let R2 = [];
        try {
          let D = await T5.json();
          t34.debug("Fetched:", h16, D), R2 = D.resolvedOffers ?? [];
        } catch (D) {
          t34.error(`Error parsing JSON: ${D.message}`, { ...D.context, ...y5?.duration });
        }
        R2 = R2.map(ve), E3.forEach(({ resolve: D }, Y) => {
          let J = R2.filter(({ offerSelectorIds: X }) => X.includes(Y)).flat();
          J.length && (S4.delete(Y), E3.delete(Y), D(J));
        });
      } else _2 = mt;
    } catch (R2) {
      _2 = `Network error: ${R2.message}`;
    } finally {
      N2 = performance.measure(k2, H2), performance.clearMarks(H2), performance.clearMeasures(k2);
    }
    if (m18 && E3.size) {
      t34.debug("Missing:", { offerSelectorIds: [...E3.keys()] });
      let R2 = Ir(T5);
      E3.forEach((D) => {
        D.reject(new ge(_2, { ...h16, ...R2, response: T5, measure: ot(N2), ...y5?.duration }));
      });
    }
  }
  function u36() {
    clearTimeout(s19);
    let h16 = [...o52.values()];
    o52.clear(), h16.forEach(({ options: E3, promises: m18 }) => c33(E3, m18));
  }
  function l16(h16) {
    if (!h16 || typeof h16 != "object") throw new TypeError("Cache must be a Map or similar object");
    let E3 = r25 === q2.STAGE ? "stage" : "prod", m18 = h16[E3];
    if (!m18 || typeof m18 != "object") {
      t34.warn(`No cache found for environment: ${r25}`);
      return;
    }
    for (let [y5, _2] of Object.entries(m18)) i21.set(y5, Promise.resolve(_2.map(ve)));
    t34.debug(`Prefilled WCS cache with ${m18.size} entries`);
  }
  function p30() {
    let h16 = i21.size;
    a23 = new Map(i21), i21.clear(), t34.debug(`Moved ${h16} cache entries to stale cache`);
  }
  function f11({ country: h16, language: E3, perpetual: m18 = false, promotionCode: y5 = "", wcsOsi: _2 = [] }) {
    let b12 = `${E3}_${h16}`;
    h16 !== "GB" && !m18 && (E3 = "MULT");
    let T5 = [h16, E3, y5].filter((S4) => S4).join("-").toLowerCase();
    return _2.map((S4) => {
      let v6 = `${S4}-${T5}`;
      if (i21.has(v6)) return i21.get(v6);
      let w3 = new Promise((H2, k2) => {
        let N2 = o52.get(T5);
        if (!N2) {
          let R2 = { country: h16, locale: b12, offerSelectorIds: [] };
          h16 !== "GB" && !m18 && (R2.language = E3), N2 = { options: R2, promises: /* @__PURE__ */ new Map() }, o52.set(T5, N2);
        }
        y5 && (N2.options.promotionCode = y5), N2.options.offerSelectorIds.push(S4), N2.promises.set(S4, { resolve: H2, reject: k2 }), u36();
      }).catch((H2) => {
        if (a23.has(v6)) return a23.get(v6);
        throw H2;
      });
      return i21.set(v6, w3), w3;
    });
  }
  return { Commitment: ie3, PlanType: Nr, Term: $3, applyPlanType: ve, resolveOfferSelectors: f11, flushWcsCacheInternal: p30, prefillWcsCache: l16 };
}
var ai = "mas-commerce-service";
var ci = "mas-commerce-service:start";
var li = "mas-commerce-service:ready";
var Ue;
var Ae;
var ye;
var ui;
var hi;
var pr = class extends HTMLElement {
  constructor() {
    super(...arguments);
    pe(this, ye);
    pe(this, Ue);
    pe(this, Ae);
    O(this, "lastLoggingTime", 0);
  }
  async registerCheckoutAction(r25) {
    typeof r25 == "function" && (this.buildCheckoutAction = async (n25, i21, o52) => {
      let s19 = await r25?.(n25, i21, this.imsSignedInPromise, o52);
      return s19 || null;
    });
  }
  get featureFlags() {
    return ne(this, Ae) || Te(this, Ae, { [me]: xr(this, ye, hi).call(this, me) }), ne(this, Ae);
  }
  activate() {
    let r25 = ne(this, ye, ui), n25 = ii(r25, this);
    je(r25.lana);
    let i21 = V2.init(r25.hostEnv).module("service");
    i21.debug("Activating:", r25);
    let s19 = { price: en(n25) }, a23 = { checkout: /* @__PURE__ */ new Set(), price: /* @__PURE__ */ new Set() }, c33 = { literals: s19, providers: a23, settings: n25 };
    Object.defineProperties(this, Object.getOwnPropertyDescriptors({ ...Kr(c33), ...Zr(c33), ...ni(c33), ...si(c33), ...Rt, Log: V2, get defaults() {
      return P3;
    }, get log() {
      return V2;
    }, get providers() {
      return { checkout(l16) {
        return a23.checkout.add(l16), () => a23.checkout.delete(l16);
      }, price(l16) {
        return a23.price.add(l16), () => a23.price.delete(l16);
      }, has: (l16) => a23.price.has(l16) || a23.checkout.has(l16) };
    }, get settings() {
      return n25;
    } })), i21.debug("Activated:", { literals: s19, settings: n25 });
    let u36 = new CustomEvent(be, { bubbles: true, cancelable: false, detail: this });
    performance.mark(li), Te(this, Ue, performance.measure(li, ci)), this.dispatchEvent(u36), setTimeout(() => {
      this.logFailedRequests();
    }, 1e4);
  }
  connectedCallback() {
    performance.mark(ci), this.activate();
  }
  flushWcsCache() {
    this.flushWcsCacheInternal(), this.log.debug("Flushed WCS cache");
  }
  refreshOffers() {
    this.flushWcsCacheInternal(), document.querySelectorAll(ut).forEach((r25) => r25.requestUpdate(true)), this.log.debug("Refreshed WCS offers"), this.logFailedRequests();
  }
  refreshFragments() {
    this.flushWcsCacheInternal(), customElements.get("aem-fragment")?.cache.clear(), document.querySelectorAll("aem-fragment").forEach((r25) => r25.refresh(false)), this.log.debug("Refreshed AEM fragments"), this.logFailedRequests();
  }
  get duration() {
    return { "mas-commerce-service:measure": ot(ne(this, Ue)) };
  }
  logFailedRequests() {
    let r25 = [...performance.getEntriesByType("resource")].filter(({ startTime: i21 }) => i21 > this.lastLoggingTime).filter(({ transferSize: i21, duration: o52, responseStatus: s19 }) => i21 === 0 && o52 === 0 && s19 < 200 || s19 >= 400), n25 = Array.from(new Map(r25.map((i21) => [i21.name, i21])).values());
    if (n25.some(({ name: i21 }) => /(\/fragment\?|web_commerce_artifact)/.test(i21))) {
      let i21 = n25.map(({ name: o52 }) => o52);
      this.log.error("Failed requests:", { failedUrls: i21, ...this.duration });
    }
    this.lastLoggingTime = performance.now().toFixed(3);
  }
};
Ue = /* @__PURE__ */ new WeakMap(), Ae = /* @__PURE__ */ new WeakMap(), ye = /* @__PURE__ */ new WeakSet(), ui = function() {
  let r25 = this.getAttribute("env") ?? "prod", n25 = { commerce: { env: r25 }, hostEnv: { name: r25 }, lana: { tags: this.getAttribute("lana-tags"), sampleRate: parseInt(this.getAttribute("lana-sample-rate") ?? 1, 10), isProdDomain: r25 === "prod" }, masIOUrl: this.getAttribute("mas-io-url") };
  return ["locale", "country", "language", "preview"].forEach((i21) => {
    let o52 = this.getAttribute(i21);
    o52 && (n25[i21] = o52);
  }), ["checkout-workflow-step", "force-tax-exclusive", "checkout-client-id", "allow-override", "wcs-api-key"].forEach((i21) => {
    let o52 = this.getAttribute(i21);
    if (o52 != null) {
      let s19 = i21.replace(/-([a-z])/g, (a23) => a23[1].toUpperCase());
      n25.commerce[s19] = o52;
    }
  }), n25;
}, hi = function(r25) {
  return ["on", "true", true].includes(this.getAttribute(`data-${r25}`) || L2(r25));
};
window.customElements.get(ai) || window.customElements.define(ai, pr);

// src/custom-elements/commerce/inline-price.css.js
var styles = `
  *, *::before, *::after {
    box-sizing: border-box;
  }
  
  inline-price {
    display: inline-block;
    font-family: 'Adobe Clean', 'Segoe UI', Roboto, sans-serif;
    box-sizing: border-box;
    color: var(--spectrum-alias-text-color);
  }

  /* Add space before recurrence, unit type, and tax */
  inline-price .price-recurrence:not(.disabled),
  inline-price .price-unit-type:not(.disabled),
  inline-price .price-tax-inclusivity:not(.disabled) {
    margin-left: 0.25em;
  }

  /* Variant: strikethrough */
  inline-price[template="strikethrough"] {
    text-decoration: line-through;
  }
  
  inline-price[template="strikethrough"] * {
    text-decoration: inherit;
  }

  /* Keep regular font size for strikethrough template */
  inline-price[template="strikethrough"] .price-integer,
  inline-price[template="strikethrough"] .price-decimals,
  inline-price[template="strikethrough"] .price-decimals-delimiter,
  inline-price[template="strikethrough"] .price-currency-symbol,
  inline-price[template="strikethrough"] .price-unit-type,
  inline-price[template="strikethrough"] .price-recurrence:not(.disabled),
  inline-price[template="strikethrough"] .price-tax-inclusivity:not(.disabled) {
    font-size: inherit;
    font-weight: inherit;
    line-height: inherit;
    letter-spacing: inherit;
    text-transform: inherit;
  }

  /* Variant: upw */
  inline-price[variant="upw"]:not([template="strikethrough"]) {
    font-family: 'Adobe Clean', 'Segoe UI', Roboto, sans-serif;
    height: 48px;
  }

  /* UPW: Price integer and decimals */
  inline-price[variant="upw"]:not([template="strikethrough"]) .price-integer,
  inline-price[variant="upw"]:not([template="strikethrough"]) .price-decimals,
  inline-price[variant="upw"]:not([template="strikethrough"]) .price-decimals-delimiter {
    font-family: 'Adobe Clean', 'Segoe UI', Roboto, sans-serif;
    font-style: normal;
    font-weight: 900;
    font-size: 36px;
    line-height: 130%;
    color: var(--spectrum-alias-heading-text-color);
  }

  /* UPW: Other parts (currency symbol, unit type, etc.) */
  inline-price[variant="upw"]:not([template="strikethrough"]) .price-currency-symbol,
  inline-price[variant="upw"]:not([template="strikethrough"]) .price-unit-type,
  inline-price[variant="upw"]:not([template="strikethrough"]) .price-recurrence:not(.disabled),
  inline-price[variant="upw"]:not([template="strikethrough"]) .price-tax-inclusivity:not(.disabled) {
    font-family: 'Adobe Clean', 'Segoe UI', Roboto, sans-serif;
    font-style: normal;
    font-weight: 800;
    font-size: 11px;
    line-height: 150%;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: var(--spectrum-alias-secondary-text-color);
  }
`;
var inlinePriceStyleSheet = new CSSStyleSheet();
inlinePriceStyleSheet.replaceSync(styles);
if (!document.getElementById("inline-price-styles")) {
  document.adoptedStyleSheets.push(inlinePriceStyleSheet);
  const styleEl = document.createElement("style");
  styleEl.id = "inline-price-styles";
  styleEl.textContent = styles;
  document.head.appendChild(styleEl);
}

// src/custom-elements/core/slot-utils.js
function isAssignedToSlot(element) {
  if (!element) return true;
  const slotAttr = element.getAttribute("slot");
  if (!slotAttr) {
    return true;
  }
  return element.assignedSlot !== null;
}

// src/custom-elements/commerce/inline-price.js
function toBoolean(value) {
  if (value === true || value === false) {
    return value;
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (normalized === "true" || normalized === "") {
      return true;
    }
    if (normalized === "false") {
      return false;
    }
  }
  return Boolean(value);
}
var INDIVIDUAL = "INDIVIDUAL_COM";
var BUSINESS = "TEAM_COM";
var STUDENT = "INDIVIDUAL_EDU";
var UNIVERSITY = "TEAM_EDU";
var DISPLAY_ALL_TAX_COUNTRIES = [
  "GB_en",
  "AU_en",
  "FR_fr",
  "AT_de",
  "BE_en",
  "BE_fr",
  "BE_nl",
  "BG_bg",
  "CH_de",
  "CH_fr",
  "CH_it",
  "CZ_cs",
  "DE_de",
  "DK_da",
  "EE_et",
  "EG_ar",
  "EG_en",
  "ES_es",
  "FI_fi",
  "GR_el",
  "GR_en",
  "HU_hu",
  "IE_en",
  "IT_it",
  "LU_de",
  "LU_en",
  "LU_fr",
  "NL_nl",
  "NO_nb",
  "PL_pl",
  "PT_pt",
  "RO_ro",
  "SE_sv",
  "SI_sl",
  "SK_sk",
  "TR_tr",
  "UA_uk",
  "ID_en",
  "ID_in",
  "IN_en",
  "IN_hi",
  "JP_ja",
  "MY_en",
  "MY_ms",
  "NZ_en",
  "TH_en",
  "TH_th"
];
var DISPLAY_TAX_MAP = {
  [INDIVIDUAL]: [
    "MU_en",
    "LT_lt",
    "LV_lv",
    "NG_en",
    "SA_ar",
    "SA_en",
    "SG_en",
    "KR_ko"
  ],
  [BUSINESS]: ["MU_en", "LT_lt", "LV_lv", "NG_en", "CO_es", "KR_ko"],
  [STUDENT]: ["LT_lt", "LV_lv", "SA_en", "SG_en"],
  [UNIVERSITY]: ["SG_en", "KR_ko"]
};
var TAX_EXCLUDED_MAP = {
  ["MU_en"]: [false, false, false, false],
  ["NG_en"]: [false, false, false, false],
  ["AU_en"]: [false, false, false, false],
  ["JP_ja"]: [false, false, false, false],
  ["NZ_en"]: [false, false, false, false],
  ["TH_en"]: [false, false, false, false],
  ["TH_th"]: [false, false, false, false],
  ["CO_es"]: [false, true, false, false],
  ["AT_de"]: [false, false, false, true],
  ["SG_en"]: [false, false, false, true]
};
var TAX_EXCLUDED_MAP_INDEX = [INDIVIDUAL, BUSINESS, STUDENT, UNIVERSITY];
var defaultTaxExcluded = (segment) => [BUSINESS, UNIVERSITY].includes(segment);
var Defaults = {
  displayTax: false,
  forceTaxExclusive: false
};
function resolveTaxExclusive(country, language, customerSegment, marketSegment) {
  const locale = `${country}_${language}`;
  const segment = `${customerSegment}_${marketSegment}`;
  const val = TAX_EXCLUDED_MAP[locale];
  if (val) {
    const index = TAX_EXCLUDED_MAP_INDEX.indexOf(segment);
    return val[index];
  }
  return defaultTaxExcluded(segment);
}
function resolveDisplayTaxForGeoAndSegment(country, language, customerSegment, marketSegment) {
  const locale = `${country}_${language}`;
  if (DISPLAY_ALL_TAX_COUNTRIES.includes(country) || DISPLAY_ALL_TAX_COUNTRIES.includes(locale)) {
    return true;
  }
  const segmentConfig = DISPLAY_TAX_MAP[`${customerSegment}_${marketSegment}`];
  if (!segmentConfig) {
    return Defaults.displayTax;
  }
  if (segmentConfig.includes(country) || segmentConfig.includes(locale)) {
    return true;
  }
  return Defaults.displayTax;
}
async function resolvePriceTaxFlags(country, language, customerSegment, marketSegment) {
  const displayTax = resolveDisplayTaxForGeoAndSegment(
    country,
    language,
    customerSegment,
    marketSegment
  );
  return {
    displayTax,
    forceTaxExclusive: displayTax ? resolveTaxExclusive(country, language, customerSegment, marketSegment) : Defaults.forceTaxExclusive
  };
}
function debounce(fn2, delay3) {
  let timeoutId;
  const debounced = function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn2.apply(this, args), delay3);
  };
  debounced.cancel = () => {
    clearTimeout(timeoutId);
  };
  return debounced;
}
if (!document.getElementById("sr-only-style")) {
  const style = document.createElement("style");
  style.id = "sr-only-style";
  style.textContent = "sr-only { display: none; }";
  document.head.appendChild(style);
}
var InlinePrice = class extends HTMLElement {
  static get observedAttributes() {
    return [
      "template",
      "variant",
      "wcs-osi",
      "promotion-code",
      "display-old-price",
      "display-per-unit",
      "display-recurrence",
      "display-tax",
      "display-plan-type",
      "display-annual",
      "perpetual",
      "force-tax-exclusive"
    ];
  }
  #value;
  #options;
  #renderCancel;
  constructor() {
    super();
    this.handleClick = this.handleClick.bind(this);
    this.#value = null;
    const originalRender = this.render.bind(this);
    this.render = debounce(originalRender, 10);
    this.#renderCancel = this.render.cancel;
  }
  get isInlinePrice() {
    return true;
  }
  get value() {
    return this.#value;
  }
  get options() {
    return this.#options;
  }
  get template() {
    const template = this.getAttribute("template");
    return template !== null ? template : void 0;
  }
  #waitForService() {
    return new Promise((resolve) => {
      const checkService = () => {
        const service2 = j2();
        if (service2 && service2.resolveOfferSelectors && service2.buildPriceHTML) {
          return service2;
        }
        return null;
      };
      const service = checkService();
      if (service) {
        resolve(service);
        return;
      }
      let resolved = false;
      const handler = (event) => {
        if (resolved) return;
        const service2 = checkService();
        if (service2) {
          resolved = true;
          document.removeEventListener(be, handler);
          clearInterval(checkInterval);
          resolve(service2);
        }
      };
      document.addEventListener(be, handler);
      const checkInterval = setInterval(() => {
        if (resolved) return;
        const service2 = checkService();
        if (service2) {
          resolved = true;
          clearInterval(checkInterval);
          document.removeEventListener(be, handler);
          resolve(service2);
        }
      }, 50);
    });
  }
  connectedCallback() {
    this.addEventListener("click", this.handleClick);
    this.render();
  }
  disconnectedCallback() {
    this.removeEventListener("click", this.handleClick);
    if (this.#renderCancel) {
      this.#renderCancel();
    }
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (this.isConnected) {
        this.render();
      }
    }
  }
  handleClick(event) {
    if (event.target === this) {
      event.stopImmediatePropagation();
      return;
    }
    event.stopImmediatePropagation();
    this.dispatchEvent(
      new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
        view: window
      })
    );
  }
  async render() {
    if (!this.isConnected) return false;
    if (!isAssignedToSlot(this)) {
      return false;
    }
    const service = await this.#waitForService();
    if (!service) {
      return false;
    }
    const baseOptions = {
      country: service.settings.country,
      language: service.settings.language,
      locale: service.settings.locale
    };
    const elementValues = {
      template: this.getAttribute("template"),
      variant: this.getAttribute("variant"),
      wcsOsi: this.getAttribute("wcs-osi"),
      promotionCode: this.getAttribute("promotion-code"),
      displayOldPrice: this.getAttribute("display-old-price"),
      displayPerUnit: this.getAttribute("display-per-unit"),
      displayRecurrence: this.getAttribute("display-recurrence"),
      displayTax: this.getAttribute("display-tax"),
      displayPlanType: this.getAttribute("display-plan-type"),
      displayAnnual: this.getAttribute("display-annual"),
      perpetual: this.getAttribute("perpetual"),
      forceTaxExclusive: this.getAttribute("force-tax-exclusive")
    };
    const options = {
      ...baseOptions,
      template: elementValues.template,
      variant: elementValues.variant,
      wcsOsi: elementValues.wcsOsi ? Re(elementValues.wcsOsi) : [],
      promotionCode: elementValues.promotionCode || "",
      ...elementValues.displayOldPrice !== null && {
        displayOldPrice: toBoolean(elementValues.displayOldPrice)
      },
      ...elementValues.displayPerUnit !== null && {
        displayPerUnit: toBoolean(elementValues.displayPerUnit)
      },
      ...elementValues.displayRecurrence !== null && {
        displayRecurrence: toBoolean(elementValues.displayRecurrence)
      },
      ...elementValues.displayTax !== null && {
        displayTax: toBoolean(elementValues.displayTax)
      },
      ...elementValues.displayPlanType !== null && {
        displayPlanType: toBoolean(elementValues.displayPlanType)
      },
      ...elementValues.displayAnnual !== null && {
        displayAnnual: toBoolean(elementValues.displayAnnual)
      },
      ...elementValues.perpetual !== null && {
        perpetual: toBoolean(elementValues.perpetual)
      },
      ...elementValues.forceTaxExclusive !== null && {
        forceTaxExclusive: toBoolean(elementValues.forceTaxExclusive)
      }
    };
    if (!options.wcsOsi || !options.wcsOsi.length) {
      return false;
    }
    try {
      this.innerHTML = "";
      const [offerSelectors] = await service.resolveOfferSelectors(options);
      let offers = Ft(await offerSelectors, options);
      if (options.displayTax === void 0 || options.forceTaxExclusive === void 0) {
        const [offer] = offers;
        if (offer) {
          const { country, language } = options;
          const [marketSegment = ""] = offer.marketSegments || [];
          const flags = await resolvePriceTaxFlags(
            country,
            language,
            offer.customerSegment,
            marketSegment
          );
          if (options.displayTax === void 0) {
            options.displayTax = flags?.displayTax;
          }
          if (options.forceTaxExclusive === void 0) {
            options.forceTaxExclusive = flags?.forceTaxExclusive;
          }
          if (options.forceTaxExclusive) {
            offers = Ft(await offerSelectors, options);
          }
        }
      }
      this.#value = offers[0];
      this.#options = Object.freeze({ ...service.settings, ...options });
      const rendered = this.renderOffers(offers, options);
      if (rendered && this.#value) {
        this.dispatchEvent(
          new CustomEvent("mas:resolved", {
            bubbles: true,
            composed: true,
            detail: { value: this.#value }
          })
        );
      }
      return rendered;
    } catch (error) {
      this.innerHTML = "";
      throw error;
    }
  }
  renderOffers(offers) {
    if (!this.isConnected) return false;
    const service = j2();
    if (!service) return false;
    if (!Array.isArray(offers) || !offers.length) {
      this.innerHTML = "";
      return false;
    }
    const html = service.buildPriceHTML(offers, this.#options);
    this.innerHTML = html || "";
    return true;
  }
};
customElements.define("inline-price", InlinePrice);

// src/custom-elements/commerce/inline-price.author.js
var OVERRIDE_FLAG_ATTRS = [
  "display-old-price",
  "display-per-unit",
  "display-recurrence",
  "display-tax",
  "display-plan-type",
  "display-annual",
  "perpetual",
  "force-tax-exclusive"
];
var overrideCheckboxState = /* @__PURE__ */ new WeakMap();
var DEFAULT_WCS_OSI = "r_JXAnlFI7xD6FxWKl2ODvZriLYBoSL701Kd1hRyhe8";
var hasOverrideFlagAttr = (element) => !!element && OVERRIDE_FLAG_ATTRS.some((attrName) => element.hasAttribute?.(attrName));
var isOverrideEnabled = (element) => {
  if (!element) return true;
  return overrideCheckboxState.get(element) === true || hasOverrideFlagAttr(element);
};
var masCommerceService = document.querySelector("mas-commerce-service");
if (!masCommerceService) {
  const masCommerceService2 = document.createElement("mas-commerce-service");
  masCommerceService2.setAttribute("data-mas-ff-defaults", "on");
  document.body.appendChild(masCommerceService2);
}
InlinePrice.ee = {
  getElementIcon(html) {
    return html`$`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Inline Price",
        description: "Displays pricing information with currency, value, and optional period"
      },
      attributes: {
        template: {
          type: "enum",
          options: ["price", "optical", "annual", "strikethrough", "legal"],
          default: "price",
          label: "Template",
          description: "Price display template"
        },
        variant: {
          type: "enum",
          options: ["regular", "acom", "upw", "fifefly", "express"],
          default: "regular",
          label: "Variant",
          description: "Preset styles for price rendering"
        },
        "promotion-code": {
          type: "text",
          default: "",
          label: "Promotion Code",
          description: "Promotion code to apply"
        },
        "wcs-osi": {
          type: "text",
          default: DEFAULT_WCS_OSI,
          label: "WCS OSI",
          description: "Offer Selector ID for fetching price data"
        },
        "override": {
          type: "transient",
          summaryLabel: "Override options",
          showFieldLabel: false,
          description: "Enable to control optional display flags. Disabling removes any overrides and reverts to the element defaults.",
          render: ({ html, element, updateAttribute }) => {
            const checked = isOverrideEnabled(element);
            const schema2 = InlinePrice.ee.getSchema();
            const attributesSchema = schema2?.attributes || {};
            return html`
              <sp-checkbox
                id="inline-price-override-options"
                aria-label="Override options"
                ?checked=${checked}
                @change=${(event) => {
              if (event.target?.checked === true) {
                overrideCheckboxState.set(element, true);
                OVERRIDE_FLAG_ATTRS.forEach((attrName) => {
                  const attrDef = attributesSchema[attrName];
                  const defaultValue = attrDef?.default ?? false;
                  updateAttribute(attrName, defaultValue);
                });
              } else {
                overrideCheckboxState.delete(element);
                OVERRIDE_FLAG_ATTRS.forEach(
                  (attrName) => updateAttribute(attrName, null)
                );
              }
            }}
              >
                Override options
              </sp-checkbox>
            `;
          }
        },
        "display-old-price": {
          type: "boolean",
          default: "false",
          label: "Display Old Price",
          description: "Show the original price with strikethrough",
          evaluate: ({ element }) => ({ render: isOverrideEnabled(element) })
        },
        "display-per-unit": {
          type: "boolean",
          default: "false",
          label: "Display Per Unit",
          description: "Show price per unit",
          evaluate: ({ element }) => ({ render: isOverrideEnabled(element) })
        },
        "display-recurrence": {
          type: "boolean",
          default: "true",
          label: "Display Recurrence",
          description: "Show billing recurrence information",
          evaluate: ({ element }) => ({ render: isOverrideEnabled(element) })
        },
        "display-tax": {
          type: "boolean",
          default: "false",
          label: "Display Tax",
          description: "Show tax information",
          evaluate: ({ element }) => ({ render: isOverrideEnabled(element) })
        },
        "display-plan-type": {
          type: "boolean",
          default: "false",
          label: "Display Plan Type",
          description: "Show plan type information",
          evaluate: ({ element }) => ({ render: isOverrideEnabled(element) })
        },
        "display-annual": {
          type: "boolean",
          default: "false",
          label: "Display Annual",
          description: "Show annual price information",
          evaluate: ({ element }) => ({ render: isOverrideEnabled(element) })
        },
        perpetual: {
          type: "boolean",
          default: "false",
          label: "Perpetual",
          description: "Indicates if this is a perpetual license",
          evaluate: ({ element }) => ({ render: isOverrideEnabled(element) })
        },
        "force-tax-exclusive": {
          type: "boolean",
          default: "false",
          label: "Force Tax Exclusive",
          description: "Force price to be displayed without tax",
          evaluate: ({ element }) => ({ render: isOverrideEnabled(element) })
        }
      },
      slots: { order: [], configs: {} },
      tools: [
        {
          id: "offer-selector-tool",
          tag: "offer-selector-tool",
          label: "Offer Selector",
          description: "Select and configure offers for pricing",
          icon: "sp-icon-shopping-cart"
        }
      ]
    };
  },
  // Sanitize before saving - remove authoring attributes and normalize values
  sanitize(el) {
    if (!el) return;
    el.innerHTML = "";
    if (!el.hasAttribute("wcs-osi") || !el.getAttribute("wcs-osi")) {
      el.setAttribute("wcs-osi", DEFAULT_WCS_OSI);
    }
    const attrsToRemove = [];
    for (const { name } of Array.from(el.attributes || [])) {
      if (typeof name === "string" && name.toLowerCase().startsWith("data-ee-")) {
        const lower = name.toLowerCase();
        if (lower === "data-ee-comment-id") continue;
        if (lower === "data-ee-locked") continue;
        attrsToRemove.push(name);
      }
    }
    attrsToRemove.forEach((name) => el.removeAttribute(name));
    const textAttrs = ["promotion-code", "wcs-osi"];
    textAttrs.forEach((attr) => {
      const value = el.getAttribute(attr);
      if (value != null && !String(value).trim()) {
        el.removeAttribute(attr);
      }
    });
  }
};

// src/custom-elements/commerce/commerce.library.js
var LIBRARY_ID = "commerce";
function register({
  registerLibrary: registerLibrary2,
  registerElement: registerElement2,
  LibraryLevel: LibraryLevel2
}) {
  registerLibrary2({
    id: LIBRARY_ID,
    level: LibraryLevel2.ORG,
    name: "Commerce",
    description: "Pricing and checkout elements for purchase experiences."
  });
  registerElement2(LIBRARY_ID, "inline-price");
  registerElement2(LIBRARY_ID, "checkout-button");
}

// src/custom-elements/core/sp-theme.author.js
var spThemeSchemaApi = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Page",
        description: "Page container with theme support.",
        category: "structure",
        allowDuplicate: false,
        allowDelete: false
      },
      attributes: {
        color: {
          type: "enum",
          options: ["light", "dark"],
          default: "light",
          label: "Theme",
          description: "Color theme for the page."
        },
        scale: {
          type: "enum",
          options: ["medium", "large"],
          default: "medium",
          label: "Scale",
          description: "Size scale for Spectrum components."
        },
        system: {
          type: "enum",
          options: ["spectrum-two"],
          default: "spectrum-two",
          label: "System",
          description: "Spectrum design system version."
        }
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Page Content",
            description: "Page structure: header, main, footer",
            allowedTags: ["header", "main", "footer"],
            minLength: 0,
            maxLength: 3
          }
        }
      }
    };
  },
  create() {
    const theme = document.createElement("sp-theme");
    theme.setAttribute("color", "light");
    theme.setAttribute("scale", "medium");
    theme.setAttribute("system", "spectrum-two");
    const header = document.createElement("header");
    const main = document.createElement("main");
    const footer = document.createElement("footer");
    const section = document.createElement("section");
    main.appendChild(section);
    theme.appendChild(header);
    theme.appendChild(main);
    theme.appendChild(footer);
    return theme;
  },
  sanitize(element, helpers) {
    if (!element) return;
    const tagName = element.tagName?.toLowerCase?.();
    if (tagName !== "sp-theme") return;
    const children = Array.from(element.children);
    let header = null;
    let main = null;
    let footer = null;
    for (const child of children) {
      const childTag = child.tagName?.toLowerCase?.();
      if (childTag === "header" && !header) {
        header = child;
      } else if (childTag === "main" && !main) {
        main = child;
      } else if (childTag === "footer" && !footer) {
        footer = child;
      }
    }
    if (!header) {
      header = document.createElement("header");
    }
    if (!main) {
      main = document.createElement("main");
    }
    if (!footer) {
      footer = document.createElement("footer");
    }
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    const mainChildren = Array.from(main.children);
    while (main.firstChild) {
      main.removeChild(main.firstChild);
    }
    for (const child of mainChildren) {
      const childTag = child.tagName?.toLowerCase?.();
      if (childTag === "section") {
        main.appendChild(child);
      }
    }
    if (main.children.length === 0) {
      const section = document.createElement("section");
      main.appendChild(section);
    }
    element.appendChild(header);
    element.appendChild(main);
    element.appendChild(footer);
    if (!element.hasAttribute("color")) {
      element.setAttribute("color", "light");
    }
    if (!element.hasAttribute("scale")) {
      element.setAttribute("scale", "medium");
    }
    if (!element.hasAttribute("system")) {
      element.setAttribute("system", "spectrum-two");
    }
  }
};
var getSpThemeConstructor = () => {
  return customElements.get("sp-theme");
};
var SpTheme = getSpThemeConstructor();
if (SpTheme) {
  SpTheme.ee = spThemeSchemaApi;
}

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconMovieCamera.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/MovieCamera.js
var MovieCameraIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Movie Camera" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m11.75,16H3.25c-1.24072,0-2.25-1.00928-2.25-2.25v-7.5c0-1.24072,1.00928-2.25,2.25-2.25h8.5c1.24072,0,2.25,1.00928,2.25,2.25v1.04639l2.36816-1.68408c.03125-.02246.06445-.04199.09912-.05957.54639-.27344,1.18311-.24463,1.70264.07666.52002.32129.83008.87793.83008,1.48877v5.76367c0,.61084-.31006,1.16748-.83008,1.48877-.51953.3208-1.15625.3501-1.70264.07666-.03467-.01758-.06787-.03711-.09912-.05957l-2.36816-1.68408v1.04639c0,1.24072-1.00928,2.25-2.25,2.25ZM3.25,5.5c-.41357,0-.75.33643-.75.75v7.5c0,.41357.33643.75.75.75h8.5c.41357,0,.75-.33643.75-.75v-2.5c0-.28076.15674-.5376.40625-.6665.24951-.12793.5498-.10742.77832.05518l3.49072,2.48242c.0918.03125.16699-.00146.20605-.02637.04443-.02734.11865-.09131.11865-.21289v-5.76367c0-.12158-.07422-.18555-.11865-.21289-.03955-.02441-.11621-.05713-.20605-.02637l-3.49072,2.48242c-.22852.1626-.52881.18311-.77832.05518-.24951-.12891-.40625-.38574-.40625-.6665v-2.5c0-.41357-.33643-.75-.75-.75H3.25Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/MovieCamera.js
var MovieCameraIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: a23 = false, title: r25 = "Movie Camera" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M32.4 10.2 24 16.5V9.818A1.818 1.818 0 0 0 22.182 8H5.818A1.818 1.818 0 0 0 4 9.818v16.364A1.818 1.818 0 0 0 5.818 28h16.364A1.818 1.818 0 0 0 24 26.182V19.5l8.4 6.3A1 1 0 0 0 34 25V11a1 1 0 0 0-1.6-.8Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconMovieCamera.js
var IconMovieCamera = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? MovieCameraIcon({ hidden: !this.label, title: this.label }) : MovieCameraIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-movie-camera.js
init_define_element();
defineElement("sp-icon-movie-camera", IconMovieCamera);

// src/custom-elements/ee-media/ee-media.js
init_lit();
init_class_map2();

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPlay.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Play.js
var PlayIcon = ({ width: t34 = 24, height: e36 = 24, hidden: l16 = false, title: a23 = "Play" } = {}) => tag`<svg
    data-name="ICONS"
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M4.74902,18.00391c-.39795,0-.79541-.10742-1.15332-.32129-.68604-.41016-1.0957-1.13281-1.0957-1.93164V4.24902c0-.79883.40967-1.52148,1.0957-1.93164.68555-.40918,1.51514-.42969,2.21924-.0498l10.70117,5.75098c.73047.39258,1.18408,1.15234,1.18408,1.98145s-.45361,1.58887-1.18408,1.98145l-10.70117,5.75098c-.33643.18164-.70166.27148-1.06592.27148ZM4.75244,3.49609c-.17822,0-.31836.06836-.38721.10938-.10986.06543-.36523.25977-.36523.64355v11.50195c0,.38379.25537.57812.36523.64355s.40137.19824.73975.01758l10.70068-5.75098c.35596-.19238.39453-.52637.39453-.66113s-.03857-.46875-.39453-.66113L5.10498,3.58789c-.12646-.06738-.24609-.0918-.35254-.0918Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Play.js
var PlayIcon2 = ({ width: t34 = 24, height: e36 = 24, hidden: a23 = false, title: l16 = "Play" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${a23 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M9.46 4H7a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h2.46a2 2 0 0 0 1.007-.272l22.064-12.866a1 1 0 0 0 0-1.724L10.467 4.272A2 2 0 0 0 9.46 4Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPlay.js
var IconPlay = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? PlayIcon({ hidden: !this.label, title: this.label }) : PlayIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-play.js
init_define_element();
defineElement("sp-icon-play", IconPlay);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPause.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Pause.js
var PauseIcon = ({ width: c33 = 24, height: t34 = 24, hidden: r25 = false, title: e36 = "Pause" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${c33}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${e36}"
  >
    <path
      d="m6.75,18h-2.5c-1.24072,0-2.25-1.00977-2.25-2.25V4.25c0-1.24023,1.00928-2.25,2.25-2.25h2.5c1.24072,0,2.25,1.00977,2.25,2.25v11.5c0,1.24023-1.00928,2.25-2.25,2.25ZM4.25,3.5c-.41357,0-.75.33691-.75.75v11.5c0,.41309.33643.75.75.75h2.5c.41357,0,.75-.33691.75-.75V4.25c0-.41309-.33643-.75-.75-.75h-2.5Z"
      fill="currentColor"
    />
    <path
      d="m15.75,18h-2.5c-1.24072,0-2.25-1.00977-2.25-2.25V4.25c0-1.24023,1.00928-2.25,2.25-2.25h2.5c1.24072,0,2.25,1.00977,2.25,2.25v11.5c0,1.24023-1.00928,2.25-2.25,2.25Zm-2.5-14.5c-.41357,0-.75.33691-.75.75v11.5c0,.41309.33643.75.75.75h2.5c.41357,0,.75-.33691.75-.75V4.25c0-.41309-.33643-.75-.75-.75h-2.5Z"
      fill="currentColor"
    />
    <path
      d="m6.75,18h-2.5c-1.24072,0-2.25-1.00977-2.25-2.25V4.25c0-1.24023,1.00928-2.25,2.25-2.25h2.5c1.24072,0,2.25,1.00977,2.25,2.25v11.5c0,1.24023-1.00928,2.25-2.25,2.25ZM4.25,3.5c-.41357,0-.75.33691-.75.75v11.5c0,.41309.33643.75.75.75h2.5c.41357,0,.75-.33691.75-.75V4.25c0-.41309-.33643-.75-.75-.75h-2.5Z"
      fill="currentColor"
    />
    <path
      d="m15.75,18h-2.5c-1.24072,0-2.25-1.00977-2.25-2.25V4.25c0-1.24023,1.00928-2.25,2.25-2.25h2.5c1.24072,0,2.25,1.00977,2.25,2.25v11.5c0,1.24023-1.00928,2.25-2.25,2.25Zm-2.5-14.5c-.41357,0-.75.33691-.75.75v11.5c0,.41309.33643.75.75.75h2.5c.41357,0,.75-.33691.75-.75V4.25c0-.41309-.33643-.75-.75-.75h-2.5Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Pause.js
var PauseIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: r25 = false, title: a23 = "Pause" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <g>
      <rect height="28" rx="1" width="8" x="6" y="4" />
      <rect height="28" rx="1" width="8" x="20" y="4" />
    </g>
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPause.js
var IconPause = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? PauseIcon({ hidden: !this.label, title: this.label }) : PauseIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-pause.js
init_define_element();
defineElement("sp-icon-pause", IconPause);

// src/custom-elements/ee-media/ee-media.css.js
init_lit();
var eeMediaStyles = i`
  :host {
    display: block;
    box-sizing: border-box;
  }

  :host([hidden]) {
    display: none;
  }

  .media-frame {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
    gap: var(--ee-media-content-gap, var(--spectrum-global-dimension-size-200));
  }

  .media-frame ::slotted(*) {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: var(--ee-media-radius, var(--spectrum-global-dimension-size-100));
  }

  .media-toggle {
    position: absolute;
    z-index: 1;
    pointer-events: auto;
  }

  :host([toggle-placement="top-left"]) .media-toggle {
    top: var(--ee-media-toggle-offset, var(--spectrum-global-dimension-size-200));
    left: var(--ee-media-toggle-offset, var(--spectrum-global-dimension-size-200));
  }

  :host([toggle-placement="top-right"]) .media-toggle {
    top: var(--ee-media-toggle-offset, var(--spectrum-global-dimension-size-200));
    right: var(--ee-media-toggle-offset, var(--spectrum-global-dimension-size-200));
  }

  :host([toggle-placement="bottom-left"]) .media-toggle {
    bottom: var(--ee-media-toggle-offset, var(--spectrum-global-dimension-size-200));
    left: var(--ee-media-toggle-offset, var(--spectrum-global-dimension-size-200));
  }

  :host([toggle-placement="bottom-right"]) .media-toggle {
    bottom: var(--ee-media-toggle-offset, var(--spectrum-global-dimension-size-200));
    right: var(--ee-media-toggle-offset, var(--spectrum-global-dimension-size-200));
  }

  :host([toggle-placement="center"]) .media-toggle {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  :host([toggle-placement="center"]) .media-toggle:focus-visible {
    outline-offset: var(--spectrum-global-dimension-size-75);
  }

  .media-toggle sp-icon-play,
  .media-toggle sp-icon-pause {
    pointer-events: none;
  }
`;

// src/custom-elements/ee-media/ee-media.js
var TOGGLE_POSITIONS = /* @__PURE__ */ new Set([
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right",
  "center"
]);
var EeMedia = class extends i4 {
  static styles = [eeMediaStyles];
  static properties = {
    autoplay: { type: Boolean, reflect: true, converter: booleanConverter },
    muted: { type: Boolean, reflect: true, converter: booleanConverter },
    loop: { type: Boolean, reflect: true, converter: booleanConverter },
    playsInline: { type: Boolean, attribute: "playsinline", reflect: true, converter: booleanConverter },
    showToggle: { type: Boolean, attribute: "show-toggle", reflect: true, converter: booleanConverter },
    labelPlay: { type: String, attribute: "label-play" },
    labelPause: { type: String, attribute: "label-pause" },
    togglePlacement: { type: String, attribute: "toggle-placement", reflect: true },
    src: { type: String, reflect: true },
    poster: { type: String, reflect: true },
    playing: { type: Boolean, state: true },
    hasVideo: { type: Boolean, state: true }
  };
  #slotEl = null;
  #mediaEl = null;
  #eventCleanups = [];
  #onSlotChange = () => {
    this.#attachMedia();
  };
  #onVideoPlay = () => {
    this.playing = true;
  };
  #onVideoPause = () => {
    this.playing = false;
  };
  #onVideoEnded = () => {
    this.playing = false;
  };
  constructor() {
    super();
    this.autoplay = false;
    this.loop = false;
    this.muted = false;
    this.playsInline = false;
    this.showToggle = false;
    this.labelPlay = "Play motion";
    this.labelPause = "Pause motion";
    this.togglePlacement = "bottom-right";
    this.playing = false;
    this.hasVideo = false;
    ensureId(this, "ee-media");
  }
  firstUpdated() {
    this.#slotEl = this.shadowRoot?.querySelector('slot[name="media"]') ?? null;
    this.#slotEl?.addEventListener("slotchange", this.#onSlotChange);
    this.#attachMedia();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.#slotEl?.removeEventListener("slotchange", this.#onSlotChange);
    this.#detachMedia();
  }
  willUpdate(changed) {
    if (changed.has("src")) {
      if (this.src) {
        this.#prepareForManagedVideo();
      } else {
        this.#prepareForSlottedMedia();
      }
    }
  }
  updated(changed) {
    if (changed.has("togglePlacement")) {
      this.#normalizeTogglePlacement();
    }
    if (changed.has("autoplay") || changed.has("muted") || changed.has("loop") || changed.has("playsInline") || changed.has("showToggle") || changed.has("src") || changed.has("poster")) {
      this.#syncMediaAttributes();
    }
    if (changed.has("src") && this.src) {
      this.#ensureVideoElement();
    }
    if (changed.has("autoplay") && this.#mediaEl instanceof HTMLVideoElement) {
      if (this.autoplay && this.#mediaEl.paused) {
        this.#mediaEl.play().catch(() => {
        });
      } else if (!this.autoplay && !this.#mediaEl.paused) {
        this.#mediaEl.pause();
      }
    }
  }
  render() {
    const frameClasses = {
      "media-frame": true,
      "media-frame--video": this.hasVideo
    };
    const toggleClasses = {
      "media-toggle": true,
      [`media-toggle--${this.togglePlacement}`]: true
    };
    const showToggle = this.showToggle && this.hasVideo;
    return x`
      <div class=${e10(frameClasses)}>
        <slot name="media"></slot>
        ${showToggle ? this.#renderToggle(toggleClasses) : E}
      </div>
    `;
  }
  #renderToggle(toggleClasses) {
    const label = this.playing ? this.labelPause : this.labelPlay;
    return x`
      <sp-action-button
        class=${e10(toggleClasses)}
        aria-label=${label}
        aria-pressed=${this.playing ? "true" : "false"}
        size="m"
        quiet
        ?selected=${this.playing}
        @click=${this.#togglePlayback}
      >
        ${this.playing ? x`<sp-icon-pause slot="icon"></sp-icon-pause>` : x`<sp-icon-play slot="icon"></sp-icon-play>`}
      </sp-action-button>
    `;
  }
  #togglePlayback = (e36) => {
    if (e36) {
      e36.stopPropagation();
    }
    if (!(this.#mediaEl instanceof HTMLVideoElement)) {
      return;
    }
    if (this.#mediaEl.paused || this.#mediaEl.ended) {
      const result = this.#mediaEl.play();
      if (result && typeof result.then === "function") {
        result.catch(() => {
        });
      }
      return;
    }
    this.#mediaEl.pause();
  };
  #attachMedia() {
    if (this.src) {
      this.#ensureVideoElement();
      return;
    }
    const assigned = this.#slotEl?.assignedNodes({ flatten: true }) ?? [];
    const element = assigned.find((node) => node.nodeType === Node.ELEMENT_NODE);
    if (element === this.#mediaEl) {
      this.#syncMediaAttributes();
      return;
    }
    this.#detachMedia();
    if (!(element instanceof HTMLElement)) {
      this.hasVideo = false;
      this.playing = false;
      this.#mediaEl = null;
      return;
    }
    this.#mediaEl = element;
    this.hasVideo = element instanceof HTMLVideoElement;
    this.playing = element instanceof HTMLVideoElement ? !element.paused && !element.ended : false;
    if (element instanceof HTMLVideoElement) {
      const bindings = [
        ["play", this.#onVideoPlay],
        ["pause", this.#onVideoPause],
        ["ended", this.#onVideoEnded]
      ];
      bindings.forEach(([type, handler]) => {
        element.addEventListener(type, handler);
        this.#eventCleanups.push(() => element.removeEventListener(type, handler));
      });
    }
    this.#syncMediaAttributes();
  }
  #ensureVideoElement() {
    let video = this.querySelector('video[slot="media"]');
    if (!video) {
      video = document.createElement("video");
      video.setAttribute("slot", "media");
      this.appendChild(video);
    }
    if (this.#mediaEl !== video) {
      this.#detachMedia();
      this.#mediaEl = video;
      const bindings = [
        ["play", this.#onVideoPlay],
        ["pause", this.#onVideoPause],
        ["ended", this.#onVideoEnded]
      ];
      bindings.forEach(([type, handler]) => {
        video.addEventListener(type, handler);
        this.#eventCleanups.push(() => video.removeEventListener(type, handler));
      });
    }
    this.#syncMediaAttributes();
  }
  #detachMedia() {
    this.#eventCleanups.forEach((cleanup) => cleanup());
    this.#eventCleanups = [];
    this.#mediaEl = null;
  }
  #prepareForManagedVideo() {
    this.#eventCleanups.forEach((cleanup) => cleanup());
    this.#eventCleanups = [];
    this.#mediaEl = null;
    this.hasVideo = true;
    this.playing = false;
  }
  #prepareForSlottedMedia() {
    this.#eventCleanups.forEach((cleanup) => cleanup());
    this.#eventCleanups = [];
    this.#mediaEl = null;
    this.hasVideo = false;
    this.playing = false;
  }
  #syncMediaAttributes() {
    if (!(this.#mediaEl instanceof HTMLVideoElement)) {
      return;
    }
    const video = this.#mediaEl;
    if (this.src && video.getAttribute("src") !== this.src) {
      while (video.firstChild) {
        video.removeChild(video.firstChild);
      }
      video.src = this.src;
    }
    if (this.poster && video.getAttribute("poster") !== this.poster) {
      video.poster = this.poster;
    }
    video.loop = this.loop;
    video.autoplay = this.autoplay;
    video.muted = this.muted;
    video.playsInline = this.playsInline;
    if (this.muted) {
      video.setAttribute("muted", "");
    } else {
      video.removeAttribute("muted");
    }
    if (this.playsInline) {
      video.setAttribute("playsinline", "");
    } else {
      video.removeAttribute("playsinline");
    }
    if (this.autoplay) {
      video.setAttribute("autoplay", "");
    } else {
      video.removeAttribute("autoplay");
    }
    if (this.loop) {
      video.setAttribute("loop", "");
    } else {
      video.removeAttribute("loop");
    }
    const shouldShowControls = !this.showToggle;
    video.controls = shouldShowControls;
    if (shouldShowControls) {
      video.setAttribute("controls", "");
    } else {
      video.removeAttribute("controls");
    }
    if (this.autoplay && video.paused) {
      video.play().catch(() => {
      });
    }
  }
  #normalizeTogglePlacement() {
    if (!TOGGLE_POSITIONS.has(this.togglePlacement)) {
      this.togglePlacement = "bottom-right";
    }
  }
};
customElements.define("ee-media", EeMedia);

// src/custom-elements/ee-media/ee-media.author.js
var TOGGLE_OPTIONS = ["top-left", "top-right", "bottom-left", "bottom-right", "center"];
EeMedia.ee = {
  getElementIcon(html) {
    return html`<sp-icon-movie-camera slot="icon"></sp-icon-movie-camera>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Media",
        description: "Encapsulates video or imagery with Spectrum controls and responsive behavior.",
        category: "media"
      },
      attributes: {
        autoplay: {
          type: "boolean",
          default: false,
          label: "Autoplay",
          description: "Enable autoplay when the media is a video."
        },
        muted: {
          type: "boolean",
          default: false,
          label: "Muted",
          description: "Mute the video to allow autoplay in most browsers."
        },
        loop: {
          type: "boolean",
          default: false,
          label: "Loop",
          description: "Restart playback automatically when the video ends."
        },
        playsinline: {
          type: "boolean",
          default: false,
          label: "Plays Inline",
          description: "Prevent mobile browsers from forcing full-screen playback."
        },
        "show-toggle": {
          type: "boolean",
          default: false,
          label: "Show Play/Pause Toggle",
          description: "Display an overlay toggle instead of native controls."
        },
        src: {
          type: "text",
          label: "Video Source",
          description: "URL of the video file."
        },
        poster: {
          type: "text",
          label: "Poster Image",
          description: "URL of the poster image shown before playback."
        },
        "label-play": {
          type: "text",
          default: "Play motion",
          label: "Play Label",
          description: "Accessible label used when the toggle resumes playback.",
          maxLength: 40
        },
        "label-pause": {
          type: "text",
          default: "Pause motion",
          label: "Pause Label",
          description: "Accessible label used when the toggle pauses playback.",
          maxLength: 40
        },
        "toggle-placement": {
          type: "enum",
          options: [...TOGGLE_OPTIONS],
          default: "bottom-right",
          label: "Toggle Placement",
          description: "Choose where the overlay button is positioned."
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <ee-media
        label-play="Play motion"
        label-pause="Pause motion"
      ></ee-media>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    if (!TOGGLE_OPTIONS.includes(element.getAttribute("toggle-placement") || "")) {
      element.setAttribute("toggle-placement", "bottom-right");
    }
    Array.from(element.children).forEach((child) => {
      if (child.tagName === "VIDEO" && child.getAttribute("slot") === "media") {
        return;
      }
      child.remove();
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// src/custom-elements/core/ee-reference.author.js
init_lit();

// src/custom-elements/core/ee-reference.js
init_lit();
init_sp_overlay();
init_sp_underlay();
var EeReference = class extends i4 {
  static styles = [i`
  :host {
    display: block;
  }

  :host([display="inline"]) {
    display: inline;
  }

  :host([display="inline-block"]) {
    display: inline-block;
  }

  :host([display="inline-flex"]) {
    display: inline-flex;
  }

  :host([full-width]) {
    width: 100%;
  }

  :host([full-width]) ::slotted(:not([slot])) {
    margin: auto;
  }

  :host([stretch]) slot[name="trigger"] {
    display: block;
    width: 100%;
  }

  :host([stretch]) ::slotted([slot="trigger"]) {
    width: 100%;
  }

  #container {
    display: contents;
  }


  #reference-underlay {
    z-index: 1;
  }

  sp-overlay::part(dialog) {
    z-index: 2;
  }

  #reference-modal-shell {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }

  #reference-modal-content {
    pointer-events: auto;
  }

  

`];
  static properties = {
    urn: { type: String, reflect: true },
    inline: { type: Boolean, reflect: true, converter: booleanConverter },
    modal: { type: Boolean, reflect: true, converter: booleanConverter },
    modalOpen: { type: Boolean, attribute: false },
    display: { type: String, reflect: true },
    fullWidth: { type: Boolean, attribute: "full-width", reflect: true, converter: booleanConverter },
    stretch: { type: Boolean, reflect: true, converter: booleanConverter }
  };
  #currentRefToken = 0;
  #documentStore = null;
  #lastLoadedUrn = null;
  #loadingUrn = null;
  #loadPromise = null;
  #log(method, message, data = {}) {
    console.log(`[ee-reference] ${method}:`, message, { urn: this.urn, inline: this.inline, ...data });
  }
  constructor() {
    super();
    this.#documentStore = null;
    this.urn = "";
    this.inline = false;
    this.modal = false;
    this.modalOpen = false;
    this.display = "block";
    this.fullWidth = false;
    this.stretch = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.#documentStore = this.#resolveDocumentStore();
    this.#log("connectedCallback", "Element connected", {
      hasDocumentStore: !!this.#documentStore,
      isPreviewMode: this.#isPreviewMode()
    });
  }
  firstUpdated() {
    this.#log("firstUpdated", "First render complete, scheduling auto-load check");
    requestAnimationFrame(() => this.#maybeAutoLoad());
  }
  updated(changed) {
    this.#log("updated", "Properties changed", { changedKeys: [...changed.keys()] });
    if (changed.has("urn")) {
      const hasTrigger = this.#hasTriggerAssigned();
      this.#log("updated", "URN changed", { oldUrn: changed.get("urn"), newUrn: this.urn, hasTrigger });
      if (!hasTrigger) {
        const urn = this.urn;
        if (this.#isSelfReference(urn)) {
          this.#log("updated", "Self-reference detected, emitting event");
          this.#emitSelfReference(urn);
        } else {
          this.#log("updated", "Calling updateFromUrn due to URN change");
          this.#updateFromUrn();
        }
      }
    }
    if (changed.has("inline")) {
      this.#log("updated", "Inline flag changed", { oldInline: changed.get("inline"), newInline: this.inline });
      if (!this.inline) {
        this.#log("updated", "Inline disabled, calling updateFromUrn");
        this.#updateFromUrn();
      } else {
        this.#log("updated", "Inline enabled, calling maybeAutoLoad");
        this.#maybeAutoLoad();
      }
    }
    if (changed.has("modal") && !this.modal) {
      this.modalOpen = false;
    }
  }
  // Template renders trigger slot only when not inline; default slot always present
  render() {
    const showTrigger = !this.inline || this.modal;
    const containerStyle = this.fullWidth ? "display: block; width: 100%;" : "display: contents";
    return x`
      <div
        id="container"
        style=${containerStyle}
        @click=${this.#onContainerClick}
        @fire=${this.#onContainerFire}
      >
        ${this.modal ? x`<slot
                name="trigger"
                part="editor"
                @slotchange=${this.#onTriggerSlotChange}
              ></slot>
              <sp-underlay
                id="reference-underlay"
                ?open=${this.modalOpen}
                @close=${this.#onDialogClose}
              ></sp-underlay>
              <sp-overlay
                id="reference-overlay"
                type="modal"
                receives-focus="auto"
                ?open=${this.modalOpen}
                @sp-closed=${this.#onDialogClose}
              >
                <div id="reference-modal-shell">
                  <div id="reference-modal-content">
                    <slot part="editor"></slot>
                  </div>
                </div>
              </sp-overlay>` : x`${showTrigger ? x`<slot
                      name="trigger"
                      part="editor"
                      @slotchange=${this.#onTriggerSlotChange}
                    ></slot>` : E}
              <slot part="editor"></slot>`}
      </div>
    `;
  }
  async #getDocument(id) {
    this.#log("getDocument", "Fetching document", { id, hasDocumentStore: !!this.#documentStore, isPreviewMode: this.#isPreviewMode() });
    if (this.#isPreviewMode()) {
      this.#log("getDocument", "Preview mode, fetching from URL");
      return this.#fetchFromUrl(id);
    }
    if (!this.#documentStore.configLoaded) {
      this.#log("getDocument", "Config not loaded, initializing store");
      await this.#documentStore.init();
    }
    const doc3 = await this.#documentStore.getDocument(id);
    this.#log("getDocument", "Document fetched", { found: !!doc3 });
    return doc3;
  }
  #deserializeElement(htmlString) {
    if (typeof htmlString !== "string") return null;
    const parser = new DOMParser();
    const doc3 = parser.parseFromString(htmlString, "text/html");
    const frag = document.createDocumentFragment();
    const children = Array.from(doc3.body.children || []);
    if (!children.length) return null;
    for (const child of children) {
      const clone = document.importNode?.(child, true) ?? child.cloneNode(true);
      frag.appendChild(clone);
    }
    return frag;
  }
  async #updateFromUrn(force = false) {
    const urn = this.urn;
    this.#log("updateFromUrn", "Starting", { force, lastLoadedUrn: this.#lastLoadedUrn, loadingUrn: this.#loadingUrn });
    if (!force && !this.inline) {
      this.#log("updateFromUrn", "Not inline and not forced, clearing content and returning");
      this.#clearDefaultSlotContent();
      this.#lastLoadedUrn = null;
      return;
    }
    if (!force && urn && this.#lastLoadedUrn && this.#lastLoadedUrn === urn) {
      this.#log("updateFromUrn", "URN unchanged, skipping fetch");
      return;
    }
    if (!force && this.#loadPromise && this.#loadingUrn === urn) {
      this.#log("updateFromUrn", "Already loading same URN, returning existing promise");
      return this.#loadPromise;
    }
    this.#log("updateFromUrn", "Clearing default slot content");
    this.#clearDefaultSlotContent();
    if (!urn) {
      this.#log("updateFromUrn", "No URN provided, returning");
      return;
    }
    if (this.#hasAncestorWithUrn(urn)) {
      this.#log("updateFromUrn", "Ancestor has same URN, preventing infinite loop");
      return;
    }
    if (this.#isSelfReference(urn)) {
      this.#log("updateFromUrn", "Self-reference detected, emitting event");
      this.#emitSelfReference(urn);
      return;
    }
    if (this.modal) {
      this.#log("updateFromUrn", "Modal mode, opening modal");
      this.modalOpen = true;
    }
    const token = ++this.#currentRefToken;
    this.#loadingUrn = urn;
    this.#log("updateFromUrn", "Starting fetch", { token });
    const load = (async () => {
      this.#log("updateFromUrn", "Fetching document from store");
      const doc3 = await this.#getDocument(urn);
      if (token !== this.#currentRefToken) {
        this.#log("updateFromUrn", "Token stale, aborting", { token, currentToken: this.#currentRefToken });
        return;
      }
      if (!doc3) {
        this.#log("updateFromUrn", "No document found for URN");
        return;
      }
      this.#log("updateFromUrn", "Document fetched", { hasHtml: !!doc3.html, docKeys: Object.keys(doc3) });
      const htmlString = doc3.html;
      if (!htmlString || typeof htmlString !== "string") {
        this.#log("updateFromUrn", "Invalid HTML string in document", { htmlString });
        return;
      }
      this.#log("updateFromUrn", "Deserializing element", { htmlLength: htmlString.length });
      const el = this.#deserializeElement(htmlString);
      if (!el) {
        this.#log("updateFromUrn", "Failed to deserialize element");
        return;
      }
      this.#log("updateFromUrn", "Appending element to DOM", { tagName: el.tagName });
      el.removeAttribute && el.removeAttribute("slot");
      this.appendChild(el);
      this.#lastLoadedUrn = urn;
      this.#log("updateFromUrn", "Load complete", { lastLoadedUrn: this.#lastLoadedUrn });
    })();
    this.#loadPromise = load.finally(() => {
      if (token === this.#currentRefToken) {
        this.#loadingUrn = null;
        this.#loadPromise = null;
        this.#log("updateFromUrn", "Load promise cleared");
      }
    });
    return this.#loadPromise;
  }
  #resolveDocumentStore() {
    if (window.eeStores?.documentStore) {
      this.#log("resolveDocumentStore", "Using global eeStores.documentStore");
      return window.eeStores.documentStore;
    }
    this.#log("resolveDocumentStore", "No global store (preview/publish mode)");
    return null;
  }
  #isPreviewMode() {
    return !window.eeStores?.documentStore;
  }
  async #fetchFromUrl(path) {
    const segments = path.replace(/^\/+/, "").replace(/\.html$/, "").split("/");
    const contentPath = segments.slice(2).join("/");
    const url = `${window.location.origin}/${contentPath}.plain.html`;
    this.#log("fetchFromUrl", "Fetching from URL", { path, contentPath, url });
    const response = await fetch(url);
    if (!response.ok) {
      this.#log("fetchFromUrl", "Fetch failed", { status: response.status });
      return null;
    }
    const edsHtml = await response.text();
    this.#log("fetchFromUrl", "Fetch successful, converting from EDS format", { edsHtmlLength: edsHtml.length });
    const html = fromEds(edsHtml);
    this.#log("fetchFromUrl", "Converted to custom element HTML", { htmlLength: html.length });
    return { html };
  }
  #clearDefaultSlotContent() {
    const toRemove = [];
    for (const n25 of Array.from(this.childNodes)) {
      if (n25.nodeType === Node.TEXT_NODE) {
        toRemove.push(n25);
      } else if (n25.nodeType === Node.ELEMENT_NODE) {
        const el = n25;
        const slot = el.getAttribute && el.getAttribute("slot");
        if (!slot) toRemove.push(el);
      }
    }
    toRemove.forEach((n25) => n25.remove());
  }
  get #triggerSlot() {
    return this.renderRoot?.querySelector?.('slot[name="trigger"]') || null;
  }
  #hasTriggerAssigned() {
    const slot = this.#triggerSlot;
    if (!slot) return false;
    const assignedEls = slot.assignedElements({ flatten: true }) || [];
    return assignedEls.length > 0;
  }
  #getCurrentDocIdFromContext() {
    let p30 = this.parentElement;
    while (p30) {
      if (p30.hasAttribute && p30.hasAttribute("data-ee-current-id")) {
        const id = p30.getAttribute("data-ee-current-id");
        if (id) return id;
      }
      p30 = p30.parentElement;
    }
    return null;
  }
  #isSelfReference(urn) {
    const currentId = this.#getCurrentDocIdFromContext();
    if (!currentId || !urn) return false;
    return String(currentId) === String(urn);
  }
  #emitSelfReference(urn) {
    this.dispatchEvent(
      new CustomEvent("ee-self-reference", {
        bubbles: true,
        composed: true,
        detail: { urn }
      })
    );
  }
  #onTriggerSlotChange() {
    this.#log("onTriggerSlotChange", "Trigger slot changed");
    this.#maybeAutoLoad();
  }
  #onContainerFire(e36) {
    e36.stopPropagation();
    this.#updateFromUrn(true);
  }
  #onDialogClose() {
    this.modalOpen = false;
  }
  #onContainerClick(e36) {
    const path = e36.composedPath();
    let triggerRoot = null;
    for (const n25 of path) {
      if (!n25 || !n25.tagName) continue;
      const el = n25;
      if (el.getAttribute && el.getAttribute("slot") === "trigger" && el.parentElement === this) {
        triggerRoot = el;
        break;
      }
    }
    if (!triggerRoot) return;
    const clicked = path.find((n25) => {
      const t34 = n25 && n25.tagName ? n25.tagName.toLowerCase() : null;
      return t34 === "sp-button" || t34 === "sp-link" || t34 === "a";
    });
    if (clicked) {
      e36.preventDefault();
      triggerRoot.dispatchEvent(new Event("fire", { bubbles: true, composed: true }));
    }
  }
  #maybeAutoLoad() {
    const hasTrigger = this.#hasTriggerAssigned();
    const hasContent = this.#hasDefaultSlotContent();
    this.#log("maybeAutoLoad", "Checking auto-load conditions", { hasTrigger, hasContent });
    if (hasTrigger) {
      this.#log("maybeAutoLoad", "Trigger assigned, skipping auto-load");
      return;
    }
    if (hasContent) {
      this.#log("maybeAutoLoad", "Already has inline content, skipping auto-load");
      return;
    }
    this.#log("maybeAutoLoad", "Proceeding with auto-load");
    this.#updateFromUrn();
  }
  #hasDefaultSlotContent() {
    const childNodes = Array.from(this.childNodes);
    this.#log("hasDefaultSlotContent", "Checking children", { childCount: childNodes.length });
    for (const n25 of childNodes) {
      if (n25.nodeType === Node.TEXT_NODE && n25.textContent.trim()) {
        this.#log("hasDefaultSlotContent", "Found text node with content", { text: n25.textContent.trim().substring(0, 50) });
        return true;
      }
      if (n25.nodeType === Node.ELEMENT_NODE) {
        const slot = n25.getAttribute?.("slot");
        this.#log("hasDefaultSlotContent", "Found element", { tagName: n25.tagName, slot });
        if (!slot) {
          this.#log("hasDefaultSlotContent", "Element in default slot found");
          return true;
        }
      }
    }
    this.#log("hasDefaultSlotContent", "No default slot content found");
    return false;
  }
  #hasAncestorWithUrn(urn) {
    let p30 = this.parentElement;
    while (p30) {
      if (p30.tagName && p30.tagName.toLowerCase() === "ee-reference") {
        const r25 = p30.getAttribute && p30.getAttribute("urn");
        if (r25 && r25 === urn) return true;
      }
      p30 = p30.parentElement;
    }
    return false;
  }
  // Public: force refresh the referenced content even if URN is unchanged
  refresh() {
    this.#log("refresh", "Force refresh requested");
    this.#lastLoadedUrn = null;
    this.#updateFromUrn(true);
  }
};
customElements.define("ee-reference", EeReference);
var sheet2 = new CSSStyleSheet();
sheet2.replaceSync(`
  /* When inside the RTE surface, ee-reference must not inherit pre-wrap + break-word,
     otherwise inline-block children can grow extremely tall due to forced wrapping. */
  ee-rte ee-reference,

  /* Reset whitespace/wrapping for ee-reference and all its descendants in RTE */
  ee-rte ee-reference,
  .ProseMirror ee-reference,
  ee-rte ee-reference *,
  .ProseMirror ee-reference * {
    white-space: normal !important;
    word-break: normal !important;
    overflow-wrap: normal !important;
  }

  ee-reference.ProseMirror-selectednode {
    display: inline-block;
  }

  /* Force section to full width when it contains a full-width ee-reference */
  section:has(> ee-reference[full-width]) {
    width: 100%;
  }
`);
document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet2];

// src/custom-elements/core/ee-reference.author.js
EeReference.ee = {
  getSchema(element) {
    const editor = document.querySelector("experience-elements-editor");
    const target = element || editor?.editorStore?.editingElement || null;
    const isInline2 = target?.hasAttribute("inline") && !target?.hasAttribute("modal");
    return {
      schemaVersion: 1,
      element: {
        label: "Reference",
        description: "Inline content reference to a saved element (by URN).",
        category: "structure"
      },
      attributes: {
        urn: {
          type: "text",
          default: "",
          label: "Reference URN",
          description: "URN of the saved element to inline (e.g., urn:eeid:\u2026).",
          placeholder: "urn:eeid:\u2026"
        },
        inline: {
          type: "boolean",
          default: false,
          label: "Inline",
          description: "Inline referenced content immediately; hides the trigger slot."
        },
        modal: {
          type: "boolean",
          default: false,
          label: "Display as modal",
          description: "Render referenced content in a Spectrum modal dialog.",
          evaluate: ({ element: element2 }) => ({ render: !element2.hasAttribute("inline") || element2.hasAttribute("modal") })
        },
        display: {
          type: "enum",
          label: "Display",
          description: "CSS display style for the element.",
          options: ["block", "inline", "inline-block", "inline-flex"],
          default: "block"
        },
        "full-width": {
          type: "boolean",
          default: false,
          label: "Full width",
          description: "Stretch referenced content to occupy the full available width."
        },
        stretch: {
          type: "boolean",
          default: false,
          label: "Stretch trigger",
          description: "Stretch the trigger slot and its content to the whole width of the parent.",
          evaluate: ({ element: element2 }) => ({ render: !element2.hasAttribute("inline") || element2.hasAttribute("modal") })
        }
      },
      // Trigger slot: when provided, referenced content loads upon a 'fire' event
      slots: {
        // Hide 'trigger' slot in authoring UI when inline is present on the element
        order: isInline2 ? [] : ["trigger"],
        configs: {
          trigger: {
            label: "Trigger",
            description: "Click target to load the experience. Accepts inline text or checkout-link.",
            placeholder: "Open experience\u2026"
          }
        }
      }
    };
  },
  // Contribute custom toolbar actions for ee-reference
  // Editor will call this when ee-reference is selected
  getToolbarActions(el, helpers) {
    const urn = el.getAttribute("urn") || "";
    if (!urn) return [];
    const handleOpenInEditor = () => {
      helpers.openInEditor(urn);
    };
    return [
      x`<sp-action-button
        quiet
        size="m"
        title="Open in Editor"
        @click=${handleOpenInEditor}
      >
        <sp-icon-open-in slot="icon"></sp-icon-open-in>
      </sp-action-button>`
    ];
  },
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};
document.addEventListener("ee-self-reference", (e36) => {
  const target = e36.target;
  if (!target) return;
  target.remove();
  const editor = target.closest("experience-elements-editor") || document.querySelector("experience-elements-editor");
  if (editor) {
    editor.showToast("Removed self-reference: cannot reference the current document.");
  } else {
    console.warn("Removed self-reference: cannot reference the current document.");
  }
});

// src/custom-elements/core/ee-content.js
var EeContent = class extends HTMLElement {
};
customElements.define("ee-content", EeContent);
var sheet3 = new CSSStyleSheet();
sheet3.replaceSync(`
  /* Base style: ee-content uses display:contents to be transparent in layout,
     preserving whitespace between adjacent elements */
  ee-content {
    display: inline;
  }

  /* When inside the RTE surface, ee-content must not inherit pre-wrap + break-word,
     otherwise inline-block children can grow extremely tall due to forced wrapping. */
  ee-rte ee-content,
  .ProseMirror ee-content {
    display: inline-flex;
  }

  /* Reset whitespace/wrapping for ee-content and all its descendants in RTE */
  ee-rte ee-content,
  .ProseMirror ee-content,
  ee-rte ee-content *,
  .ProseMirror ee-content * {
    white-space: normal !important;
    word-break: normal !important;
    overflow-wrap: normal !important;
  }

  ee-content.ProseMirror-selectednode {
    display: inline-block;
  }
`);
document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet3];

// src/custom-elements/core/ee-content.author.js
EeContent.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Inline Content",
        description: "Wraps arbitrary HTML content for preservation in rich text.",
        category: "structure"
      },
      attributes: {},
      slots: {
        order: [],
        configs: {}
      }
    };
  },
  create() {
    const el = document.createElement("ee-content");
    return el;
  },
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/core/spectrum-toggle.js
init_lit();

// src/custom-elements/core/spectrum-toggle.css.js
init_lit();
var spectrumToggleStyles = i`
  *, *::before, *::after {
    box-sizing: border-box;
  }

  :host {
    --toggle-radius: var(--spectrum-global-dimension-size-400, 32px);
    --toggle-height: var(--spectrum-global-dimension-size-500, 40px);
    align-items: stretch;
    background: rgba(255, 255, 255, 0.08);
    box-shadow: inset 0 -4px 8px rgba(255, 255, 255, 0.08);
    box-sizing: border-box;
    display: inline-flex;
    padding: var(--spectrum-global-dimension-size-75, 4px);
    position: relative;
    border-radius: 24px;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([data-disabled]) {
    opacity: 0.7;
  }

  slot {
    color: inherit;
    display: inline-flex;
    gap: 8px;
  }

  ::slotted(sp-button) {
    transition: color 160ms ease;
  }

  ::slotted(sp-button)::part(button) {
    transition: background-color 200ms ease, box-shadow 200ms ease;
  }

  ::slotted(sp-button[disabled]) {
    cursor: not-allowed;
    opacity: 0.65;
  }
`;

// src/custom-elements/core/spectrum-toggle.js
var MIN_OPTIONS = 2;
var MAX_OPTIONS = 10;
var INLINE_EDITOR_SELECTOR2 = "ee-rte[data-ee-inline-editor]";
var SpectrumToggle = class extends i4 {
  static styles = [spectrumToggleStyles];
  static properties = {
    value: { type: String, reflect: true },
    disabled: { type: Boolean, reflect: true, converter: booleanConverter },
    optionsData: { state: true }
  };
  constructor() {
    super();
    this.value = "";
    this.disabled = false;
    this.optionsData = [];
  }
  connectedCallback() {
    super.connectedCallback();
    ensureId(this, "spectrum-toggle");
    this.setAttribute("role", "radiogroup");
    this.addEventListener("click", this.handleButtonClick);
    this.addEventListener("keydown", this.handleButtonKeydown);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.handleButtonClick);
    this.removeEventListener("keydown", this.handleButtonKeydown);
  }
  firstUpdated() {
    this.#syncOptions();
  }
  updated(changedProperties) {
    if (changedProperties.has("value")) {
      this.#applySelectionAttributes();
    }
    if (changedProperties.has("disabled")) {
      this.#syncDisabledState();
      this.#applySelectionAttributes();
    }
  }
  render() {
    const hasEnoughOptions = Array.isArray(this.optionsData) && this.optionsData.length >= MIN_OPTIONS;
    return x`
      ${hasEnoughOptions ? E : x`<span id="empty" part="empty">
            Add at least ${MIN_OPTIONS} toggle options.
          </span>`}
      <slot @slotchange=${this.handleSlotChange}></slot>
    `;
  }
  handleSlotChange() {
    const nodes2 = this.#getOptionElements();
    const lastSelectedElement = nodes2.slice().reverse().find((node) => node.hasAttribute("data-selected"));
    const preservedValue = lastSelectedElement?.dataset.value;
    nodes2.forEach((node) => {
      node.removeAttribute("data-selected");
      node.removeAttribute("value");
    });
    this.#syncOptions();
    if (preservedValue) {
      const normalizedPreservedValue = this.#normalizeValue(preservedValue);
      const preservedOption = this.optionsData.find(
        (item) => item.value === normalizedPreservedValue
      );
      if (preservedOption) {
        this.value = normalizedPreservedValue;
        this.#applySelectionAttributes();
      }
    }
  }
  handleButtonClick(event) {
    if (this.#hasInlineEditor()) return;
    const target = this.#findInteractiveButton(event);
    if (!target) return;
    const value = target.dataset.value;
    if (!value) return;
    this.#setValue(value);
  }
  handleButtonKeydown(event) {
    if (this.#hasInlineEditor()) return;
    const target = this.#findInteractiveButton(event);
    if (!target) return;
    const { key } = event;
    if (!key) return;
    const controlsNavigation = [
      "ArrowRight",
      "ArrowDown",
      "ArrowLeft",
      "ArrowUp",
      "Home",
      "End"
    ];
    if (!controlsNavigation.includes(key)) return;
    event.preventDefault();
    switch (key) {
      case "ArrowRight":
      case "ArrowDown":
        this.#focusNeighbor(target, 1);
        break;
      case "ArrowLeft":
      case "ArrowUp":
        this.#focusNeighbor(target, -1);
        break;
      case "Home":
        this.#focusByIndex(0);
        break;
      case "End":
        this.#focusByIndex(this.optionsData.length - 1);
        break;
      default:
        break;
    }
  }
  #findInteractiveButton(event) {
    const path = typeof event.composedPath === "function" ? event.composedPath() : [];
    return path.find(
      (node) => node instanceof HTMLElement && node.tagName?.toLowerCase() === "sp-button" && node.parentElement === this
    ) || null;
  }
  #focusNeighbor(currentButton, delta) {
    const currentIndex = Number(currentButton.dataset.index || 0);
    this.#focusByIndex(currentIndex + delta);
  }
  #focusByIndex(index) {
    if (!this.optionsData.length) return;
    const size3 = this.optionsData.length;
    const clamped = (index % size3 + size3) % size3;
    const item = this.optionsData[clamped];
    if (!item?.element) return;
    this.#setValue(item.value);
    item.element.focus();
  }
  #tabIndexFor(value, disabledState) {
    if (disabledState) return -1;
    return this.value === value ? 0 : -1;
  }
  #syncOptions() {
    const nodes2 = this.#getOptionElements();
    const trimmed = nodes2.slice(0, MAX_OPTIONS);
    nodes2.forEach((node, index) => {
      const hidden = index >= MAX_OPTIONS;
      node.toggleAttribute("aria-hidden", hidden);
      node.toggleAttribute("data-hidden-option", hidden);
      node.toggleAttribute("hidden", hidden);
      if (hidden) {
        node.tabIndex = -1;
      }
    });
    const usedValues = /* @__PURE__ */ new Set();
    const mapped = trimmed.map((node, index) => {
      const fallbackValue = `option-${index + 1}`;
      const rawDataValue = node.getAttribute("data-value");
      const normalizedDataValue = this.#normalizeValue(rawDataValue);
      const hasCustomDataValue = Boolean(
        rawDataValue && normalizedDataValue.length
      );
      const textCandidate = this.#normalizeValue(node.textContent);
      let value = hasCustomDataValue ? normalizedDataValue : textCandidate || fallbackValue;
      if (usedValues.has(value)) {
        let counter = 1;
        let uniqueValue = `${value}-${counter}`;
        while (usedValues.has(uniqueValue)) {
          counter++;
          uniqueValue = `${value}-${counter}`;
        }
        value = uniqueValue;
      }
      usedValues.add(value);
      node.dataset.value = value;
      node.removeAttribute("value");
      const id = node.id || `${this.tagName.toLowerCase()}-${this.id}-option-${index + 1}`;
      node.id = id;
      node.dataset.index = String(index);
      node.setAttribute("role", "radio");
      node.setAttribute("type", "button");
      if (!node.hasAttribute("size")) {
        node.setAttribute("size", "m");
      }
      node.setAttribute("variant", node.getAttribute("variant") || "primary");
      return { element: node, value, id };
    });
    this.optionsData = mapped;
    if (mapped.length && !mapped.some((option) => option.value === this.value)) {
      this.value = mapped[0].value;
    }
    if (!mapped.length) {
      this.value = "";
    }
    this.#applySelectionAttributes();
    this.#syncDisabledState();
  }
  #getOptionElements() {
    return Array.from(this.children).filter(
      (node) => node instanceof HTMLElement && node.tagName?.toLowerCase() === "sp-button"
    );
  }
  #applySelectionAttributes() {
    if (!Array.isArray(this.optionsData)) return;
    const current = this.#normalizeValue(this.value);
    const disabledState = this.#isInteractionDisabled();
    this.optionsData.forEach((item) => {
      const element = item.element;
      if (!element) return;
      const selected = item.value === current;
      element.toggleAttribute("data-selected", selected);
      element.setAttribute("aria-checked", selected ? "true" : "false");
      element.tabIndex = this.#tabIndexFor(item.value, disabledState);
      element.setAttribute("variant", selected ? "primary" : "secondary");
      element.toggleAttribute("quiet", !selected);
    });
  }
  #syncDisabledState() {
    const disabledState = this.#isInteractionDisabled();
    this.setAttribute("aria-disabled", disabledState ? "true" : "false");
    this.toggleAttribute("data-disabled", disabledState);
    this.optionsData.forEach((item) => {
      const element = item.element;
      if (!element) return;
      element.toggleAttribute("disabled", disabledState);
      element.setAttribute("aria-disabled", disabledState ? "true" : "false");
    });
    return disabledState;
  }
  #isInteractionDisabled() {
    const count = Array.isArray(this.optionsData) ? this.optionsData.length : 0;
    return this.disabled || count < MIN_OPTIONS;
  }
  #setValue(value) {
    if (this.#isInteractionDisabled()) return;
    const normalized = this.#normalizeValue(value);
    if (!normalized) return;
    if (!this.optionsData.some((item) => item.value === normalized)) return;
    if (normalized === this.value) return;
    this.value = normalized;
    this.dispatchEvent(
      new CustomEvent("change", {
        detail: { value: normalized },
        bubbles: true,
        composed: true
      })
    );
  }
  #normalizeValue(value) {
    return String(value ?? "").trim();
  }
  #hasInlineEditor() {
    return Boolean(this.querySelector(INLINE_EDITOR_SELECTOR2));
  }
};
customElements.define("spectrum-toggle", SpectrumToggle);

// src/custom-elements/core/spectrum-toggle.author.js
var MIN_OPTIONS2 = 2;
var MAX_OPTIONS2 = 10;
SpectrumToggle.ee = {
  getSchema(element) {
    return {
      schemaVersion: 1,
      element: {
        label: "Spectrum Toggle",
        description: "Segmented control supporting up to ten options"
      },
      attributes: {
        value: {
          type: "text",
          label: "Selected Value",
          description: "Default selected option value"
        },
        disabled: {
          type: "boolean",
          label: "Disabled",
          description: "Disable user interaction"
        }
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Options",
            description: `Add between ${MIN_OPTIONS2} and ${MAX_OPTIONS2} sp-button items`,
            allowedTags: ["sp-button"],
            placeholder: "Add toggle option",
            maxLength: MAX_OPTIONS2
          }
        }
      }
    };
  },
  create() {
    const toggle = document.createElement("spectrum-toggle");
    const button1 = document.createElement("sp-button");
    button1.setAttribute("data-value", "option1");
    button1.setAttribute("size", "xl");
    button1.setAttribute("variant", "primary");
    button1.textContent = "Option 1";
    const button2 = document.createElement("sp-button");
    button2.setAttribute("data-value", "option2");
    button2.setAttribute("size", "xl");
    button2.setAttribute("variant", "secondary");
    button2.setAttribute("quiet", "");
    button2.textContent = "Option 2";
    toggle.appendChild(button1);
    toggle.appendChild(button2);
    return toggle;
  },
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/core/ee-list/ee-list.js
init_lit();

// src/custom-elements/core/ee-list/ee-list.css.js
init_lit();
var eeListStyles = i`
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--ee-list-gap, var(--spectrum-global-dimension-size-300));
    --ee-list-icon-name: '';
    --ee-list-icon-color: var(--spectrum-global-color-green-400);
    --ee-list-columns: 1;
  }

  :host([hidden]) {
    display: none !important;
  }

  ::slotted([slot='label']) {
    font-size: var(--spectrum-global-dimension-size-225);
    font-weight: 600;
    margin-bottom: var(--spectrum-global-dimension-size-75);
    color: inherit;
  }

  :host([columns='2']) slot[part='items'],
  :host([columns='3']) slot[part='items'] {
    display: grid;
    grid-template-columns: repeat(var(--ee-list-columns, 1), 1fr);
    gap: var(--ee-list-gap, var(--spectrum-global-dimension-size-300));
  }

  :host(:not([columns])) slot[part='items'] {
    display: flex;
    flex-direction: column;
  }
`;

// src/custom-elements/core/icon-transform-properties.js
var iconTransformProperties = {
  name: { type: String, attribute: "name", reflect: true },
  size: { type: String, attribute: "size", reflect: true },
  color: { type: String, attribute: "color", reflect: true },
  rotate: { type: Number, attribute: "rotate", reflect: true },
  flipH: { type: Boolean, attribute: "flip-h", reflect: true, converter: booleanConverter },
  flipV: { type: Boolean, attribute: "flip-v", reflect: true, converter: booleanConverter }
};

// src/custom-elements/core/ee-list/ee-list.js
var EeList = class extends i4 {
  static styles = [eeListStyles];
  static properties = {
    ...iconTransformProperties,
    columns: { type: Number, reflect: true }
  };
  #labelSlot;
  #onLabelSlotChange;
  constructor() {
    super();
    this.name = "";
    this.size = "s";
    this.color = "";
    this.rotate = 0;
    this.flipH = false;
    this.flipV = false;
    this.columns = void 0;
    this.#labelSlot = null;
    this.#onLabelSlotChange = () => this.#syncAriaLabelling();
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "list");
  }
  firstUpdated() {
    this.#labelSlot = this.renderRoot?.querySelector('slot[name="label"]') || null;
    if (this.#labelSlot) {
      this.#labelSlot.addEventListener("slotchange", this.#onLabelSlotChange);
    }
    this.#syncAriaLabelling();
    this.#updateColumnLayout();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#labelSlot) {
      this.#labelSlot.removeEventListener("slotchange", this.#onLabelSlotChange);
      this.#labelSlot = null;
    }
  }
  updated(changedProps) {
    if (changedProps.has("name") || changedProps.has("size") || changedProps.has("color") || changedProps.has("rotate") || changedProps.has("flipH") || changedProps.has("flipV")) {
      this.dispatchEvent(
        new CustomEvent("ee-list:icon-defaults-changed", {
          bubbles: true,
          composed: true
        })
      );
    }
    if (changedProps.has("columns")) {
      this.#updateColumnLayout();
    }
    this.#syncAriaLabelling();
  }
  #syncAriaLabelling() {
    const labelNode = this.querySelector('[slot="label"]');
    if (labelNode) {
      ensureId(labelNode, "ee-list-label");
      this.setAttribute("aria-labelledby", labelNode.id);
    } else {
      this.removeAttribute("aria-labelledby");
    }
  }
  #updateColumnLayout() {
    const validColumns = [2, 3];
    if (this.columns && validColumns.includes(this.columns)) {
      this.style.setProperty("--ee-list-columns", String(this.columns));
    } else {
      this.style.removeProperty("--ee-list-columns");
      this.columns = void 0;
    }
  }
  render() {
    return x`
      <slot name="label" part="label"></slot>
      <slot part="items"></slot>
    `;
  }
};
customElements.define("ee-list", EeList);

// src/custom-elements/core/ee-list/ee-list.author.js
EeList.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "List",
        description: "Semantic list container with optional heading.",
        category: "structure"
      },
      attributes: {
        name: makeSWCIconNameSchema({
          defaultValue: "",
          label: "Default Icon",
          description: "Default icon applied to list items that do not have their own icon."
        }),
        color: makeSWCColorSchema({
          defaultValue: "",
          label: "Icon Color",
          description: "Default icon color applied to list items that do not have their own color."
        }),
        columns: {
          type: "enum",
          options: ["", 2, 3],
          label: "Columns",
          description: "Number of columns to display list items (2 or 3 columns)."
        }
      },
      slots: {
        order: ["label", "default"],
        configs: {
          label: {
            label: "Label",
            description: "Optional heading for the list.",
            maxLength: 1
          },
          default: {
            label: "Items",
            description: "Add ee-list-item elements describing each benefit.",
            allowedTags: ["ee-list-item"],
            minLength: 1
          }
        }
      }
    };
  },
  create() {
    const list = document.createElement("ee-list");
    const item = document.createElement("ee-list-item");
    item.textContent = "Example list item";
    list.appendChild(item);
    return list;
  },
  sanitize(element) {
    if (!element) return;
    element.setAttribute("role", "list");
    const name = element.getAttribute("name");
    if (name != null && !String(name).trim()) {
      element.removeAttribute("name");
    }
    const color = element.getAttribute("color");
    if (color != null && !String(color).trim()) {
      element.removeAttribute("color");
    }
    if (element.hasAttribute("size")) {
      const size3 = (element.getAttribute("size") || "").trim();
      const ok = ["xxs", "xs", "s", "m", "l", "xl", "xxl"];
      if (!ok.includes(size3)) {
        element.removeAttribute("size");
      }
    }
    if (element.hasAttribute("rotate")) {
      const r25 = Number(element.getAttribute("rotate") || 0);
      const allowed = /* @__PURE__ */ new Set([0, 90, 180, 270]);
      if (!allowed.has(r25)) {
        element.removeAttribute("rotate");
      }
    }
    ["flip-h", "flip-v"].forEach((attr) => {
      if (element.hasAttribute(attr)) {
        element.setAttribute(attr, "");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// src/custom-elements/core/ee-list/ee-list-item.js
init_lit();

// src/custom-elements/core/ee-list/ee-list-item.css.js
init_lit();
var eeListItemStyles = i`
  :host {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: var(--spectrum-global-dimension-size-200);
    align-items: flex-start;
    color: var(--ee-list-item-text-color, var(--spectrum-global-color-gray-900));
  }

  #icon {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    color: var(--ee-list-item-icon-color, var(--ee-list-icon-color, var(--spectrum-global-color-green-400)));
  }

  ::slotted([slot="icon"]) {
    display: flex;
    align-items: center;
    color: inherit;
  }

  :host([tone='negative']) {
    --ee-list-item-text-color: var(--spectrum-global-color-gray-600);
    --ee-list-item-icon-color: var(--spectrum-red-800);
  }
`;

// src/custom-elements/core/ee-list/ee-list-item.js
var EeListItem = class extends i4 {
  static styles = [eeListItemStyles];
  static properties = {
    name: { type: String, attribute: "name", reflect: true },
    size: { type: String, attribute: "size", reflect: true },
    color: { type: String, attribute: "color", reflect: true },
    rotate: { type: Number, attribute: "rotate", reflect: true },
    flipH: { type: Boolean, attribute: "flip-h", reflect: true, converter: booleanConverter },
    flipV: { type: Boolean, attribute: "flip-v", reflect: true, converter: booleanConverter }
  };
  #iconDefaultsListener = null;
  #iconDefaultsSource = null;
  constructor() {
    super();
    this.name = "";
    this.size = "";
    this.color = "";
    this.rotate = null;
    this.flipH = null;
    this.flipV = null;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "listitem");
    this.#iconDefaultsListener = () => this.requestUpdate();
    this.#iconDefaultsSource = this.closest("ee-list");
    if (this.#iconDefaultsSource) {
      this.#iconDefaultsSource.addEventListener(
        "ee-list:icon-defaults-changed",
        this.#iconDefaultsListener
      );
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#iconDefaultsSource && this.#iconDefaultsListener) {
      this.#iconDefaultsSource.removeEventListener(
        "ee-list:icon-defaults-changed",
        this.#iconDefaultsListener
      );
    }
    this.#iconDefaultsSource = null;
    this.#iconDefaultsListener = null;
  }
  resolveIconProps() {
    const parent = this.closest("ee-list");
    const localName = this.hasAttribute("name") && this.name ? this.name : parent?.name;
    const localSize = this.hasAttribute("size") && this.size ? this.size : parent?.size;
    const localColor = this.hasAttribute("color") && this.color ? this.color : parent?.color;
    const localRotate = this.hasAttribute("rotate") ? this.rotate : parent?.rotate;
    const localFlipH = this.hasAttribute("flip-h") ? this.flipH : parent?.flipH;
    const localFlipV = this.hasAttribute("flip-v") ? this.flipV : parent?.flipV;
    return {
      name: localName,
      size: localSize,
      color: localColor,
      rotate: localRotate,
      flipH: localFlipH,
      flipV: localFlipV
    };
  }
  #renderDefaultIcon() {
    const { name, size: size3, color } = this.resolveIconProps();
    const tag3 = name && customElements.get(name) ? s9(name) : null;
    const style = color ? color.startsWith("--") ? `color: var(${color})` : `color: ${color}` : null;
    if (!tag3) {
      return x`<sp-icon-checkmark-circle
        size=${size3 || "s"}
        style=${style || E}
        aria-hidden="true"
      ></sp-icon-checkmark-circle>`;
    }
    return u16`<${tag3} size=${size3 || "s"} style=${style || E} aria-hidden="true"></${tag3}>`;
  }
  render() {
    const { rotate, flipH, flipV } = this.resolveIconProps();
    const transforms = [];
    if (rotate) transforms.push(`rotate(${rotate}deg)`);
    if (flipH) transforms.push("scaleX(-1)");
    if (flipV) transforms.push("scaleY(-1)");
    const iconStyle = transforms.length ? `transform: ${transforms.join(" ")}` : null;
    return x`
      <div id="icon" style=${iconStyle || E}>
        <slot name="icon">${this.#renderDefaultIcon()}</slot>
      </div>
      <slot></slot>
    `;
  }
};
customElements.define("ee-list-item", EeListItem);

// src/custom-elements/core/ee-list/ee-list-item.author.js
var TEXT_STYLES = ["bold", "italic", "underline", "strikethrough"];
var ALIGN_FORMATS = ["align-left", "align-center", "align-right"];
EeListItem.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "List Item",
        description: "List entry with optional icon.",
        category: "structure"
      },
      attributes: {
        name: makeSWCIconNameSchema({
          defaultValue: "",
          label: "Icon",
          description: "Override the default icon with any Spectrum icon."
        }),
        color: makeSWCColorSchema({
          defaultValue: "",
          label: "Icon Color",
          description: "Spectrum token or CSS color for the icon."
        }),
        tone: {
          type: "enum",
          options: ["positive", "negative"],
          label: "Tone",
          allowEmpty: true
        }
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Primary Text",
            description: "Main description for the list item.",
            inlineEditable: true,
            multiline: false,
            plain: false,
            allowedStyles: [...TEXT_STYLES],
            allowedFormats: [...ALIGN_FORMATS],
            allowLinks: true,
            tag: "span"
          }
        }
      }
    };
  },
  sanitize(el) {
    if (!el) return;
    const name = (el.getAttribute("name") || "").trim();
    if (name && !customElements.get(name)) {
      el.removeAttribute("name");
    }
    const color = el.getAttribute("color");
    if (color != null && !String(color).trim()) {
      el.removeAttribute("color");
    }
    const tone = el.getAttribute("tone");
    if (tone != null && !String(tone).trim()) {
      el.removeAttribute("tone");
    }
    if (el.hasAttribute("size")) {
      const size3 = (el.getAttribute("size") || "").trim();
      const ok = ["xxs", "xs", "s", "m", "l", "xl", "xxl"];
      if (!ok.includes(size3)) {
        el.removeAttribute("size");
      }
    }
    if (el.hasAttribute("rotate")) {
      const r25 = Number(el.getAttribute("rotate") || 0);
      const allowed = /* @__PURE__ */ new Set([90, 180, 270]);
      if (!allowed.has(r25)) {
        el.removeAttribute("rotate");
      }
    }
    ["flip-h", "flip-v"].forEach((attr) => {
      if (el.hasAttribute(attr)) {
        el.setAttribute(attr, "");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// src/custom-elements/core/core.library.js
var LIBRARY_ID2 = "core";
function register2({
  registerLibrary: registerLibrary2,
  registerElement: registerElement2,
  LibraryLevel: LibraryLevel2
}) {
  registerLibrary2({
    id: LIBRARY_ID2,
    level: LibraryLevel2.SYSTEM,
    name: "Core Elements",
    description: "Foundational reference and media elements."
  });
  registerElement2(LIBRARY_ID2, "ee-media");
  registerElement2(LIBRARY_ID2, "ee-reference");
  registerElement2(LIBRARY_ID2, "ee-content");
  registerElement2(LIBRARY_ID2, "spectrum-toggle");
  registerElement2(LIBRARY_ID2, "ee-list");
  registerElement2(LIBRARY_ID2, "ee-list-item");
  registerElement2(LIBRARY_ID2, {
    tag: "sp-theme",
    displayName: "Spectrum Page",
    schema: spThemeSchemaApi
  });
}

// src/custom-elements/upw/subscribe-all-plans-store.js
var SubscribeAllPlansStore = class {
  static observableActions = [
    "setOpen",
    "setBillingTerm",
    "setRegion",
    "setOfferCodes",
    "setHrefBase",
    "setContinue"
  ];
  static computedProperties = ["isAnnual"];
  open = false;
  billingTerm = "monthly";
  country = "US";
  language = "en";
  offerCodes = {};
  // { [planId: string]: string }
  ctaHrefBase = "";
  selectedPlanId = "";
  continuePending = false;
  // Actions
  setOpen(v6) {
    this.open = !!v6;
  }
  setBillingTerm(term) {
    const v6 = term === "annual" ? "annual" : "monthly";
    this.billingTerm = v6;
  }
  setRegion(country, language) {
    if (country) this.country = String(country).toUpperCase();
    if (language) this.language = String(language).toLowerCase();
  }
  setOfferCodes(codes) {
    this.offerCodes = codes && typeof codes === "object" ? { ...codes } : {};
  }
  setHrefBase(url) {
    this.ctaHrefBase = String(url || "");
  }
  setContinue(planId) {
    this.selectedPlanId = String(planId || "");
    this.continuePending = true;
  }
  // Computed
  get isAnnual() {
    return this.billingTerm === "annual";
  }
};
makeObservable(SubscribeAllPlansStore);
var subscribeAllPlansStore = new SubscribeAllPlansStore();

// src/custom-elements/upw/subscribe-all-plans-toggle.js
init_lit();

// src/custom-elements/upw/subscribe-all-plans-toggle.css.js
init_lit();
var styles2 = i`
  :host {
    display: block;
  }
  .row {
    display: inline-flex;
    gap: var(--spectrum-global-dimension-size-200);
    align-items: center;
  }
`;

// src/custom-elements/upw/subscribe-all-plans-toggle.js
var SubscribeAllPlansToggle = class extends i4 {
  static styles = [styles2];
  static properties = {
    term: { type: String, reflect: true }
  };
  constructor() {
    super();
    this.term = "monthly";
  }
  connectedCallback() {
    super.connectedCallback();
    const initial = (this.getAttribute("default-term") || this.term || "monthly").toLowerCase();
    this.term = initial === "annual" ? "annual" : "monthly";
  }
  onChange = (e36) => {
    const value = e36.target?.value === "annual" ? "annual" : "monthly";
    this.term = value;
    this.dispatchEvent(new CustomEvent("billing-term-change", {
      detail: { term: this.term },
      bubbles: true,
      composed: true
    }));
  };
  get selected() {
    return this.term === "annual" ? "annual" : "monthly";
  }
  render() {
    return x`
      <div class="row" role="group" aria-label="Billing term">
        <sp-radio-group value=${this.selected} @change=${this.onChange} emphasized>
          <sp-radio value="monthly">Monthly</sp-radio>
          <sp-radio value="annual">Annual</sp-radio>
        </sp-radio-group>
      </div>
    `;
  }
};
customElements.define("subscribe-all-plans-toggle", SubscribeAllPlansToggle);

// src/custom-elements/upw/subscribe-all-plans-toggle.author.js
var Ctor = customElements.get("subscribe-all-plans-toggle");
Ctor.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Billing Toggle",
        description: "Monthly/Annual selection control",
        category: "commerce"
      },
      attributes: {
        "default-term": {
          type: "enum",
          options: ["monthly", "annual"],
          default: "monthly",
          label: "Default Term",
          description: "Initial billing term selection"
        }
      },
      slots: { order: [], configs: {} }
    };
  },
  create() {
    const el = document.createElement("subscribe-all-plans-toggle");
    el.setAttribute("default-term", "monthly");
    return el;
  },
  sanitize(el) {
    if (!el) return;
    const t34 = (el.getAttribute("default-term") || "monthly").toLowerCase();
    el.setAttribute("default-term", t34 === "annual" ? "annual" : "monthly");
  },
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/upw/subscribe-all-plans-type.js
init_lit();

// src/custom-elements/upw/subscribe-all-plans-type.css.js
init_lit();
var styles3 = i`
  :host { 
    display: block; 
    border: 2px solid var(--spectrum-global-color-gray-300);
    border-radius: var(--spectrum-global-dimension-size-100);
    padding: var(--spectrum-global-dimension-size-300);
    background: var(--spectrum-global-color-gray-50);
  }

  :host([data-term="annual"][data-selected="true"]) {
    border-color: var(--spectrum-global-color-blue-400);
    background: var(--spectrum-global-color-blue-50);
  }

  .row {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-200);
    align-items: flex-start;
  }

  .head { 
    display: flex; 
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-50);
    width: 100%;
  }
  
  .desc { 
    color: var(--spectrum-alias-secondary-text-color); 
    font-size: 14px;
    line-height: 1.4;
  }
  
  .prices { 
    display: flex; 
    gap: var(--spectrum-global-dimension-size-100); 
    align-items: baseline;
    margin: var(--spectrum-global-dimension-size-100) 0;
  }
  

  /* Spacing tweaks for slotted elements */
  ::slotted([slot="title"]) { 
    font-weight: 700; 
    font-size: 16px; 
    line-height: 22px; 
    margin: 0;
  }
  
  ::slotted([slot="subtitle"]) { 
    color: var(--spectrum-alias-secondary-text-color); 
    font-size: 13px; 
    line-height: 18px; 
    margin: 0;
  }
  
  ::slotted([slot="description"]) { 
    font-size: 13px; 
    line-height: 18px; 
    margin: 0;
  }
  
  ::slotted([slot="price"]) { 
    font-size: 20px;
    font-weight: 600;
    line-height: 1.2;
  }
  
  ::slotted([slot="annual-price"]) { 
    font-size: 20px;
    font-weight: 600;
    line-height: 1.2;
  }

  /* Toggle price visibility based on term */
  :host([data-term="monthly"]) ::slotted([slot="annual-price"]) { display: none !important; }
  :host([data-term="annual"]) ::slotted([slot="price"]) { display: none !important; }
`;

// src/custom-elements/upw/subscribe-all-plans-type.js
var SubscribeAllPlansType = class extends i4 {
  static styles = [styles3];
  static properties = {
    planId: { type: String, attribute: "plan-id" },
    analyticsId: { type: String, attribute: "analytics-id" },
    term: { type: String, reflect: true }
  };
  constructor() {
    super();
    this.planId = "";
    this.analyticsId = "";
    this.term = "monthly";
  }
  connectedCallback() {
    super.connectedCallback();
    this.syncTermAttr();
  }
  updated() {
    this.syncTermAttr();
  }
  syncTermAttr() {
    const t34 = this.term === "annual" ? "annual" : "monthly";
    this.setAttribute("data-term", t34);
  }
  render() {
    return x`
      <div class="row">
        <div class="head">
          <slot name="title" part="editor"></slot>
          <slot name="subtitle" part="editor"></slot>
        </div>
        <div class="prices">
          <slot name="price" part="editor"></slot>
          <slot name="annual-price" part="editor"></slot>
        </div>
        <div class="desc"><slot name="description" part="editor"></slot></div>
      </div>
    `;
  }
};
customElements.define("subscribe-all-plans-type", SubscribeAllPlansType);

// src/custom-elements/upw/subscribe-all-plans-type.author.js
var Ctor2 = customElements.get("subscribe-all-plans-type");
Ctor2.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Subscribe Plan Type",
        description: "A single subscription option with price(s) and CTA",
        category: "commerce"
      },
      attributes: {
        "plan-id": {
          type: "text",
          default: "",
          label: "Plan ID",
          description: "Plan identifier used for CTA link composition"
        },
        "analytics-id": {
          type: "text",
          default: "",
          label: "Analytics ID",
          description: "Optional analytics identifier"
        }
      },
      slots: {
        order: ["title", "subtitle", "description", "price", "annual-price", "cta"],
        configs: {
          title: {
            label: "Title",
            description: "Plan title",
            maxLength: 100,
            minLength: 1,
            placeholder: "Plan title"
          },
          subtitle: {
            label: "Subtitle",
            description: "Optional subtitle",
            maxLength: 100,
            minLength: 0,
            placeholder: "Subtitle"
          },
          description: {
            label: "Description",
            description: "Plan description text",
            maxLength: null,
            minLength: 0,
            placeholder: "Describe key features"
          },
          price: {
            label: "Monthly Price",
            description: "Monthly price (inline-price element)",
            maxLength: 1,
            minLength: 1
          },
          "annual-price": {
            label: "Annual Price",
            description: "Annual price (inline-price element)",
            maxLength: 1,
            minLength: 0
          },
          cta: {
            label: "CTA",
            description: "Checkout button",
            maxLength: 1,
            minLength: 0
          }
        }
      }
    };
  },
  create() {
    const el = document.createElement("subscribe-all-plans-type");
    const price = document.createElement("inline-price");
    price.setAttribute("slot", "price");
    price.setAttribute("value", "9.99");
    price.setAttribute("currency", "US$");
    price.setAttribute("period", "mo");
    el.appendChild(price);
    const annual = document.createElement("inline-price");
    annual.setAttribute("slot", "annual-price");
    annual.setAttribute("value", "119.88");
    annual.setAttribute("currency", "US$");
    annual.setAttribute("period", "yr");
    el.appendChild(annual);
    const cta = document.createElement("checkout-button");
    cta.setAttribute("slot", "cta");
    cta.textContent = "Subscribe";
    el.appendChild(cta);
    return el;
  },
  sanitize(el) {
    if (!el) return;
    const pid = (el.getAttribute("plan-id") || "").trim();
    if (pid) el.setAttribute("plan-id", pid);
    else el.removeAttribute("plan-id");
    const aid = (el.getAttribute("analytics-id") || "").trim();
    if (aid) el.setAttribute("analytics-id", aid);
    else el.removeAttribute("analytics-id");
  },
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/upw/subscribe-all-plans.js
init_lit();

// src/custom-elements/upw/subscribe-all-plans.css.js
init_lit();
var styles4 = i`
  :host {
    display: inline-block;
    box-sizing: border-box;
    color: var(--spectrum-alias-text-color);
    /* Tune these to match pixel spec */
    --sap-max-width: 1130px;
    --sap-section-gap: var(--spectrum-global-dimension-size-300); /* ~24px */
    --sap-plan-padding: var(--spectrum-global-dimension-size-300);
    --sap-border-radius: var(--spectrum-global-dimension-size-75);
    --sap-offers-width: 342px; /* right column width */
    --sap-price-col: 280px;   /* price column width inside plan row */
    --sap-cta-col: 200px;     /* CTA column width inside plan row */
  }

  /* Single Grid Layout (page + modal) */
  .sap-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr var(--sap-offers-width);
    grid-template-rows: auto auto auto auto auto auto auto;
    grid-template-areas:
      "header header header header"
      "toggle toggle toggle offers"
      "icons  icons  icons  offers"
      "desc   desc   desc   offers"
      "includes extras recommended offers"
      ". . . continue"
      "footer footer footer footer";
    gap: var(--sap-section-gap);
    align-items: start;
    max-width: var(--sap-max-width);
    margin-inline: auto;
    margin-block: var(--spectrum-global-dimension-size-400);
    padding-inline: var(--spectrum-global-dimension-size-300);
    box-sizing: border-box;
  }

  /* Modal content uses same grid, without header/footer area inside content */
  .sap-grid.sap-grid--modal {
    grid-template-areas:
      "toggle toggle toggle offers"
      "icons  icons  icons  offers"
      "desc   desc   desc   offers"
      "includes extras recommended offers"
      ". . . continue";
    width: fit-content;
    max-width: 100%;
    margin-inline: 0;
    margin-block: 0;
    padding-inline: 0;
  }

  /* Grid area assignments */
  #header { grid-area: header; display: grid; align-content: center; }
  #toggle { grid-area: toggle; display: flex; justify-content: center; }
  #icons { grid-area: icons; display: inline-flex; gap: var(--spectrum-global-dimension-size-100); align-items: center; }
  #desc { grid-area: desc; color: var(--spectrum-alias-secondary-text-color); }
  #includes { grid-area: includes; }
  #extras { grid-area: extras; }
  #recommended { grid-area: recommended; }
  #offers { grid-area: offers; display: grid; gap: var(--spectrum-global-dimension-size-200); }
  #continue { grid-area: continue; display: flex; justify-content: end; }
  #footer { grid-area: footer; display: grid; justify-content: end; }

  /* Minimum dimensions for slots */
  slot {
    display: block;
    min-width: 128px;
    min-height: 32px;
  }

  /* Header typography (author-provided heading) */
  ::slotted([slot="header"]) { margin: 0; font-weight: 700; }
  ::slotted(h2[slot="header"]) { font-size: 22px; line-height: 28px; }
  ::slotted(h3[slot="header"]) { font-size: 18px; line-height: 24px; font-weight: 600; }

  /* Section heading styles inside left meta areas */
  #includes h3, #extras h3, #recommended h3 {
    margin: 0 0 var(--spectrum-global-dimension-size-100) 0;
    font-size: 14px;
    font-weight: 700;
    color: var(--spectrum-alias-label-text-color);
  }
  #recommended ul { margin: 0; padding-left: 1.2em; }
  #recommended li { list-style: disc; margin-block: 0.25em; }
  #includes .items { display: grid; gap: var(--spectrum-global-dimension-size-100); }
  #includes .item { display: inline-flex; align-items: center; gap: var(--spectrum-global-dimension-size-100); }

  /* Continue section */
  .continue-wrapper {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: var(--spectrum-global-dimension-size-100);
  }
  .stock-offer {
    align-self: stretch;
  }
  .stock-offer ::slotted(*) {
    display: inline-flex;
    align-items: center;
  }
  .secure-text {
    font-size: var(--spectrum-global-dimension-size-150);
    color: var(--spectrum-alias-text-color);
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-75);
  }

  /* Style plan rows consistently when slotted */
  ::slotted(subscribe-all-plans-type) {
    border: 1px solid var(--spectrum-global-color-gray-300);
    border-radius: var(--sap-border-radius);
    padding: var(--sap-plan-padding);
    background: var(--spectrum-global-color-gray-50);
  }

  /* Dialog sizing: let content define width; keep reasonable viewport max */
  sp-dialog { max-width: calc(100vw - 64px); }
  sp-divider { margin-block: var(--spectrum-global-dimension-size-150); }

  /* Responsive */
  @media (max-width: 920px) {
  .sap-grid {
      grid-template-columns: 1fr;
      grid-template-areas:
        "header"
        "toggle"
        "icons"
        "desc"
        "offers"
        "includes"
        "extras"
        "recommended"
        "continue"
        "footer";
    }
    .sap-grid.sap-grid--modal {
      grid-template-areas:
        "toggle"
        "icons"
        "desc"
        "offers"
        "includes"
        "extras"
        "recommended"
        "continue";
    }
    #footer { justify-content: start; }
  }

  /* Debug overlay removed per request */
`;

// src/custom-elements/upw/subscribe-all-plans.js
var SubscribeAllPlans = class extends i4 {
  static styles = [styles4];
  static properties = {
    open: { type: Boolean, reflect: true, converter: booleanConverter },
    modal: { type: Boolean, reflect: true, converter: booleanConverter },
    showAllThreshold: { type: Number, attribute: "show-all-threshold" }
  };
  constructor() {
    super();
    this.open = false;
    this.modal = false;
    this.showAllThreshold = void 0;
  }
  // If embedded under an ee-reference, prefer modal presentation
  willUpdate(_changed) {
    if (!this.modal) {
      const inEeReference = typeof this.closest === "function" ? this.closest("ee-reference") : null;
      if (inEeReference) this.modal = true;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.updateAria();
    this.updateAppVisibility();
    window.addEventListener("keydown", this.onKeyDown);
    this.#initTermFromToggle();
    this.addEventListener("billing-term-change", this.onBillingTermChange);
    this.#syncModalWithContext();
    const schedule = typeof requestAnimationFrame === "function" ? requestAnimationFrame : (cb) => setTimeout(cb, 0);
    schedule(() => {
      this.#syncModalWithContext();
      if (this.modal && !this.open) this.open = true;
    });
  }
  updated(changed) {
    if (changed.has("modal")) this.updateAria();
    if (changed.has("showAllThreshold")) this.updateAppVisibility();
    this.updateAria();
  }
  updateAria() {
    const header = this.querySelector('[slot="header"]');
    let headingId = null;
    if (header) {
      headingId = ensureId(header, "sap-title");
    }
    if (!this.modal) {
      this.setAttribute("role", "region");
      this.removeAttribute("aria-modal");
      if (headingId) {
        this.setAttribute("aria-labelledby", headingId);
        this.removeAttribute("aria-label");
      } else {
        this.setAttribute("aria-label", "Subscribe - All Plans");
        this.removeAttribute("aria-labelledby");
      }
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-modal");
      this.removeAttribute("aria-labelledby");
      this.removeAttribute("aria-label");
    }
  }
  updateAppVisibility() {
    const includes = this.querySelector('[slot="includes"]');
    if (!includes) return;
    const items = includes.querySelectorAll(".items .item");
    const showAllLink = includes.querySelector('.items a[href="#"]');
    if (this.showAllThreshold === void 0 || this.showAllThreshold === null || this.showAllThreshold <= 0) {
      items.forEach((item) => item.style.display = "");
      if (showAllLink) showAllLink.style.display = "none";
    } else {
      items.forEach((item, index) => {
        if (index < this.showAllThreshold) {
          item.style.display = "";
        } else {
          item.style.display = "none";
        }
      });
      if (showAllLink) {
        const totalApps = items.length;
        showAllLink.textContent = `Show all ${totalApps}+ apps`;
        showAllLink.style.display = "";
      }
    }
  }
  get isOpen() {
    return !!this.open;
  }
  renderPage() {
    return x`
      <div class="sap-grid">
        <slot id="header" name="header" part="editor"></slot>
        <slot id="toggle" name="toggle" part="editor"></slot>
        <slot id="icons" name="icons" part="editor"></slot>
        <slot id="desc" name="description" part="editor"></slot>
        <slot id="includes" name="includes" part="editor"></slot>
        <slot id="extras" name="extras" part="editor"></slot>
        <slot id="recommended" name="recommended" part="editor"></slot>
        <slot id="offers" part="editor"></slot>

        <div id="continue">
          <div class="continue-wrapper">
            <div class="stock-offer">
              <slot name="stock-offer" part="editor">
                <sp-checkbox id="stock-offer-checkbox">Include Adobe Stock (optional)</sp-checkbox>
              </slot>
            </div>
            <span class="secure-text"> Secure transaction</span>
            <sp-button variant="accent" size="l" @click=${this.onContinue}>Continue</sp-button>
          </div>
        </div>

        <slot id="footer" name="footer" part="editor"></slot>
      </div>
    `;
  }
  renderModal() {
    return x`
      <overlay-trigger
        type="modal"
        triggered-by="click"
        receives-focus="auto"
        .open=${this.isOpen ? "click" : void 0}
        @sp-closed=${this.onOverlayClosed}
      >
        <sp-dialog-wrapper dismissable underlay slot="click-content" @close=${this.onOverlayClosed}>
          <div slot="heading"><slot name="header" part="editor"></slot></div>
          <div class="sap-grid sap-grid--modal">
            <slot id="toggle" name="toggle" part="editor"></slot>
            <slot id="icons" name="icons" part="editor"></slot>
            <slot id="desc" name="description" part="editor"></slot>
            <slot id="includes" name="includes" part="editor"></slot>
            <slot id="extras" name="extras" part="editor"></slot>
            <slot id="recommended" name="recommended" part="editor"></slot>
            <slot id="offers" part="editor"></slot>

            <div id="continue">
              <div class="continue-wrapper">
                <div class="stock-offer">
                  <slot name="stock-offer" part="editor">
                    <sp-checkbox id="stock-offer-checkbox">Include Adobe Stock (optional)</sp-checkbox>
                  </slot>
                </div>
                <span class="secure-text"> Secure transaction</span>
                <sp-button variant="accent" size="l" @click=${this.onContinue}>Continue</sp-button>
              </div>
            </div>
          </div>
          <div slot="button"><slot name="footer" part="editor"></slot></div>
        </sp-dialog-wrapper>
      </overlay-trigger>
    `;
  }
  onOverlayClosed = () => {
    this.open = false;
    this.remove();
  };
  onContinue = () => {
    const selectedPlanId = this.#getSelectedPlanId();
    this.dispatchEvent(new CustomEvent("subscribe-continue", {
      detail: { planId: selectedPlanId },
      bubbles: true,
      composed: true
    }));
  };
  #getSelectedPlanId() {
    const selectedType = this.querySelector('subscribe-all-plans-type[data-selected="true"]');
    return selectedType ? selectedType.getAttribute("plan-id") || "" : "";
  }
  disconnectedCallback() {
    this.removeEventListener("billing-term-change", this.onBillingTermChange);
    window.removeEventListener("keydown", this.onKeyDown);
    super.disconnectedCallback();
  }
  onKeyDown = (e36) => {
    if (this.modal && this.isOpen && (e36.key === "Escape" || e36.key === "Esc")) {
      this.open = false;
    }
  };
  render() {
    return this.modal ? this.renderModal() : this.renderPage();
  }
  onBillingTermChange = (e36) => {
    e36.stopPropagation();
    const term = (e36.detail?.term || "").toLowerCase() === "annual" ? "annual" : "monthly";
    this.#setTypesTerm(term);
  };
  #syncModalWithContext() {
    if (!this.modal) {
      const inEeReference = typeof this.closest === "function" ? this.closest("ee-reference") : null;
      if (inEeReference) this.modal = true;
    }
  }
  #initTermFromToggle() {
    const toggle = this.querySelector("subscribe-all-plans-toggle");
    let term = "monthly";
    if (toggle) {
      const tAttr = (toggle.getAttribute("term") || toggle.getAttribute("default-term") || "").toLowerCase();
      if (tAttr === "annual") term = "annual";
    }
    this.#setTypesTerm(term);
  }
  #setTypesTerm(term) {
    this.querySelectorAll("subscribe-all-plans-type").forEach((el) => {
      el.term = term;
    });
  }
};
customElements.define("subscribe-all-plans", SubscribeAllPlans);

// src/custom-elements/upw/subscribe-all-plans.author.js
var Ctor3 = customElements.get("subscribe-all-plans");
var textStyles = ["bold", "italic", "underline", "strikethrough"];
var alignFormats = ["align-left", "align-center", "align-right"];
Ctor3.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Subscribe All Plans",
        description: "Container for subscription options with optional modal presentation"
      },
      attributes: {
        "data-modal": {
          type: "boolean",
          default: false,
          label: "Render as modal",
          description: "When enabled, persists with modal attribute. Editor always shows page layout."
        }
      },
      slots: {
        order: [
          "header",
          "icons",
          "description",
          "includes",
          "extras",
          "recommended",
          "toggle",
          "default",
          "footer"
        ],
        configs: {
          header: {
            label: "Header",
            description: "Heading content for the subscribe container",
            maxLength: 100,
            minLength: 1,
            placeholder: "Subscribe"
          },
          icons: {
            label: "Product Icons",
            description: "Product icon(s) to display",
            maxLength: null,
            minLength: 1
          },
          description: {
            inlineEditable: true,
            label: "Product Description",
            description: "Short description text under the header",
            placeholder: "Describe the bundle",
            multiline: true,
            allowedStyles: [...textStyles],
            allowedFormats: [...alignFormats],
            allowLinks: true
          },
          includes: {
            label: "Includes",
            description: "Included apps or items",
            maxLength: null,
            minLength: 1
          },
          extras: {
            label: "Extras",
            description: "Extra benefits/features list",
            maxLength: 1,
            minLength: 1
          },
          recommended: {
            label: "Recommended For",
            description: "Audience list (bulleted or text)",
            placeholder: "Photo, Graphic design, ..."
          },
          toggle: {
            label: "Billing Toggle",
            description: "Monthly/Annual toggle",
            maxLength: 1,
            minLength: 1
          },
          default: {
            label: "Plans",
            description: "Plan rows",
            maxLength: 3,
            minLength: 1
          },
          footer: {
            label: "Footer",
            description: "Optional action or note",
            maxLength: 1,
            minLength: 0
          }
        }
      }
    };
  },
  // Create a default instance hierarchy
  create() {
    const root = document.createElement("subscribe-all-plans");
    const toggle = document.createElement("subscribe-all-plans-toggle");
    toggle.setAttribute("slot", "toggle");
    toggle.setAttribute("default-term", "monthly");
    root.appendChild(toggle);
    const plan = document.createElement("subscribe-all-plans-type");
    const title = document.createElement("span");
    title.setAttribute("slot", "title");
    title.textContent = "Individual Plan";
    plan.appendChild(title);
    const price = document.createElement("inline-price");
    price.setAttribute("slot", "price");
    price.setAttribute("value", "19.99");
    price.setAttribute("currency", "US$");
    price.setAttribute("period", "mo");
    plan.appendChild(price);
    const annual = document.createElement("inline-price");
    annual.setAttribute("slot", "annual-price");
    annual.setAttribute("value", "239.88");
    annual.setAttribute("currency", "US$");
    annual.setAttribute("period", "yr");
    plan.appendChild(annual);
    root.appendChild(plan);
    return root;
  },
  sanitize(el) {
    if (!el) return;
    const flag = el.hasAttribute("data-modal");
    if (flag) el.setAttribute("modal", "");
    else el.removeAttribute("modal");
    el.removeAttribute("data-modal");
  },
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    const result = makeToJson(el, schema2, serializeNode);
    const modalFlag = el.hasAttribute("data-modal") || el.hasAttribute("modal");
    if (modalFlag) result.attributes["modal"] = true;
    const threshold = el.getAttribute("show-all-threshold");
    if (threshold !== null && threshold !== "" && Number(threshold) > 0) {
      result.attributes["show-all-threshold"] = Number(threshold);
    }
    return result;
  }
};

// src/custom-elements/upw/paywall-card.author.js
var TEXT_STYLES2 = ["bold", "italic", "underline", "strikethrough"];
var ALIGN_FORMATS2 = ["align-left", "align-center", "align-right"];
PaywallCard.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Paywall Card",
        description: "Plan summary card using inline price and CTA slots."
      },
      attributes: {
        "plan-type": {
          type: "enum",
          options: ["M2M", "ABM", "PUF"],
          default: "ABM",
          label: "Plan Type"
        }
      },
      slots: {
        order: [
          "badge",
          "plan-name",
          "plan-description",
          "price-M2M",
          "price-ABM",
          "price-PUF",
          "terms",
          "cta",
          "generative-credits",
          "mnemonics",
          "disclaimer",
          "features",
          "footer"
        ],
        configs: {
          badge: {
            label: "Badge",
            description: "Optional badge at the top of the card.",
            maxLength: 1,
            minLength: 0,
            allowedTags: ["paywall-card-badge"],
            create: () => {
              const badge = document.createElement("paywall-card-badge");
              badge.textContent = "MOST POPULAR";
              return badge;
            }
          },
          "plan-name": {
            label: "Plan Name",
            description: "Heading displayed at the top of the card.",
            inlineEditable: true,
            maxLength: 1,
            tag: "h2"
          },
          "plan-description": {
            label: "Plan Description",
            inlineEditable: true,
            multiline: true,
            maxLength: 1
          },
          "price-M2M": {
            label: "Price (M2M)",
            description: "Use an inline-price element to display currency and cadence for M2M plan type.",
            allowedTags: ["inline-price"],
            allowPaste: true,
            maxLength: 1
          },
          "price-ABM": {
            label: "Price (ABM)",
            description: "Use an inline-price element to display currency and cadence for ABM plan type.",
            allowedTags: ["inline-price"],
            allowPaste: true,
            maxLength: 1
          },
          "price-PUF": {
            label: "Price (PUF)",
            description: "Use an inline-price element to display currency and cadence for PUF plan type.",
            allowedTags: ["inline-price"],
            allowPaste: true,
            maxLength: 1
          },
          terms: {
            label: "Terms",
            inlineEditable: true,
            multiline: true,
            maxLength: 1
          },
          cta: {
            label: "Primary CTA",
            description: "Checkout button or Spectrum button.",
            allowedTags: ["checkout-button", "sp-button", "a"],
            allowPaste: true,
            maxLength: 1
          },
          "generative-credits": {
            label: "Generative Credits",
            description: "Credits or supporting metric beneath the CTA.",
            inlineEditable: true,
            multiline: false,
            plain: false,
            allowedStyles: [...TEXT_STYLES2],
            allowedFormats: [...ALIGN_FORMATS2],
            allowLinks: true,
            tag: "span"
          },
          mnemonics: {
            label: "App Mnemonics",
            description: "Row of app icons/mnemonics (e.g., Firefly, Express, Photoshop).",
            allowedTags: ["merch-mnemonic"]
          },
          disclaimer: {
            label: "App Disclaimer",
            description: "Disclaimer text for included apps.",
            inlineEditable: true,
            multiline: false,
            maxLength: 1,
            tag: "p"
          },
          features: {
            label: "Feature List",
            description: "Provide an ee-list with ee-list-item children.",
            allowedTags: ["ee-list"],
            minLength: 1
          },
          footer: {
            label: "Footer Note",
            inlineEditable: true,
            multiline: true,
            maxLength: 1
          }
        }
      }
    };
  },
  create() {
    const html = `
      <paywall-card plan-type="ABM">
        <h2 slot="plan-name">Firefly Standard</h2>
        <p slot="plan-description">Essential tools to create standout content</p>
        <inline-price slot="price-M2M" wcs-osi="PpnQ-UmW9NBwZwXlFw79zw2JybhvwIUwMTDYiIlu5qI" variant="upw"></inline-price>
        <inline-price slot="price-ABM" wcs-osi="r_JXAnlFI7xD6FxWKl2ODvZriLYBoSL701Kd1hRyhe8" variant="upw"></inline-price>
        <inline-price slot="price-PUF" wcs-osi="LzMV-Ok5xsBW10pPKrRMWq7ewtZjtbOqhaPUIO7tFD0" variant="upw"></inline-price>
        <p slot="terms">Cancel anytime, no fee</p>
        <checkout-button slot="cta" variant="accent" size="l" href="https://www.adobe.com/firefly.html">Buy now</checkout-button>
        <span slot="generative-credits"><strong>2,000</strong> Credits monthly</span>
        <merch-mnemonic slot="mnemonics" name="firefly" size="m"></merch-mnemonic>
        <merch-mnemonic slot="mnemonics" name="express" size="m"></merch-mnemonic>
        <merch-mnemonic slot="mnemonics" name="photoshop" size="m"></merch-mnemonic>
        <p slot="disclaimer">Included web and mobile apps *</p>
        <ee-list slot="features">
          <ee-list-item>Unlimited standard features</ee-list-item>
          <ee-list-item>Firefly Boards access</ee-list-item>
          <ee-list-item status="negative">Queue Firefly Video beyond credit limits</ee-list-item>
        </ee-list>
        <small slot="footer">*Generative credits reset each month.</small>
      </paywall-card>
    `;
    const template = document.createElement("template");
    template.innerHTML = html.trim();
    return template.content.firstElementChild;
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// src/custom-elements/upw/paywall-card-badge.author.js
PaywallCardBadge.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Paywall Card Badge",
        description: "Badge displayed at the top of paywall cards",
        category: "indicators"
      },
      attributes: {},
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Badge Text",
            description: "Text content for the badge",
            placeholder: "MOST POPULAR",
            inlineEditable: true,
            allowLinks: false,
            multiline: false,
            plain: true,
            allowedStyles: [],
            allowedFormats: []
          }
        }
      }
    };
  },
  sanitize(el) {
    if (!el) return;
    const text = (el.textContent || "").trim();
    el.textContent = text.slice(0, 40);
  },
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/upw/paywall-container.author.js
var TEXT_STYLES3 = ["bold", "italic", "underline", "strikethrough"];
PaywallContainer.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Paywall Container",
        description: "Container for paywall cards with plan type toggle control."
      },
      slots: {
        order: [
          "heading",
          "toggle",
          "default",
          "footer-link",
          "footer-disclaimer"
        ],
        configs: {
          heading: {
            label: "Heading",
            description: "Main title text displayed at the top.",
            inlineEditable: true,
            multiline: false,
            maxLength: 1,
            tag: "p"
          },
          toggle: {
            label: "Commitment selector",
            description: "Spectrum toggle component with sp-button options for plan types (M2M, ABM, PUF).",
            allowedTags: ["spectrum-toggle"],
            maxLength: 1,
            minLength: 1
          },
          default: {
            label: "Paywall Cards",
            description: "Add paywall-card elements to display plan options.",
            allowedTags: ["paywall-card"],
            allowPaste: true,
            minLength: 1
          },
          "footer-link": {
            label: "Footer Link",
            description: "Link displayed below the cards (e.g., 'View all plans').",
            inlineEditable: true,
            multiline: false,
            plain: false,
            allowedStyles: [],
            allowedFormats: [],
            allowPaste: false,
            allowLinks: true,
            tag: "div"
          },
          "footer-disclaimer": {
            label: "Footer Disclaimer",
            description: "Disclaimer text displayed below the footer link.",
            inlineEditable: true,
            multiline: false,
            plain: false,
            allowedStyles: [...TEXT_STYLES3],
            allowedFormats: [],
            allowPaste: false,
            allowLinks: false,
            tag: "div"
          }
        }
      }
    };
  },
  create() {
    const html = `
      <paywall-container>
        <p slot="heading">Keep creating with Firefly</p>
        <spectrum-toggle slot="toggle" value="M2M">
          <sp-button data-value="M2M" size="xl" variant="primary">Monthly</sp-button>
          <sp-button data-value="ABM" size="xl" variant="secondary" quiet>Annual, billed monthly</sp-button>
          <sp-button data-value="PUF" size="xl" variant="secondary" quiet>Annual, prepaid</sp-button>
        </spectrum-toggle>
        <paywall-card plan-type="M2M">
          <h2 slot="plan-name">Firefly Standard</h2>
          <p slot="plan-description">Essential tools to create standout content</p>
          <inline-price slot="price-M2M" wcs-osi="PpnQ-UmW9NBwZwXlFw79zw2JybhvwIUwMTDYiIlu5qI" variant="upw"></inline-price>
          <inline-price slot="price-ABM" wcs-osi="r_JXAnlFI7xD6FxWKl2ODvZriLYBoSL701Kd1hRyhe8" variant="upw"></inline-price>
          <inline-price slot="price-PUF" wcs-osi="LzMV-Ok5xsBW10pPKrRMWq7ewtZjtbOqhaPUIO7tFD0" variant="upw"></inline-price>
          <p slot="terms">Cancel anytime, no fee</p>
          <checkout-button slot="cta" variant="accent" size="l" href="https://www.adobe.com/firefly.html">Buy now</checkout-button>
          <span slot="generative-credits"><strong>2,000</strong> Credits monthly</span>
          <merch-mnemonic slot="mnemonics" name="firefly" size="m"></merch-mnemonic>
          <p slot="disclaimer">Included web and mobile apps *</p>
          <ee-list slot="features">
            <ee-list-item>Unlimited standard features</ee-list-item>
            <ee-list-item>Firefly Boards access</ee-list-item>
            <ee-list-item status="negative">Queue Firefly Video beyond credit limits</ee-list-item>
          </ee-list>
        </paywall-card>
        <paywall-card plan-type="M2M">
          <paywall-card-badge slot="badge">MOST POPULAR</paywall-card-badge>
          <h2 slot="plan-name">Firefly Pro</h2>
          <p slot="plan-description">Enhanced creative power to elevate your content</p>
          <inline-price slot="price-M2M" wcs-osi="PpnQ-UmW9NBwZwXlFw79zw2JybhvwIUwMTDYiIlu5qI" variant="upw"></inline-price>
          <inline-price slot="price-ABM" wcs-osi="r_JXAnlFI7xD6FxWKl2ODvZriLYBoSL701Kd1hRyhe8" variant="upw"></inline-price>
          <inline-price slot="price-PUF" wcs-osi="LzMV-Ok5xsBW10pPKrRMWq7ewtZjtbOqhaPUIO7tFD0" variant="upw"></inline-price>
          <p slot="terms">Cancel anytime, no fee</p>
          <checkout-button slot="cta" variant="accent" size="l" href="https://www.adobe.com/firefly.html">Buy now</checkout-button>
          <span slot="generative-credits"><strong>7,000</strong> Credits monthly</span>
          <merch-mnemonic slot="mnemonics" name="firefly" size="m"></merch-mnemonic>
          <merch-mnemonic slot="mnemonics" name="express" size="m"></merch-mnemonic>
          <merch-mnemonic slot="mnemonics" name="photoshop" size="m"></merch-mnemonic>
          <p slot="disclaimer">Included web and mobile apps *</p>
          <ee-list slot="features">
            <ee-list-item>Unlimited standard features</ee-list-item>
            <ee-list-item>Firefly Boards access</ee-list-item>
            <ee-list-item status="negative">Queue Firefly Video beyond credit limits</ee-list-item>
          </ee-list>
        </paywall-card>
        <paywall-card plan-type="M2M">
          <h2 slot="plan-name">Firefly Premium</h2>
          <p slot="plan-description">The ultimate solution to multiply your content</p>
          <inline-price slot="price-M2M" wcs-osi="PpnQ-UmW9NBwZwXlFw79zw2JybhvwIUwMTDYiIlu5qI" variant="upw"></inline-price>
          <inline-price slot="price-ABM" wcs-osi="r_JXAnlFI7xD6FxWKl2ODvZriLYBoSL701Kd1hRyhe8" variant="upw"></inline-price>
          <inline-price slot="price-PUF" wcs-osi="LzMV-Ok5xsBW10pPKrRMWq7ewtZjtbOqhaPUIO7tFD0" variant="upw"></inline-price>
          <p slot="terms">Cancel anytime, no fee</p>
          <checkout-button slot="cta" variant="accent" size="l" href="https://www.adobe.com/firefly.html">Buy now</checkout-button>
          <span slot="generative-credits"><strong>50,000</strong> Credits monthly</span>
          <merch-mnemonic slot="mnemonics" name="firefly" size="m"></merch-mnemonic>
          <merch-mnemonic slot="mnemonics" name="express" size="m"></merch-mnemonic>
          <merch-mnemonic slot="mnemonics" name="photoshop" size="m"></merch-mnemonic>
          <p slot="disclaimer">Included web and mobile apps *</p>
          <ee-list slot="features">
            <ee-list-item>Unlimited standard features</ee-list-item>
            <ee-list-item>Firefly Boards access</ee-list-item>
            <ee-list-item>Queue Firefly Video beyond credit limits</ee-list-item>
          </ee-list>
        </paywall-card>
        <div slot="footer-link"> <a href="#">View all plans</a> </div>
        <div slot="footer-disclaimer">* This plan does not include desktop apps.</div>
      </paywall-container>
    `;
    const template = document.createElement("template");
    template.innerHTML = html.trim();
    return template.content.firstElementChild;
  },
  sanitize() {
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// src/custom-elements/upw/upw.library.js
var LIBRARY_ID3 = "upw";
function register3({
  registerLibrary: registerLibrary2,
  registerElement: registerElement2,
  LibraryLevel: LibraryLevel2
}) {
  registerLibrary2({
    id: LIBRARY_ID3,
    level: LibraryLevel2.ORG,
    name: "UPW",
    description: "Unified Paywall"
  });
  registerElement2(LIBRARY_ID3, "subscribe-all-plans");
  registerElement2(LIBRARY_ID3, "paywall-card");
  registerElement2(LIBRARY_ID3, "paywall-card-badge");
  registerElement2(LIBRARY_ID3, "paywall-container");
}

// src/custom-elements/merch-card/merch-badge.css.js
var styles5 = `
  *, *::before, *::after {
    box-sizing: border-box;
  }
  
  :host {
    display: inline-block;
    font-family: 'Adobe Clean', 'Segoe UI', Roboto, sans-serif;
    box-sizing: border-box;
  }

  .badge {
    align-items: center;
    border-radius: 4px 0 0 4px;
    display: flex;
    font-size: 12px;
    font-weight: 600;
    height: 40px;
    justify-content: center;
    letter-spacing: 0.5px;
    line-height: 1;
    padding: 2px 10px 3px 10px;
    white-space: nowrap;
    color: var(--spectrum-alias-text-color);
    font-family: var(--Font-adobe-clean, "Adobe Clean");
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 150%; /* 21px */
  }
`;
var merchBadgeStyleSheet = new CSSStyleSheet();
merchBadgeStyleSheet.replaceSync(styles5);

// src/custom-elements/merch-card/merch-badge.js
var MerchBadge = class extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    this.shadowRoot.adoptedStyleSheets = [merchBadgeStyleSheet];
  }
  static get observedAttributes() {
    return ["color"];
  }
  connectedCallback() {
    this.render();
    if (!this.hasAttribute("color")) {
      this.setAttribute("color", "var(--spectrum-yellow-400)");
    }
  }
  attributeChangedCallback() {
    this.render();
  }
  render() {
    if (!this.isConnected) return;
    if (!this.shadowRoot) {
      return;
    }
    const color = this.getAttribute("color");
    this.shadowRoot.innerHTML = `
      <div class="badge" style="background-color: ${color};">
        <slot part="editor"></slot>
      </div>
    `;
  }
};
customElements.define("merch-badge", MerchBadge);

// src/custom-elements/merch-card/merch-badge.author.js
MerchBadge.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Badge",
        description: "Small status or category badge for highlighting important information",
        category: "indicators"
      },
      attributes: {
        color: makeSWCColorSchema({ label: "Badge Color", description: "Color override for the badge" })
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Badge Text",
            description: "Short text label for the badge",
            placeholder: "Badge",
            inlineEditable: true,
            allowLinks: true,
            multiline: false,
            plain: true,
            allowedStyles: [],
            allowedFormats: []
          }
        }
      }
    };
  },
  sanitize(el) {
    if (!el) return;
    const text = (el.textContent || "").trim();
    el.textContent = text.slice(0, 40);
    const color = el.getAttribute("color");
    if (color != null) {
      const trimmed = color.trim();
      if (!trimmed) el.removeAttribute("color");
      else el.setAttribute("color", trimmed);
    }
  },
  // Serialize element to JSON
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/merch-card/merch-callout.js
init_lit();

// src/custom-elements/merch-card/merch-callout.css.js
init_lit();
var styles6 = i`
  *, *::before, *::after {
    box-sizing: border-box;
  }
  
  :host {
    align-items: center;
    background: var(--spectrum-global-color-gray-100);
    border-radius: 4px;
    box-sizing: border-box;
    color: var(--spectrum-alias-text-color);
    display: flex;
    font-family: 'Adobe Clean', 'Segoe UI', Roboto, sans-serif;
    font-size: 14px;
    gap: 8px;
    padding: 8px 12px;
  }

  #icon {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    margin-left: auto;
  }

  /* Compose transform using numeric variables so output is always valid */
  #icon {
    transform:
      rotate(var(--ee-rotate, 0deg))
      scaleX(var(--ee-flipx, 1))
      scaleY(var(--ee-flipy, 1));
  }
  :host([rotate="90"])  { --ee-rotate: 90deg; }
  :host([rotate="180"]) { --ee-rotate: 180deg; }
  :host([rotate="270"]) { --ee-rotate: 270deg; }
  :host([flip-h]) { --ee-flipx: -1; }
  :host([flip-v]) { --ee-flipy: -1; }

  #icon svg {
    width: 1em;
    height: 1em;
  }
  #icon ::slotted(sp-icon-*) {
    display: inline-flex;
  }

  #content {
    flex: 1;
    line-height: 1.4;
  }

  ::slotted([slot="icon"]) {
    display: flex;
    align-items: center;
  }
`;

// src/custom-elements/merch-card/merch-callout.js
var MerchCallout = class extends i4 {
  static get properties() {
    return { ...iconTransformProperties };
  }
  static get styles() {
    return [styles6];
  }
  constructor() {
    super();
    this.name = "";
    this.size = "m";
    this.color = "";
    this.rotate = 0;
    this.flipH = false;
    this.flipV = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "note");
  }
  get iconTemplate() {
    const tag3 = (this.name || "").trim();
    const size3 = (this.size || "m").trim();
    if (tag3 && customElements.get(tag3)) {
      const T5 = s9(tag3);
      return u16`<${T5} size=${size3}></${T5}>`;
    }
    return x`<sp-icon-info size=${size3}></sp-icon-info>`;
  }
  render() {
    const iconStyle = this.color ? `color: ${this.color}` : "";
    return x`
      <div id="content">
        <slot part="editor"></slot>
      </div>
      <div id="icon" style=${iconStyle}>
        <slot name="icon" part="editor">${this.iconTemplate}</slot>
      </div>
    `;
  }
};
customElements.define("merch-callout", MerchCallout);

// src/custom-elements/merch-card/merch-callout.author.js
var textStyles2 = ["bold", "italic", "underline", "strikethrough"];
var alignFormats2 = ["align-left", "align-center", "align-right"];
MerchCallout.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Callout Message",
        description: "Highlighted callout message with icon for important information"
      },
      attributes: {
        "name": makeSWCIconNameSchema({
          defaultValue: "",
          label: "Icon",
          description: "Spectrum icon (leave empty to use default info icon)"
        }),
        "color": makeSWCColorSchema({
          defaultValue: "",
          label: "Icon Color",
          description: "Icon color (Spectrum token)"
        })
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Callout Text",
            description: "Short text label for the callout",
            placeholder: "Callout",
            inlineEditable: true,
            multiline: false,
            allowLinks: true,
            allowedStyles: [...textStyles2],
            allowedFormats: [...alignFormats2]
          }
        }
      }
    };
  },
  sanitize(el) {
    if (!el) return;
    const text = (el.textContent || "").trim();
    el.textContent = text.slice(0, 120);
    const iconName = (el.getAttribute("name") || "").trim();
    if (iconName && !customElements.get(iconName)) {
      el.removeAttribute("name");
    }
    const size3 = (el.getAttribute("size") || "m").trim();
    const ok = ["xxs", "xs", "s", "m", "l", "xl", "xxl"];
    el.setAttribute("size", ok.includes(size3) ? size3 : "m");
    const c33 = el.getAttribute("color");
    if (c33 != null && !String(c33).trim()) el.removeAttribute("color");
    const r25 = Number(el.getAttribute("rotate") || 0);
    const allowed = /* @__PURE__ */ new Set([0, 90, 180, 270]);
    el.setAttribute("rotate", allowed.has(r25) ? String(r25) : "0");
    ["flip-h", "flip-v"].forEach((attr) => {
      if (el.hasAttribute(attr)) {
        el.setAttribute(attr, "");
      }
    });
  },
  // Serialize element to JSON, aware of default text content only
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/merch-card/merch-card-compare.js
init_lit();

// src/custom-elements/merch-card/merch-card-compare.css.js
init_lit();
var styles7 = i`
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  :host {
    padding: 20px;
    background: var(--spectrum-alias-component-background-color);
    border-radius: 16px;
    border: 1px solid var(--spectrum-alias-border-color);
    box-shadow: 0 1px 3px
      color-mix(in srgb, var(--spectrum-global-color-gray-900) 10%, transparent);
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    font-family: "Adobe Clean", "Segoe UI", Roboto, sans-serif;
    margin: 0 auto;
    width: 379px;
    padding: 24px;
    position: relative;
  }

  /* Badge slot styling */
  slot[name="badge"] {
    display: block;
    position: absolute;
    top: 16px;
    right: 0;
  }

  /* Placeholder while loading */
  .card-placeholder {
    min-height: 400px;
    background: linear-gradient(
      90deg,
      var(--spectrum-global-color-gray-100) 25%,
      var(--spectrum-global-color-gray-50) 50%,
      var(--spectrum-global-color-gray-100) 75%
    );
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
  }

  @keyframes loading {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }

  /* Slot styling with min-height from CSS variables */
  slot[name="mnemonics"] {
    display: flex;
    gap: 4px;
    min-height: var(--mnemonics-height, auto);
  }

  slot[name="heading-xs"] {
    display: block;
    min-height: var(--heading-xs-height, 22px);
    margin-top: 16px;
  }

  slot[name="body-xxs"] {
    display: block;
    min-height: var(--body-xxs-height, auto);
    margin-top: 8px;
  }

  slot[name="price"] {
    display: block;
    min-height: var(--price-height, auto);
    margin-top: 16px;
  }

  slot[name="annual-price"] {
    display: block;
    min-height: var(--annual-price-height, auto);
    margin-top: 4px;
  }

  slot[name="legal-disclaimer"] {
    display: block;
    min-height: var(--legal-disclaimer-height, auto);
    margin-top: 4px;
  }

  slot[name="promo-text"] {
    display: block;
    min-height: var(--promo-text-height, auto);
    margin-top: 12px;
  }

  slot[name="body-xs"] {
    display: block;
    min-height: var(--body-xs-height, auto);
    margin-top: 12px;
    color: var(--spectrum-global-color-gray-900);
  }

  slot[name="callout"] {
    display: block;
    min-height: var(--callout-height, auto);
    margin-top: 16px;
  }

  slot[name="footer"] {
    display: flex;
    gap: 4px;
    min-height: var(--footer-height, auto);
    margin-top: 24px;
    margin-bottom: 16px;
    justify-content: flex-end;
    align-items: end;
  }

  slot[name="footer-list"] {
    display: block;
    min-height: var(--footer-list-height, auto);
  }

  ::slotted([slot="heading-xs"]) {
    font-size: 18px;
    font-weight: 700;
    color: var(--spectrum-global-color-gray-900);
    margin: 0;
  }

  ::slotted([slot="body-xxs"]) {
    font-size: 12px;
    font-weight: 400;
    color: var(--spectrum-global-color-gray-900);
    margin: 0;
  }

  ::slotted([slot="legal-disclaimer"]) {
    font-size: 12px;
    margin: 0;
    color: var(--spectrum-global-color-gray-900);
    line-height: 1.3;
  }

  ::slotted([slot="promo-text"]) {
    margin: 0;
    font-size: 14px;
    color: var(--spectrum-global-color-green-700);
    font-weight: 400;
  }

  ::slotted([slot="promo-text"]) a {
    color: var(--spectrum-global-color-blue-800);
    text-decoration: none;
  }

  ::slotted([slot="promo-text"]) a:hover {
    text-decoration: underline;
  }

  ::slotted([slot="body-xs"]) {
    font-size: 14px;
    line-height: 1.5;
    margin: 0;
  }

  ::slotted([slot="callout"]) {
    margin: 0;
  }

  ::slotted([slot="footer"]) {
    align-self: center;
  }

  ::slotted([slot="footer-list"]) {
    margin: 0;
    margin-top: auto;
    padding-top: 16px;
    border-top: 1px solid var(--spectrum-alias-border-color);
  }
`;
var globalSheet = new CSSStyleSheet();
globalSheet.replaceSync(`
  merch-card-compare p, merch-card-compare h3, merch-card-compare ul {
    margin: initial;
  }
`);
document.adoptedStyleSheets.push(globalSheet);

// src/custom-elements/merch-card/merch-card-compare.js
var cardObserver = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      entry.target.requestUpdate();
      cardObserver.unobserve(entry.target);
    }
  });
}, {
  rootMargin: "50px"
  // Start rendering 50px before entering viewport
});
var MerchCardCompare = class extends i4 {
  static styles = [styles7];
  static properties = {
    variant: { type: String }
  };
  constructor() {
    super();
    this.variant = "default";
    this.#jsonLdScript = null;
  }
  // Private state
  #jsonLdScript;
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "article");
    const scriptChildren = Array.from(this.children).filter(
      (child) => child.tagName === "SCRIPT"
    );
    if (scriptChildren.length > 1) {
      scriptChildren.forEach((script) => script.remove());
      this.#jsonLdScript = null;
    } else if (scriptChildren.length === 1) {
      this.#jsonLdScript = scriptChildren[0];
    }
    if (this.isVisible()) {
    } else {
      cardObserver.observe(this);
    }
    const slotNames = ["heading-xs", "body-xxs", "price", "annual-price", "legal-disclaimer", "promo-text", "body-xs", "footer"];
    slotNames.forEach((name) => {
      const slotEl = this.shadowRoot?.querySelector(`slot[name="${name}"]`);
      if (slotEl) {
        slotEl.addEventListener("slotchange", () => this.updateA11yAndJsonLd());
      }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    cardObserver.unobserve(this);
  }
  isVisible() {
    const rect = this.getBoundingClientRect();
    return rect.top < window.innerHeight && rect.bottom > 0;
  }
  firstUpdated() {
    this.updateSlotHeights();
    this.updateA11yAndJsonLd();
  }
  updated() {
    this.updateSlotHeights();
    this.updateA11yAndJsonLd();
  }
  render() {
    return x`
      <slot name="badge" part="editor"></slot>
      <slot name="mnemonics" part="editor"></slot>
      <slot name="heading-xs" part="editor"></slot>
      <slot name="body-xxs" part="editor"></slot>
      <slot name="price" part="editor"></slot>
      <slot
        name="annual-price"
        part="editor"
      ></slot>
      <slot
        name="legal-disclaimer"
        part="editor"
      ></slot>
      <slot name="promo-text" part="editor"></slot>
      <slot name="body-xs" part="editor"></slot>
      <slot name="callout" part="editor"></slot>
      <slot name="footer" part="editor"></slot>
      <slot name="footer-list" part="editor"></slot>
    `;
  }
  /**
   * Synchronizes the heights of list items across compare cards
   * @param {HTMLElement} merchList - The merch-list element containing items
   * @param {HTMLElement} parent - The parent element to set CSS variables on
   */
  syncListItemHeights(merchList, parent) {
    const listItems = merchList.querySelectorAll("merch-list-item");
    listItems.forEach((item, index) => {
      const itemStyles = window.getComputedStyle(item);
      const itemMarginTop = parseFloat(itemStyles.marginTop) || 0;
      const itemMarginBottom = parseFloat(itemStyles.marginBottom) || 0;
      const itemHeight = item.offsetHeight + itemMarginTop + itemMarginBottom;
      if (itemHeight > 0) {
        const varName = `--merch-list-item-${index}-height`;
        const currentValue = parseFloat(parent.style.getPropertyValue(varName)) || 0;
        if (itemHeight > currentValue) {
          parent.style.setProperty(varName, `${itemHeight}px`);
        }
        item.style.minHeight = `var(${varName})`;
      }
    });
  }
  updateSlotHeights() {
    const parent = this.parentElement;
    if (!parent) return;
    if (parent.getAttribute("resizing") !== "fill") return;
    const slots = [
      "badge",
      "mnemonics",
      "heading-xs",
      "body-xxs",
      "price",
      "annual-price",
      "legal-disclaimer",
      "promo-text",
      "body-xs",
      "callout",
      "footer",
      "footer-list"
    ];
    slots.forEach((slotName) => {
      const slot = this.shadowRoot?.querySelector(`slot[name="${slotName}"]`);
      if (!slot) return;
      const nodes2 = slot.assignedNodes();
      if (nodes2.length > 0) {
        let slotHeight = 0;
        nodes2.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const styles12 = window.getComputedStyle(node);
            const marginTop = parseFloat(styles12.marginTop) || 0;
            const marginBottom = parseFloat(styles12.marginBottom) || 0;
            const totalHeight = node.offsetHeight + marginTop + marginBottom;
            slotHeight = Math.max(slotHeight, totalHeight);
            if (slotName === "footer-list" && node.tagName === "MERCH-LIST") {
              this.syncListItemHeights(node, parent);
            }
          }
        });
        if (slotHeight > 0) {
          const currentValue = parseFloat(parent.style.getPropertyValue(`--${slotName}-height`)) || 0;
          if (slotHeight > currentValue) {
            parent.style.setProperty(`--${slotName}-height`, `${slotHeight}px`);
          }
        }
      }
    });
  }
  // Helper: map display currency to ISO 4217 code
  getCurrencyCode(symbol) {
    const map2 = {
      "US$": "USD",
      "$": "USD",
      "EUR": "EUR",
      "\u20AC": "EUR",
      "GBP": "GBP",
      "\xA3": "GBP",
      "JPY": "JPY",
      "\xA5": "JPY",
      "AUD": "AUD",
      "CAD": "CAD"
    };
    if (!symbol) return "USD";
    if (map2[symbol]) return map2[symbol];
    const letters = String(symbol).replace(/[^A-Za-z]/g, "").toUpperCase();
    return letters.length >= 3 ? letters.slice(0, 3) : "USD";
  }
  // Helper: get trimmed text from slotted light DOM nodes
  getSlotText(slotName) {
    const nodes2 = Array.from(this.querySelectorAll(`[slot="${slotName}"]`));
    const texts = nodes2.map((n25) => (n25.textContent || "").trim()).filter(Boolean);
    return texts.join(" ").replace(/\s+/g, " ").trim();
  }
  // Helper: ensure heading has id and return it
  ensureHeadingId() {
    let heading = this.querySelector('[slot="heading-xs"]');
    if (!heading && this.shadowRoot) {
      const slotEl = this.shadowRoot.querySelector('slot[name="heading-xs"]');
      if (slotEl) {
        const assigned = slotEl.assignedNodes();
        const textNodes = assigned.filter(
          (n25) => n25 && n25.nodeType === Node.TEXT_NODE && n25.textContent && n25.textContent.trim()
        );
        if (textNodes.length) {
          const wrapper = document.createElement("span");
          wrapper.setAttribute("slot", "heading-xs");
          wrapper.textContent = textNodes.map((n25) => n25.textContent).join(" ").replace(/\s+/g, " ").trim();
          const ref = textNodes[0];
          this.insertBefore(wrapper, ref);
          textNodes.forEach((n25) => n25.remove());
          heading = wrapper;
        }
      }
    }
    if (!heading) return null;
    return ensureId(heading, "mcc-title");
  }
  // Build and attach/update JSON-LD for this card
  updateJsonLd() {
    const name = this.getSlotText("heading-xs");
    const description = this.getSlotText("body-xs");
    const priceEl = this.querySelector('inline-price[slot="price"]');
    const annualEl = this.querySelector('inline-price[slot="annual-price"]');
    const buildOffer = (el, label) => {
      if (!el) return null;
      const price = el.getAttribute("value") || "";
      const currency = this.getCurrencyCode(el.getAttribute("currency"));
      const href = this.querySelector('checkout-button[slot="footer"][href]')?.getAttribute("href") || this.querySelector('a[slot="footer"][href]')?.getAttribute("href") || void 0;
      if (!price) return null;
      const offer = {
        "@type": "Offer",
        price,
        priceCurrency: currency
      };
      if (href) offer.url = href;
      if (label) offer.category = label;
      return offer;
    };
    const monthly = buildOffer(priceEl, "Monthly");
    const annual = buildOffer(annualEl, "Annual");
    let offers = null;
    if (monthly && annual) {
      offers = { "@type": "AggregateOffer", offers: [monthly, annual] };
    } else if (monthly) {
      offers = monthly;
    } else if (annual) {
      offers = annual;
    }
    if (!name || !offers) {
      if (this.#jsonLdScript && this.contains(this.#jsonLdScript)) {
        this.#jsonLdScript.remove();
      }
      this.#jsonLdScript = null;
      return;
    }
    const json = {
      "@context": "https://schema.org",
      "@type": "Product",
      name,
      ...description ? { description } : {},
      offers
    };
    const text = JSON.stringify(json);
    if (this.#jsonLdScript && this.contains(this.#jsonLdScript)) {
      this.#jsonLdScript.type = "application/ld+json";
      this.#jsonLdScript.setAttribute("data-ee-jsonld", "product-card");
      this.#jsonLdScript.textContent = text;
    } else {
      const s19 = document.createElement("script");
      s19.type = "application/ld+json";
      s19.setAttribute("data-ee-jsonld", "product-card");
      s19.textContent = text;
      this.appendChild(s19);
      this.#jsonLdScript = s19;
    }
  }
  // Update ARIA labeling and JSON-LD together
  updateA11yAndJsonLd() {
    const titleId = this.ensureHeadingId();
    if (titleId) {
      this.setAttribute("aria-labelledby", titleId);
      this.removeAttribute("aria-label");
    } else {
      const label = this.getSlotText("heading-xs") || "Comparison Card";
      this.setAttribute("aria-label", label);
      this.removeAttribute("aria-labelledby");
    }
    this.updateJsonLd();
  }
};
customElements.define("merch-card-compare", MerchCardCompare);

// src/custom-elements/merch-card/merch-card-compare.author.js
MerchCardCompare.ee = {
  getSchema() {
    const textStyles5 = ["bold", "italic", "underline", "strikethrough"];
    const alignFormats5 = ["align-left", "align-center", "align-right"];
    const listFormats2 = ["unordered-list", "ordered-list"];
    const slotConfigs = {
      badge: {
        label: "Badge",
        description: "Short badge text displayed at the top of the card",
        maxLength: 1,
        allowedTags: ["merch-badge"],
        minLength: 0,
        placeholder: 'e.g., "BEST VALUE"'
      },
      mnemonics: {
        label: "Product Icons",
        description: "Container for mnemonics",
        allowedTags: ["merch-mnemonic"],
        maxLength: 4,
        minLength: 0,
        placeholder: "Add mnemonics"
      },
      "heading-xs": {
        allowedFormats: [...alignFormats5],
        allowedStyles: ["bold", "italic", "underline"],
        allowLinks: false,
        description: "Main heading for the card",
        inlineEditable: true,
        tag: "h3",
        label: "Card Title",
        multiline: false,
        placeholder: "Enter card title"
      },
      "body-xxs": {
        label: "Subtitle",
        description: "Small subtitle text, typically used for pricing context",
        placeholder: 'e.g., "Starting at"',
        inlineEditable: true,
        tag: "span",
        allowedFormats: [],
        allowedStyles: [],
        allowLinks: false,
        allowPaste: false,
        multiline: false,
        plain: true
      },
      price: {
        label: "Primary Price",
        description: "Primary price display with optional inline text",
        // Allow formatted inline text before/after the inline-price component
        allowedTags: ["inline-price"],
        maxLength: 2,
        placeholder: "Add price and optional text"
      },
      "annual-price": {
        label: "Annual Price",
        description: "Annual price display (optional)",
        allowedTags: ["inline-price"],
        maxLength: 1,
        placeholder: "Add annual price"
      },
      "legal-disclaimer": {
        label: "Legal Disclaimer",
        description: "Legal text or pricing terms",
        inlineEditable: true,
        multiline: false,
        plain: true,
        placeholder: 'e.g., "Annual, paid monthly"'
      },
      "promo-text": {
        label: "Promotional Text",
        description: "Promotional or offer text with links",
        placeholder: "Enter promotional message",
        inlineEditable: true,
        allowedStyles: [],
        allowedFormats: [],
        allowLinks: true
      },
      "body-xs": {
        label: "Description",
        description: "Main body text with rich formatting support",
        placeholder: "Enter description",
        inlineEditable: true,
        allowedStyles: [...textStyles5],
        allowedFormats: [...alignFormats5, ...listFormats2],
        allowLinks: true,
        multiline: true
      },
      callout: {
        label: "Callout Message",
        allowedTags: ["merch-callout"],
        description: "Callout message component",
        maxLength: 1,
        minLength: 0,
        placeholder: "Add callout component"
      },
      footer: {
        label: "Action Buttons",
        description: "Container for CTA buttons",
        maxLength: 3,
        allowedTags: ["checkout-button", "sp-link", "a"],
        allowPaste: true,
        placeholder: "Add action buttons"
      },
      "footer-list": {
        label: "Footer List",
        description: "Feature list container with items",
        maxLength: 1,
        allowedTags: ["merch-list"],
        placeholder: "Add footer list"
      }
    };
    return {
      schemaVersion: 1,
      element: {
        label: "Comparison Card",
        description: "A card component for comparing products or plans with aligned slots for consistent comparison layouts"
      },
      attributes: {},
      slots: {
        order: Object.keys(slotConfigs),
        configs: slotConfigs
      }
    };
  },
  // Create a new instance with default values
  create() {
    const card = document.createElement("merch-card-compare");
    card.innerHTML = `
      <merch-badge slot="badge">Badge</merch-badge>
      <h3 slot="heading-xs">Heading</h3>
      <p slot="body-xxs">Starting at</p>
      <inline-price slot="price" value="0.00" currency="US$" period="mo"></inline-price>
      <div slot="body-xs">Description</div>
      <checkout-button slot="footer">Select</checkout-button>
    `;
    return card;
  },
  sanitize(el) {
    if (!el) return;
    const badges = Array.from(el.querySelectorAll('[slot="badge"]'));
    if (badges.length > 1) badges.slice(1).forEach((b12) => b12.remove());
    const headings = Array.from(el.querySelectorAll('[slot="heading-xs"]'));
    if (headings.length) {
      const [first, ...rest] = headings;
      rest.forEach((n25) => n25.remove());
      const firstTag = first.tagName?.toLowerCase?.();
      if (firstTag === "ee-reference") {
      } else if (firstTag !== "h3") {
        const h32 = document.createElement("h3");
        h32.setAttribute("slot", "heading-xs");
        const text = (first.textContent || "").trim();
        h32.textContent = text || "Heading";
        first.replaceWith(h32);
      }
    }
  },
  // Serialize element to JSON
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/merch-card/merch-cards-compare.js
init_lit();

// src/custom-elements/merch-card/merch-cards-compare.css.js
init_lit();
var styles8 = i`
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  :host {
    display: grid;
    gap: 16px;
    padding: 16px;
    min-width: 320px;
    min-height: 320px;
    width: fit-content;
    max-width: 100%;
    margin: 0 auto;
    font-family: "Adobe Clean", "Segoe UI", Roboto, sans-serif;
    box-sizing: border-box;
  }

  /* Default: 3 columns on desktop */
  @media (min-width: 1024px) {
    :host {
      grid-template-columns: repeat(var(--merch-cards-cols, 3), 379px);
      justify-content: center;
    }
  }

  /* Tablet: 2 columns */
  @media (min-width: 768px) and (max-width: 1023px) {
    :host {
      grid-template-columns: repeat(2, 379px);
    }
  }

  /* Mobile: single column, centered */
  @media (max-width: 767px) {
    :host {
      grid-template-columns: 379px;
      justify-content: center;
      padding: 8px;
    }
  }
`;

// src/custom-elements/merch-card/merch-cards-compare.js
var MerchCardsCompare = class extends i4 {
  static styles = [styles8];
  static properties = {
    resizing: { type: String, reflect: true }
  };
  constructor() {
    super();
    this.resizing = "hug";
  }
  connectedCallback() {
    super.connectedCallback();
  }
  firstUpdated() {
    const slot = this.shadowRoot.querySelector("slot");
    slot.addEventListener("slotchange", () => {
      this.updateChildCards();
      this.updateGridColumnCount();
    });
    this.updateChildCards();
    this.updateGridColumnCount();
  }
  clearCSSVariables() {
    const styles12 = this.style;
    const cssText = styles12.cssText;
    const varPattern = /--[\w-]+(?:-\d+)?-height/g;
    const matches3 = cssText.match(varPattern) || [];
    matches3.forEach((varName) => {
      styles12.removeProperty(varName);
    });
  }
  updateChildCards() {
    const slot = this.shadowRoot.querySelector("slot");
    const cards = slot.assignedElements().filter((el) => el.tagName === "MERCH-CARD-COMPARE");
    cards.forEach((card) => {
      if (card.requestUpdate) {
        card.requestUpdate();
      }
    });
  }
  updated(changedProperties) {
    if (changedProperties.has("resizing")) {
      this.updateChildCards();
    }
    this.updateGridColumnCount();
  }
  willUpdate() {
    this.clearCSSVariables();
  }
  render() {
    return x`<slot part="editor"></slot>`;
  }
  updateGridColumnCount() {
    const slot = this.shadowRoot.querySelector("slot");
    if (!slot) return;
    const directChildren = slot.assignedElements({ flatten: false }) || [];
    const count = Math.max(1, Math.min(3, directChildren.length || 0));
    this.style.setProperty("--merch-cards-cols", String(count));
  }
};
customElements.define("merch-cards-compare", MerchCardsCompare);

// src/custom-elements/merch-card/merch-cards-compare.author.js
MerchCardsCompare.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Compare Cards",
        description: "Container for multiple comparison cards with automatic layout and height synchronization"
      },
      attributes: {
        resizing: {
          type: "enum",
          options: ["hug", "fill"],
          default: "hug",
          label: "Resizing Mode",
          description: "How cards adapt to content: hug (natural height) or fill (synchronized heights)"
        }
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Comparison Cards",
            description: "Container for merch-card-compare elements (2-4 recommended)",
            maxLength: null,
            minLength: 2,
            placeholder: "Add comparison cards"
          }
        }
      }
    };
  },
  // Create a new instance with default values
  create() {
    const container = document.createElement("merch-cards-compare");
    const merchCardCompareElement = customElements.get("merch-card-compare");
    const createCard = merchCardCompareElement?.ee?.create;
    for (let i21 = 0; i21 < 3; i21++) {
      const card = createCard();
      container.appendChild(card);
    }
    return container;
  },
  sanitize(el) {
    if (!el) return;
    el.removeAttribute("id");
    el.removeAttribute("style");
    const preserveIds = /* @__PURE__ */ new Set();
    el.querySelectorAll('merch-card-compare [slot="heading-xs"][id]').forEach(
      (n25) => {
        const v6 = n25.getAttribute("id");
        if (v6) preserveIds.add(v6);
      }
    );
    el.querySelectorAll("merch-card-compare[aria-labelledby]").forEach(
      (card) => {
        const ref = card.getAttribute("aria-labelledby") || "";
        ref.split(/\s+/).filter(Boolean).forEach((id) => preserveIds.add(id));
      }
    );
    el.querySelectorAll("[aria-describedby]").forEach((host) => {
      const ref = host.getAttribute("aria-describedby") || "";
      ref.split(/\s+/).filter(Boolean).forEach((id) => preserveIds.add(id));
    });
    Array.from(el.querySelectorAll("[id]")).forEach((node) => {
      const id = node.getAttribute("id");
      if (!preserveIds.has(id)) node.removeAttribute("id");
    });
    Array.from(el.children).forEach((child) => {
      const tag3 = child.tagName?.toLowerCase?.() || "";
      if (tag3 === "ee-reference") return;
      if (tag3 !== "merch-card-compare") {
        child.remove();
      }
    });
  },
  // Serialize element to JSON
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/merch-card/merch-list-item.js
init_lit();

// src/custom-elements/merch-card/merch-list-item.css.js
init_lit();
var styles9 = i`
  *, *::before, *::after {
    box-sizing: border-box;
  }
  
  :host {
    display: block;
    font-family: 'Adobe Clean', 'Segoe UI', Roboto, sans-serif;
    box-sizing: border-box;
  }

  #item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 0;
    font-size: 14px;
    line-height: 1.5;
    color: var(--spectrum-alias-text-color);
  }

  #icon {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    color: var(--spectrum-global-color-green-700);
  }

  /* Compose transform with local or inherited rotate + flips via numeric variables */
  :host {
    /* Choose local values if present; otherwise inherited; provide numeric defaults */
    --ee-rotate-final: var(--ee-rotate-local, var(--ee-rotate-inherited, 0deg));
    --ee-flipx-final: var(--ee-flipx-local, var(--ee-flipx-inherited, 1));
    --ee-flipy-final: var(--ee-flipy-local, var(--ee-flipy-inherited, 1));
  }
  #icon {
    transform:
      rotate(var(--ee-rotate-final, 0deg))
      scaleX(var(--ee-flipx-final, 1))
      scaleY(var(--ee-flipy-final, 1));
  }
  /* Local attributes set local variables */
  :host([rotate="90"])  { --ee-rotate-local: 90deg; }
  :host([rotate="180"]) { --ee-rotate-local: 180deg; }
  :host([rotate="270"]) { --ee-rotate-local: 270deg; }
  :host([flip-h]) { --ee-flipx-local: -1; }
  :host([flip-v]) { --ee-flipy-local: -1; }
  /* Let Spectrum icon size control intrinsic svg size */

  #content {
    flex: 1;
  }

  #content ::slotted(a) {
    color: var(--spectrum-global-color-blue-600);
    text-decoration: underline;
  }

  #content ::slotted(a:hover) {
    color: var(--spectrum-global-color-blue-700);
  }

  ::slotted([slot="icon"]) {
    display: flex;
    align-items: center;
    color: inherit;
  }
`;

// src/custom-elements/merch-card/merch-list-item.js
var MerchListItem = class extends i4 {
  static styles = [styles9];
  static properties = {
    name: { type: String, attribute: "name", reflect: true },
    size: { type: String, attribute: "size", reflect: true },
    color: { type: String, attribute: "color", reflect: true },
    rotate: { type: Number, attribute: "rotate", reflect: true },
    flipH: { type: Boolean, attribute: "flip-h", reflect: true, converter: booleanConverter },
    flipV: { type: Boolean, attribute: "flip-v", reflect: true, converter: booleanConverter }
  };
  #iconDefaultsListener = null;
  #iconDefaultsSource = null;
  constructor() {
    super();
    this.name = "";
    this.size = "";
    this.color = "";
    this.rotate = null;
    this.flipH = null;
    this.flipV = null;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "listitem");
    this.#iconDefaultsListener = () => this.requestUpdate();
    this.#iconDefaultsSource = this.closest("merch-list");
    if (this.#iconDefaultsSource) {
      this.#iconDefaultsSource.addEventListener(
        "merch-list:icon-defaults-changed",
        this.#iconDefaultsListener
      );
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#iconDefaultsSource && this.#iconDefaultsListener) {
      this.#iconDefaultsSource.removeEventListener(
        "merch-list:icon-defaults-changed",
        this.#iconDefaultsListener
      );
    }
    this.#iconDefaultsSource = null;
    this.#iconDefaultsListener = null;
  }
  renderIcon() {
    const { name, size: size3, color } = this.resolveIconProps();
    if (!name) return E;
    const t34 = s9(name);
    const style = color ? color.startsWith("--") ? `color: var(${color})` : `color: ${color}` : null;
    return u16`<${t34} size=${size3 || E} style=${style || E}></${t34}>`;
  }
  render() {
    const iconTpl = this.renderIcon();
    return x`
      <div id="item">
        <div id="icon">
          <slot name="icon" part="editor">${iconTpl}</slot>
        </div>
        <div id="content">
          <slot part="editor"></slot>
        </div>
      </div>
    `;
  }
  resolveIconProps() {
    const parent = this.closest("merch-list");
    const localName = this.name || parent?.name;
    const localSize = this.size || parent?.size;
    const localColor = this.color || parent?.color;
    const localRotation = this.rotate != null && this.rotate !== "" ? this.rotate : parent?.rotate;
    return { name: localName, size: localSize, color: localColor, rotate: localRotation };
  }
};
customElements.define("merch-list-item", MerchListItem);

// src/custom-elements/merch-card/merch-list-item.author.js
MerchListItem.ee = {
  getSchema() {
    const textStyles5 = ["bold", "italic", "underline", "strikethrough"];
    return {
      schemaVersion: 1,
      element: {
        label: "List Item",
        description: "Feature or bullet list item with icon and text",
        allowBlank: false
      },
      attributes: {
        name: makeSWCIconNameSchema({
          defaultValue: "",
          description: "Inherit from list if empty",
          label: "Icon"
        }),
        color: makeSWCColorSchema({
          defaultValue: "",
          description: "Inherit from list if empty",
          label: "Color"
        })
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Item Text",
            description: "Inline editable list item content with formatting and links",
            inlineEditable: true,
            multiline: false,
            placeholder: "List item",
            allowedStyles: [...textStyles5],
            allowedFormats: [],
            allowLinks: true
          }
        }
      }
    };
  },
  // Create a new instance with default values
  create() {
    const item = document.createElement("merch-list-item");
    item.innerHTML = "<span>Unlimited creative assets</span>";
    return item;
  },
  sanitize(el) {
    ["name", "color", "size", "rotate", "flip-h", "flip-v"].forEach((a23) => {
      const v6 = el.getAttribute(a23);
      if (v6 != null && !String(v6).trim()) el.removeAttribute(a23);
    });
  },
  // Serialize element to JSON, preserving inline links and simple inline markup in default slot
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/merch-card/merch-list.js
init_lit();

// src/custom-elements/merch-card/merch-list.css.js
init_lit();
var styles10 = i`
  *, *::before, *::after {
    box-sizing: border-box;
  }
  
  :host {
    display: flex;
    flex-direction: column;
    gap: 8px;
    font-family: 'Adobe Clean', 'Segoe UI', Roboto, sans-serif;
    box-sizing: border-box;
  }

  slot[name="label"] {
    display: block;
  }

  ::slotted([slot="label"]) {
    display: block;
    font-size: 14px;
    font-weight: 700;
    color: var(--spectrum-alias-heading-text-color);
    text-transform: uppercase;
    letter-spacing: 0.02em;
    margin: 0;
  }
  
  ::slotted([slot="label"].body-xs) {
    font-size: 14px;
    line-height: 1.4;
  }
  
  ::slotted([slot="label"].bold) {
    font-weight: 700;
  }

  ::slotted(merch-list-item) {
    display: block;
  }

  /* Broadcast attributes to children via inherited custom properties */
  :host([rotate="90"]) { --ee-rotate-inherited: 90deg; }
  :host([rotate="180"]) { --ee-rotate-inherited: 180deg; }
  :host([rotate="270"]) { --ee-rotate-inherited: 270deg; }
  :host([flip-h]) { --ee-flipx-inherited: -1; }
  :host([flip-v]) { --ee-flipy-inherited: -1; }
`;

// src/custom-elements/merch-card/merch-list.js
var MerchList = class extends i4 {
  static styles = [styles10];
  static properties = { ...iconTransformProperties };
  constructor() {
    super();
    this.name = "sp-icon-checkmark";
    this.size = "";
    this.color = "";
    this.rotate = 0;
    this.flipH = false;
    this.flipV = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "list");
    this.updateAriaLabelling();
    const slotEl = this.shadowRoot?.querySelector('slot[name="label"]');
    if (slotEl) slotEl.addEventListener("slotchange", () => this.updateAriaLabelling());
  }
  updateAriaLabelling() {
    const labelEl = this.querySelector('[slot="label"]');
    if (labelEl) {
      this.setAttribute("aria-labelledby", ensureId(labelEl, "ml-label"));
    } else {
      this.removeAttribute("aria-labelledby");
    }
  }
  updated(changed) {
    if (changed.has("name") || changed.has("size") || changed.has("color") || changed.has("rotate") || changed.has("flipH") || changed.has("flipV")) {
      this.dispatchEvent(
        new CustomEvent("merch-list:icon-defaults-changed", {
          bubbles: true,
          composed: true
        })
      );
    }
    this.updateAriaLabelling();
  }
  render() {
    return x`
      <slot name="label" part="editor"></slot>
      <slot part="editor"></slot>
    `;
  }
};
customElements.define("merch-list", MerchList);

// src/custom-elements/merch-card/merch-list.author.js
var textStyles3 = ["bold", "italic", "underline", "strikethrough"];
var alignFormats3 = ["align-left", "align-center", "align-right"];
MerchList.ee = {
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "Feature List",
        description: "Container for feature or benefit list items"
      },
      attributes: {
        name: makeSWCIconNameSchema({
          defaultValue: "sp-icon-checkmark",
          label: "Default Icon Name"
        }),
        color: makeSWCColorSchema(
          { defaultValue: "", label: "Default Icon Color" },
          5
        ),
        size: makeSWCIconSizeSchema({
          defaultValue: "m",
          label: "Default Icon Size"
        })
      },
      slots: {
        order: ["label", "default"],
        configs: {
          label: {
            label: "Label",
            description: "Short label/title for the list",
            inlineEditable: true,
            multiline: false,
            allowedStyles: [...textStyles3],
            allowedFormats: [...alignFormats3],
            allowLinks: false,
            placeholder: "Add list label"
          },
          default: {
            label: "List Items",
            description: "Container for merch-list-item elements (default slot - no slot attribute needed)",
            maxLength: null,
            allowedTags: ["merch-list-item"],
            placeholder: "Add list items"
          }
        }
      }
    };
  },
  // Create a new instance with default values
  create() {
    const list = document.createElement("merch-list");
    const item1 = document.createElement("merch-list-item");
    item1.textContent = "100GB cloud storage";
    list.appendChild(item1);
    const item2 = document.createElement("merch-list-item");
    item2.textContent = "Access to premium templates";
    list.appendChild(item2);
    const item3 = document.createElement("merch-list-item");
    item3.textContent = "Advanced collaboration tools";
    list.appendChild(item3);
    return list;
  },
  sanitize(el, helpers = {}) {
    if (!el) return;
    el.removeAttribute("style");
    Array.from(el.children).forEach((child) => {
      if (child.tagName?.toLowerCase() !== "merch-list-item") return;
    });
    Array.from(el.childNodes).forEach((n25) => {
      if (n25.nodeType === Node.TEXT_NODE && !n25.textContent.trim()) n25.remove();
    });
    ["name", "color", "size", "rotate", "flip-h", "flip-v"].forEach((a23) => {
      const v6 = el.getAttribute(a23);
      if (v6 != null && !String(v6).trim()) el.removeAttribute(a23);
    });
  },
  // Serialize element to JSON, aware of 'label' slot and default list items
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/merch-card/merch-mnemonic.js
init_lit();

// src/custom-elements/merch-card/merch-mnemonic.css.js
init_lit();
var styles11 = i`
  :host {
    display: inline-block;
  }

  :host(not([icon-only])) {
    cursor: pointer;
  }

  img {
    display: block;
    width: var(--icon-size);
    height: var(--icon-size);
  }
  
  :host([size="xxs"]) { --icon-size: 12px; }
  :host([size="xs"]) { --icon-size: 14px; }
  :host([size="s"]) { --icon-size: 16px; }
  :host([size="m"]) { --icon-size: 27px; }
  :host([size="l"]), :host(:not([size])) { --icon-size: 40px; }
  
  :host([size="xl"]) {
    --icon-size: 48px;
  }
  
  :host([size="xxl"]) {
    --icon-size: 64px;
  }
`;

// src/custom-elements/merch-card/merch-mnemonic.js
var PRODUCT_MAP = {
  "creative-cloud": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/creative-cloud.svg",
    target: "https://www.adobe.com/creativecloud.html"
  },
  "acrobat-pro": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/acrobat-pro.svg",
    target: "https://www.adobe.com/acrobat.html"
  },
  "photoshop": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/photoshop.svg",
    target: "https://www.adobe.com/products/photoshop.html"
  },
  "premiere-pro": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/premiere-pro.svg",
    target: "https://www.adobe.com/products/premiere.html"
  },
  "illustrator": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/illustrator.svg",
    target: "https://www.adobe.com/products/illustrator.html"
  },
  "stock": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/stock.svg",
    target: "https://stock.adobe.com/"
  },
  "express": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/express.svg",
    target: "https://www.adobe.com/express/"
  },
  "firefly": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/firefly.svg",
    target: "https://www.adobe.com/sensei/generative-ai/firefly.html"
  },
  "after-effects": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/after-effects.svg",
    target: "https://www.adobe.com/products/aftereffects.html"
  },
  "lightroom": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/lightroom.svg",
    target: "https://www.adobe.com/products/photoshop-lightroom.html"
  },
  "indesign": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/indesign.svg",
    target: "https://www.adobe.com/products/indesign.html"
  },
  "animate": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/animate.svg",
    target: "https://www.adobe.com/products/animate.html"
  },
  "dreamweaver": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/dreamweaver.svg",
    target: "https://www.adobe.com/products/dreamweaver.html"
  },
  "substance-3d-stager": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/substance-3d-stager.svg",
    target: "https://www.adobe.com/products/substance3d-stager.html"
  },
  "substance-3d-painter": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/substance-3d-painter.svg",
    target: "https://www.adobe.com/products/substance3d-painter.html"
  },
  "substance-3d-sampler": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/substance-3d-sampler.svg",
    target: "https://www.adobe.com/products/substance3d-sampler.html"
  },
  "substance-3d-designer": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/substance-3d-designer.svg",
    target: "https://www.adobe.com/products/substance3d-designer.html"
  },
  "substance-3d-modeler": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/substance-3d-modeler.svg",
    target: "https://www.adobe.com/products/substance3d-modeler.html"
  },
  "audition": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/audition.svg",
    target: "https://www.adobe.com/products/audition.html"
  },
  "incopy": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/incopy.svg",
    target: "https://www.adobe.com/products/incopy.html"
  },
  "aero": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/aero.svg",
    target: "https://www.adobe.com/products/aero.html"
  },
  "photoshop-express": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/photoshop-express.svg",
    target: "https://www.adobe.com/photoshop/online/photo-editor.html"
  },
  "digital-editions": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/digital-editions.svg",
    target: "https://www.adobe.com/solutions/ebook/digital-editions.html"
  },
  "adobe-connect": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/adobe-connect.svg",
    target: "https://www.adobe.com/products/adobeconnect.html"
  },
  "design-to-print": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/design-to-print.svg",
    target: null
  },
  "coldfusion": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/coldfusion.svg",
    target: "https://www.adobe.com/products/coldfusion-family.html"
  },
  "presenter-video-express": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/presenter-video-express.svg",
    target: null
  },
  "framemaker-server": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/framemaker-server.svg",
    target: null
  },
  "http-dynamic-streaming": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/http-dynamic-streaming.svg",
    target: null
  },
  "captivate": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/captivate.svg",
    target: "https://www.adobe.com/products/captivate.html"
  },
  "media-server": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/media-server.svg",
    target: null
  },
  "fonts": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/fonts.svg",
    target: "https://fonts.adobe.com/"
  },
  "color": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/color.svg",
    target: "https://color.adobe.com/"
  },
  "photoshop-elements": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/photoshop-elements.svg",
    target: "https://www.adobe.com/products/photoshop-elements.html"
  },
  "premiere-elements": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/premiere-elements.svg",
    target: "https://www.adobe.com/products/premiere-elements.html"
  },
  "technical-communication-suite": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/technical-communication-suite.svg",
    target: null
  },
  "postscript": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/postscript.svg",
    target: null
  },
  "behance": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/behance.svg",
    target: "https://www.behance.net/"
  },
  "robohelp": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/robohelp.svg",
    target: "https://www.adobe.com/products/robohelp.html"
  },
  "fresco": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/fresco.svg",
    target: "https://www.adobe.com/products/fresco.html"
  },
  "lightroom-classic": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/lightroom-classic.svg",
    target: "https://www.adobe.com/products/photoshop-lightroom-classic.html"
  },
  "experience-platform": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/experience-platform.svg",
    target: "https://business.adobe.com/products/experience-platform/adobe-experience-platform.html"
  },
  "experience-cloud": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/experience-cloud.svg",
    target: "https://business.adobe.com/products/experience-cloud/overview.html"
  },
  "coldfusion-builder": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/coldfusion-builder.svg",
    target: null
  },
  "pdf-print-engine": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/pdf-print-engine.svg",
    target: null
  },
  "capture": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/capture.svg",
    target: null
  },
  "bridge": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/bridge.svg",
    target: "https://www.adobe.com/products/bridge.html"
  },
  "frame-io": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/frame-io.svg",
    target: "https://frame.io/"
  },
  "character-animator": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/character-animator.svg",
    target: "https://www.adobe.com/products/character-animator.html"
  },
  "media-encoder": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/media-encoder.svg",
    target: "https://www.adobe.com/products/media-encoder.html"
  },
  "acrobat-scan": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/acrobat-scan.svg",
    target: null
  },
  "framemaker": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/framemaker.svg",
    target: "https://www.adobe.com/products/framemaker.html"
  },
  "acrobat-sign": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/acrobat-sign.svg",
    target: "https://www.adobe.com/sign.html"
  },
  "indesign-server": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/indesign-server.svg",
    target: null
  },
  "portfolio": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/portfolio.svg",
    target: null
  },
  "acrobat-classic": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/acrobat-classic.svg",
    target: null
  },
  "default-app-icon": {
    icon: "https://www.adobe.com/cc-shared/assets/img/product-icons/svg/default-app-icon.svg",
    target: null
  }
};
var MerchMnemonic = class extends i4 {
  static get styles() {
    return [styles11];
  }
  static get properties() {
    return {
      name: { type: String, reflect: true },
      size: { type: String, reflect: true },
      href: { type: String, reflect: true },
      "icon-only": { type: Boolean, reflect: true, attribute: "icon-only", converter: booleanConverter }
    };
  }
  constructor() {
    super();
    this.name = "";
    this.size = "l";
    this.href = "";
    this["icon-only"] = false;
  }
  get product() {
    return PRODUCT_MAP[this.name];
  }
  get iconUrl() {
    return this.product ? this.product.icon : PRODUCT_MAP["default-app-icon"].icon;
  }
  get hasLink() {
    return this.href || this.product && this.product.target;
  }
  get targetUrl() {
    return this.href || this.product && this.product.target;
  }
  handleClick(event) {
    if (this.targetUrl) {
      event.preventDefault();
      window.open(this.targetUrl, "_blank", "noopener,noreferrer");
    }
  }
  render() {
    const img = x`
      <img 
        src="${this.iconUrl}" 
        alt="${this.name || "Adobe product"}" 
        loading="lazy"
        @click=${this["icon-only"] ? void 0 : this.handleClick}
      />
    `;
    if (this["icon-only"] || !this.hasLink) {
      return img;
    }
    return x`
      <a 
        href="${this.targetUrl}" 
        target="_blank" 
        rel="noopener noreferrer"
        @click=${this.handleClick}
      >
        ${img}
      </a>
    `;
  }
};
customElements.define("merch-mnemonic", MerchMnemonic);

// src/custom-elements/core/spectrum-product-palette.js
init_lit();
init_sp_popover();

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconApp.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/App.js
var AppIcon = ({ width: t34 = 24, height: l16 = 24, hidden: e36 = false, title: r25 = "App" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M13.25,18h-6.5c-2.61914,0-4.75-2.13086-4.75-4.75v-6.5c0-2.61914,2.13086-4.75,4.75-4.75h6.5c2.61914,0,4.75,2.13086,4.75,4.75v6.5c0,2.61914-2.13086,4.75-4.75,4.75ZM6.75,3.5c-1.79199,0-3.25,1.45801-3.25,3.25v6.5c0,1.79199,1.45801,3.25,3.25,3.25h6.5c1.79199,0,3.25-1.45801,3.25-3.25v-6.5c0-1.79199-1.45801-3.25-3.25-3.25h-6.5Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="M13.44043,12.72461l-2.75-6.5c-.23438-.55469-1.14648-.55469-1.38086,0l-2.75,6.5c-.16211.38086.0166.82129.39844.98242.37891.16602.82129-.0166.98242-.39844l.76538-1.80859h2.58838l.76538,1.80859c.12109.28613.39844.45801.69043.45801.09766,0,.19727-.01855.29199-.05957.38184-.16113.56055-.60156.39844-.98242ZM9.34033,10l.65967-1.55859.65967,1.55859h-1.31934Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/App.js
var AppIcon2 = ({ width: t34 = 24, height: a23 = 24, hidden: e36 = false, title: l16 = "App" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${a23}"
    viewBox="0 0 36 36"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M18.865 15.889q-.19-.61-.385-1.218-.19-.61-.353-1.176c-.106-.377-.201-.723-.288-1.036h-.021a17.472 17.472 0 0 1-.448 1.71c-.2.641-.404 1.296-.61 1.966q-.31 1.005-.61 1.86h3.377a43.973 43.973 0 0 0-.3-.963l-.362-1.143Z"
    />
    <path
      d="M27.2 2H8.8A6.8 6.8 0 0 0 2 8.8v18.4A6.8 6.8 0 0 0 8.8 34h18.4a6.8 6.8 0 0 0 6.8-6.8V8.8A6.8 6.8 0 0 0 27.2 2Zm-2.8 22h-2.778a.195.195 0 0 1-.212-.148l-1.092-3.165h-4.937l-1.004 3.121a.254.254 0 0 1-.258.192H11.62c-.142 0-.193-.078-.15-.235l4.274-12.312c.043-.127.087-.273.129-.438a4.41 4.41 0 0 0 .085-.865.134.134 0 0 1 .15-.15h3.398q.151 0 .171.108l4.852 13.68c.042.142 0 .212-.129.212Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconApp.js
var IconApp = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? AppIcon({ hidden: !this.label, title: this.label }) : AppIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-app.js
init_define_element();
defineElement("sp-icon-app", IconApp);

// src/custom-elements/core/spectrum-product-palette.js
var SpectrumProductPalette = class extends i4 {
  static properties = {
    name: { type: String, reflect: true },
    size: { type: String, reflect: true },
    products: { type: Array },
    // Editor store for direct updates (optional; resolves from editor context if not provided)
    store: { type: Object, attribute: false },
    // Attribute names to update on the current editing element
    nameAttr: { type: String, attribute: "name-attr" },
    sizeAttr: { type: String, attribute: "size-attr" }
  };
  static styles = i`
    :host {
      display: inline-block;
    }
    .panel {
      display: block;
      /* Prefer growing horizontally; clamp to viewport */
      width: max-content;
      max-width: min(90vw, 1280px);
      max-height: min(70vh, 720px);
      overflow: auto; /* last resort scroll */
      box-sizing: border-box;
    }
    .grid {
      display: grid;
      /* Fixed 6 columns for a wider popover */
      grid-template-columns: repeat(6, 84px);
      gap: 10px;
      padding: var(--spectrum-global-dimension-size-100);
      background-color: var(--spectrum-alias-component-background-color);
    }
    button.tile {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      width: 84px;
      height: 84px;
      padding: 6px 4px;
      border: 1px solid var(--spectrum-global-color-gray-300);
      background: var(--spectrum-global-color-gray-50);
      border-radius: var(--spectrum-global-dimension-size-100);
      cursor: pointer;
    }
    button.tile[aria-current="true"] {
      outline: 2px solid var(--spectrum-global-color-blue-600);
    }
    /* Prevent nested mnemonic from handling pointer events (no new tabs) */
    button.tile merch-mnemonic {
      pointer-events: none;
    }
    .name {
      max-width: 100%;
      text-align: center;
      font-size: 11px;
      color: var(--spectrum-alias-label-text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* Compact buttons in the size selector */
    sp-action-group {
      --swc-actionbutton-m-min-width: 0;
      padding: var(--spectrum-global-dimension-size-100);
      display: inline-flex;
      flex-wrap: wrap;
      gap: var(--spectrum-global-dimension-size-100);
    }
    sp-field-label {
      padding: var(--spectrum-global-dimension-size-100);
      padding-bottom: 0;
      display: inline-block;
    }
  `;
  constructor() {
    super();
    this.name = "";
    this.size = "m";
    this.products = [];
    this.nameAttr = "name";
    this.sizeAttr = "size";
  }
  handlePick(name) {
    this.name = name || "";
    this.applyToEditingElement("name");
  }
  handleSize(size3) {
    this.size = size3 || "m";
    this.applyToEditingElement("size");
  }
  renderTile(name) {
    const isCurrent = this.name === name;
    const title = name || "default-app-icon";
    return x`
      <button
        type="button"
        class="tile"
        aria-current=${isCurrent ? "true" : "false"}
        title=${title}
        aria-label=${title}
        @click=${{
      handleEvent: (e36) => {
        e36.preventDefault();
        e36.stopPropagation();
        this.handlePick(name);
      },
      capture: true
    }}
      >
        <merch-mnemonic icon-only size="l" name=${name}></merch-mnemonic>
        <div class="name">${title}</div>
      </button>
    `;
  }
  get previewIconTemplate() {
    const n25 = this.name;
    if (!n25) return x`<sp-icon-app slot="icon" size="m"></sp-icon-app>`;
    return x`<merch-mnemonic slot="icon" icon-only size="m" name=${n25} style="pointer-events: none;"></merch-mnemonic>`;
  }
  render() {
    const items = Array.isArray(this.products) ? this.products : [];
    return x`
      <overlay-trigger triggered-by="click hover" placement="bottom-start" offset="6">
        <sp-action-button slot="trigger" size="l" quiet title="Choose product icon" aria-label="Choose product icon">
          ${this.previewIconTemplate}
        </sp-action-button>
        <sp-popover slot="click-content" open>
          <div class="panel">
            <sp-field-label size="s">Size</sp-field-label>
            <sp-action-group
              quiet
              selects="single"
            @change=${(e36) => {
      e36.stopPropagation();
    }}
            @click=${(e36) => {
      e36.stopPropagation();
    }}
            >
              ${["xxs", "xs", "s", "m", "l", "xl", "xxl"].map((sz) => x`
                <sp-action-button
                  quiet
                  ?selected=${(this.size || "m") === sz}
                @click=${(e36) => {
      e36.stopPropagation();
      this.handleSize(sz);
    }}
                >${sz.toUpperCase()}</sp-action-button>
              `)}
            </sp-action-group>
            <div class="grid" role="grid" aria-label="Adobe products">
              ${items.map((name) => this.renderTile(name))}
            </div>
          </div>
        </sp-popover>
      </overlay-trigger>
    `;
  }
  // Apply current selection to the editor's selected element
  applyToEditingElement(what) {
    const store = this.store || (document.querySelector("experience-elements-editor")?.editorStore || null);
    const current = store?.editingElement || null;
    if (!current) return;
    const actions = store && (store.toolbarActions || store.toolbarActionsData) || null;
    const el = actions && actions.isSlotContent && actions.parentElement ? actions.parentElement : current;
    if (!what || what === "name") {
      const n25 = (this.name || "").trim();
      const a23 = this.nameAttr || "name";
      if (!n25) el.removeAttribute(a23);
      else el.setAttribute(a23, n25);
    }
    if (!what || what === "size") {
      const s19 = (this.size || "").trim();
      const a23 = this.sizeAttr || "size";
      if (!s19) el.removeAttribute(a23);
      else el.setAttribute(a23, s19);
    }
    store?.scheduleSnapshot?.();
  }
};
customElements.define("spectrum-product-palette", SpectrumProductPalette);

// src/custom-elements/merch-card/merch-mnemonic.author.js
var ADOBE_PRODUCTS = [
  "creative-cloud",
  "acrobat-pro",
  "photoshop",
  "premiere-pro",
  "illustrator",
  "stock",
  "express",
  "firefly",
  "after-effects",
  "lightroom",
  "indesign",
  "animate",
  "dreamweaver",
  "substance-3d-stager",
  "substance-3d-painter",
  "substance-3d-sampler",
  "substance-3d-designer",
  "substance-3d-modeler",
  "audition",
  "incopy",
  "aero",
  "photoshop-express",
  "digital-editions",
  "adobe-connect",
  "design-to-print",
  "coldfusion",
  "presenter-video-express",
  "framemaker-server",
  "http-dynamic-streaming",
  "captivate",
  "media-server",
  "fonts",
  "color",
  "photoshop-elements",
  "premiere-elements",
  "technical-communication-suite",
  "postscript",
  "behance",
  "robohelp",
  "fresco",
  "lightroom-classic",
  "experience-platform",
  "experience-cloud",
  "coldfusion-builder",
  "pdf-print-engine",
  "capture",
  "bridge",
  "frame-io",
  "character-animator",
  "media-encoder",
  "acrobat-scan",
  "framemaker",
  "acrobat-sign",
  "indesign-server",
  "portfolio",
  "acrobat-classic",
  "default-app-icon"
];
MerchMnemonic.ee = {
  getSchema(element) {
    return {
      schemaVersion: 1,
      element: {
        label: "Product Icon",
        description: "Adobe product icon mnemonic with optional link",
        allowBlank: false
      },
      attributes: {
        name: {
          // Popover palette showing real product icons
          type: "popover",
          default: "creative-cloud",
          label: "Product Name",
          description: "Adobe product to display",
          render: ({ html, value, onChange, read, updateAttribute }) => {
            const sz = read && read("size") || "m";
            return html`<spectrum-product-palette
              .name=${value}
              .size=${sz}
              .products=${ADOBE_PRODUCTS}
              @change=${(e36) => onChange(e36.detail?.name ?? e36.detail?.value)}
              @size-change=${(e36) => updateAttribute && updateAttribute("size", e36.detail?.size)}
            ></spectrum-product-palette>`;
          }
        },
        "icon-only": {
          type: "boolean",
          default: false,
          label: "Disable link",
          description: "Display icon without wrapping link element"
        },
        href: {
          type: "text",
          default: "",
          label: "Custom Link URL",
          description: "Override the default product link (optional)",
          placeholder: "Override link",
          // Hide when icon-only is enabled. Receives the live element.
          evaluate: ({ element: element2 }) => {
            const el = element2;
            const iconOnly = !!el && el.hasAttribute && el.hasAttribute("icon-only");
            return { render: !iconOnly };
          }
        }
      },
      slots: { order: [], configs: {} }
    };
  },
  // Optional icon for tree/listing
  getElementIcon(html) {
    return html`<sp-icon-app
      size="l"
      name="Product Icon"
      style="color: var(--spectrum-global-color-red-900)"
    ></sp-icon-app>`;
  },
  // Create a new instance with default values
  create() {
    const mnemonic = document.createElement("merch-mnemonic");
    mnemonic.setAttribute("name", "default-app-icon");
    mnemonic.setAttribute("size", "l");
    return mnemonic;
  },
  sanitize(el) {
    if (!el) return;
    const allowed = new Set(ADOBE_PRODUCTS);
    const sizeOk = /* @__PURE__ */ new Set(["xxs", "xs", "s", "m", "l", "xl", "xxl"]);
    const name = (el.getAttribute("name") || el.getAttribute("product") || "").trim();
    el.setAttribute("name", allowed.has(name) ? name : "creative-cloud");
    const size3 = (el.getAttribute("size") || "l").trim().toLowerCase();
    el.setAttribute("size", sizeOk.has(size3) ? size3 : "l");
    const href = el.getAttribute("href");
    if (href != null && !String(href).trim()) el.removeAttribute("href");
  },
  // Serialize element to JSON (no slots; attributes only)
  toJson(el, serializeNode) {
    const schema2 = this.getSchema(el);
    return makeToJson(el, schema2, serializeNode);
  }
};

// src/custom-elements/merch-card/merch-card.library.js
var LIBRARY_ID4 = "merch-card";
function register4({
  registerLibrary: registerLibrary2,
  registerElement: registerElement2,
  LibraryLevel: LibraryLevel2
}) {
  registerLibrary2({
    id: LIBRARY_ID4,
    level: LibraryLevel2.ORG,
    name: "M@S",
    description: "Composable merchandising cards and supporting building blocks."
  });
  [
    "merch-card-compare",
    "merch-cards-compare",
    "merch-callout",
    "merch-list",
    "merch-list-item",
    "merch-badge",
    "merch-mnemonic"
  ].forEach((tag3) => registerElement2(LIBRARY_ID4, tag3));
}

// src/custom-elements/acom/acom-hero-marquee.js
init_lit();

// src/custom-elements/acom/acom-hero-marquee.css.js
init_lit();
var acomHeroMarqueeStyleSheet = i`
  :host {
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
    position: relative;
    overflow: hidden;
    width: 100%;
    padding: 56px 4px;
    gap: var(--spectrum-global-dimension-size-600);
    background: var(--acom-hero-marquee-background, transparent);
  }

  sp-theme {
    display: contents;
  }

  .background {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: -1;
  }

  .background-layer {
    position: absolute;
    inset: 0;
    display: none;
  }

  .background-layer--default {
    display: block;
  }

  .background-layer::slotted(*) {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  :host(:not([data-has-background])) .background {
    display: none;
  }

  @media (max-width: 599px) {
    :host([data-has-background-mobile]) .background-layer--default {
      display: none;
    }

    :host([data-has-background-mobile]) .background-layer--mobile {
      display: block;
    }
  }

  @media (min-width: 600px) and (max-width: 1023px) {
    :host([data-has-background-tablet]) .background-layer--default {
      display: none;
    }

    :host([data-has-background-tablet]) .background-layer--tablet {
      display: block;
    }
  }

  .copy {
    display: flex;
    flex-direction: column;
    max-width: 36rem;
    position: relative;
    flex: 1;

  }

  .lockup {
    display: inline-flex;
    gap: var(--spectrum-global-dimension-size-200);
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: var(--spectrum-global-dimension-size-150);
  }

  slot[name='lockup']::slotted(merch-mnemonic) {
    display: block;
    width: var(--spectrum-global-dimension-size-600);
    height: var(--spectrum-global-dimension-size-600);
  }

  slot[name='lockup-label']::slotted(*) {
    margin: 0;
    font-size: var(--spectrum-body-l-font-size, 1.125rem);
    font-weight: 700;
    line-height: var(--spectrum-body-l-line-height, 1.5);
    color: var(--spectrum-body-color);
  }

  slot[name='heading']::slotted(*) {
    margin: 0;
    font-size: var(--spectrum-heading-xxl-font-size, 2.75rem);
    line-height: var(--spectrum-heading-xxl-line-height, 1.25);
    font-weight: 800;
    letter-spacing: -0.01em;
    margin-bottom: var(--spectrum-global-dimension-size-300);
    color: var(--spectrum-body-color);
  }

  slot[name='body'],
  slot:not([name]) {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-200);
    font-size: var(--spectrum-body-l-font-size, 1.125rem);
    line-height: var(--spectrum-body-l-line-height, 1.5);
    font-weight: 400;
    margin-bottom: var(--spectrum-global-dimension-size-250);
    color: var(--spectrum-body-color);
  }

  slot[name='body']::slotted(*),
  slot:not([name])::slotted(*) {
    margin: 0;
  }

  slot[name='actions'] {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-300);
    align-items: flex-start;
    margin-bottom: var(--spectrum-global-dimension-size-300);
  }

  @media (min-width: 600px) {
    slot[name='actions'] {
      flex-direction: row;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-start;
      gap: 12px;
    }

    slot[name='actions']::slotted(*) {
      flex: 0 0 auto;
    }

    slot[name='actions']::slotted(sp-button),
    slot[name='actions']::slotted(checkout-button) {
      --mod-button-border-radius: 25px;
      --mod-button-font-size: 19px;
      --mod-button-font-weight: 700;
      --mod-button-line-height: 24px;
      --mod-button-spacing-label-to-edge-default: 24px;
      --mod-button-min-height: 44px;
    }
  }

  slot[name='supporting'] {
    display: block;
    font-size: var(--spectrum-body-s-font-size, 0.875rem);
    line-height: var(--spectrum-body-s-line-height, 1.5);
    color: var(--spectrum-body-color);
  }

  slot[name='supporting']::slotted(*) {
    margin: 0;
  }

  .media {
    position: relative;
    border-radius: var(--spectrum-global-dimension-size-200);
    overflow: hidden;
    isolation: isolate;
    flex: 1;
    align-self: stretch;
    display: flex;
  }

  .media slot[name='media'] {
    display: block;
    height: 100%;
    width: 100%;
  }

  /* When using ee-media, it handles its own aspect ratio and padding */
  .media slot[name='media']::slotted(ee-media) {
    width: 100%;
    height: 100%;
    display: block;
    --ee-media-radius: var(--spectrum-global-dimension-size-200);
  }

  /* Fallback for other media types */
  .media:not(:has(ee-media))::before {
    content: '';
    display: block;
    padding-bottom: 56.25%;
  }

  .media slot[name='media']::slotted(*:not(ee-media)) {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  @media (min-width: 900px) {
    :host {
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: var(--spectrum-global-dimension-size-800);
    }

    .copy {
      flex: 1;
      max-width: 550px;
    }

    .media {
      flex: 1;
      max-width: 600px;
    }

    slot[name='heading']::slotted(*) {
      font-size: var(--spectrum-heading-xxxl-font-size, 3.5rem);
      line-height: var(--spectrum-heading-xxxl-line-height, 1.15);
    }

    :host([media-align='left']) .copy {
      order: 2;
    }

    :host([media-align='left']) .media {
      order: 1;
    }

    :host([media-align='right']) .copy {
      order: 1;
    }

    :host([media-align='right']) .media {
      order: 2;
    }
  }
`;

// src/custom-elements/acom/acom-hero-marquee.js
var DEFAULT_BACKGROUND = "transparent";
var AcomHeroMarquee = class extends i4 {
  static styles = [acomHeroMarqueeStyleSheet];
  static properties = {
    theme: { type: String, reflect: true },
    mediaAlign: { type: String, attribute: "media-align", reflect: true },
    backgroundColor: { type: String, attribute: "background-color" },
    padding: { type: String },
    mediaAspect: { type: String, attribute: "media-aspect" },
    mediaRadius: { type: String, attribute: "media-radius" },
    scale: { type: String, reflect: true }
  };
  #slotObservers;
  #sectionLabelId;
  constructor() {
    super();
    this.theme = "";
    this.mediaAlign = "right";
    this.backgroundColor = DEFAULT_BACKGROUND;
    this.mediaRadius = "var(--spectrum-global-dimension-size-200)";
    this.scale = "";
    this.#slotObservers = [];
    this.#sectionLabelId = null;
    ensureId(this, "acom-hero-marquee");
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.scale) {
      this.scale = this.closest("sp-theme")?.getAttribute("scale") || document.querySelector("sp-theme")?.getAttribute("scale") || "medium";
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    disconnectSlotObservers(this.#slotObservers);
  }
  firstUpdated() {
    const watchedSlots = [
      "lockup",
      "lockup-label",
      "heading",
      "body",
      "",
      "actions",
      "supporting",
      "media",
      "background",
      "background-mobile",
      "background-tablet"
    ];
    this.#slotObservers = observeSlots(this, watchedSlots, () => {
      this.#syncBackgroundFlags();
      this.#updateAccessibility();
    });
    this.#syncBackgroundFlags();
    this.#updateAccessibility();
  }
  updated(changed) {
    if (changed.has("theme")) {
      this.#normalizeTheme();
    }
    if (changed.has("mediaAlign")) {
      this.#normalizeMediaAlign();
    }
    this.#syncBackgroundFlags();
    this.#updateAccessibility();
    this.#syncHostStyles();
  }
  render() {
    const hasLockup = this.#hasSlot("lockup") || this.#hasSlot("lockup-label");
    const lockupTemplate = hasLockup ? x`
          <div class="lockup" id="${this.id}-lockup">
            <slot name="lockup"></slot>
            <slot name="lockup-label"></slot>
          </div>
        ` : E;
    const marqueeContent = x`
      ${this.#renderBackgroundLayers() || E}
      <div class="copy" id="${this.id}-copy">
        ${lockupTemplate}
        <slot name="heading"></slot>
        <slot></slot>
        <slot name="body"></slot>
        <slot name="actions"></slot>
        <slot name="supporting"></slot>
      </div>
      <div class="media" id="${this.id}-media">
        <slot name="media"></slot>
      </div>
    `;
    if (this.theme === "dark" || this.theme === "light") {
      return x`
        <sp-theme color="${this.theme}" scale="${this.scale}" system="spectrum-two">
          ${marqueeContent}
        </sp-theme>
      `;
    }
    return marqueeContent;
  }
  #syncHostStyles() {
    const backgroundValue = normalizeBackgroundValue(
      this.backgroundColor,
      DEFAULT_BACKGROUND
    );
    this.style.setProperty("--acom-hero-marquee-background", backgroundValue || "");
  }
  #normalizeTheme() {
    this.theme = normalizeTheme(this.theme);
  }
  #normalizeMediaAlign() {
    if (this.mediaAlign !== "left" && this.mediaAlign !== "right") {
      this.mediaAlign = "right";
    }
  }
  #renderBackgroundLayers() {
    const layers = [
      { slot: "background", className: "default" },
      { slot: "background-mobile", className: "mobile" },
      { slot: "background-tablet", className: "tablet" }
    ];
    const active = layers.filter((layer) => this.#hasSlot(layer.slot));
    if (!active.length) {
      return null;
    }
    return x`
      <div class="background" aria-hidden="true">
        ${active.map(
      (layer) => x`
            <slot name=${layer.slot} class="background-layer background-layer--${layer.className}"></slot>
          `
    )}
      </div>
    `;
  }
  #hasSlot(name) {
    if (name) {
      return this.querySelector(`[slot="${name}"]`) !== null;
    }
    return Array.from(this.childNodes).some(
      (node) => node.nodeType === Node.ELEMENT_NODE && !node.hasAttribute("slot")
    );
  }
  #syncBackgroundFlags() {
    const hasDefault = this.#hasSlot("background");
    const hasMobile = this.#hasSlot("background-mobile");
    const hasTablet = this.#hasSlot("background-tablet");
    const hasAny = hasDefault || hasMobile || hasTablet;
    this.toggleAttribute("data-has-background", hasAny);
    this.toggleAttribute("data-has-background-mobile", hasMobile);
    this.toggleAttribute("data-has-background-tablet", hasTablet);
  }
  #updateAccessibility() {
    this.#sectionLabelId = updateRegionAccessibility({
      host: this,
      container: this,
      headingSlot: "heading",
      fallbackLabel: "Featured hero section",
      idPrefix: `${this.id}-heading`
    });
  }
};
customElements.define("acom-hero-marquee", AcomHeroMarquee);

// src/custom-elements/acom/acom-hero-marquee.author.js
var HERO_MARQUEE_SLOTS = /* @__PURE__ */ new Set([
  "",
  "lockup",
  "lockup-label",
  "heading",
  "body",
  "actions",
  "supporting",
  "media",
  "background",
  "background-mobile",
  "background-tablet"
]);
var TEXT_STYLES4 = ["bold", "italic", "underline"];
var TEXT_FORMATS = ["align-left", "align-center", "align-right", "unordered-list", "ordered-list"];
AcomHeroMarquee.ee = {
  getElementIcon(html) {
    return html`<sp-icon-app slot="icon"></sp-icon-app>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Hero Marquee",
        description: "Primary hero with product lockup, heavy headline, and managed media integration.",
        category: "hero",
        allowBlank: true
      },
      attributes: {
        theme: {
          type: "enum",
          options: ["", "light", "dark"],
          default: "",
          label: "Theme",
          description: "Switch text treatment for light or dark backgrounds.",
          allowEmpty: true
        },
        "media-align": {
          type: "enum",
          options: ["left", "right"],
          default: "right",
          label: "Media Alignment",
          description: "Side for media on desktop (Split 50/50)."
        },
        "background-color": makeSWCColorSchema({
          label: "Background Fill",
          description: "Solid color or gradient behind the marquee.",
          attr: "background-color",
          allowGradient: true
        }),
        padding: {
          type: "text",
          default: "var(--spectrum-global-dimension-size-900) var(--spectrum-global-dimension-size-500)",
          label: "Wrapper Padding",
          description: "Supports Spectrum tokens or CSS values."
        },
        "media-aspect": {
          type: "text",
          default: "16:9",
          label: "Custom Aspect Ratio",
          description: "Used only if not using ee-media (e.g., 16:9 or 56.25%)."
        },
        "media-radius": {
          type: "text",
          default: "var(--spectrum-global-dimension-size-200)",
          label: "Media Corners",
          description: "Border radius for the media area."
        }
      },
      slots: {
        order: [
          "lockup",
          "lockup-label",
          "heading",
          "body",
          "",
          "actions",
          "supporting",
          "media",
          "background",
          "background-mobile",
          "background-tablet"
        ],
        configs: {
          lockup: {
            label: "Product Icon",
            description: "Use merch-mnemonic for product branding.",
            minLength: 0,
            maxLength: 1,
            allowedTags: ["merch-mnemonic"]
          },
          "lockup-label": {
            label: "Product Name",
            description: "Label appearing next to the product icon.",
            minLength: 0,
            maxLength: 1,
            inlineEditable: true,
            allowedStyles: [...TEXT_STYLES4],
            placeholder: "e.g. Photoshop"
          },
          heading: {
            label: "Marquee Headline",
            description: "Bold 44px headline.",
            minLength: 1,
            maxLength: 1,
            inlineEditable: true,
            allowedStyles: [...TEXT_STYLES4],
            placeholder: "Enter headline",
            tag: "h1"
          },
          body: {
            label: "Intro Description",
            description: "Primary supporting narrative (20px).",
            minLength: 0,
            maxLength: null,
            inlineEditable: true,
            multiline: true,
            allowedStyles: [...TEXT_STYLES4],
            allowedFormats: [...TEXT_FORMATS],
            allowLinks: true,
            linkRequired: false,
            placeholder: "Add intro description"
          },
          "": {
            label: "Extra Content",
            description: "Additional paragraphs before CTAs.",
            minLength: 0,
            maxLength: null,
            inlineEditable: true,
            multiline: true,
            allowedStyles: [...TEXT_STYLES4],
            allowedFormats: [...TEXT_FORMATS],
            allowLinks: true,
            placeholder: "Add extra content if needed"
          },
          actions: {
            label: "Primary Actions",
            description: "Buy now and Free trial buttons.",
            minLength: 0,
            allowedTags: ["checkout-button", "sp-button"],
            allowPaste: true,
            maxLength: 2
          },
          supporting: {
            label: "Secondary Links",
            description: "Footnote or supplemental business links.",
            minLength: 0,
            maxLength: null,
            inlineEditable: true,
            multiline: true,
            allowedStyles: [...TEXT_STYLES4],
            allowedFormats: [...TEXT_FORMATS],
            allowLinks: true,
            placeholder: "Add supplemental links"
          },
          media: {
            label: "Managed Media",
            description: "Auto-playing video via ee-media or static imagery.",
            minLength: 0,
            maxLength: 1,
            allowedTags: ["ee-media", "video", "img", "picture"]
          },
          background: {
            label: "Background",
            description: "Fallback background element.",
            minLength: 0,
            maxLength: 1
          },
          "background-mobile": {
            label: "Mobile BG",
            description: "Breakpoint-specific background.",
            minLength: 0,
            maxLength: 1
          },
          "background-tablet": {
            label: "Tablet BG",
            description: "Breakpoint-specific background.",
            minLength: 0,
            maxLength: 1
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-hero-marquee>
        <merch-mnemonic slot="lockup" name="photoshop" size="l"></merch-mnemonic>
        <span slot="lockup-label">Photoshop</span>
        <h1 slot="heading">Work smarter and faster in Photoshop.</h1>
        <div slot="body">
          <p>Generative AI and partner integrations help you remove distractions, blend scenes, and ideate faster than ever. Starting at <ee-content inline><inline-price value="22.99" currency="US$" period="mo"></inline-price></ee-content></p>
        </div>
        <checkout-button slot="actions" variant="accent" size="l" href="https://www.adobe.com/creativecloud/plans.html?plan=individual&amp;filter=all">Buy now</checkout-button>
        <checkout-button slot="actions" variant="secondary" size="l" href="https://commerce.adobe.com/store/segmentation?cli=mini_plans&amp;ctx=if&amp;co=US&amp;lang=en&amp;ms=COM&amp;ot=TRIAL&amp;cs=INDIVIDUAL&amp;pa=phsp_direct_individual&amp;rtc=t&amp;lo=sl&amp;af=uc_new_user_iframe%2Cuc_new_system_close">Free trial</checkout-button>
        <p slot="supporting">Browse plans for <a href="https://www.adobe.com/creativecloud/business/teams/photoshop.html">businesses</a> or <a href="https://www.adobe.com/creativecloud/buy/students.html">students and teachers</a>.</p>
        <ee-media slot="media" src="https://www.adobe.com/creativecloud/media_144f0767f767e2c5ec1fe47834c64f876a55f20e5.mp4" poster="https://www.adobe.com/creativecloud/media_1c97b086fb69ba9a23d43c94d5c27d31e60f9f317.jpg?width=1600&amp;format=webply&amp;optimize=medium"></ee-media>
      </acom-hero-marquee>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    Array.from(element.children).forEach((child) => {
      const slot = child.getAttribute("slot") || "";
      if (!HERO_MARQUEE_SLOTS.has(slot)) {
        child.removeAttribute("slot");
        return;
      }
      if (slot === "lockup" && child.tagName !== "MERCH-MNEMONIC") {
        child.removeAttribute("slot");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPanel.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Panel.js
var PanelIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: h16 = "Panel" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${h16}"
  >
    <rect height="3" rx="1" ry="1" width="16" x="10" y="30" />
    <rect height="3" rx="1" ry="1" width="16" x="10" y="8" />
    <rect height="3" rx="1" ry="1" width="16" x="10" y="14" />
    <path
      d="M30.5 2h-25A1.5 1.5 0 0 0 4 3.5V34h2v-8h24v8h2V3.5A1.5 1.5 0 0 0 30.5 2ZM30 22H6V4h24Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconPanel.js
var IconPanel = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? PanelIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-panel.js
init_define_element();
defineElement("sp-icon-panel", IconPanel);

// src/custom-elements/acom/acom-aside.js
init_lit();
init_style_map2();

// src/custom-elements/acom/acom-aside.css.js
init_lit();
var acomAsideStyleSheet = i`
  :host {
    display: block;
    box-sizing: border-box;
    background: var(--acom-aside-background, transparent);
    border-radius: var(--spectrum-global-dimension-size-100);
    font-family: var(--spectrum-alias-body-text-font-family, var(--spectrum-global-font-family-base, "Adobe Clean", "Helvetica Neue", Helvetica, Arial, sans-serif));
    font-size: var(--spectrum-alias-body-text-font-size, var(--spectrum-global-dimension-font-size-200, 1rem));
    line-height: var(--spectrum-alias-body-text-line-height, 1.5);
    --acom-aside-padding-block: var(--spectrum-global-dimension-size-600);
    --acom-aside-padding-inline: var(--spectrum-global-dimension-size-500);
    --acom-aside-layout-gap: var(--spectrum-global-dimension-size-400);
    --acom-aside-column-gap: 100px;
    --acom-aside-text-gap: var(--spectrum-global-dimension-size-200);
    --acom-aside-body-gap: var(--spectrum-global-dimension-size-200);
    --acom-aside-text-max-width: 28rem;
    --acom-aside-media-max-size: 500px;
    --acom-aside-content-max-width: 1200px;
  }

  :host([hidden]) {
    display: none !important;
  }

  sp-theme {
    display: block;
    border-radius: inherit;
  }

  article {
    position: relative;
    display: grid;
    gap: var(--acom-aside-layout-gap);
    padding-block: var(--acom-aside-padding-block);
    padding-inline: var(--acom-aside-padding-inline);
    box-sizing: border-box;
    overflow: hidden;
    color: var(--spectrum-body-color);
  }

  :host([variant="small"]) {
    --acom-aside-padding-block: var(--spectrum-global-dimension-size-400);
    --acom-aside-padding-inline: var(--spectrum-global-dimension-size-300);
    --acom-aside-layout-gap: var(--spectrum-global-dimension-size-300);
  }

  :host([variant="medium"]) {
    --acom-aside-padding-block: var(--spectrum-global-dimension-size-500);
    --acom-aside-padding-inline: var(--spectrum-global-dimension-size-500);
  }

  :host([variant="large"]) {
    --acom-aside-padding-block: var(--spectrum-global-dimension-size-700);
    --acom-aside-padding-inline: var(--spectrum-global-dimension-size-600);
    --acom-aside-layout-gap: var(--spectrum-global-dimension-size-500);
  }

  .aside-layout {
    display: grid;
    row-gap: var(--acom-aside-layout-gap);
    column-gap: var(--acom-aside-column-gap, 100px);
    align-items: center;
    justify-items: center;
    align-content: center;
    justify-content: center;
    grid-template-columns: minmax(0, 1fr);
    width: min(100%, var(--acom-aside-content-max-width, 1200px));
    margin-inline: auto;
  }

  :host([media-position="top"]) .aside-layout,
  :host([media-position="bottom"]) .aside-layout,
  :host([media-position="none"]) .aside-layout {
    grid-template-columns: minmax(0, 1fr);
  }

  @media (min-width: 900px) {
    :host([media-position="left"]:not([media-stacked])) .aside-layout {
      grid-template-columns:
        minmax(0, 1fr)
        minmax(0, var(--acom-aside-text-max-width, 28rem));
    }

    :host([media-position="right"]:not([media-stacked])) .aside-layout {
      grid-template-columns:
        minmax(0, var(--acom-aside-text-max-width, 28rem))
        minmax(0, 1fr);
    }

    :host([media-position="left"]:not([media-stacked])) .aside-text,
    :host([media-position="right"]:not([media-stacked])) .aside-text {
      max-width: var(--acom-aside-text-max-width, 28rem);
      width: 100%;
    }
  }

  .aside-background {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: -1;
  }

  .background-layer {
    position: absolute;
    inset: 0;
  }

  .background-layer ::slotted(*) {
    display: block;
    width: 100%;
    height: 100%;
  }

  .background-layer--default {
    display: block;
  }

  .background-layer--mobile,
  .background-layer--tablet,
  .background-layer--desktop {
    display: none;
  }

  @media (max-width: 599px) {
    :host([data-has-background-mobile]) .background-layer--default {
      display: none;
    }

    :host([data-has-background-mobile]) .background-layer--mobile {
      display: block;
    }
  }

  @media (min-width: 600px) and (max-width: 1023px) {
    :host([data-has-background-tablet]) .background-layer--default {
      display: none;
    }

    :host([data-has-background-tablet]) .background-layer--tablet {
      display: block;
    }
  }

  @media (min-width: 1024px) {
    :host([data-has-background-desktop]) .background-layer--default {
      display: none;
    }

    :host([data-has-background-desktop]) .background-layer--desktop {
      display: block;
    }
  }

  .aside-media {
    display: grid;
    justify-items: center;
    gap: var(--spectrum-global-dimension-size-200);
    order: 2;
    max-width: min(100%, var(--acom-aside-media-max-size, 500px));
    justify-self: center;
  }

  .aside-media ::slotted(*) {
    max-width: min(100%, var(--acom-aside-media-max-size, 500px));
    max-height: var(--acom-aside-media-max-size, 500px);
    width: 100%;
    border-radius: var(--spectrum-global-dimension-size-100);
    object-fit: cover;
  }

  .aside-text {
    display: grid;
    gap: var(--acom-aside-text-gap);
    order: 1;
    text-align: left;
  }

  .aside-eyebrow ::slotted(*) {
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    font-size: var(--acom-aside-eyebrow-size, var(--spectrum-global-dimension-font-size-100, 0.875rem));
    font-weight: var(--acom-aside-eyebrow-weight, 600);
  }

  .aside-heading ::slotted(*) {
    margin: 0;
    font-size: var(
      --acom-aside-heading-size,
      clamp(1.75rem, 2.5vw, var(--spectrum-global-dimension-font-size-800, 2.75rem))
    );
    line-height: var(--acom-aside-heading-line-height, 1.15);
    font-weight: var(--acom-aside-heading-weight, 700);
    letter-spacing: var(--acom-aside-heading-letter-spacing, -0.02em);
  }

  .aside-body {
    display: grid;
    gap: var(--acom-aside-body-gap);
  }

  .aside-body ::slotted(*) {
    margin: 0;
    font-size: var(--acom-aside-body-size, var(--spectrum-global-dimension-font-size-200, 1rem));
    line-height: var(--acom-aside-body-line-height, 1.6);
  }

  .aside-actions {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spectrum-global-dimension-size-200);
    justify-content: center;
    align-items: center;
  }

  :host([inline-align="center"]) .aside-text {
    text-align: center;
    justify-self: center;
  }

  :host([inline-align="end"]) .aside-text {
    text-align: right;
    justify-self: flex-end;
  }

  :host([inline-align="start"]) .aside-text,
  :host([inline-align="stretch"]) .aside-text {
    justify-self: flex-start;
  }

  :host([inline-align="center"]) .aside-actions {
    justify-content: center;
  }

  :host([inline-align="start"]) .aside-actions,
  :host([inline-align="stretch"]) .aside-actions {
    justify-content: flex-start;
  }

  :host([inline-align="end"]) .aside-actions {
    justify-content: flex-end;
  }

  :host([media-position="top"]) .aside-media {
    order: 1;
  }

  :host([media-position="top"]) .aside-text {
    order: 2;
  }

  @media (min-width: 900px) {
    :host([media-position="left"]:not([media-stacked])) .aside-media {
      order: 1;
      justify-self: flex-end;
    }

    :host([media-position="right"]:not([media-stacked])) .aside-media {
      justify-self: flex-start;
    }
  }
`;

// src/custom-elements/acom/acom-aside.js
var DEFAULT_BACKGROUND2 = "transparent";
var JSON_LD_KEY = "acom-aside";
var OBSERVED_SLOTS = [
  "eyebrow",
  "heading",
  "body",
  "",
  "actions",
  "media",
  "background",
  "background-mobile",
  "background-tablet",
  "background-desktop"
];
var BACKGROUND_LAYERS = [
  { slot: "background", className: "default", attribute: null },
  { slot: "background-mobile", className: "mobile", attribute: "data-has-background-mobile" },
  { slot: "background-tablet", className: "tablet", attribute: "data-has-background-tablet" },
  { slot: "background-desktop", className: "desktop", attribute: "data-has-background-desktop" }
];
var VALID_VARIANTS2 = /* @__PURE__ */ new Set(["small", "medium", "large"]);
var VALID_MEDIA_POSITIONS = /* @__PURE__ */ new Set(["left", "right", "top", "bottom", "none"]);
var VALID_ALIGNMENTS = /* @__PURE__ */ new Set(["start", "center", "end", "stretch"]);
var VALID_INLINE_ALIGNMENTS = /* @__PURE__ */ new Set(["start", "center", "end", "stretch"]);
var AcomAside = class extends i4 {
  static styles = [acomAsideStyleSheet];
  static properties = {
    backgroundColor: { type: String, attribute: "background-color" },
    variant: { type: String, reflect: true },
    theme: { type: String, reflect: true },
    mediaPosition: { type: String, attribute: "media-position", reflect: true },
    mediaStacked: {
      type: Boolean,
      attribute: "media-stacked",
      reflect: true,
      converter: booleanConverter
    },
    align: { type: String, reflect: true },
    inlineAlign: { type: String, attribute: "inline-align", reflect: true }
  };
  #slotObservers = [];
  #sectionLabelId = null;
  constructor() {
    super();
    this.backgroundColor = DEFAULT_BACKGROUND2;
    this.variant = "medium";
    this.mediaPosition = "right";
    this.mediaStacked = false;
    this.align = "center";
    this.inlineAlign = "start";
    this.theme = "";
  }
  connectedCallback() {
    super.connectedCallback();
    this.#ensureHostId();
    this.#applyBackgroundColor();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    disconnectSlotObservers(this.#slotObservers);
    this.#slotObservers = [];
    setJsonLd(this, null, JSON_LD_KEY);
  }
  firstUpdated() {
    this.#slotObservers = observeSlots(this, OBSERVED_SLOTS, () => {
      this.#handleSlotActivity();
    });
    this.#handleSlotActivity();
  }
  updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("backgroundColor")) {
      this.#applyBackgroundColor();
    }
    if (changedProps.has("theme")) {
      this.#normalizeTheme();
    }
    if (changedProps.has("variant")) {
      this.#normalizeVariant();
    }
    if (changedProps.has("mediaPosition")) {
      this.#normalizeMediaPosition();
    }
    if (changedProps.has("align")) {
      this.#normalizeAlign();
    }
    if (changedProps.has("inlineAlign")) {
      this.#normalizeInlineAlign();
    }
    this.#handleSlotActivity();
  }
  render() {
    const asideContent = x`
      <article
        id="${this.#articleId}"
        role="complementary"
        aria-labelledby=${this.#ariaLabelledby}
      >
        ${this.#backgroundTemplate}
        <div class="aside-layout" style=${o10(this.#layoutStyle)}>
          ${this.#layoutTemplates}
        </div>
      </article>
    `;
    if (this.theme === "dark" || this.theme === "light") {
      return x`
        <sp-theme color="${this.theme}" scale="medium" system="spectrum-two">
          ${asideContent}
        </sp-theme>
      `;
    }
    return asideContent;
  }
  get #articleId() {
    return `${this.id}-article`;
  }
  get #textColumnId() {
    return `${this.id}-text`;
  }
  get #mediaColumnId() {
    return `${this.id}-media`;
  }
  get #ariaLabelledby() {
    return this.#sectionLabelId ?? E;
  }
  get #layoutStyle() {
    const alignment = this.align;
    const inlineAlign = this.inlineAlign;
    const alignItems = alignment === "stretch" ? "stretch" : alignment;
    const justifyItems = inlineAlign === "stretch" ? "stretch" : inlineAlign;
    return {
      "align-items": alignItems,
      "justify-items": justifyItems,
      "align-content": alignItems
    };
  }
  get #layoutTemplates() {
    const text = this.#textColumnTemplate;
    const media = this.#hasMedia && this.mediaPosition !== "none" ? this.#mediaColumnTemplate : E;
    switch (this.mediaPosition) {
      case "left":
        return this.mediaStacked ? x`${text}${media}` : x`${media}${text}`;
      case "top":
        return x`${media}${text}`;
      case "bottom":
        return x`${text}${media}`;
      case "none":
        return x`${text}`;
      case "right":
      default:
        return x`${text}${media}`;
    }
  }
  get #textColumnTemplate() {
    return x`
      <div class="aside-text" id="${this.#textColumnId}">
        <div class="aside-eyebrow" id="${this.id}-eyebrow">
          <slot name="eyebrow"></slot>
        </div>
        <div class="aside-heading" id="${this.id}-heading">
          <slot name="heading"></slot>
        </div>
        <div class="aside-body" id="${this.id}-body">
          <slot name="body"></slot>
          <slot></slot>
        </div>
        <div class="aside-actions" id="${this.id}-actions">
          <slot name="actions"></slot>
        </div>
      </div>
    `;
  }
  get #mediaColumnTemplate() {
    return x`
      <div class="aside-media" id="${this.#mediaColumnId}">
        <slot name="media"></slot>
      </div>
    `;
  }
  get #backgroundTemplate() {
    const layers = BACKGROUND_LAYERS.filter((layer) => this.#hasSlot(layer.slot));
    if (!layers.length) {
      return E;
    }
    return x`
      <div class="aside-background" aria-hidden="true">
        ${layers.map(
      (layer) => x`
            <div class="background-layer background-layer--${layer.className}">
              <slot name="${layer.slot}"></slot>
            </div>
          `
    )}
      </div>
    `;
  }
  get #hasMedia() {
    return this.#hasSlot("media");
  }
  #handleSlotActivity() {
    this.#syncBackgroundAttributes();
    this.#updateAccessibility();
  }
  #syncBackgroundAttributes() {
    let hasAny = false;
    for (const layer of BACKGROUND_LAYERS) {
      const present = this.#hasSlot(layer.slot);
      hasAny = hasAny || present;
      if (layer.attribute) {
        this.toggleAttribute(layer.attribute, present);
      }
    }
    this.toggleAttribute("data-has-background", hasAny);
  }
  #updateAccessibility() {
    const container = this.shadowRoot?.getElementById(this.#articleId);
    if (!container) {
      return;
    }
    this.#sectionLabelId = updateRegionAccessibility({
      host: this,
      container,
      headingSlot: "heading",
      fallbackLabel: "Related information",
      idPrefix: `${this.id}-heading`
    });
    this.#emitJsonLd();
  }
  #emitJsonLd() {
    emitCreativeWorkJsonLd(this, {
      key: JSON_LD_KEY,
      type: "WebPageElement",
      headingSlot: "heading",
      descriptionSlots: ["", "body"],
      actionSlot: "actions",
      priceSelector: "inline-price",
      mediaSlot: "media",
      aboutSlot: "eyebrow"
    });
  }
  #applyBackgroundColor() {
    const normalized = normalizeBackgroundValue(this.backgroundColor, DEFAULT_BACKGROUND2);
    this.style.setProperty("--acom-aside-background", normalized);
  }
  #normalizeTheme() {
    this.theme = normalizeTheme(this.theme);
  }
  #normalizeVariant() {
    if (!VALID_VARIANTS2.has(this.variant)) {
      this.variant = "medium";
    }
  }
  #normalizeMediaPosition() {
    if (!VALID_MEDIA_POSITIONS.has(this.mediaPosition)) {
      this.mediaPosition = "right";
    }
  }
  #normalizeAlign() {
    if (!VALID_ALIGNMENTS.has(this.align)) {
      this.align = "center";
    }
  }
  #normalizeInlineAlign() {
    if (!VALID_INLINE_ALIGNMENTS.has(this.inlineAlign)) {
      this.inlineAlign = "start";
    }
  }
  #hasSlot(name) {
    if (!name) {
      return Array.from(this.childNodes).some((node) => {
        if (node.nodeType === Node.TEXT_NODE) {
          return node.textContent && node.textContent.trim().length > 0;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          return !node.hasAttribute("slot");
        }
        return false;
      });
    }
    return Array.from(this.children).some((child) => child.slot === name);
  }
  #ensureHostId() {
    ensureId(this, JSON_LD_KEY);
  }
};
customElements.define("acom-aside", AcomAside);

// src/custom-elements/acom/acom-aside.author.js
var ASIDE_SLOTS = /* @__PURE__ */ new Set([
  "",
  "eyebrow",
  "heading",
  "body",
  "actions",
  "media",
  "background",
  "background-mobile",
  "background-tablet",
  "background-desktop"
]);
var textStyles4 = ["bold", "italic", "underline", "strikethrough"];
var alignFormats4 = ["align-left", "align-center", "align-right"];
var listFormats = ["unordered-list", "ordered-list"];
AcomAside.ee = {
  getElementIcon(html) {
    return html`<sp-icon-panel slot="icon"></sp-icon-panel>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Aside",
        description: "Flexible aside block supporting imagery or video alongside copy and actions."
      },
      attributes: {
        variant: {
          type: "enum",
          options: ["small", "medium", "large"],
          default: "large",
          label: "Size Variant",
          description: "Adjust spacing and padding for different contexts."
        },
        "background-color": makeSWCColorSchema({
          defaultValue: "linear-gradient(122deg, var(--spectrum-global-color-blue-300) 0%, var(--spectrum-global-color-blue-500) 100%)",
          label: "Background Fill",
          description: "Choose a solid color or craft a gradient background.",
          attr: "background-color",
          allowGradient: true
        }),
        theme: {
          type: "enum",
          options: ["", "light", "dark"],
          default: "",
          label: "Theme",
          description: "Switch typography between light and dark treatments."
        },
        "media-position": {
          type: "enum",
          options: ["left", "right", "top", "bottom", "none"],
          default: "right",
          label: "Media Position",
          description: "Place media before or after the text content."
        },
        "media-stacked": {
          type: "boolean",
          default: false,
          label: "Stack Media",
          description: "Force media below text regardless of breakpoint."
        },
        align: {
          type: "enum",
          options: ["start", "center", "end", "stretch"],
          default: "center",
          label: "Content Alignment",
          description: "Align the content block vertically within the layout."
        },
        "inline-align": {
          type: "enum",
          options: ["start", "center", "end", "stretch"],
          default: "start",
          label: "Horizontal Alignment",
          description: "Align the content horizontally (left, center, right)."
        }
      },
      slots: {
        order: [
          "eyebrow",
          "heading",
          "body",
          "actions",
          "media",
          "background",
          "background-mobile",
          "background-tablet",
          "background-desktop"
        ],
        configs: {
          eyebrow: {
            label: "Eyebrow",
            description: "Upper detail text or label.",
            placeholder: "Add eyebrow or detail text.",
            minLength: 0,
            maxLength: 1,
            inlineEditable: true,
            allowedStyles: ["bold", "italic", "underline"],
            allowedFormats: [...alignFormats4],
            allowLinks: false,
            tag: "p",
            multiline: false
          },
          heading: {
            label: "Heading",
            description: "Main headline or title.",
            placeholder: "Add a descriptive heading.",
            minLength: 1,
            maxLength: 1,
            inlineEditable: true,
            allowedStyles: ["bold", "italic", "underline"],
            allowedFormats: [...alignFormats4],
            allowLinks: false,
            tag: "h2",
            multiline: false
          },
          body: {
            label: "Body",
            description: "Supporting text content.",
            placeholder: "Add supporting paragraphs.",
            inlineEditable: true,
            multiline: true,
            allowedStyles: [...textStyles4],
            allowedFormats: [...alignFormats4, ...listFormats],
            allowLinks: true,
            allowPaste: true,
            tag: "div"
          },
          actions: {
            label: "Actions",
            description: "Buttons or links associated with the aside.",
            minLength: 0,
            maxLength: 3,
            allowPaste: true
          },
          media: {
            label: "Media",
            description: "Image, video, or illustration.",
            minLength: 0,
            maxLength: 1
          },
          background: {
            label: "Background",
            description: "Optional background picture or gradient.",
            minLength: 0,
            maxLength: 1
          },
          "background-mobile": {
            label: "Background (Mobile)",
            description: "Optional background for mobile viewports (<600px).",
            minLength: 0,
            maxLength: 1
          },
          "background-tablet": {
            label: "Background (Tablet)",
            description: "Optional background for tablet viewports (600px\u20131023px).",
            minLength: 0,
            maxLength: 1
          },
          "background-desktop": {
            label: "Background (Desktop)",
            description: "Optional background for desktop viewports (\u22651024px).",
            minLength: 0,
            maxLength: 1
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-aside
        variant="large"
        background-color="linear-gradient(122deg, var(--spectrum-global-color-blue-300) 0%, var(--spectrum-global-color-blue-500) 100%)"
        media-position="left"
        align="center"
        inline-align="start"
      >
        <p slot="eyebrow" class="detail-l"><strong>Remove objects</strong></p>
        <h2 slot="heading">Decluttering on demand.</h2>
        <div slot="body">
        <p>
          Tidy up your scene in a click. Distraction Removal in the Remove tool
          automatically detects and deletes unwanted elements like wires and people in the background.
          Get Photoshop on web and mobile with the Firefly Pro plan.
          </p>
        </div>
          <sp-button
          slot="actions"
            variant="accent"
            size="m"
            href="https://commerce.adobe.com/store/segmentation?cli=mini_plans&ctx=if&co=US&lang=en&ms=COM&ot=TRIAL&cs=INDIVIDUAL&pa=PA-1929&rtc=t&lo=sl&af=uc_new_user_iframe%2Cuc_new_system_close"
          >
            Free trial
          </sp-button>
          <sp-button
          slot="actions"
            variant="secondary"
            size="m"
            href="https://www.adobe.com/creativecloud/plans.html?plan=individual&filter=all&single_app=photoshop"
          >
            Buy now
          </sp-button>
        <ee-media
          slot="media"
          autoplay
          muted
          loop
          playsinline
          label-play="Play motion"
          label-pause="Pause motion"
        >
          <video
            slot="media"
            autoplay
            loop
            muted
            playsinline
            poster="https://www.adobe.com/creativecloud/media_10b9c9c3ef46f2e6d40d155fe5bb76684fb32c00b.jpg?width=960&format=jpg&optimize=medium"
          >
            <source
              type="video/mp4"
              src="https://www.adobe.com/creativecloud/media_10b9c9c3ef46f2e6d40d155fe5bb76684fb32c00b.mp4"
            >
          </video>
        </ee-media>
      </acom-aside>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    Array.from(element.children).forEach((child) => {
      const slot = child.getAttribute("slot") || "";
      if (!ASIDE_SLOTS.has(slot)) {
        child.removeAttribute("slot");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCard.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Card.js
var CardIcon = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Card" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${t34}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M31 2H5a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1ZM12 29.5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5Zm18 0a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 .5.5Zm0-7.5H6V4h24Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconCard.js
var IconCard = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? CardIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-card.js
init_define_element();
defineElement("sp-icon-card", IconCard);

// src/custom-elements/acom/acom-feature-card.js
init_lit();

// src/custom-elements/acom/acom-feature-card.css.js
init_lit();
var acomFeatureCardStyleSheet = i`
  :host {
    display: block;
    box-sizing: border-box;
    background: var(--acom-feature-card-background, var(--spectrum-global-color-gray-50));
    border-radius: var(--spectrum-global-dimension-size-100);
    min-height: 100%;
  }

  :host([theme="dark"]) {
    background: var(--acom-feature-card-background, rgb(34, 34, 34));
  }

  :host([hidden]) {
    display: none !important;
  }

  sp-theme {
    display: block;
    border-radius: inherit;
    min-height: 100%;
  }

  article {
    display: grid;
    gap: var(--spectrum-global-dimension-size-300);
    padding: var(--spectrum-global-dimension-size-400);
    box-sizing: border-box;
    color: var(--spectrum-body-color);
  }

  .feature-media {
    display: block;
  }

  .feature-media ::slotted(img),
  .feature-media ::slotted(video),
  .feature-media ::slotted(picture) {
    width: 100%;
    border-radius: var(--spectrum-global-dimension-size-100);
  }

  .feature-heading ::slotted(*) {
    margin: 0;
  }

  .feature-body {
    display: grid;
    gap: var(--spectrum-global-dimension-size-150);
  }

  .feature-actions {
    display: flex;
    gap: var(--spectrum-global-dimension-size-200);
    flex-wrap: wrap;
  }
`;

// src/custom-elements/acom/acom-feature-card.js
var AcomFeatureCard = class extends i4 {
  static styles = [acomFeatureCardStyleSheet];
  static properties = {
    theme: { type: String, reflect: true },
    backgroundColor: { type: String, attribute: "background-color" }
  };
  #slotObservers;
  #sectionLabelId;
  constructor() {
    super();
    this.theme = "";
    this.backgroundColor = "";
    this.#slotObservers = [];
    this.#sectionLabelId = null;
    ensureId(this, "acom-feature-card");
  }
  connectedCallback() {
    super.connectedCallback();
    this.#applyBackgroundColor();
  }
  #applyBackgroundColor() {
    const backgroundValue = normalizeBackgroundValue(this.backgroundColor, "");
    if (backgroundValue) {
      this.style.setProperty("--acom-feature-card-background", backgroundValue);
    } else {
      this.style.removeProperty("--acom-feature-card-background");
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    disconnectSlotObservers(this.#slotObservers);
    setJsonLd(this, null, "acom-feature-card");
  }
  firstUpdated() {
    this.#slotObservers = observeSlots(
      this,
      ["media", "heading", "body", "", "actions"],
      () => this.#updateAccessibilityAndSchema()
    );
    this.#updateAccessibilityAndSchema();
  }
  updated(changed) {
    if (changed.has("theme")) {
      this.#normalizeTheme();
    }
    if (changed.has("backgroundColor")) {
      this.#applyBackgroundColor();
    }
    this.#updateAccessibilityAndSchema();
  }
  render() {
    const cardContent = x`
      <article
        id="${this.id}-article"
        role="article"
        aria-labelledby=${this.#sectionLabelId || E}
      >
        <div class="feature-media" id="${this.id}-media">
          <slot name="media"></slot>
        </div>
        <div class="feature-heading" id="${this.id}-heading">
          <slot name="heading"></slot>
        </div>
        <div class="feature-body" id="${this.id}-body">
          <slot></slot>
          <slot name="body"></slot>
        </div>
        <div class="feature-actions" id="${this.id}-actions">
          <slot name="actions"></slot>
        </div>
      </article>
    `;
    if (this.theme === "dark" || this.theme === "light") {
      return x`
        <sp-theme color="${this.theme}" scale="medium" system="spectrum-two">
          ${cardContent}
        </sp-theme>
      `;
    }
    return cardContent;
  }
  #normalizeTheme() {
    this.theme = normalizeTheme(this.theme);
  }
  #updateAccessibilityAndSchema() {
    const article = this.shadowRoot?.getElementById(`${this.id}-article`);
    this.#sectionLabelId = updateRegionAccessibility({
      host: this,
      container: article,
      headingSlot: "heading",
      fallbackLabel: "Featured item",
      idPrefix: `${this.id}-heading`
    });
    this.#emitJsonLd();
  }
  #emitJsonLd() {
    emitCreativeWorkJsonLd(this, {
      key: "acom-feature-card",
      headingSlot: "heading",
      descriptionSlots: ["", "body"],
      actionSlot: "actions",
      priceSelector: "inline-price",
      mediaSlot: "media"
    });
  }
};
customElements.define("acom-feature-card", AcomFeatureCard);

// src/custom-elements/acom/acom-feature-card.author.js
var FEATURE_CARD_SLOTS = /* @__PURE__ */ new Set(["media", "heading", "body", "actions", ""]);
var TEXT_STYLES5 = ["bold", "italic", "underline", "strikethrough"];
var ALIGN_FORMATS3 = ["align-left", "align-center", "align-right"];
var LIST_FORMATS = ["unordered-list", "ordered-list"];
AcomFeatureCard.ee = {
  getElementIcon(html) {
    return html`<sp-icon-card slot="icon"></sp-icon-card>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Feature Card",
        description: "Editorial feature card with media, heading, supporting copy, and actions.",
        category: "content"
      },
      attributes: {
        theme: {
          type: "enum",
          options: ["", "light", "dark"],
          default: "",
          label: "Theme",
          description: "Set typography for light or dark backgrounds."
        },
        "background-color": makeSWCColorSchema({
          defaultValue: "linear-gradient(135deg, #8ceaff 0%, #56afff 100%)",
          label: "Background Fill",
          description: "Solid color or gradient applied behind the card.",
          attr: "background-color",
          allowGradient: true
        })
      },
      slots: {
        order: ["media", "heading", "body", "actions"],
        configs: {
          media: {
            label: "Media",
            description: "Image or video preview.",
            minLength: 0,
            maxLength: 1
          },
          heading: {
            label: "Heading",
            description: "Card headline text.",
            placeholder: "Add a concise title.",
            minLength: 1,
            maxLength: 1,
            inlineEditable: true,
            allowedStyles: ["bold", "italic", "underline"],
            allowedFormats: [...ALIGN_FORMATS3],
            allowLinks: false,
            tag: "h3",
            multiline: false
          },
          body: {
            label: "Body",
            description: "Supporting descriptive content.",
            placeholder: "Add descriptive text.",
            minLength: 1,
            maxLength: null,
            inlineEditable: true,
            multiline: true,
            allowedStyles: [...TEXT_STYLES5],
            allowedFormats: [...ALIGN_FORMATS3, ...LIST_FORMATS],
            allowLinks: true
          },
          actions: {
            label: "Actions",
            description: "Optional CTA buttons or links.",
            minLength: 0,
            maxLength: 2
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-feature-card background-color="linear-gradient(135deg, #8ceaff 0%, #56afff 100%)">
        <h3 slot="heading">Feature title</h3>
        <p slot="body">Explain the key value point for this feature.</p>
      </acom-feature-card>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    Array.from(element.children).forEach((child) => {
      const slot = child.getAttribute("slot") || "";
      if (!FEATURE_CARD_SLOTS.has(slot)) {
        child.removeAttribute("slot");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconImageCarousel.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ImageCarousel.js
var ImageCarouselIcon = ({ width: e36 = 24, height: r25 = 24, hidden: t34 = false, title: a23 = "Image Carousel" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${r25}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <rect height="22" rx="1" ry="1" width="24" x="6" y="2" />
    <path
      d="M4 22H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h3ZM35 22h-3V6h3a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1Z"
    />
    <circle cx="8" cy="30" r="1.4" />
    <circle cx="14" cy="30" r="2.1" />
    <circle cx="20" cy="30" r="1.4" />
    <circle cx="26" cy="30" r="1.4" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconImageCarousel.js
var IconImageCarousel = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? ImageCarouselIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-image-carousel.js
init_define_element();
defineElement("sp-icon-image-carousel", IconImageCarousel);

// src/custom-elements/acom/acom-feature-carousel.js
init_lit();
init_style_map2();
init_repeat2();

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconArrowLeft.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ArrowLeft.js
var ArrowLeftIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Arrow Left" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M16 12h17a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H16v6.993a.5.5 0 0 1-.854.354L1.8 18 15.146 4.654a.5.5 0 0 1 .854.353Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconArrowLeft.js
var IconArrowLeft = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? ArrowLeftIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-arrow-left.js
init_define_element();
defineElement("sp-icon-arrow-left", IconArrowLeft);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconArrowRight.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/ArrowRight.js
var ArrowRightIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: a23 = "Arrow Right" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${e36}"
    viewBox="0 0 36 36"
    width="${t34}"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M20 12H3a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h17v6.993a.5.5 0 0 0 .854.354L34.2 18 20.854 4.654a.5.5 0 0 0-.854.353Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconArrowRight.js
var IconArrowRight = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? ArrowRightIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-arrow-right.js
init_define_element();
defineElement("sp-icon-arrow-right", IconArrowRight);

// src/custom-elements/acom/acom-feature-carousel.css.js
init_lit();
var acomFeatureCarouselStyleSheet = i`
  :host {
    display: block;
    box-sizing: border-box;
  }

  :host([hidden]) {
    display: none !important;
  }

  .carousel {
    position: relative;
    padding-inline: var(--spectrum-global-dimension-size-200);
  }

  .carousel-track {
    display: grid;
    grid-auto-flow: column;
    gap: var(--spectrum-global-dimension-size-300);
    overflow: hidden;
  }

  .carousel-window {
    overflow: hidden;
  }

  .carousel-track-inner {
    display: grid;
    grid-auto-flow: column;
    gap: var(--spectrum-global-dimension-size-300);
    transition: transform 200ms ease;
  }

  .carousel-track-inner ::slotted(*) {
    min-width: var(--acom-feature-carousel-item-width, 100%);
  }

  .carousel-controls {
    margin-top: var(--spectrum-global-dimension-size-300);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-200);
    flex-wrap: wrap;
  }

  .carousel-buttons {
    display: flex;
    gap: var(--spectrum-global-dimension-size-200);
  }

  .carousel-indicators {
    display: grid;
    grid-auto-flow: column;
    gap: var(--spectrum-global-dimension-size-200);
  }

  .indicator {
    width: var(--spectrum-global-dimension-size-150);
    height: var(--spectrum-global-dimension-size-150);
    border-radius: 50%;
    background: var(--spectrum-global-color-gray-400);
  }

  .indicator[aria-current="true"] {
    background: var(--spectrum-global-color-gray-900);
  }
`;

// src/custom-elements/acom/acom-feature-carousel.js
var AcomFeatureCarousel = class extends i4 {
  static styles = [acomFeatureCarouselStyleSheet];
  static properties = {
    slidesPerView: { type: Number, attribute: "slides-per-view" },
    currentIndex: { type: Number, state: true },
    slides: { state: true },
    showIndicators: {
      type: Boolean,
      attribute: "show-indicators",
      converter: booleanConverter
    }
  };
  #regionLabel;
  constructor() {
    super();
    this.slidesPerView = 3;
    this.currentIndex = 0;
    this.showIndicators = true;
    this.slides = [];
    this.#regionLabel = "Feature carousel";
    ensureId(this, "acom-feature-carousel");
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    setJsonLd(this, null, "acom-feature-carousel");
  }
  render() {
    const itemWidth = this.slidesPerView > 0 ? 100 / this.slidesPerView : 100;
    const maxIndex = this.#maxIndex();
    const constrainedIndex = Math.min(this.currentIndex, maxIndex);
    if (constrainedIndex !== this.currentIndex) {
      this.currentIndex = constrainedIndex;
    }
    const offset4 = constrainedIndex * itemWidth;
    const innerStyles = {
      transform: `translateX(-${offset4}%)`,
      "--acom-feature-carousel-item-width": `${itemWidth}%`
    };
    return x`
      <div
        class="carousel"
        id="${this.id}-carousel"
        role="region"
        aria-label=${this.getAttribute("aria-label") || this.#regionLabel}
      >
        <div class="carousel-window">
          <div class="carousel-track">
            <div class="carousel-track-inner" style=${o10(innerStyles)}>
              <slot @slotchange=${this.#handleSlotChange}></slot>
            </div>
          </div>
        </div>
        ${this.#renderControls(maxIndex)}
      </div>
    `;
  }
  #renderControls(maxIndex) {
    const hasSlides = this.slides.length > this.slidesPerView;
    if (!hasSlides) {
      return E;
    }
    return x`
      <div class="carousel-controls" id="${this.id}-controls">
        <div class="carousel-buttons">
          <sp-action-button
            aria-controls="${this.id}-carousel"
            aria-label="Previous slide"
            @click=${this.#goPrevious}
            ?disabled=${this.currentIndex === 0}
          >
            <sp-icon-arrow-left slot="icon"></sp-icon-arrow-left>
            Previous
          </sp-action-button>
          <sp-action-button
            aria-controls="${this.id}-carousel"
            aria-label="Next slide"
            @click=${this.#goNext}
            ?disabled=${this.currentIndex >= maxIndex}
          >
            <sp-icon-arrow-right slot="icon"></sp-icon-arrow-right>
            Next
          </sp-action-button>
        </div>
        ${this.showIndicators ? x`
              <div class="carousel-indicators" role="tablist">
                ${c5(
      this.slides,
      (_2, index) => `${this.id}-indicator-${index}`,
      (_2, index) => x`
                    <button
                      type="button"
                      class="indicator"
                      role="tab"
                      aria-controls="${this.id}-carousel"
                      aria-label="Slide ${index + 1}"
                      aria-current=${this.currentIndex === index ? "true" : "false"}
                      @click=${() => this.#goTo(index)}
                    ></button>
                  `
    )}
              </div>
            ` : E}
      </div>
    `;
  }
  #handleSlotChange(event) {
    this.slides = event.target.assignedElements({ flatten: true }).filter((el) => el instanceof HTMLElement);
    this.currentIndex = Math.min(this.currentIndex, this.#maxIndex());
    this.#updateJsonLd();
  }
  #maxIndex() {
    if (this.slides.length === 0) {
      return 0;
    }
    const max2 = this.slides.length - this.slidesPerView;
    return max2 > 0 ? max2 : 0;
  }
  #goPrevious = () => {
    this.currentIndex = Math.max(0, this.currentIndex - 1);
  };
  #goNext = () => {
    this.currentIndex = Math.min(this.#maxIndex(), this.currentIndex + 1);
  };
  #goTo(index) {
    this.currentIndex = Math.min(Math.max(index, 0), this.#maxIndex());
  }
  #updateJsonLd() {
    const items = this.slides.map((slide, index) => {
      const name = collectSlotText(slide, "heading") || collectSlotText(slide, "") || `Slide ${index + 1}`;
      const description = collectSlotText(slide, "body") || collectSlotText(slide, "");
      const action = slide.querySelector("checkout-button[href]")?.getAttribute("href") || slide.querySelector("a[href]")?.getAttribute("href") || "";
      return {
        position: index + 1,
        name,
        description,
        url: action
      };
    }).filter((item) => item.name);
    emitItemListJsonLd(this, "acom-feature-carousel", items);
  }
};
customElements.define("acom-feature-carousel", AcomFeatureCarousel);

// src/custom-elements/acom/acom-feature-carousel.author.js
AcomFeatureCarousel.ee = {
  getElementIcon(html) {
    return html`<sp-icon-image-carousel slot="icon"></sp-icon-image-carousel>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Feature Carousel",
        description: "Carousel container that displays feature cards with navigation.",
        category: "structure"
      },
      attributes: {
        "slides-per-view": {
          type: "number",
          default: 3,
          label: "Slides per view",
          description: "Number of cards visible at once on wide viewports.",
          min: 1,
          max: 6
        },
        "show-indicators": {
          type: "boolean",
          default: true,
          label: "Show indicators",
          description: "Toggle visibility of pagination indicators."
        }
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Feature Cards",
            description: "Add acom-feature-card elements.",
            minLength: 1,
            maxLength: null
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-feature-carousel slides-per-view="3" show-indicators>
        <acom-feature-card background-color="--spectrum-global-color-gray-50">
          <h3 slot="heading">Feature 1</h3>
          <p slot="body">Describe this feature benefit and supporting details.</p>
        </acom-feature-card>
        <acom-feature-card background-color="--spectrum-global-color-gray-50">
          <h3 slot="heading">Feature 2</h3>
          <p slot="body">Describe this feature benefit and supporting details.</p>
        </acom-feature-card>
        <acom-feature-card background-color="--spectrum-global-color-gray-50">
          <h3 slot="heading">Feature 3</h3>
          <p slot="body">Describe this feature benefit and supporting details.</p>
        </acom-feature-card>
      </acom-feature-carousel>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    Array.from(element.children).forEach((child) => {
      if (child.tagName !== "ACOM-FEATURE-CARD") {
        child.remove();
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconText.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Text.js
var TextIcon = ({ width: t34 = 24, height: e36 = 24, hidden: r25 = false, title: l16 = "Text" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="m14.58984,2H5.41016c-1.24072,0-2.25,1.00977-2.25,2.25v1.11035c0,.41406.33594.75.75.75s.75-.33594.75-.75v-1.11035c0-.41309.33643-.75.75-.75h3.83984v13h-1.56982c-.41406,0-.75.33594-.75.75s.33594.75.75.75h4.63965c.41406,0,.75-.33594.75-.75s-.33594-.75-.75-.75h-1.56982V3.5h3.83984c.41357,0,.75.33691.75.75v1.11035c0,.41406.33594.75.75.75s.75-.33594.75-.75v-1.11035c0-1.24023-1.00928-2.25-2.25-2.25Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Text.js
var TextIcon2 = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: r25 = "Text" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${a23}"
    height="${t34}"
    viewBox="0 0 36 36"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M5 4a1.003 1.003 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v20h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-3V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1.003 1.003 0 0 0-1-1Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconText.js
var IconText = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TextIcon({ hidden: !this.label, title: this.label }) : TextIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-text.js
init_define_element();
defineElement("sp-icon-text", IconText);

// src/custom-elements/acom/acom-text.js
init_lit();

// src/custom-elements/acom/acom-text.css.js
init_lit();
var acomTextStyleSheet = i`
  :host {
    display: block;
    box-sizing: border-box;
    background: var(--acom-text-background, transparent);
  }

  :host([hidden]) {
    display: none !important;
  }

  sp-theme {
    display: block;
  }

  section {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-400);
    padding: var(--acom-text-padding, var(--spectrum-global-dimension-size-1000));
    text-align: var(--acom-text-align, center);
    margin: 0 auto;
    color: var(--spectrum-body-color);
  }

  slot {
    display: block;
  }

  slot[name="icon"] {
    display: flex;
    justify-content: center;
  }

  slot[name="icon"]::slotted(*) {
    margin: 0 auto;
  }

  slot[name="icon"]::slotted(img),
  slot[name="icon"]::slotted(svg) {
    width: var(--spectrum-global-dimension-size-700);
    height: var(--spectrum-global-dimension-size-700);
    display: block;
  }

  slot[name="icon"]::slotted(merch-mnemonic) {
    --icon-size: var(--acom-text-icon-size, var(--spectrum-global-dimension-size-900));
  }

  slot[name="heading"]::slotted(*) {
    margin: 0;
    font-size: var(--spectrum-global-dimension-font-size-800, 2.75rem);
    font-weight: 700;
    line-height: 1.15;
    letter-spacing: -0.02em;
  }

  slot[name="body"],
  slot:not([name]) {
    display: contents;
  }

  slot[name="body"]::slotted(*),
  slot:not([name])::slotted(*) {
    margin: 0;
    font-size: var(--spectrum-global-dimension-font-size-300, 1.25rem);
    line-height: 1.6;
  }

  slot[name="body"]::slotted(p),
  slot:not([name])::slotted(p),
  slot[name="body"]::slotted(div),
  slot:not([name])::slotted(div) {
    margin: 0;
    font-size: var(--spectrum-global-dimension-font-size-300, 1.25rem);
    line-height: 1.6;
  }

  slot[name="actions"] {
    display: inline-flex;
    flex-wrap: wrap;
    justify-content: var(--acom-text-justify, center);
    gap: var(--spectrum-global-dimension-size-300);
  }

  slot[name="actions"]::slotted(*) {
    margin: 0;
  }

`;

// src/custom-elements/acom/acom-text.js
var AcomText = class extends i4 {
  static styles = [acomTextStyleSheet];
  static properties = {
    align: { type: String, reflect: true },
    theme: { type: String, reflect: true },
    backgroundColor: { type: String, attribute: "background-color" },
    padding: { type: String }
  };
  #slotObservers;
  #sectionLabelId;
  constructor() {
    super();
    this.align = "center";
    this.backgroundColor = "";
    this.padding = "";
    this.theme = "";
    this.#slotObservers = [];
    this.#sectionLabelId = null;
    ensureId(this, "acom-text");
  }
  connectedCallback() {
    super.connectedCallback();
    this.#applyHostStyles();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    disconnectSlotObservers(this.#slotObservers);
    setJsonLd(this, null, "acom-text");
  }
  firstUpdated() {
    this.#slotObservers = observeSlots(
      this,
      ["heading", "body", "", "actions", "icon"],
      () => this.#handleContentChange()
    );
    this.#handleContentChange();
  }
  updated(changedProps) {
    if (changedProps.has("align")) {
      this.#normalizeAlign();
    }
    if (changedProps.has("theme")) {
      this.#normalizeTheme();
    }
    if (changedProps.has("backgroundColor") || changedProps.has("padding") || changedProps.has("align")) {
      this.#applyHostStyles();
    }
    this.#handleContentChange();
  }
  render() {
    const sectionContent = x`
      <section
        id="${this.id}-section"
        role="region"
        aria-labelledby=${this.#sectionLabelId || E}
      >
        <slot name="icon"></slot>
        <slot name="heading"></slot>
        <slot name="body"></slot>
        <slot></slot>
        <slot name="actions"></slot>
      </section>
    `;
    if (this.theme === "dark" || this.theme === "light") {
      return x`
        <sp-theme color="${this.theme}" scale="medium" system="spectrum-two">
          ${sectionContent}
        </sp-theme>
      `;
    }
    return sectionContent;
  }
  #normalizeAlign() {
    const allowed = ["left", "center", "right"];
    if (!allowed.includes(this.align)) {
      this.align = "center";
    }
  }
  #normalizeTheme() {
    this.theme = normalizeTheme(this.theme);
  }
  #applyHostStyles() {
    const backgroundValue = normalizeBackgroundValue(this.backgroundColor, "");
    this.style.setProperty("--acom-text-background", backgroundValue || "");
    if (this.padding) {
      this.style.setProperty("--acom-text-padding", this.padding);
    } else {
      this.style.removeProperty("--acom-text-padding");
    }
    this.style.setProperty("--acom-text-align", this.align);
    const justify = this.align === "center" ? "center" : this.align === "right" ? "flex-end" : "flex-start";
    this.style.setProperty("--acom-text-justify", justify);
  }
  #handleContentChange() {
    const section = this.shadowRoot?.getElementById(`${this.id}-section`);
    if (!section) {
      return;
    }
    this.#sectionLabelId = updateRegionAccessibility({
      host: this,
      container: section,
      headingSlot: "heading",
      fallbackLabel: "Text spotlight",
      idPrefix: `${this.id}-heading`
    });
  }
};
customElements.define("acom-text", AcomText);

// src/custom-elements/acom/acom-text.author.js
var TEXT_STYLES6 = ["bold", "italic", "underline", "strikethrough"];
var ALIGN_FORMATS4 = ["align-left", "align-center", "align-right"];
var LIST_FORMATS2 = ["unordered-list", "ordered-list"];
AcomText.ee = {
  getElementIcon(html) {
    return html`<sp-icon-text slot="icon"></sp-icon-text>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Text",
        description: "Centered hero-style text block with icon, price, and CTAs."
      },
      attributes: {
        align: {
          type: "enum",
          options: ["left", "center", "right"],
          default: "center",
          label: "Alignment",
          description: "Control how the text block aligns contents and actions."
        },
        theme: {
          type: "enum",
          options: ["", "light", "dark"],
          default: "",
          label: "Theme",
          description: "Optional override to force light or dark typography."
        },
        "background-color": makeSWCColorSchema({
          defaultValue: "var(--spectrum-global-color-gray-900)",
          label: "Background Fill",
          description: "Solid color, gradient, or token for the surface.",
          attr: "background-color",
          allowGradient: true
        }),
        padding: {
          type: "text",
          default: "var(--spectrum-global-dimension-size-600)",
          label: "Padding",
          description: "Custom padding around the surface (CSS value)."
        }
      },
      slots: {
        order: ["icon", "heading", "body", "actions"],
        configs: {
          icon: {
            label: "Icon",
            description: "Optional product or app icon.",
            minLength: 0,
            maxLength: 1
          },
          heading: {
            label: "Heading",
            description: "Primary headline text.",
            inlineEditable: true,
            multiline: false,
            allowedStyles: ["bold", "italic", "underline"],
            allowedFormats: [...ALIGN_FORMATS4],
            allowLinks: false,
            placeholder: "Add headline",
            tag: "h3"
          },
          body: {
            label: "Body",
            description: "Supporting text paragraphs (wrap inline-price with ee-content when needed).",
            inlineEditable: true,
            allowedStyles: [...TEXT_STYLES6],
            allowedFormats: [...ALIGN_FORMATS4, ...LIST_FORMATS2],
            allowLinks: true,
            multiline: true
          },
          actions: {
            label: "Actions",
            description: "CTA buttons or links (e.g., Free trial / Buy now).",
            minLength: 0,
            maxLength: 3
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `<acom-text></acom-text>`;
    return template.content.firstElementChild;
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconRocketQuickActions.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/RocketQuickActions.js
var RocketQuickActionsIcon = ({ width: t34 = 24, height: l16 = 24, hidden: r25 = false, title: c33 = "Rocket Quick Actions" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${t34}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${c33}"
  >
    <path
      d="m6.17871,18.82227c-.19238,0-.38379-.07324-.53027-.21973-.29297-.29297-.29297-.76855,0-1.06055l.93848-.9375c.29297-.29395.76758-.29199,1.06055,0,.29297.29297.29297.76855,0,1.06055l-.93848.9375c-.14648.14648-.33887.21973-.53027.21973Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="m1.91797,14.60254c-.19238,0-.38379-.07324-.53027-.21973-.29297-.29297-.29297-.76855,0-1.06055l.93848-.9375c.29395-.29395.76855-.29199,1.06055,0,.29297.29297.29297.76855,0,1.06055l-.93848.9375c-.14648.14648-.33887.21973-.53027.21973Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="m2.49805,18.25195c-.19141,0-.38281-.07227-.5293-.21777-.29297-.29297-.29492-.76758-.00293-1.06152l2.49609-2.50977c.29395-.29199.76758-.29492,1.06152-.00293.29297.29297.29492.76758.00293,1.06152l-2.49609,2.50977c-.14746.14648-.33984.2207-.53223.2207Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="m18.17969,1.66211c-.63672-.58496-1.5752-.78809-2.78125-.61133-2.32446.34424-4.17236,1.60938-5.65601,3.021-.3728-.04517-.74731-.07251-1.09302-.07178-2.9873.0293-5.75684,1.64844-7.40918,4.33301-.30566.49609-.31934,1.11816-.03516,1.62109.28223.49902.79199.7959,1.36035.7959h2.80249c.0874.51196.32861.99683.71216,1.37988l1.79004,1.79004c.38696.3877.87158.62378,1.37988.71143v2.78174c-.00488.58105.29199,1.09766.7959,1.38184.24121.13574.50977.2041.7793.2041.29102,0,.58398-.08008.84277-.23926,2.68359-1.65234,4.30273-4.42188,4.33203-7.40918.00317-.36157-.02563-.73145-.07178-1.10205.0708-.07422.15381-.1499.22217-.22412,1.55176-1.68066,2.46094-3.40625,2.7793-5.27734.23145-1.35938-.02832-2.42578-.75-3.08496Zm-12.38965,7.17773c-.07715.11133-.14062.22559-.19824.34375l-.00293.00586c-.00952.01978-.01465.04053-.02368.06055h-2.94165c-.0791,0-.12988-.08984-.08862-.15723,1.28149-2.08838,3.48608-3.45483,5.82349-3.57056-.10645.12231-.21875.24634-.32031.36646-.7207.85156-1.47656,1.84375-2.24805,2.95117Zm5.11768,8.62207c-.06738.04175-.15771-.00903-.15771-.08813v-2.9353c.14136-.06445.27979-.13794.41113-.22949,1.28613-.896,2.37158-1.74805,3.31689-2.57935-.11694,2.34155-1.46509,4.52954-3.57031,5.83228Zm6.54346-12.9668c-.26855,1.57617-1.05371,3.05176-2.40234,4.51172-1.15918,1.25488-2.71094,2.55371-4.74512,3.97168-.42969.2998-1.00586.24805-1.37305-.11914l-1.79004-1.79102c-.32031-.31934-.40137-.81055-.20312-1.22363.02539-.05078.05176-.10156.08398-.14844.74414-1.06738,1.47168-2.02246,2.16113-2.83887,1.6123-1.90527,3.63672-3.90918,6.43457-4.32227.51074-.07617,1.19141-.0957,1.5498.2334.43457.39746.36426,1.25293.28418,1.72656Z"
      fill="currentColor"
      stroke-width="0"
    />
    <path
      d="m14.5,6.75c0,.69036-.55964,1.25-1.25,1.25s-1.25-.55964-1.25-1.25c0-.69036.55964-1.25,1.25-1.25s1.25.55964,1.25,1.25Z"
      fill="currentColor"
      stroke-width="0"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconRocketQuickActions.js
var IconRocketQuickActions = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? RocketQuickActionsIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-rocket-quick-actions.js
init_define_element();
defineElement("sp-icon-rocket-quick-actions", IconRocketQuickActions);

// src/custom-elements/acom/acom-action-tile.js
init_lit();
init_style_map2();

// src/custom-elements/acom/acom-action-tile.css.js
init_lit();
var acomActionTileStyleSheet = i`
  :host {
    display: block;
    box-sizing: border-box;
  }

  :host([hidden]) {
    display: none !important;
  }

  article {
    display: grid;
    gap: var(--spectrum-global-dimension-size-200);
    padding: var(--spectrum-global-dimension-size-300);
    border-radius: var(--spectrum-global-dimension-size-100);
    background: var(--acom-action-tile-background, var(--spectrum-global-color-gray-50));
    text-align: center;
    min-height: 100%;
    box-sizing: border-box;
  }

  .tile-icon ::slotted(img),
  .tile-icon ::slotted(picture),
  .tile-icon ::slotted(svg) {
    width: var(--spectrum-global-dimension-size-400);
    height: var(--spectrum-global-dimension-size-400);
  }

  .tile-heading ::slotted(*) {
    margin: 0;
  }
`;

// src/custom-elements/acom/acom-action-tile.js
var AcomActionTile = class extends i4 {
  static styles = [acomActionTileStyleSheet];
  static properties = {
    href: { type: String },
    target: { type: String },
    rel: { type: String },
    backgroundColor: { type: String, attribute: "background-color" }
  };
  #slotObservers;
  constructor() {
    super();
    this.href = "";
    this.target = "_self";
    this.rel = "noopener noreferrer";
    this.backgroundColor = "";
    this.#slotObservers = [];
    ensureId(this, "acom-action-tile");
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    disconnectSlotObservers(this.#slotObservers);
    setJsonLd(this, null, "acom-action-tile");
  }
  firstUpdated() {
    this.#slotObservers = observeSlots(
      this,
      ["icon", "heading", "body"],
      () => this.#updateJsonLd()
    );
    this.#updateJsonLd();
  }
  updated(changed) {
    if (changed.has("href") || changed.has("backgroundColor")) {
      this.requestUpdate();
    }
    this.#updateJsonLd();
  }
  render() {
    const styles12 = {};
    const backgroundValue = normalizeBackgroundValue(this.backgroundColor, "");
    if (backgroundValue) {
      styles12["--acom-action-tile-background"] = backgroundValue;
    }
    const content = x`
      <article id="${this.id}-article" style=${o10(styles12)}>
        <div class="tile-icon" id="${this.id}-icon">
          <slot name="icon"></slot>
        </div>
        <div class="tile-heading" id="${this.id}-heading">
          <slot name="heading"></slot>
        </div>
        <div class="tile-body" id="${this.id}-body">
          <slot></slot>
          <slot name="body"></slot>
        </div>
      </article>
    `;
    if (this.href) {
      return x`
        <a
          id="${this.id}-link"
          href=${this.href}
          target=${this.target || "_self"}
          rel=${this.rel || ""}
        >
          ${content}
        </a>
      `;
    }
    return content;
  }
  #updateJsonLd() {
    emitCreativeWorkJsonLd(this, {
      key: "acom-action-tile",
      headingSlot: "heading",
      descriptionSlots: ["body"],
      actionSlot: null,
      priceSelector: null,
      url: this.href || ""
    });
  }
};
customElements.define("acom-action-tile", AcomActionTile);

// src/custom-elements/acom/acom-action-tile.author.js
var ACTION_TILE_SLOTS = /* @__PURE__ */ new Set(["icon", "heading", "body", ""]);
var TEXT_STYLES7 = ["bold", "italic", "underline"];
var ALIGN_FORMATS5 = ["align-left", "align-center", "align-right"];
AcomActionTile.ee = {
  getElementIcon(html) {
    return html`<sp-icon-rocket-quick-actions slot="icon"></sp-icon-rocket-quick-actions>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Action Tile",
        description: "Small icon-based tile linking to quick actions or tools.",
        category: "content"
      },
      attributes: {
        href: {
          type: "text",
          default: "",
          label: "Link URL",
          description: "Optional destination for the entire tile.",
          placeholder: "https://example.com"
        },
        target: {
          type: "text",
          default: "_self",
          label: "Link Target",
          description: "Target attribute when href is provided."
        },
        rel: {
          type: "text",
          default: "noopener noreferrer",
          label: "Link Rel",
          description: "Rel attribute when opening external links."
        },
        "background-color": makeSWCColorSchema({
          defaultValue: "linear-gradient(135deg, #ffd654 0%, #ff8c5a 100%)",
          label: "Background Fill",
          description: "Solid color or gradient background behind the tile.",
          attr: "background-color",
          allowGradient: true
        })
      },
      slots: {
        order: ["icon", "heading", "body"],
        configs: {
          icon: {
            label: "Icon",
            description: "Place a product icon or illustration.",
            minLength: 0,
            maxLength: 1
          },
          heading: {
            label: "Heading",
            description: "Short title for the tile.",
            minLength: 1,
            maxLength: 1,
            inlineEditable: true,
            allowedStyles: [...TEXT_STYLES7],
            allowedFormats: [...ALIGN_FORMATS5],
            allowLinks: false,
            placeholder: "Add tile heading",
            tag: "p",
            multiline: false
          },
          body: {
            label: "Body",
            description: "Optional supporting label or caption.",
            minLength: 0,
            maxLength: 1,
            inlineEditable: true,
            allowedStyles: [...TEXT_STYLES7],
            allowedFormats: [...ALIGN_FORMATS5],
            allowLinks: true,
            placeholder: "Add supporting caption",
            tag: "p",
            multiline: false
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-action-tile background-color="linear-gradient(135deg, #ffd654 0%, #ff8c5a 100%)">
        <p slot="heading">Quick action</p>
        <p slot="body">Launch into the featured workflow.</p>
      </acom-action-tile>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    Array.from(element.children).forEach((child) => {
      const slot = child.getAttribute("slot") || "";
      if (!ACTION_TILE_SLOTS.has(slot)) {
        child.removeAttribute("slot");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconQuickSelect.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/QuickSelect.js
var QuickSelectIcon = ({ width: a23 = 24, height: l16 = 24, hidden: e36 = false, title: t34 = "Quick Select" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${l16}"
    viewBox="0 0 36 36"
    width="${a23}"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="M16.333 17.814a4.468 4.468 0 0 0-3.14.838 6.435 6.435 0 0 0-1.968 3.436c-.433 1.378-.948 2.877-2.182 3.627a2.28 2.28 0 0 0-.588.41.524.524 0 0 0-.062.657.729.729 0 0 0 .4.189c3.317.764 7.549 1.018 10.278-1.434a4.4 4.4 0 0 0-1.281-7.327 4.714 4.714 0 0 0-1.457-.396ZM22.937 19.527c5.707-6.49 12.954-15.41 11.056-17.308S24.235 9.174 18.582 15.37a7.93 7.93 0 0 1 4.355 4.157ZM7.469 5.954l-.6-2.037A11.153 11.153 0 0 0 3.064 8.39l1.985.483a9.007 9.007 0 0 1 2.42-2.919ZM4 13c0-.242.052-.469.071-.706l-1.988-.484A11.163 11.163 0 0 0 2 13.111v3.111h2ZM4 23v-3.222H2v3.111a11.167 11.167 0 0 0 .11 1.483l1.98-.483A8.717 8.717 0 0 1 4 23ZM5.14 27.293l-1.994.486a11.151 11.151 0 0 0 3.726 4.3l.6-2.038a8.979 8.979 0 0 1-2.332-2.748ZM13 32a8.87 8.87 0 0 1-2.3-.336l-.563 1.921a10.864 10.864 0 0 0 5.948 0L15.5 31.6a8.868 8.868 0 0 1-2.5.4ZM20.886 27.245A8.991 8.991 0 0 1 18.71 29.9l.64 2.185a11.154 11.154 0 0 0 3.727-4.3ZM20.942 8.856q.805-.869 1.554-1.66a11.1 11.1 0 0 0-3.146-3.279L18.71 6.1a8.98 8.98 0 0 1 2.232 2.756ZM13 4a8.867 8.867 0 0 1 2.5.4l.581-1.983a10.864 10.864 0 0 0-5.948 0l.562 1.92A8.884 8.884 0 0 1 13 4Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconQuickSelect.js
var IconQuickSelect = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? QuickSelectIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-quick-select.js
init_define_element();
defineElement("sp-icon-quick-select", IconQuickSelect);

// src/custom-elements/acom/acom-action-scroller.js
init_lit();
init_style_map2();

// src/custom-elements/acom/acom-action-scroller.css.js
init_lit();
var acomActionScrollerStyleSheet = i`
  :host {
    display: block;
    box-sizing: border-box;
  }

  :host([hidden]) {
    display: none !important;
  }

  .scroller {
    position: relative;
    display: grid;
    gap: var(--spectrum-global-dimension-size-300);
  }

  .actions {
    display: grid;
    gap: var(--spectrum-global-dimension-size-300);
    grid-auto-flow: column;
    grid-auto-columns: minmax(0, var(--acom-action-tile-width, 220px));
    overflow-x: auto;
    padding-bottom: var(--spectrum-global-dimension-size-100);
    scroll-snap-type: x mandatory;
  }

  .actions ::slotted(*) {
    scroll-snap-align: start;
  }

  .nav {
    display: flex;
    justify-content: flex-end;
    gap: var(--spectrum-global-dimension-size-200);
  }
`;

// src/custom-elements/acom/acom-action-scroller.js
var AcomActionScroller = class extends i4 {
  static styles = [acomActionScrollerStyleSheet];
  static properties = {
    tileWidth: { type: Number, attribute: "tile-width" },
    showNav: {
      type: Boolean,
      attribute: "show-nav",
      converter: booleanConverter
    }
  };
  #actionsContainer;
  #slotObservers;
  constructor() {
    super();
    this.tileWidth = 220;
    this.showNav = true;
    ensureId(this, "acom-action-scroller");
    this.#actionsContainer = null;
    this.#slotObservers = [];
  }
  firstUpdated() {
    this.#actionsContainer = this.shadowRoot?.querySelector(".actions") ?? null;
    this.#slotObservers = observeSlots(this, [""], () => this.#updateJsonLd());
    this.#updateJsonLd();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    disconnectSlotObservers(this.#slotObservers);
    setJsonLd(this, null, "acom-action-scroller");
  }
  render() {
    const styles12 = {
      "--acom-action-tile-width": `${this.tileWidth}px`
    };
    return x`
      <div
        class="scroller"
        id="${this.id}-scroller"
        style=${o10(styles12)}
        role="region"
        aria-label=${this.getAttribute("aria-label") || "Quick actions"}
      >
        <div class="actions" id="${this.id}-actions">
          <slot></slot>
        </div>
        ${this.showNav ? this.#renderNav() : E}
      </div>
    `;
  }
  #renderNav() {
    return x`
      <div class="nav" id="${this.id}-nav">
        <sp-action-button
          aria-label="Scroll actions left"
          @click=${() => this.#scroll(-this.#scrollDistance())}
        >
          <sp-icon-arrow-left slot="icon"></sp-icon-arrow-left>
          Previous
        </sp-action-button>
        <sp-action-button
          aria-label="Scroll actions right"
          @click=${() => this.#scroll(this.#scrollDistance())}
        >
          <sp-icon-arrow-right slot="icon"></sp-icon-arrow-right>
          Next
        </sp-action-button>
      </div>
    `;
  }
  #scrollDistance() {
    return this.tileWidth * 1.5;
  }
  #scroll(distance) {
    if (!this.#actionsContainer) {
      return;
    }
    this.#actionsContainer.scrollBy({
      left: distance,
      behavior: "smooth"
    });
  }
  #updateJsonLd() {
    const items = Array.from(this.querySelectorAll("acom-action-tile")).map((tile, index) => ({
      position: index + 1,
      name: collectSlotText(tile, "heading") || `Action ${index + 1}`,
      description: collectSlotText(tile, "body") || "",
      url: tile.getAttribute("href") || ""
    }));
    emitItemListJsonLd(this, "acom-action-scroller", items);
  }
};
customElements.define("acom-action-scroller", AcomActionScroller);

// src/custom-elements/acom/acom-action-scroller.author.js
AcomActionScroller.ee = {
  getElementIcon(html) {
    return html`<sp-icon-quick-select slot="icon"></sp-icon-quick-select>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Action Scroller",
        description: "Horizontal scroller for quick action tiles with optional navigation controls.",
        category: "structure"
      },
      attributes: {
        "tile-width": {
          type: "number",
          default: 220,
          label: "Tile Width",
          description: "Base width for each action tile (px).",
          min: 160,
          max: 400
        },
        "show-nav": {
          type: "boolean",
          default: true,
          label: "Show navigation buttons",
          description: "Toggle next/previous buttons."
        }
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Action Tiles",
            description: "Add acom-action-tile elements.",
            minLength: 1,
            maxLength: null
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-action-scroller tile-width="240" show-nav>
        <acom-action-tile background-color="linear-gradient(135deg, #ffd654 0%, #ff8c5a 100%)">
          <span slot="heading">Action 1</span>
        </acom-action-tile>
        <acom-action-tile background-color="linear-gradient(135deg, #ffd654 0%, #ff8c5a 100%)">
          <span slot="heading">Action 2</span>
        </acom-action-tile>
        <acom-action-tile background-color="linear-gradient(135deg, #ffd654 0%, #ff8c5a 100%)">
          <span slot="heading">Action 3</span>
        </acom-action-tile>
      </acom-action-scroller>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    Array.from(element.children).forEach((child) => {
      if (child.tagName !== "ACOM-ACTION-TILE") {
        child.remove();
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconQuestion.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Question.js
var QuestionIcon = ({ width: a23 = 24, height: t34 = 24, hidden: e36 = false, title: l16 = "Question" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${a23}"
    height="${t34}"
    viewBox="0 0 36 36"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M33 4H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h11l3.536 6.839a.5.5 0 0 0 .928 0L22 28h11a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1ZM18.104 25.444a2.538 2.538 0 0 1-.35 0 2.557 2.557 0 0 1-2.7-2.7 2.6 2.6 0 0 1 2.526-2.672q.087-.003.174 0a2.6 2.6 0 0 1 2.699 2.498q.003.087.001.174a2.531 2.531 0 0 1-2.35 2.7ZM20.81 14.2l-.173.164c-.7.662-1.493 1.412-1.493 1.872a2 2 0 0 0 .3 1.04.6.6 0 0 1-.51.948h-2.089a.941.941 0 0 1-.692-.271 3.17 3.17 0 0 1-.7-1.98c0-1.358.837-2.2 1.994-3.353.765-.765 1.1-1.155 1.1-1.684 0-.264 0-.964-1.537-.964a5.652 5.652 0 0 0-2.8.739l-.18.072h-.119a.61.61 0 0 1-.616-.602V7.837a.71.71 0 0 1 .357-.68 8.11 8.11 0 0 1 3.885-.9 4.402 4.402 0 0 1 4.96 4.266A4.747 4.747 0 0 1 20.81 14.2Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconQuestion.js
var IconQuestion = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? QuestionIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-question.js
init_define_element();
defineElement("sp-icon-question", IconQuestion);

// src/custom-elements/acom/acom-faq-item.js
init_lit();
init_when2();
var AccordionItemElement = customElements.get("sp-accordion-item");
var AcomFaqItem = class extends AccordionItemElement {
  static styles = [
    AccordionItemElement.styles,
    i`
      :host {
        color: inherit;
      }
      #header {
        color: inherit;
      }
      .faq-item__description {
        color: inherit;
      }
    `
  ];
  static properties = {
    question: { type: String },
    hasDescription: { type: Boolean, attribute: "has-description", reflect: true, converter: booleanConverter },
    openState: {
      type: String,
      attribute: "open-state",
      converter: {
        fromAttribute(value) {
          if (value === null || value === "") return "inherit";
          return value;
        },
        toAttribute(value) {
          if (value === "inherit") return null;
          return value;
        }
      }
    }
  };
  constructor() {
    super();
    this.question = "";
    this.hasDescription = false;
    this.openState = "inherit";
  }
  connectedCallback() {
    super.connectedCallback();
    ensureId(this, "acom-faq-item");
    this.#updateOpenState();
  }
  updated(changed) {
    super.updated?.(changed);
    if (changed.has("question")) {
      const normalized = (this.question || "").replace(/\s+/g, " ").trim();
      if (normalized !== this.question) {
        this.question = normalized;
      }
      if (!this.label) {
        this.label = this.question;
      }
    }
    if (changed.has("openState")) {
      this.#updateOpenState();
    }
    if (changed.has("open")) {
      this.#preserveSlotAttributes();
    }
  }
  firstUpdated() {
    const titleSlot = this.shadowRoot?.querySelector('slot[name="title"]');
    if (titleSlot) {
      const assignedElements = titleSlot.assignedElements({ flatten: true });
      assignedElements.forEach((element) => {
        if (element.hasAttribute("slot") && element.getAttribute("slot") === "title") {
          const pTags = element.querySelectorAll("p");
          pTags.forEach((p30) => {
            const text = p30.textContent;
            p30.replaceWith(document.createTextNode(text));
          });
          element.normalize();
        }
      });
    }
    const slot = this.shadowRoot?.querySelector('slot[name="description"]');
    if (slot) {
      this.hasDescription = this.#slotHasContent(slot);
    }
  }
  render() {
    return x`
      <h3 id="heading">
        ${n9(this.size, this.renderChevronIcon)}
        <button
          id="header"
          @click=${this.onClick}
          aria-expanded=${this.open}
          aria-controls="content"
          ?disabled=${this.disabled}
        >
          <slot
            name="title"
            class="faq-item__title"
            @slotchange=${this.#handleTitleSlotChange}
          ></slot>
        </button>
      </h3>
      <div id="content" role="region" aria-labelledby="header">
        <slot
          class="faq-item__description"
          name="description"
          @slotchange=${this.#handleDescriptionSlotChange}
        ></slot>
      </div>
    `;
  }
  #preserveSlotAttributes() {
    requestAnimationFrame(() => {
      Array.from(this.children).forEach((child) => {
        if (child.hasAttribute("slot") && child.getAttribute("slot") === "description") {
          const slotName = child.getAttribute("slot");
          child.removeAttribute("slot");
          child.setAttribute("slot", slotName);
        }
      });
    });
  }
  #handleTitleSlotChange(event) {
    const slot = event.target;
    const assignedElements = slot.assignedElements({ flatten: true });
    assignedElements.forEach((element) => {
      if (element.hasAttribute("slot") && element.getAttribute("slot") === "title") {
        const pTags = element.querySelectorAll("p");
        pTags.forEach((p30) => {
          const text2 = p30.textContent;
          p30.replaceWith(document.createTextNode(text2));
        });
        element.normalize();
      }
    });
    const assignedNodes = slot.assignedNodes({ flatten: true });
    assignedNodes.forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE && node.hasAttribute("slot")) {
        const slotName = node.getAttribute("slot");
        if (slotName === "description") {
          node.removeAttribute("slot");
          requestAnimationFrame(() => {
            node.setAttribute("slot", "description");
          });
        }
      }
    });
    const text = this.#collectText(slot);
    this.label = text || this.question || "";
    this.dispatchEvent(
      new CustomEvent("acom-faq-item-updated", { bubbles: true, composed: true })
    );
  }
  #handleDescriptionSlotChange(event) {
    this.hasDescription = this.#slotHasContent(event.target);
    this.dispatchEvent(
      new CustomEvent("acom-faq-item-updated", { bubbles: true, composed: true })
    );
  }
  #slotHasContent(slot) {
    if (!slot) return false;
    const nodes2 = slot.assignedNodes({ flatten: true });
    return nodes2.some((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        return true;
      }
      if (node.nodeType === Node.TEXT_NODE) {
        return Boolean(node.textContent && node.textContent.trim());
      }
      return false;
    });
  }
  #collectText(slot) {
    if (!slot) return "";
    return slot.assignedNodes({ flatten: true }).map((node) => node.textContent || "").join(" ").replace(/\s+/g, " ").trim();
  }
  #updateOpenState() {
    if (this.openState === "inherit") {
      if (!this.hasAttribute("open")) {
        this.open = false;
      }
    } else if (this.openState === "true") {
      this.open = true;
      if (!this.hasAttribute("open")) {
        this.setAttribute("open", "");
      }
    } else if (this.openState === "false") {
      this.open = false;
      if (this.hasAttribute("open")) {
        this.removeAttribute("open");
      }
    }
  }
  get focusElement() {
    if (!this.shadowRoot) {
      return null;
    }
    try {
      return super.focusElement;
    } catch {
      return null;
    }
  }
};
customElements.define("acom-faq-item", AcomFaqItem);

// src/custom-elements/acom/acom-faq-item.author.js
var TEXT_STYLES8 = ["bold", "italic", "underline", "strikethrough"];
var ALIGN_FORMATS6 = ["align-left", "align-center", "align-right"];
var LIST_FORMATS3 = ["unordered-list", "ordered-list"];
AcomFaqItem.ee = {
  getElementIcon(html) {
    return html`<sp-icon-question slot="icon"></sp-icon-question>`;
  },
  getSchema() {
    return {
      schemaVersion: 2,
      element: {
        label: "ACOM FAQ Item",
        description: "Single FAQ entry with inline-editable question and answer.",
        allowBlank: false
      },
      attributes: {
        "open-state": {
          type: "enum",
          options: ["inherit", "true", "false"],
          default: "inherit",
          label: "Expanded state",
          description: "Whether this FAQ item is expanded. 'Inherit' follows the parent FAQ's expand/collapse state."
        }
      },
      slots: {
        order: ["title", "description"],
        configs: {
          title: {
            label: "Question title",
            description: "Displayed in the accordion header.",
            inlineEditable: true,
            multiline: false,
            allowedStyles: [],
            allowedFormats: [],
            tag: "span"
          },
          description: {
            label: "Answer",
            description: "Rich text content answering the question.",
            inlineEditable: true,
            multiline: true,
            allowedStyles: [...TEXT_STYLES8],
            allowedFormats: [...ALIGN_FORMATS6, ...LIST_FORMATS3],
            allowLinks: true,
            allowPaste: true
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-faq-item>
      <div slot="title">What is included?</div>
      <div slot="description"><p>Provide a concise answer and add links if needed.</p></div>
    `;
    return template.content.firstElementChild;
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconHelpCircle.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/HelpCircle.js
var HelpCircleIcon = ({ width: e36 = 24, height: l16 = 24, hidden: r25 = false, title: t34 = "Help Circle" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${l16}"
    viewBox="0 0 20 20"
    aria-hidden=${r25 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="m9.9881,15.52679c-.23065.00813-.45538-.07387-.62661-.22862-.33033-.36505-.33033-.92102,0-1.28607.16935-.15851.39483-.24308.62664-.23504.23635-.00948.46589.08035.63302.24775.16207.1679.24916.39432.24137.62755.01238.23497-.06959.46515-.2277.6394-.17358.16474-.40786.24988-.64671.23503Z"
      fill="currentColor"
    />
    <path
      d="m10,18.75c-4.8252,0-8.75-3.9248-8.75-8.75S5.1748,1.25,10,1.25s8.75,3.9248,8.75,8.75-3.9248,8.75-8.75,8.75Zm0-16c-3.99805,0-7.25,3.25195-7.25,7.25s3.25195,7.25,7.25,7.25,7.25-3.25195,7.25-7.25-3.25195-7.25-7.25-7.25Z"
      fill="currentColor"
    />
    <path
      d="m9.99219,12.70605c-.41406,0-.75-.33594-.75-.75,0-1.02246.07031-1.71387,1.03906-2.68262.78516-.78613.91797-1.10156.91797-1.65137,0-.20996-.06641-1.25781-1.37402-1.25781-1.36523,0-1.51074,1.15625-1.52637,1.3877-.02637.41309-.39258.7207-.79688.69922-.41406-.02734-.72656-.38379-.69922-.79688.06348-.96484.77637-2.79004,3.02246-2.79004,1.88672,0,2.87402,1.3877,2.87402,2.75781,0,1.14355-.45703,1.81055-1.35742,2.71191-.57617.57617-.59961.81152-.59961,1.62207,0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Help.js
var HelpIcon = ({ width: e36 = 24, height: a23 = 24, hidden: t34 = false, title: l16 = "Help" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${a23}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${l16}"
  >
    <path
      d="M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2Zm.047 26.876a2.69 2.69 0 1 1 0-5.375 2.62 2.62 0 0 1 2.8 2.67 2.581 2.581 0 0 1-2.8 2.705Zm3.566-12.818-.2.21c-.789.829-1.684 1.768-1.684 2.351a2.771 2.771 0 0 0 .359 1.348l.145.277-.113.429a.617.617 0 0 1-.567.378h-2.682a.867.867 0 0 1-.65-.235 4.111 4.111 0 0 1-.845-2.525c0-1.677.934-2.714 2.225-4.15.2-.219.39-.42.575-.609.629-.651 1.013-1.071 1.013-1.515 0-.308 0-1.245-1.786-1.245a5.918 5.918 0 0 0-3.159.919.592.592 0 0 1-.653-.02l-.237-.169-.055-.443v-2.9a.879.879 0 0 1 .393-.819 8.275 8.275 0 0 1 4.3-1.1c3.291 0 5.5 2.117 5.5 5.272a6.131 6.131 0 0 1-1.879 4.546Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconHelpCircle.js
var IconHelpCircle = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? HelpCircleIcon({ hidden: !this.label, title: this.label }) : HelpIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-help-circle.js
init_define_element();
defineElement("sp-icon-help-circle", IconHelpCircle);

// src/custom-elements/acom/acom-faq.author.js
var FAQ_METADATA_SLOTS = /* @__PURE__ */ new Set(["heading", "description"]);
var FAQ_TEXT_STYLES = ["bold", "italic", "underline"];
var FAQ_ALIGN_FORMATS = ["align-left", "align-center", "align-right"];
AcomFaq.ee = {
  getElementIcon(html) {
    return html`<sp-icon-help-circle slot="icon"></sp-icon-help-circle>`;
  },
  getSchema() {
    return {
      schemaVersion: 2,
      element: {
        label: "ACOM FAQ",
        description: "Frequently asked questions with heading, optional intro text, and Spectrum accordion items.",
        category: "content"
      },
      attributes: {
        "background-color": makeSWCColorSchema({
          defaultValue: "linear-gradient(135deg, #70a6ff 0%, #8a63ff 100%)",
          label: "Background Fill",
          description: "Solid color or gradient applied behind the FAQ.",
          attr: "background-color",
          allowGradient: true
        }),
        theme: {
          type: "enum",
          options: ["", "light", "dark"],
          default: "",
          label: "Theme",
          description: "Switch typography between light and dark treatments."
        },
        "expand-all": {
          type: "boolean",
          default: false,
          label: "Expand all",
          description: "When checked, expands all FAQ items. When unchecked, collapses all items."
        }
      },
      slots: {
        order: ["heading", "description", "default"],
        configs: {
          default: {
            label: "FAQ Items",
            description: "FAQ items to display in the list.",
            allowedTags: ["acom-faq-item"]
          },
          heading: {
            label: "Heading",
            description: "Section heading for the FAQ.",
            maxLength: 1,
            inlineEditable: true,
            multiline: false,
            plain: true,
            allowedStyles: [],
            allowedFormats: [],
            placeholder: "Questions? We have answers.",
            tag: "h2"
          },
          description: {
            label: "Description",
            description: "Supporting body copy under the heading.",
            minLength: 0,
            maxLength: null,
            inlineEditable: true,
            multiline: true,
            allowedStyles: [...FAQ_TEXT_STYLES],
            allowedFormats: [...FAQ_ALIGN_FORMATS],
            allowLinks: true,
            placeholder: "Add context for the FAQ list"
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-faq background-color="linear-gradient(135deg, #70a6ff 0%, #8a63ff 100%)">
        <h2 slot="heading">Common questions</h2>
        <div slot="description"><p>Provide quick answers so visitors can keep moving without contacting support.</p></div>
        <acom-faq-item>
          <div slot="title"><p>How do I get started?</p></div>
          <div slot="description"><p>Sign in, choose a plan that fits your team, and follow the guided setup inside the product.</p></div>
        </acom-faq-item>
        <acom-faq-item>
          <div slot="title"><p>Can I try it for free?</p></div>
          <div slot="description"><p>Yes, start a free trial to explore every feature before upgrading.</p></div>
        </acom-faq-item>
        <acom-faq-item>
          <div slot="title"><p>What's included in the plan?</p></div>
          <div slot="description"><p>All plans include desktop, web, and mobile access plus priority support.</p></div>
        </acom-faq-item>
      </acom-faq>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    Array.from(element.children).forEach((child) => {
      if (child.tagName === "SCRIPT" && child.type === "application/ld+json") {
        return;
      }
      const slot = child.getAttribute("slot");
      if (slot && !FAQ_METADATA_SLOTS.has(slot)) {
        child.removeAttribute("slot");
      }
      if (!slot && child.tagName !== "ACOM-FAQ-ITEM") {
        child.remove();
        return;
      }
      if (child.tagName === "ACOM-FAQ-ITEM" && slot) {
        child.removeAttribute("slot");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconMarketingActivities.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons/MarketingActivities.js
var MarketingActivitiesIcon = ({ width: e36 = 24, height: r25 = 24, hidden: t34 = false, title: a23 = "Marketing Activities" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="${r25}"
    viewBox="0 0 36 36"
    width="${e36}"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M25.865 6.9a4.853 4.853 0 0 1-1.508 1.315l3.91 4.729a4.859 4.859 0 0 1 1.559-1.253Zm-16.85 8.869 4.268 3.386a4.843 4.843 0 0 1 1.312-1.512l-4.31-3.419a4.852 4.852 0 0 1-1.27 1.545Zm12.71 3.4a4.79 4.79 0 0 1 .584 1.928l5.623-2.473a4.809 4.809 0 0 1-.706-1.875ZM7.042 28.255A4.851 4.851 0 0 1 8.3 29.809l5.88-4.791a4.864 4.864 0 0 1-1.152-1.641ZM10.136 9.5a4.8 4.8 0 0 1 .657 1.938L18.2 6.98a4.8 4.8 0 0 1-.89-1.8Z"
    />
    <circle cx="4" cy="32" r="3.85" />
    <circle cx="17.5" cy="21.5" r="3.85" />
    <circle cx="22" cy="4" r="3.85" />
    <circle cx="6" cy="12" r="3.85" />
    <circle cx="32" cy="16" r="3.85" />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconMarketingActivities.js
var IconMarketingActivities = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 1 ? MarketingActivitiesIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-marketing-activities.js
init_define_element();
defineElement("sp-icon-marketing-activities", IconMarketingActivities);

// src/custom-elements/acom/acom-promo-bar.js
init_lit();

// src/custom-elements/acom/acom-promo-bar.css.js
init_lit();
var acomPromoBarStyleSheet = i`
  :host {
    display: block;
    box-sizing: border-box;
    position: static;
    background: var(--acom-promo-background, var(--spectrum-global-color-gray-900));
  }

  :host([sticky]) {
    position: sticky;
    bottom: 0;
    z-index: 100;
  }

  sp-theme {
    display: block;
  }

  div {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-400);
    padding: var(--spectrum-global-dimension-size-500);
    color: var(--spectrum-body-color);
  }

  slot[name="icon"] {
    display: flex;
    align-items: center;
    flex-shrink: 0;
  }

  slot[name="icon"]::slotted(*) {
    display: block;
  }

  slot:not([name]) {
    display: inline;
  }

  slot:not([name])::slotted(*) {
    margin: 0;
    font-size: var(--spectrum-global-dimension-font-size-400, 1.5rem);
    font-weight: 700;
    line-height: 1.3;
    display: inline;
  }

  slot[name="body"] {
    display: inline;
  }

  slot[name="body"]::slotted(*),
  slot[name="body"]::slotted(p) {
    margin: 0;
    font-size: var(--spectrum-global-dimension-font-size-200, 1rem);
    line-height: 1.5;
    display: inline;
  }

  slot[name="actions"] {
    display: flex;
    gap: var(--spectrum-global-dimension-size-300);
    flex-wrap: wrap;
    justify-content: flex-end;
    flex-shrink: 0;
    margin-left: auto;
  }

  slot[name="actions"]::slotted(sp-button),
  slot[name="actions"]::slotted(checkout-button) {
    font-size: var(--spectrum-global-dimension-font-size-300, 1.25rem);
  }
`;

// src/custom-elements/acom/acom-promo-bar.js
var AcomPromoBar = class extends i4 {
  static styles = [acomPromoBarStyleSheet];
  static properties = {
    backgroundColor: { type: String, attribute: "background-color" },
    theme: { type: String, reflect: true },
    sticky: {
      type: Boolean,
      reflect: true,
      converter: booleanConverter
    }
  };
  #slotObservers;
  #sectionLabelId;
  constructor() {
    super();
    this.backgroundColor = "";
    this.theme = "";
    this.sticky = false;
    this.#slotObservers = [];
    this.#sectionLabelId = null;
    ensureId(this, "acom-promo-bar");
  }
  connectedCallback() {
    super.connectedCallback();
    this.#applyBackgroundColor();
  }
  #applyBackgroundColor() {
    const backgroundValue = normalizeBackgroundValue(this.backgroundColor, "");
    if (backgroundValue) {
      this.style.setProperty("--acom-promo-background", backgroundValue);
    } else {
      this.style.removeProperty("--acom-promo-background");
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    disconnectSlotObservers(this.#slotObservers);
  }
  firstUpdated() {
    this.#slotObservers = observeSlots(
      this,
      ["icon", "", "body", "actions"],
      () => this.#updateAccessibilityAndSchema()
    );
    this.#updateAccessibilityAndSchema();
  }
  updated(changed) {
    if (changed.has("theme")) {
      this.#normalizeTheme();
    }
    if (changed.has("backgroundColor")) {
      this.#applyBackgroundColor();
    }
    this.#updateAccessibilityAndSchema();
  }
  render() {
    const promoContent = x`
      <div
        id="${this.id}-promo"
        aria-labelledby=${this.#sectionLabelId || E}
      >
        <slot name="icon"></slot>
        <slot></slot>
        <slot name="body"></slot>
        <slot name="actions"></slot>
      </div>
    `;
    if (this.theme === "dark" || this.theme === "light") {
      return x`
        <sp-theme color="${this.theme}" scale="medium" system="spectrum-two">
          ${promoContent}
        </sp-theme>
      `;
    }
    return promoContent;
  }
  #normalizeTheme() {
    this.theme = normalizeTheme(this.theme);
  }
  #updateAccessibilityAndSchema() {
    const container = this.shadowRoot?.getElementById(`${this.id}-promo`);
    if (!container) {
      return;
    }
    container.setAttribute("role", "region");
    this.#sectionLabelId = updateRegionAccessibility({
      host: this,
      container,
      headingSlot: null,
      fallbackLabel: "Promotion",
      idPrefix: `${this.id}-heading`
    });
  }
};
customElements.define("acom-promo-bar", AcomPromoBar);

// src/custom-elements/acom/acom-promo-bar.author.js
var PROMO_BAR_SLOTS = /* @__PURE__ */ new Set(["icon", "body", "actions", ""]);
var TEXT_STYLES9 = ["bold", "italic", "underline", "strikethrough"];
var ALIGN_FORMATS7 = ["align-left", "align-center", "align-right"];
var LIST_FORMATS4 = ["unordered-list", "ordered-list"];
AcomPromoBar.ee = {
  getElementIcon(html) {
    return html`<sp-icon-marketing-activities slot="icon"></sp-icon-marketing-activities>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Promo Bar",
        description: "Persistent promotional banner with icon, copy, and actions.",
        category: "messaging"
      },
      attributes: {
        sticky: {
          type: "boolean",
          default: false,
          label: "Stick to bottom",
          description: "Affix the promo bar to the bottom of the viewport."
        },
        "background-color": makeSWCColorSchema({
          defaultValue: "linear-gradient(135deg, #ff70a6 0%, #bd70ff 100%)",
          label: "Background Fill",
          description: "Solid color or gradient applied behind the promo.",
          attr: "background-color",
          allowGradient: true
        }),
        theme: {
          type: "enum",
          options: ["", "light", "dark"],
          default: "",
          label: "Theme",
          description: "Optional override to force light or dark typography. Leave empty to inherit from parent."
        }
      },
      slots: {
        order: ["icon", "body", "actions"],
        configs: {
          icon: {
            label: "Icon",
            description: "Product icon using merch-mnemonic.",
            minLength: 0,
            maxLength: 1
          },
          body: {
            label: "Body",
            description: "Supporting text and links.",
            minLength: 0,
            maxLength: null,
            inlineEditable: true,
            multiline: true,
            allowedStyles: [...TEXT_STYLES9],
            allowedFormats: [...ALIGN_FORMATS7, ...LIST_FORMATS4],
            allowLinks: true,
            placeholder: "Add supporting copy"
          },
          actions: {
            label: "Actions",
            description: "Buttons such as Free trial or Buy now.",
            minLength: 0,
            maxLength: 3
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-promo-bar background-color="linear-gradient(135deg, #ff70a6 0%, #bd70ff 100%)" theme="dark">
        <merch-mnemonic slot="icon" name="photoshop" size="l"></merch-mnemonic>
        <span>Explore product plans.</span>
      </acom-promo-bar>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    Array.from(element.children).forEach((child) => {
      const slot = child.getAttribute("slot") || "";
      if (!PROMO_BAR_SLOTS.has(slot)) {
        child.removeAttribute("slot");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFolderBreadcrumb.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/FolderBreadcrumb.js
var FolderBreadcrumbIcon = ({ width: l16 = 24, height: r25 = 24, hidden: e36 = false, title: t34 = "Folder Breadcrumb" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${e36 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="m16.75,5h-5.96387c-.21777,0-.42383-.09375-.56641-.25879l-1.7041-1.96387c-.42676-.49414-1.0459-.77734-1.7002-.77734h-3.56543c-1.24023,0-2.25,1.00977-2.25,2.25v10.5c0,1.24023,1.00977,2.25,2.25,2.25h13.5c1.24023,0,2.25-1.00977,2.25-2.25v-7.5c0-1.24023-1.00977-2.25-2.25-2.25ZM3.25,3.5h3.56543c.21777,0,.42383.09375.56641.25879l1.07703,1.24121H2.5v-.75c0-.41309.33691-.75.75-.75Zm14.25,11.25c0,.41309-.33691.75-.75.75H3.25c-.41309,0-.75-.33691-.75-.75V6.5h14.25c.41309,0,.75.33691.75.75v7.5Z"
      fill="currentColor"
    />
    <path
      d="m10,13.65039c-.19238,0-.38379-.07324-.53027-.21973l-3-3c-.29297-.29297-.29297-.76758,0-1.06055s.76758-.29297,1.06055,0l2.46973,2.46973,2.46973-2.46973c.29297-.29297.76758-.29297,1.06055,0s.29297.76758,0,1.06055l-3,3c-.14648.14648-.33789.21973-.53027.21973Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconFolderBreadcrumb.js
var IconFolderBreadcrumb = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? FolderBreadcrumbIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-folder-breadcrumb.js
init_define_element();
defineElement("sp-icon-folder-breadcrumb", IconFolderBreadcrumb);

// src/custom-elements/acom/acom-breadcrumbs.js
init_lit();

// src/custom-elements/acom/acom-breadcrumbs.css.js
init_lit();
var acomBreadcrumbsStyleSheet = i`
  :host {
    display: block;
  }

  nav {
    display: block;
  }

  ::slotted(sp-breadcrumb-item) {
    max-width: 100%;
  }
`;

// src/custom-elements/acom/acom-breadcrumbs.js
var AcomBreadcrumbs = class extends i4 {
  static styles = [acomBreadcrumbsStyleSheet];
  static properties = {
    label: { type: String, reflect: true },
    items: { state: true }
  };
  #slotListener;
  constructor() {
    super();
    this.label = "Breadcrumb";
    this.items = [];
    this.#slotListener = null;
    ensureId(this, "acom-breadcrumbs");
  }
  firstUpdated() {
    const slot = this.shadowRoot?.querySelector("slot");
    if (slot) {
      const listener = () => this.#handleSlotChange();
      slot.addEventListener("slotchange", listener);
      this.#slotListener = { slot, listener };
    }
    this.#handleSlotChange();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#slotListener) {
      const { slot, listener } = this.#slotListener;
      slot.removeEventListener("slotchange", listener);
      this.#slotListener = null;
    }
    setJsonLd(this, null, "acom-breadcrumbs");
  }
  updated(changed) {
    if (changed.has("label")) {
      this.requestUpdate();
    }
  }
  render() {
    const ariaLabel = (this.label || "").trim() || "Breadcrumb";
    const hasItems = Array.isArray(this.items) && this.items.length > 0;
    if (!hasItems) {
      return x``;
    }
    return x`
      <nav aria-label=${ariaLabel}>
        <sp-breadcrumbs>
          <slot></slot>
        </sp-breadcrumbs>
      </nav>
    `;
  }
  #handleSlotChange() {
    const slot = this.shadowRoot?.querySelector("slot");
    if (!slot) {
      this.items = [];
      setJsonLd(this, null, "acom-breadcrumbs");
      return;
    }
    const assigned = slot.assignedElements({ flatten: true });
    this.#ensureRootSlot(assigned);
    this.items = assigned;
    this.#updateJsonLd();
  }
  #ensureRootSlot(elements) {
    elements.forEach((el, index) => {
      if (!(el instanceof HTMLElement)) return;
      if (index === 0) {
        el.setAttribute("slot", "root");
      } else if (el.getAttribute("slot") === "root") {
        el.removeAttribute("slot");
      }
    });
  }
  #updateJsonLd() {
    const elements = Array.isArray(this.items) ? this.items : [];
    const itemListElement = elements.map((el, index) => {
      const name = collectSlotText(el, "") || (el.textContent || "").replace(/\s+/g, " ").trim();
      const href = el.getAttribute?.("href") || el.href || "";
      if (!name) return null;
      const listItem2 = {
        "@type": "ListItem",
        position: index + 1,
        name
      };
      if (href) listItem2.item = href;
      return listItem2;
    }).filter(Boolean);
    if (!itemListElement.length) {
      setJsonLd(this, null, "acom-breadcrumbs");
      return;
    }
    const json = {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement
    };
    setJsonLd(this, json, "acom-breadcrumbs");
  }
};
customElements.define("acom-breadcrumbs", AcomBreadcrumbs);

// src/custom-elements/acom/acom-breadcrumbs.author.js
AcomBreadcrumbs.ee = {
  getElementIcon(html) {
    return html`<sp-icon-folder-breadcrumb slot="icon"></sp-icon-folder-breadcrumb>`;
  },
  getSchema() {
    return {
      schemaVersion: 1,
      element: {
        label: "ACOM Breadcrumbs",
        description: "Navigation hierarchy with schema.org BreadcrumbList output.",
        category: "structure"
      },
      attributes: {
        label: {
          type: "text",
          default: "Breadcrumb",
          label: "ARIA Label",
          description: "Accessible label announced for the breadcrumb navigation.",
          maxLength: 80
        }
      },
      slots: {
        order: ["default"],
        configs: {
          default: {
            label: "Breadcrumb Items",
            description: "Add sp-breadcrumb-item elements with text and href attributes to build the hierarchy.",
            minLength: 1,
            maxLength: 10
          }
        }
      }
    };
  },
  create() {
    const template = document.createElement("template");
    template.innerHTML = `
      <acom-breadcrumbs label="Breadcrumb">
        <sp-breadcrumb-item slot="root" href="https://www.adobe.com/">Home</sp-breadcrumb-item>
        <sp-breadcrumb-item href="https://www.adobe.com/products/photoshop.html">Adobe Photoshop</sp-breadcrumb-item>
      </acom-breadcrumbs>
    `;
    return template.content.firstElementChild;
  },
  sanitize(element) {
    if (!element) return;
    const label = (element.getAttribute("label") || "").trim();
    if (!label) {
      element.setAttribute("label", "Breadcrumb");
    }
    const crumbs = Array.from(element.querySelectorAll("sp-breadcrumb-item"));
    crumbs.forEach((crumb, index) => {
      if (index === 0) {
        crumb.setAttribute("slot", "root");
      } else if (crumb.getAttribute("slot") === "root") {
        crumb.removeAttribute("slot");
      }
    });
  },
  toJson(element, serializeNode) {
    const schema2 = this.getSchema(element);
    return makeToJson(element, schema2, serializeNode);
  }
};

// src/custom-elements/acom/tools/ost/offer-selector-tool.js
init_lit();
init_sp_progress_circle();

// src/custom-elements/acom/tools/ost/offer-selector-tool.store.js
var DEFAULT_PRODUCTS_ENDPOINT = "https://14257-masstudio.adobeioruntime.net/api/v1/web/MerchAtScaleStudio/ost-products-read";
var TRUE_VALUES = /* @__PURE__ */ new Set([true, "true", "TRUE", "True", 1, "1"]);
var STEP_COUNT = 3;
var OFFER_TYPE_ALL = "ALL";
var OFFER_ENDPOINT = "https://aos.adobe.io/offers";
var OFFER_STATIC_PARAMS = {
  buying_program: "RETAIL",
  country: "US",
  language: "MULT",
  merchant: "ADOBE",
  sales_channel: "DIRECT",
  service_providers: "PRICING",
  api_key: "wcms-commerce-ims-user-prod",
  environment: "PROD",
  landscape: "PUBLISHED",
  page: "0",
  page_size: "1000"
};
var SEGMENT_CODE_MAP = [
  { match: ["STUDENT"], customer: "INDIVIDUAL", market: "EDU" },
  { match: ["TEAM"], customer: "TEAM", market: "COM" },
  { match: ["EDUCATION", "UNIVERS"], customer: "TEAM", market: "EDU" }
];
function defaultFetcher(input, init) {
  if (typeof fetch === "function") {
    return fetch(input, init);
  }
  throw new Error("Global fetch is not available.");
}
var OfferSelectorToolStore = class {
  static observableActions = [
    "setStep",
    "setFilter",
    "setProducts",
    "setIsLoadingProducts",
    "setLoadError",
    "setSelectedProductId",
    "setPlanType",
    "setOfferType",
    "setCustomerSegment",
    "setMarketSegments",
    "toggleMarketSegment",
    "setOffers",
    "setIsLoadingOffers",
    "setOffersError",
    "setSelectedOfferId",
    "setPromoCode",
    "resetFlow",
    "goToNextStep",
    "goToPreviousStep",
    "markComplete",
    "loadProducts",
    "loadOffers"
  ];
  static computedProperties = [
    "selectedProduct",
    "filteredProducts",
    "availablePlanTypes",
    "availableCustomerSegments",
    "availableMarketSegments",
    "selectedOffer",
    "canGoNext",
    "canSubmit",
    "stepCount",
    "marketSegmentList"
  ];
  constructor({ endpoint = DEFAULT_PRODUCTS_ENDPOINT, fetcher = null } = {}) {
    this.endpoint = endpoint;
    this.fetcher = typeof fetcher === "function" ? fetcher : defaultFetcher;
    this.step = 0;
    this.filter = "";
    this.products = [];
    this.productMap = /* @__PURE__ */ new Map();
    this.isLoadingProducts = false;
    this.loadError = "";
    this.selectedProductId = "";
    this.planType = OFFER_TYPE_ALL;
    this.offerType = "BASE";
    this.customerSegment = "";
    this.marketSegments = /* @__PURE__ */ new Set();
    this.offers = [];
    this.isLoadingOffers = false;
    this.offersError = "";
    this.selectedOfferId = "";
    this.promoCode = "";
    this.completedAt = null;
    this.lastLoadedAt = null;
  }
  setStep(value) {
    const normalized = Number.isFinite(value) ? Math.max(0, Math.min(STEP_COUNT - 1, value)) : 0;
    this.step = normalized;
  }
  setFilter(value) {
    this.filter = typeof value === "string" ? value.trim() : "";
  }
  setProducts(list) {
    const items = Array.isArray(list) ? list : [];
    this.products = items;
    this.productMap = new Map(items.map((item) => [item.id, item]));
    if (this.selectedProductId && !this.productMap.has(this.selectedProductId)) {
      this.selectedProductId = "";
    }
    this.lastLoadedAt = items.length ? /* @__PURE__ */ new Date() : null;
    this.#syncSelectionDefaults();
  }
  setIsLoadingProducts(flag) {
    this.isLoadingProducts = !!flag;
  }
  setLoadError(message) {
    this.loadError = message ? String(message) : "";
  }
  setSelectedProductId(productId) {
    const normalized = typeof productId === "string" ? productId.trim() : "";
    if (this.selectedProductId === normalized) {
      return;
    }
    this.selectedProductId = normalized;
    this.#syncSelectionDefaults();
    this.#resetOffersState();
  }
  setOfferType(offerType) {
    const alwaysAllowed = /* @__PURE__ */ new Set(["BASE", "TRIAL", "PROMOTION"]);
    const normalized = typeof offerType === "string" ? offerType.trim().toUpperCase() : "";
    const next = normalized && alwaysAllowed.has(normalized) ? normalized : "BASE";
    if (this.offerType === next) {
      return;
    }
    this.offerType = next;
    this.#resetOffersState();
  }
  setPlanType(plan) {
    const alwaysAllowed = /* @__PURE__ */ new Set([OFFER_TYPE_ALL, "BASE", "TRIAL", "PROMOTION"]);
    const productPlanTypes = new Set((this.availablePlanTypes || []).map((t34) => String(t34).toUpperCase()));
    const allowed = /* @__PURE__ */ new Set([...alwaysAllowed, ...productPlanTypes]);
    const normalized = typeof plan === "string" ? plan.trim().toUpperCase() : "";
    const next = normalized && allowed.has(normalized) ? normalized : OFFER_TYPE_ALL;
    if (this.planType === next) {
      return;
    }
    this.planType = next;
    this.#resetOffersState();
  }
  setCustomerSegment(segment) {
    const allowed = this.availableCustomerSegments || [];
    if (!allowed.length) {
      this.customerSegment = "";
      this.marketSegments = /* @__PURE__ */ new Set();
      return;
    }
    const normalized = typeof segment === "string" ? segment.trim().toUpperCase() : "";
    let next = normalized && allowed.includes(normalized) ? normalized : this.#defaultCustomerSegment(this.customerSegment, allowed);
    if (!next) {
      next = allowed[0];
    }
    const changed = this.customerSegment !== next;
    this.customerSegment = next;
    this.#applyMarketSegmentForCustomer(next);
    if (changed) {
      this.#resetOffersState();
    }
  }
  setMarketSegments(segments) {
    const allowed = new Set(this.availableMarketSegments);
    const next = /* @__PURE__ */ new Set();
    if (Array.isArray(segments)) {
      segments.forEach((segment) => {
        if (allowed.has(segment)) {
          next.add(segment);
        }
      });
    }
    if (!next.size && allowed.size) {
      allowed.forEach((segment) => next.add(segment));
    }
    this.marketSegments = next;
  }
  toggleMarketSegment(segment) {
    if (!segment) return;
    const allowed = new Set(this.availableMarketSegments);
    if (!allowed.has(segment)) return;
    const next = new Set(this.marketSegments);
    if (next.has(segment)) {
      next.delete(segment);
    } else {
      next.add(segment);
    }
    this.marketSegments = next;
  }
  setOffers(offers) {
    const list = Array.isArray(offers) ? offers : [];
    this.offers = list;
    if (!list.length) {
      this.selectedOfferId = "";
      return;
    }
    if (!this.selectedOfferId || !list.some((offer) => offer.id === this.selectedOfferId)) {
      this.selectedOfferId = list[0]?.id || "";
    }
  }
  setIsLoadingOffers(flag) {
    this.isLoadingOffers = !!flag;
  }
  setOffersError(message) {
    this.offersError = message ? String(message) : "";
  }
  setSelectedOfferId(offerId) {
    this.selectedOfferId = offerId ? String(offerId) : "";
  }
  setPromoCode(code) {
    this.promoCode = typeof code === "string" ? code.trim() : "";
  }
  resetFlow() {
    this.step = 0;
    this.completedAt = null;
    if (!this.selectedProductId) {
      this.planType = OFFER_TYPE_ALL;
      this.offerType = "BASE";
      this.customerSegment = "";
      this.marketSegments = /* @__PURE__ */ new Set();
    }
    this.#resetOffersState();
    this.promoCode = "";
  }
  goToNextStep() {
    if (!this.canGoNext) return;
    this.step = Math.min(this.step + 1, STEP_COUNT - 1);
  }
  goToPreviousStep() {
    this.step = Math.max(this.step - 1, 0);
  }
  markComplete() {
    this.completedAt = /* @__PURE__ */ new Date();
  }
  async loadProducts({ token, force = false, signal } = {}) {
    if (!token) {
      const error = "Missing access token.";
      this.setLoadError(error);
      throw new Error(error);
    }
    if (this.isLoadingProducts) {
      return this.products;
    }
    if (this.products.length && !force) {
      return this.products;
    }
    this.setLoadError("");
    this.setIsLoadingProducts(true);
    try {
      const response = await this.fetcher(this.endpoint, {
        method: "GET",
        headers: {
          Accept: "application/json",
          Authorization: `Bearer ${token}`
        },
        signal
      });
      if (!response || !response.ok) {
        const status = response ? response.status : "0";
        throw new Error(`Unable to load products (${status}).`);
      }
      const payload = await response.json();
      const products = this.#normalizeProducts(payload);
      this.setProducts(products);
      return products;
    } catch (error) {
      this.setProducts([]);
      const message = error?.message || "Unable to load products.";
      this.setLoadError(message);
      throw error;
    } finally {
      this.setIsLoadingProducts(false);
    }
  }
  async loadOffers({ signal } = {}) {
    const product = this.selectedProduct;
    if (!product) {
      this.setOffers([]);
      this.setOffersError("Select a product before loading offers.");
      return [];
    }
    const audience = this.#resolveAudienceCodes(this.customerSegment);
    const params = new URLSearchParams({
      arrangement_code: product.arrangementCode,
      customer_segment: audience.customer,
      market_segment: audience.market,
      ...OFFER_STATIC_PARAMS
    });
    const planTypeValue = this.offerType || "BASE";
    const normalizedOfferType = String(planTypeValue).toUpperCase().trim();
    params.set("offer_type", normalizedOfferType);
    const url = `${OFFER_ENDPOINT}?${params.toString()}`;
    this.setOffersError("");
    this.setIsLoadingOffers(true);
    try {
      const response = await this.fetcher(url, {
        method: "GET",
        headers: {
          Accept: "application/json"
        },
        signal
      });
      if (!response || !response.ok) {
        const status = response ? response.status : "0";
        throw new Error(`Unable to load offers (${status}).`);
      }
      const payload = await response.json();
      const offers = this.#normalizeOffers(payload);
      this.setOffers(offers);
      return offers;
    } catch (error) {
      if (error?.name === "AbortError") {
        return [];
      }
      this.setOffers([]);
      const message = error?.message || "Unable to load offers.";
      this.setOffersError(message);
      throw error;
    } finally {
      this.setIsLoadingOffers(false);
    }
  }
  get selectedProduct() {
    return this.productMap.get(this.selectedProductId) || null;
  }
  get filteredProducts() {
    const list = Array.isArray(this.products) ? [...this.products] : [];
    let filtered = list;
    if (this.filter) {
      const query = this.filter.toLowerCase();
      filtered = list.filter((product) => {
        const tokens = [
          product.name,
          product.arrangementCode,
          product.productCode,
          product.productFamily,
          ...product.planTypes || [],
          ...product.customerSegments || [],
          ...product.marketSegments || []
        ].filter(Boolean).map((value) => String(value).toLowerCase()).join(" ");
        return tokens.includes(query);
      });
    }
    if (this.selectedProductId) {
      const selectedIndex = filtered.findIndex((product) => product.id === this.selectedProductId);
      if (selectedIndex > 0) {
        const selected = filtered[selectedIndex];
        filtered.splice(selectedIndex, 1);
        filtered.unshift(selected);
      }
    }
    return filtered;
  }
  get availablePlanTypes() {
    return this.selectedProduct?.planTypes || [];
  }
  get availableCustomerSegments() {
    return this.selectedProduct?.customerSegments || [];
  }
  get availableMarketSegments() {
    return this.selectedProduct?.marketSegments || [];
  }
  get selectedOffer() {
    if (!this.selectedOfferId) {
      return null;
    }
    return this.offers.find((offer) => offer.id === this.selectedOfferId) || null;
  }
  get marketSegmentList() {
    return Array.from(this.marketSegments);
  }
  get canGoNext() {
    if (this.step === 0) {
      return !!this.selectedProduct;
    }
    if (this.step === 1) {
      return !!this.selectedProduct && !!this.offerType && !!this.customerSegment;
    }
    return true;
  }
  get canSubmit() {
    return this.step === STEP_COUNT - 1 && !!this.selectedProduct && !!this.selectedOfferId;
  }
  get stepCount() {
    return STEP_COUNT;
  }
  #syncSelectionDefaults() {
    const product = this.productMap.get(this.selectedProductId) || null;
    if (!product) {
      this.planType = OFFER_TYPE_ALL;
      this.offerType = "BASE";
      this.customerSegment = "";
      this.marketSegments = /* @__PURE__ */ new Set();
      return;
    }
    const planTypes = Array.isArray(product.planTypes) ? product.planTypes : [];
    const alwaysAllowed = /* @__PURE__ */ new Set([OFFER_TYPE_ALL, "BASE", "TRIAL", "PROMOTION"]);
    const segments = Array.isArray(product.customerSegments) ? product.customerSegments : [];
    const currentPlanType = String(this.planType || "").toUpperCase();
    if (!currentPlanType || !alwaysAllowed.has(currentPlanType) && !planTypes.includes(currentPlanType)) {
      this.planType = OFFER_TYPE_ALL;
    }
    const offerTypeAllowed = /* @__PURE__ */ new Set(["BASE", "TRIAL", "PROMOTION"]);
    const currentOfferType = String(this.offerType || "").toUpperCase();
    if (!currentOfferType || !offerTypeAllowed.has(currentOfferType)) {
      this.offerType = "BASE";
    }
    const nextSegment = this.#defaultCustomerSegment(this.customerSegment, segments);
    this.customerSegment = nextSegment;
    this.#applyMarketSegmentForCustomer(nextSegment);
  }
  #normalizeProducts(payload) {
    const combined = payload?.combinedProducts;
    if (!combined || typeof combined !== "object") {
      return [];
    }
    return Object.values(combined).map((item) => this.#normalizeProduct(item)).filter((item) => item.id);
  }
  #normalizeProduct(item) {
    if (!item || typeof item !== "object") {
      return {
        id: "",
        arrangementCode: "",
        name: "",
        icon: "",
        productCode: "",
        productFamily: "",
        planTypes: [],
        customerSegments: [],
        marketSegments: []
      };
    }
    const arrangement = item.arrangement_code || item.arrangementCode || item.product_code || "";
    return {
      id: arrangement,
      arrangementCode: arrangement,
      name: item.name ? String(item.name) : "Untitled product",
      icon: item.icon ? String(item.icon) : "",
      productCode: item.product_code ? String(item.product_code) : "",
      productFamily: item.product_family ? String(item.product_family) : "",
      planTypes: this.#enabledKeys(item.planTypes),
      customerSegments: this.#enabledKeys(item.customerSegments),
      marketSegments: this.#enabledKeys(item.marketSegments)
    };
  }
  #enabledKeys(source) {
    if (!source || typeof source !== "object") {
      return [];
    }
    return Object.entries(source).filter(([, value]) => {
      if (TRUE_VALUES.has(value)) return true;
      if (typeof value === "string") {
        return TRUE_VALUES.has(value.toLowerCase());
      }
      return false;
    }).map(([key]) => String(key).toUpperCase());
  }
  #normalizeOffers(payload) {
    const list = Array.isArray(payload?.offers) ? payload.offers : Array.isArray(payload) ? payload : Array.isArray(payload?.data) ? payload.data : [];
    return list.map((offer, index) => this.#normalizeOffer(offer, index)).filter((offer) => offer.id);
  }
  #normalizeOffer(source, index = 0) {
    if (!source || typeof source !== "object") {
      return {
        id: "",
        name: "",
        pricePointLabel: "",
        offerType: "",
        planType: "",
        language: "",
        price: { amount: null, currency: "", display: "" },
        commitment: "",
        term: ""
      };
    }
    const fallbackId = `${this.selectedProductId || "offer"}-${index}`;
    const id = source.offer_id || source.offerId || source.id || fallbackId;
    const pricePointLabel = source.price_point || source.pricePointLabel || source.pricePoint?.type || source.pricePoint?.label || "Regular";
    const planType = source.plan_type || source.planType || "";
    const offerType = source.offer_type || source.offerType || OFFER_TYPE_ALL;
    const language = source.language || source.language_code || OFFER_STATIC_PARAMS.language;
    const name = source.name || this.selectedProduct?.name || "Offer";
    const priceInfo = source.price || source.pricePoint?.price || source.amount || {};
    const currency = priceInfo.currency || priceInfo.currency_code || priceInfo.currencyCode || "USD";
    const amount = Number(priceInfo.amount ?? priceInfo.value ?? NaN);
    const display = priceInfo.display || priceInfo.formatted || priceInfo.localized || this.#formatPriceDisplay(amount, currency);
    const term = source.term || source.term_code || source.termCode || "";
    const commitment = source.commitment || source.commitment_code || source.commitmentCode || "";
    return {
      id: String(id),
      name: String(name),
      pricePointLabel: String(pricePointLabel),
      offerType: String(offerType),
      planType: planType ? String(planType) : "",
      language: String(language),
      price: {
        amount: Number.isFinite(amount) ? amount : null,
        currency,
        display: display || ""
      },
      commitment: String(commitment),
      term: String(term)
    };
  }
  #formatPriceDisplay(amount, currency) {
    if (!Number.isFinite(amount) || !currency) {
      return "";
    }
    try {
      return new Intl.NumberFormat("en-US", {
        style: "currency",
        currency
      }).format(amount);
    } catch {
      return `${currency} ${amount.toFixed(2)}`;
    }
  }
  #defaultCustomerSegment(currentValue, segments) {
    if (!Array.isArray(segments) || !segments.length) {
      return "";
    }
    const normalizedCurrent = typeof currentValue === "string" ? currentValue.trim().toUpperCase() : "";
    if (normalizedCurrent && segments.includes(normalizedCurrent)) {
      return normalizedCurrent;
    }
    return segments[0];
  }
  #resolveAudienceCodes(segment) {
    const token = typeof segment === "string" ? segment.trim().toUpperCase() : "";
    const mapping = SEGMENT_CODE_MAP.find(({ match }) => match.some((needle) => token.includes(needle))) || null;
    if (mapping) {
      return { customer: mapping.customer, market: mapping.market };
    }
    return { customer: "INDIVIDUAL", market: "COM" };
  }
  #applyMarketSegmentForCustomer(segment) {
    const { market } = this.#resolveAudienceCodes(segment);
    this.marketSegments = market ? /* @__PURE__ */ new Set([market]) : /* @__PURE__ */ new Set();
  }
  #resetOffersState() {
    this.offers = [];
    this.selectedOfferId = "";
    this.offersError = "";
    this.isLoadingOffers = false;
  }
  #clearSelectionState() {
    this.step = 0;
    this.selectedProductId = "";
    this.planType = OFFER_TYPE_ALL;
    this.offerType = "BASE";
    this.customerSegment = "";
    this.marketSegments = /* @__PURE__ */ new Set();
    this.#resetOffersState();
    this.promoCode = "";
    this.completedAt = null;
  }
};
makeObservable(OfferSelectorToolStore);

// src/custom-elements/acom/tools/ost/offer-selector-tool.css.js
init_lit();
var offerSelectorToolStyles = i`
  :host {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
  }

  :host([hidden]) {
    display: none;
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  .step-content {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-300);
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  .review-step {
    gap: var(--spectrum-global-dimension-size-250);
  }

  .selection-header {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-50);
  }

  .selection-title {
    font-size: var(--spectrum-global-dimension-size-250);
    font-weight: 600;
    color: var(--spectrum-alias-heading-text-color);
  }

  .selection-subtitle {
    color: var(--spectrum-global-color-gray-700);
    font-size: var(--spectrum-global-dimension-size-175);
  }

  .entitlements-step {
    gap: var(--spectrum-global-dimension-size-250);
  }

  .entitlements-header {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-50);
  }

  .entitlements-title {
    font-size: var(--spectrum-global-dimension-size-250);
    font-weight: 600;
    color: var(--spectrum-alias-heading-text-color);
  }

  .entitlements-product {
    font-size: var(--spectrum-global-dimension-size-175);
    color: var(--spectrum-global-color-gray-700);
  }

  .products-title {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-50);
  }

  .products-title h4 {
    margin: 0;
    font-size: var(--spectrum-global-dimension-size-250);
    color: var(--spectrum-alias-heading-text-color);
  }

  .products-search {
    width: 100%;
  }

  .products-search sp-search {
    width: 100%;
  }

  .product-list {
    border: 1px solid var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-global-dimension-size-150);
    display: flex;
    flex-direction: column;
    background: var(--spectrum-alias-component-background-color);
    flex: 1;
    min-height: 0;
    overflow-y: auto;
    margin-bottom: var(--spectrum-global-dimension-size-200);
  }

  .offer-list {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-150);
    flex: 1;
    min-height: 0;
    overflow-y: auto;
    padding: 2px;
    margin-bottom: var(--spectrum-global-dimension-size-200);
  }

  .offers-loading {
    display: grid;
    place-items: center;
    min-height: 200px;
  }

  .offer-card {
    border: 1px solid var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-global-dimension-size-150);
    padding: var(--spectrum-global-dimension-size-200);
    margin: 2px;
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-150);
    cursor: pointer;
    transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
  }

  .offer-card:hover {
    background: var(--spectrum-global-color-gray-75);
  }

  .offer-card:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px var(--spectrum-global-color-blue-500);
  }

  .offer-card--selected {
    border-color: var(--spectrum-global-color-blue-500);
    box-shadow: 0 0 0 1px var(--spectrum-global-color-blue-500);
    background: var(--spectrum-global-color-gray-100);
  }

  .offer-card__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    overflow: hidden;
  }

  .offer-card__body {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-200);
  }

  .offer-card__product {
    display: flex;
    gap: var(--spectrum-global-dimension-size-150);
    align-items: center;
  }

  .offer-card__name {
    font-weight: 600;
    color: var(--spectrum-alias-heading-text-color);
  }

  .offer-card__id {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-75);
    font-size: var(--spectrum-global-dimension-size-150);
    color: var(--spectrum-global-color-gray-700);
  }

  .offer-card__id sp-action-button {
    --spectrum-actionbutton-border-color: transparent;
  }

  .offer-card__check {
    color: var(--spectrum-global-color-green-500);
  }

  .offer-info-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--spectrum-global-dimension-size-150);
  }

  .offer-field {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-50);
  }

  .offer-label {
    font-size: var(--spectrum-global-dimension-size-150);
    color: var(--spectrum-global-color-gray-600);
  }

  .offer-value {
    font-weight: 600;
    color: var(--spectrum-alias-heading-text-color);
  }

  .product-option {
    display: flex;
    align-items: center;
    gap: var(--spectrum-global-dimension-size-200);
    padding: var(--spectrum-global-dimension-size-200) var(--spectrum-global-dimension-size-300);
    cursor: pointer;
    border-bottom: 1px solid var(--spectrum-alias-border-color);
    transition: background 120ms ease, box-shadow 120ms ease;
  }

  .product-option:last-child {
    border-bottom: none;
  }

  .product-option:hover {
    background: var(--spectrum-global-color-gray-100);
  }

  .product-option:focus-visible {
    outline: none;
    box-shadow: inset 0 0 0 2px var(--spectrum-global-color-blue-500);
  }

  .product-option--selected {
    background: var(--spectrum-global-color-gray-200);
    outline: 1px solid var(--spectrum-global-color-blue-500);
  }

  .product-list-footer {
    border-top: 1px solid var(--spectrum-alias-border-color);
    padding: var(--spectrum-global-dimension-size-150) var(--spectrum-global-dimension-size-300);
    background: var(--spectrum-alias-component-background-color);
  }

  .product-option-body {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-50);
  }

  .product-option-name {
    font-weight: 600;
    color: var(--spectrum-alias-heading-text-color);
  }

  .product-option-code {
    color: var(--spectrum-global-color-gray-600);
    font-size: var(--spectrum-global-dimension-size-125);
  }

  .loading-state {
    display: grid;
    place-items: center;
    min-height: 200px;
  }

  .empty-state {
    border: 1px dashed var(--spectrum-alias-border-color);
    border-radius: var(--spectrum-global-dimension-size-150);
    padding: var(--spectrum-global-dimension-size-300);
    text-align: center;
    color: var(--spectrum-global-color-gray-700);
  }

  .field-block {
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-150);
  }

  .field-block sp-picker {
    width: 100%;
  }

  .customer-segment-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: var(--spectrum-global-dimension-size-150);
  }

  .customer-segment-group sp-radio {
    margin: 0;
  }

  .footer-actions {
    display: flex;
    justify-content: space-between;
    gap: var(--spectrum-global-dimension-size-200);
    flex-wrap: wrap;
    margin-top: auto;
  }

  .footer-actions sp-button + sp-button {
    margin-inline-start: var(--spectrum-global-dimension-size-150);
  }

  .product-preview {
    width: 40px;
    border-radius: 8px;
    background: var(--spectrum-global-color-gray-200);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  .product-preview img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .preview-initials {
    font-weight: 600;
    font-size: var(--spectrum-global-dimension-size-200);
    color: var(--spectrum-global-color-gray-900);
  }

  .promo-block {
    border: 2px solid #ACCFFD;
    border-radius: 8px;
    padding: var(--spectrum-global-dimension-size-200);
    display: flex;
    flex-direction: column;
    gap: var(--spectrum-global-dimension-size-100);
    min-height: 97px;
    box-sizing: border-box;
    background: #F5F9FF;
    margin-bottom: var(--spectrum-global-dimension-size-200);
  }

  .promo-label {
    font-size: var(--spectrum-global-dimension-size-200);
    font-weight: 600;
    color: #292929;
  }

  .promo-block--applied {
    padding: var(--spectrum-global-dimension-size-200) var(--spectrum-global-dimension-size-250);
    min-height: 64px;
    display: flex;
    align-items: center;
  }

  .promo-applied-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spectrum-global-dimension-size-150);
  }

  .promo-applied-text {
    font-size: var(--spectrum-global-dimension-size-200);
    flex: 1;
  }

  .promo-applied-text strong {
    font-weight: 600;
    color: #000000;
  }

  .promo-close-button {
    flex-shrink: 0;
    --spectrum-actionbutton-border-color: transparent;
  }

  .promo-close-button sp-icon-close {
    color: #000000;
  }

  .promo-row {
    display: flex;
    gap: var(--spectrum-global-dimension-size-100);
    flex-wrap: wrap;
  }

  .promo-row sp-textfield {
    flex: 1;
    min-width: 200px;
  }
`;

// src/custom-elements/acom/tools/ost/offer-selector-tool.js
var PRODUCT_LIST_INITIAL_BATCH = 50;
var PRODUCT_LIST_INCREMENT = 8;
var OFFER_TYPE_LABELS = {
  base: "BASE",
  trial: "TRIAL",
  promotion: "PROMOTION"
};
var OfferSelectorTool = class extends i4 {
  static styles = [offerSelectorToolStyles];
  static properties = {
    heading: { type: String },
    subheading: { type: String },
    productsEndpoint: { type: String, attribute: "products-endpoint" },
    store: { type: Object, attribute: false, observe: true },
    visibleProductLimit: { type: Number, attribute: false },
    productArrangement: { type: String, attribute: "product-arrangement" },
    target: { type: Object, attribute: false }
  };
  set target(value) {
    const oldValue = this._target;
    if (oldValue !== value) {
      this._target = value;
      if (value && this.#initialAttributes === null) {
        this.#initialAttributes = /* @__PURE__ */ new Map();
        const promoCode = value.getAttribute("promotion-code");
        const wcsOsi = value.getAttribute("wcs-osi");
        this.#initialAttributes.set("promotion-code", promoCode);
        this.#initialAttributes.set("wcs-osi", wcsOsi);
      } else if (!value) {
        this.#initialAttributes = null;
      }
      this.requestUpdate("target", oldValue);
    }
  }
  get target() {
    return this._target;
  }
  constructor() {
    super();
    this.heading = "Compose an offer experience";
    this.subheading = "Pick a product, tailor visibility, and review before sharing.";
    this.productsEndpoint = this.getAttribute("products-endpoint") || "";
    this.productArrangement = this.getAttribute("product-arrangement") || "";
    const endpoint = this.productsEndpoint || void 0;
    this.store = new OfferSelectorToolStore({ endpoint });
    this.#loadController = null;
    this.#hasLoaded = false;
    this.visibleProductLimit = PRODUCT_LIST_INITIAL_BATCH;
    this.#lastFilterValue = "";
    this.#offerController = null;
    this.#lastOfferKey = null;
    this.#accessToken = null;
    this.#previousSelectedOfferId = null;
    this.#initialAttributes = null;
    this.#osiController = null;
    this.#hasLoadedOsi = false;
    this.#offerOsiMap = /* @__PURE__ */ new Map();
    this.#offerPlanTypeMap = /* @__PURE__ */ new Map();
  }
  #loadController;
  #hasLoaded;
  #lastFilterValue;
  #offerController;
  #lastOfferKey;
  #accessToken;
  #previousSelectedOfferId;
  #initialAttributes;
  #osiController;
  #hasLoadedOsi;
  #offerOsiMap;
  #offerPlanTypeMap;
  disconnectedCallback() {
    this.dispatchEvent(
      new CustomEvent("tool-close", {
        bubbles: true,
        composed: true
      })
    );
    super.disconnectedCallback();
    if (this.#loadController) {
      this.#loadController.abort();
      this.#loadController = null;
    }
    if (this.#offerController) {
      this.#offerController.abort();
      this.#offerController = null;
    }
    if (this.#osiController) {
      this.#osiController.abort();
      this.#osiController = null;
    }
    if (this.target && this.#initialAttributes !== null) {
      try {
        for (const [name, value] of this.#initialAttributes) {
          if (value === null) {
            this.target.removeAttribute(name);
          } else {
            this.target.setAttribute(name, value);
          }
        }
      } catch (error) {
        console.warn("Unable to restore target attributes", error);
      }
    }
  }
  updated(changed) {
    if (changed.has("productsEndpoint") && this.store) {
      this.store.endpoint = this.productsEndpoint || this.store.endpoint;
    }
    if (changed.has("store") && this.store) {
      if (this.productsEndpoint) {
        this.store.endpoint = this.productsEndpoint;
      }
      this.#resetVisibleProductLimit();
    }
    if (changed.has("productArrangement")) {
      this.#applyProductArrangement();
    }
    if (changed.has("target")) {
      if (this.target && this.store) {
        const promoCodeAttr = this.target.getAttribute("promotion-code");
        if (promoCodeAttr !== null) {
          const promoCodeValue = String(promoCodeAttr).trim();
          if (promoCodeValue && this.store.promoCode !== promoCodeValue) {
            this.store.setPromoCode(promoCodeValue);
          }
        } else if (this.store.promoCode) {
          this.store.setPromoCode("");
        }
      }
      this.#maybeLoadOsiData();
    }
    const currentSelectedOfferId = this.store?.selectedOfferId || null;
    if (currentSelectedOfferId && currentSelectedOfferId !== this.#previousSelectedOfferId) {
      this.#previousSelectedOfferId = currentSelectedOfferId;
      this.#scrollSelectedOfferIntoView(currentSelectedOfferId);
    } else if (!currentSelectedOfferId) {
      this.#previousSelectedOfferId = null;
    }
    this.setAttribute("role", "dialog");
    const describedBy = this.subheading ? this.subheadingId : null;
    if (this.heading) {
      this.setAttribute("aria-labelledby", this.headingId);
    } else {
      this.removeAttribute("aria-labelledby");
    }
    if (describedBy) {
      this.setAttribute("aria-describedby", describedBy);
    } else {
      this.removeAttribute("aria-describedby");
    }
  }
  render() {
    return x`
      ${this.heading ? x`<span id=${this.headingId} class="visually-hidden">${this.heading}</span>` : E}
      ${this.subheading ? x`<span id=${this.subheadingId} class="visually-hidden">${this.subheading}</span>` : E}
      ${this.stepTemplate}
      ${this.footerTemplate}
    `;
  }
  get stepTemplate() {
    const store = this.store;
    if (!store) return E;
    if (store.step === 0) return this.productsStepTemplate;
    if (store.step === 1) return this.segmentsStepTemplate;
    return this.reviewStepTemplate;
  }
  get productsStepTemplate() {
    const store = this.store;
    if (!store) return E;
    const products = store.filteredProducts || [];
    this.#syncVisibleProductLimit(products, store.filter || "");
    const limit = this.visibleProductLimit || PRODUCT_LIST_INITIAL_BATCH;
    const visibleProducts = products.slice(0, limit);
    const hasMoreProducts = visibleProducts.length < products.length;
    return x`
      <section class="step-content" aria-labelledby=${this.productsSectionId}>
        <div class="products-title">
          <h4 id=${this.productsSectionId}>Select product</h4>
        </div>
        <div class="products-search">
          <sp-search
            id=${this.searchId}
            label="Search products"
            placeholder="Search product"
            value=${store.filter || ""}
            @input=${this.#handleFilterInput}
          ></sp-search>
        </div>
        ${store.loadError ? x`<sp-help-text variant="negative" size="m">${store.loadError}</sp-help-text>` : E}
        ${store.isLoadingProducts ? x`<div class="loading-state">
              <sp-progress-circle indeterminate size="l"></sp-progress-circle>
            </div>` : products.length ? x`<div
                  class="product-list"
                  role="listbox"
                  aria-label="Available products"
                  @scroll=${this.#handleProductListScroll}
                >
                  ${visibleProducts.map(
      (product, index) => this.#renderProductOption(product, {
        attachFocusLoader: hasMoreProducts && index === visibleProducts.length - 1
      })
    )}
                  ${hasMoreProducts ? x`<div class="product-list-footer" aria-hidden="true">
                        <sp-help-text size="s">Scroll to load additional products.</sp-help-text>
                      </div>` : E}
                </div>` : x`<div class="empty-state">No products match this filter.</div>`}
      </section>
    `;
  }
  get segmentsStepTemplate() {
    const store = this.store;
    const product = store?.selectedProduct;
    if (!product) {
      return x`
        <sp-illustrated-message
          heading="Choose a product"
          description="Select a product in step one to adjust segment visibility."
        ></sp-illustrated-message>
      `;
    }
    const customerSegments = store.availableCustomerSegments || [];
    const hasCustomerSegments = customerSegments.length > 0;
    const selectedSegment = this.#ensureCustomerSegmentSelection(customerSegments);
    const offerTypeOptions = ["BASE", "TRIAL", "PROMOTION"];
    const hasOfferTypes = offerTypeOptions.length > 0;
    const selectedOfferType = this.#ensureOfferTypeSelection(offerTypeOptions);
    return x`
      <section class="step-content entitlements-step" aria-live="polite">
        <div class="entitlements-header">
          <div class="entitlements-title">Select entitlements</div>
          <div class="entitlements-product">For ${product.name}</div>
        </div>
        <div class="field-block">
          <sp-field-label size="s" for=${hasCustomerSegments ? this.customerSegmentGroupId : E}
            >Choose your segment</sp-field-label
          >
          ${hasCustomerSegments ? x`
                <sp-radio-group
                  id=${this.customerSegmentGroupId}
                  class="customer-segment-group"
                  selected=${selectedSegment}
                  value=${selectedSegment}
                  @change=${this.#handleCustomerSegmentChange}
                >
                  ${customerSegments.map(
      (segment) => x`<sp-radio value=${segment}>${this.#formatToken(segment)}</sp-radio>`
    )}
                </sp-radio-group>
              ` : x`<sp-help-text size="s">No segments available.</sp-help-text>`}
        </div>
        <div class="field-block">
          <sp-field-label size="s" for=${hasOfferTypes ? this.offerTypeGroupId : E}
            >Choose your offer type</sp-field-label
          >
          ${hasOfferTypes ? x`
                <sp-picker
                  id=${this.offerTypeGroupId}
                  value=${selectedOfferType}
                  @change=${this.#handleOfferTypeChange}
                >
                  ${offerTypeOptions.map((type) => {
      const optionLabel = this.#formatOfferType(type);
      return x`<sp-menu-item value=${type}>${optionLabel}</sp-menu-item>`;
    })}
                </sp-picker>
              ` : x`<sp-help-text size="s">No offer types available.</sp-help-text>`}
        </div>
      </section>
    `;
  }
  get reviewStepTemplate() {
    const store = this.store;
    const product = store?.selectedProduct;
    if (!product) {
      return x`
        <sp-illustrated-message
          heading="Nothing to review"
          description="Select a product and audience to summarize the dialog."
        ></sp-illustrated-message>
      `;
    }
    this.#maybeLoadOffers();
    if (store.offers && store.offers.length > 0 && !store.isLoadingOffers) {
      this.#ensureOfferOsiIds();
    }
    const offerType = this.#formatOfferType(store.offerType);
    const customer = this.#formatToken(store.customerSegment) || "N/A";
    return x`
      <section class="step-content review-step" aria-live="polite">
        <div class="selection-header">
          <div class="selection-title">Select offer</div>
          <div class="selection-subtitle">For ${product.name}, ${customer}, ${offerType}</div>
        </div>
        ${this.#renderOfferList()}
        ${this.#renderPromoBlock()}
      </section>
    `;
  }
  get footerTemplate() {
    const store = this.store;
    if (!store) return E;
    const step = store.step || 0;
    const lastStep = (store.stepCount || 3) - 1;
    const primaryLabel = step >= lastStep ? "Confirm selection" : "Continue";
    const primaryDisabled = step >= lastStep ? !store.canSubmit : !store.canGoNext;
    return x`
      <div class="footer-actions">
        <div>
          ${step === 0 ? x`<sp-button variant="secondary" @click=${this.#handleCancel}>Cancel</sp-button>` : x`<sp-button variant="secondary" @click=${this.#handleBack}>Back</sp-button>`}
        </div>
        <div>
          <sp-button
            variant="accent"
            id=${this.primaryButtonId}
            ?disabled=${primaryDisabled}
            @click=${this.#handlePrimaryAction}
          >
            ${primaryLabel}
          </sp-button>
        </div>
      </div>
    `;
  }
  get headingId() {
    return `${this.id}-heading`;
  }
  get subheadingId() {
    return `${this.id}-subheading`;
  }
  get dialogBodyId() {
    return `${this.id}-dialog`;
  }
  get productsSectionId() {
    return `${this.id}-products`;
  }
  get searchId() {
    return `${this.id}-search`;
  }
  get offerTypeGroupId() {
    return `${this.id}-offer-types`;
  }
  get customerSegmentGroupId() {
    return `${this.id}-customer-segments`;
  }
  get primaryButtonId() {
    return `${this.id}-primary`;
  }
  get promoFieldId() {
    return `${this.id}-promo`;
  }
  #handleFilterInput(event) {
    const value = event.target?.value || "";
    this.store?.setFilter?.(value);
  }
  #handleOfferTypeChange(event) {
    const value = event.target?.value || "";
    this.store?.setOfferType?.(value);
  }
  #handleCustomerSegmentChange(event) {
    const value = event.target?.value || "";
    this.store?.setCustomerSegment?.(value);
  }
  #handlePrimaryAction() {
    const store = this.store;
    if (!store) return;
    const lastIndex = (store.stepCount || 3) - 1;
    if (store.step >= lastIndex) {
      store.markComplete();
      const input = this.shadowRoot?.getElementById(this.promoFieldId);
      if (input) {
        const currentInputValue = (input.value || "").trim();
        if (currentInputValue !== store.promoCode) {
          store.setPromoCode(currentInputValue);
        }
      }
      const promoCodeValue = store.promoCode ? String(store.promoCode).trim() : "";
      if (this.target) {
        if (promoCodeValue) {
          this.target.setAttribute("promotion-code", promoCodeValue);
        } else {
          this.target.removeAttribute("promotion-code");
        }
      }
      this.dispatchEvent(
        new CustomEvent("offer-selector-submit", {
          detail: {
            product: store.selectedProduct,
            offerType: store.offerType,
            planType: store.planType,
            customerSegment: store.customerSegment,
            marketSegments: store.marketSegmentList,
            offer: store.selectedOffer,
            promoCode: store.promoCode
          },
          bubbles: true,
          composed: true
        })
      );
      this.dispatchEvent(
        new CustomEvent("tool-close", {
          bubbles: true,
          composed: true
        })
      );
      this.target = null;
      this.remove();
      return;
    }
    store.goToNextStep();
  }
  #handleBack() {
    this.store?.goToPreviousStep?.();
  }
  #handleCancel() {
    this.dispatchEvent(
      new CustomEvent("tool-close", {
        bubbles: true,
        composed: true
      })
    );
  }
  #handleProductSelect(productId) {
    this.store?.setSelectedProductId?.(productId);
    if (this.store?.step === 0 && this.store?.canGoNext) {
      this.store.goToNextStep();
    }
  }
  #handleProductKeydown(event, productId) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      this.#handleProductSelect(productId);
    }
  }
  #handleProductListScroll(event) {
    const scroller = event?.currentTarget;
    if (!scroller) return;
    const total = this.store?.filteredProducts?.length || 0;
    if (!total) return;
    if ((this.visibleProductLimit || PRODUCT_LIST_INITIAL_BATCH) >= total) return;
    const threshold = 32;
    const position = scroller.scrollTop + scroller.clientHeight;
    if (position >= scroller.scrollHeight - threshold) {
      this.#increaseVisibleProductLimit(total);
    }
  }
  #handleProductListEdgeFocus() {
    const total = this.store?.filteredProducts?.length || 0;
    if (!total) return;
    if ((this.visibleProductLimit || PRODUCT_LIST_INITIAL_BATCH) >= total) return;
    this.#increaseVisibleProductLimit(total);
  }
  #increaseVisibleProductLimit(total) {
    const nextLimit = Math.min(
      total,
      (this.visibleProductLimit || PRODUCT_LIST_INITIAL_BATCH) + PRODUCT_LIST_INCREMENT
    );
    if (nextLimit !== this.visibleProductLimit) {
      this.visibleProductLimit = nextLimit;
    }
  }
  #syncVisibleProductLimit(products, filterValue) {
    const normalizedFilter = filterValue || "";
    if (normalizedFilter !== this.#lastFilterValue) {
      this.#lastFilterValue = normalizedFilter;
      this.#resetVisibleProductLimit(false);
      return;
    }
    if (!products.length) {
      this.#resetVisibleProductLimit(false);
    }
  }
  #resetVisibleProductLimit(updateFilterReference = true) {
    if (this.visibleProductLimit !== PRODUCT_LIST_INITIAL_BATCH) {
      this.visibleProductLimit = PRODUCT_LIST_INITIAL_BATCH;
    }
    if (updateFilterReference) {
      this.#lastFilterValue = this.store?.filter || "";
    }
  }
  setAccessToken(token) {
    if (!token) return;
    this.#accessToken = token;
    this.#initialize();
  }
  #initialize() {
    if (!this.#accessToken) return;
    this.#loadProducts();
    this.#maybeLoadOsiData();
  }
  async #loadProducts(force = false) {
    const store = this.store;
    if (!store) return;
    if (!this.#accessToken) return;
    if (store.isLoadingProducts) return;
    if (this.#hasLoaded && !force) return;
    if (this.#loadController) {
      this.#loadController.abort();
    }
    const controller = new AbortController();
    this.#loadController = controller;
    try {
      await store.loadProducts({ token: this.#accessToken, force, signal: controller.signal });
      this.#applyProductArrangement();
      this.#hasLoaded = true;
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error("Unable to load offer products", error);
      }
    } finally {
      if (this.#loadController === controller) {
        this.#loadController = null;
      }
    }
  }
  #ensureCustomerSegmentSelection(customerSegments) {
    if (!Array.isArray(customerSegments) || !customerSegments.length) {
      return "";
    }
    const current = this.store?.customerSegment || "";
    if (current && customerSegments.includes(current)) {
      return current;
    }
    const fallback = customerSegments[0];
    this.store?.setCustomerSegment?.(fallback);
    return fallback;
  }
  #ensureOfferTypeSelection(offerTypeOptions) {
    if (!Array.isArray(offerTypeOptions) || !offerTypeOptions.length) {
      return "BASE";
    }
    const current = this.store?.offerType || "";
    if (current && offerTypeOptions.includes(current)) {
      return current;
    }
    const fallback = offerTypeOptions[0] || "BASE";
    this.store?.setOfferType?.(fallback);
    return fallback;
  }
  #applyProductArrangement() {
    const store = this.store;
    if (!store) return;
    const arrangement = (this.productArrangement || "").trim();
    if (!arrangement) return;
    const products = store.products || [];
    if (!products.length) return;
    const match = products.find(
      (product) => product.arrangementCode === arrangement || product.id === arrangement || product.productCode === arrangement
    ) || null;
    if (!match) return;
    if (store.selectedProductId !== match.id) {
      store.setSelectedProductId(match.id);
    }
    if (store.step === 0 && store.canGoNext) {
      store.goToNextStep();
    }
  }
  #renderProductOption(product, options = {}) {
    const selected = this.store?.selectedProductId === product.id;
    const optionId = `${this.id}-product-${product.id}`;
    const classes = `product-option${selected ? " product-option--selected" : ""}`;
    const label = product.name || "Untitled product";
    const meta = product.arrangementCode || product.productCode || "";
    const attachFocusLoader = Boolean(options.attachFocusLoader);
    return x`
      <div
        id=${optionId}
        class=${classes}
        role="option"
        aria-selected=${selected ? "true" : "false"}
        tabindex="0"
        @click=${() => this.#handleProductSelect(product.id)}
        @keydown=${(event) => this.#handleProductKeydown(event, product.id)}
        @focus=${attachFocusLoader ? this.#handleProductListEdgeFocus : null}
      >
        <div class="product-preview" aria-hidden="true">
          ${product.icon ? x`<img src=${product.icon} alt="" loading="lazy" decoding="async" />` : x`<span class="preview-initials">${this.#initials(label)}</span>`}
        </div>
        <div class="product-option-body">
          <div class="product-option-name">${label}</div>
          ${meta ? x`<div class="product-option-code">${meta}</div>` : E}
        </div>
      </div>
    `;
  }
  #renderOfferList() {
    const store = this.store;
    if (!store) return E;
    if (store.isLoadingOffers) {
      return x`<div class="offers-loading">
        <sp-progress-circle indeterminate size="l"></sp-progress-circle>
      </div>`;
    }
    if (store.offersError) {
      return x`<sp-help-text variant="negative">${store.offersError}</sp-help-text>`;
    }
    const offers = store.offers || [];
    if (!offers.length) {
      return x`<sp-illustrated-message
        heading="No offers found"
        description="Adjust your selections to see available offers."
      ></sp-illustrated-message>`;
    }
    return x`
      <div class="offer-list" role="listbox" aria-label="Available offers">
        ${offers.map((offer, index) => this.#renderOfferCard(offer, index))}
      </div>
    `;
  }
  #renderOfferCard(offer, index) {
    const store = this.store;
    const product = store?.selectedProduct;
    const selected = store?.selectedOfferId === offer.id;
    const classes = `offer-card${selected ? " offer-card--selected" : ""}`;
    const optionId = `${this.id}-offer-${offer.id || index}`;
    const osiId = this.#offerOsiMap.get(offer.id) || "";
    const resolvedPlanType = this.#offerPlanTypeMap.get(offer.id);
    const planTypeDisplay = resolvedPlanType || this.#formatToken(offer.planType);
    const inlinePriceId = `${this.id}-inline-price-${offer.id || index}`;
    return x`
      <div
        id=${optionId}
        class=${classes}
        role="option"
        aria-selected=${selected ? "true" : "false"}
        tabindex="0"
        @click=${() => this.#handleOfferSelect(offer.id)}
        @keydown=${(event) => this.#handleOfferKeydown(event, offer.id)}
      >
        <div class="offer-card__header">
          <div>
            <div class="offer-label">Price point</div>
            <div class="offer-value">${offer.pricePointLabel || "Regular"}</div>
          </div>
          ${selected ? x`<sp-icon-checkmark-circle class="offer-card__check" size="m" aria-hidden="true"></sp-icon-checkmark-circle>` : E}
        </div>
        <div class="offer-card__body">
          <div class="offer-card__product">
            ${this.#renderProductThumbnail(product)}
            <div>
              <div class="offer-card__name">${product?.name || offer.name}</div>
              ${offer.id ? x`<div class="offer-card__id">
                    Offer ID: ${offer.id}
                    <sp-action-button
                      quiet
                      size="s"
                      aria-label="Copy offer ID"
                      @click=${(event) => this.#handleCopyOfferId(event, offer.id)}
                    >
                      <sp-icon-copy slot="icon"></sp-icon-copy>
                    </sp-action-button>
                  </div>` : E}
            </div>
          </div>
          <div class="offer-info-grid">
            ${this.#renderOfferField("Offer type", this.#formatOfferType(offer.offerType))}
            ${this.#renderOfferField("Plan type", planTypeDisplay)}
            ${this.#renderOfferField("Language", offer.language || "N/A")}
            ${this.#renderPriceField(offer, osiId, inlinePriceId)}
          </div>
        </div>
      </div>
    `;
  }
  #renderOfferField(label, value) {
    return x`
      <div class="offer-field">
        <div class="offer-label">${label}</div>
        <div class="offer-value">${value || "N/A"}</div>
      </div>
    `;
  }
  #renderPriceField(offer, osiId, inlinePriceId) {
    const store = this.store;
    const promoCode = store?.promoCode?.trim() || "";
    if (osiId) {
      if (promoCode) {
        return x`
          <div class="offer-field">
            <div class="offer-label">Price</div>
            <div class="offer-value">
              <inline-price
                id=${inlinePriceId}
                template="price"
                wcs-osi=${osiId}
                promotion-code=${promoCode}
                @mas:resolved=${(event) => this.#handleMasResolved(event, offer.id)}
              ></inline-price>
            </div>
          </div>
        `;
      }
      return x`
        <div class="offer-field">
          <div class="offer-label">Price</div>
          <div class="offer-value">
            <inline-price
              id=${inlinePriceId}
              template="price"
              wcs-osi=${osiId}
              @mas:resolved=${(event) => this.#handleMasResolved(event, offer.id)}
            ></inline-price>
          </div>
        </div>
      `;
    }
    return this.#renderOfferField("Price", offer.price?.display || "N/A");
  }
  #renderProductThumbnail(product) {
    const name = product?.name || "Offer";
    return x`
      <div class="product-preview">
        ${product?.icon ? x`<img src=${product.icon} alt="" loading="lazy" decoding="async" />` : x`<span class="preview-initials">${this.#initials(name)}</span>`}
      </div>
    `;
  }
  #renderPromoBlock() {
    const store = this.store;
    if (!store) return E;
    const hasAppliedPromo = !!store.promoCode;
    const promoCode = store.promoCode || "";
    if (hasAppliedPromo) {
      return x`
        <div class="promo-block promo-block--applied">
          <div class="promo-applied-content">
            <span class="promo-applied-text">
              Promo code has been applied: <strong>${promoCode}</strong>
            </span>
            <sp-action-button
              quiet
              size="s"
              class="promo-close-button"
              aria-label="Remove promo code"
              @click=${this.#handlePromoRemove}
            >
              <sp-icon-close slot="icon"></sp-icon-close>
            </sp-action-button>
          </div>
        </div>
      `;
    }
    return x`
      <div class="promo-block">
        <label class="promo-label" for=${this.promoFieldId}>Promo code</label>
        <div class="promo-row">
          <sp-textfield
            id=${this.promoFieldId}
            placeholder="Enter promo code"
            value=""
            @input=${this.#handlePromoInput}
          ></sp-textfield>
          <sp-button variant="secondary" @click=${this.#handlePromoApply}>Apply</sp-button>
        </div>
      </div>
    `;
  }
  #handleOfferSelect(offerId) {
    if (!offerId) return;
    this.store?.setSelectedOfferId?.(offerId);
    this.#scrollSelectedOfferIntoView(offerId);
    this.#submitOfferSelector(offerId);
  }
  async #submitOfferSelector(offerId) {
    const store = this.store;
    if (!store || !offerId || !this.#accessToken) return;
    const product = store.selectedProduct;
    const offer = store.selectedOffer;
    if (!product || !offer) return;
    const marketSegmentList = store.marketSegmentList || [];
    const marketSegment = marketSegmentList.length > 0 ? marketSegmentList[0] : "COM";
    const pricePoint = offer.pricePoint || offer.pricePointLabel || "";
    const commitment = offer.commitment || this.#inferCommitment(offer.planType) || "YEAR";
    const term = offer.term || this.#inferTerm(offer.planType) || "ANNUAL";
    const payload = {
      product_arrangement_code: product.arrangementCode || product.productCode || "",
      buying_program: "RETAIL",
      commitment,
      term,
      customer_segment: store.customerSegment || "",
      market_segment: marketSegment,
      sales_channel: "DIRECT",
      offer_type: store.offerType || "BASE",
      price_point: pricePoint,
      merchant: "ADOBE"
    };
    const url = "https://aos.adobe.io/offer_selectors?api_key=wcms-commerce-ims-user-prod";
    try {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.#accessToken}`
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        console.warn("Failed to submit offer selector", response.status, response.statusText);
        return;
      }
      const data = await response.json();
      if (data?.id && this.target) {
        this.target.setAttribute("wcs-osi", data.id);
      }
    } catch (error) {
      console.warn("Error submitting offer selector", error);
    }
  }
  #inferCommitment(planType) {
    if (!planType) return "YEAR";
    const upper = String(planType).toUpperCase();
    if (upper.includes("MONTH")) return "MONTH";
    if (upper.includes("YEAR")) return "YEAR";
    return "YEAR";
  }
  #inferTerm(planType) {
    if (!planType) return "ANNUAL";
    const upper = String(planType).toUpperCase();
    if (upper.includes("MONTH")) return "MONTHLY";
    if (upper.includes("ANNUAL")) return "ANNUAL";
    return "ANNUAL";
  }
  #scrollSelectedOfferIntoView(offerId) {
    if (!offerId) return;
    requestAnimationFrame(() => {
      const cardId = `${this.id}-offer-${offerId}`;
      const card = this.shadowRoot?.getElementById(cardId);
      if (!card) return;
      const offerList = this.shadowRoot?.querySelector(".offer-list");
      if (!offerList) {
        card.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "nearest"
        });
        return;
      }
      const buffer = 4;
      const cardRect = card.getBoundingClientRect();
      const containerRect = offerList.getBoundingClientRect();
      const scrollTop = offerList.scrollTop;
      const cardTop = cardRect.top - containerRect.top + scrollTop;
      const cardBottom = cardTop + cardRect.height;
      const containerHeight = offerList.clientHeight;
      let targetScroll = scrollTop;
      if (cardTop < scrollTop + buffer) {
        targetScroll = cardTop - buffer;
      } else if (cardBottom > scrollTop + containerHeight - buffer) {
        targetScroll = cardBottom - containerHeight + buffer;
      }
      if (targetScroll !== scrollTop) {
        offerList.scrollTo({
          top: Math.max(0, targetScroll),
          behavior: "smooth"
        });
      }
    });
  }
  #handleOfferKeydown(event, offerId) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      this.#handleOfferSelect(offerId);
    }
  }
  async #handleCopyOfferId(event, offerId) {
    event?.stopPropagation?.();
    if (!offerId || !navigator?.clipboard?.writeText) {
      return;
    }
    try {
      await navigator.clipboard.writeText(offerId);
      this.#showToast("Offer ID copied to clipboard");
    } catch (error) {
      console.warn("Unable to copy offer ID", error);
    }
  }
  #showToast(message, variant = "info") {
    const toast = document.createElement("sp-toast");
    toast.variant = variant;
    toast.timeout = 3e3;
    toast.open = true;
    toast.textContent = message;
    toast.style.position = "fixed";
    toast.style.right = "16px";
    toast.style.bottom = "16px";
    toast.style.zIndex = "9999";
    const theme = document.querySelector("sp-theme") || this.getRootNode().querySelector("sp-theme") || document.body;
    theme.appendChild(toast);
  }
  #handlePromoInput(event) {
  }
  #handlePromoApply() {
    const input = this.shadowRoot?.getElementById(this.promoFieldId);
    const promoCode = input?.value || "";
    this.store?.setPromoCode?.(promoCode.trim());
  }
  #handlePromoRemove() {
    this.store?.setPromoCode?.("");
  }
  #maybeLoadOffers() {
    const store = this.store;
    if (!store) return;
    const lastIndex = (store.stepCount || 3) - 1;
    if (store.step !== lastIndex) return;
    const product = store.selectedProduct;
    if (!product) return;
    const key = `${product.arrangementCode}|${store.offerType}|${store.customerSegment}`;
    if (!key) return;
    if (this.#lastOfferKey === key) {
      return;
    }
    this.#lastOfferKey = key;
    if (this.#offerController) {
      this.#offerController.abort();
    }
    const controller = new AbortController();
    this.#offerController = controller;
    (async () => {
      try {
        await store.loadOffers({ signal: controller.signal });
      } catch {
      } finally {
        if (this.#offerController === controller) {
          this.#offerController = null;
        }
      }
    })();
  }
  #formatToken(value) {
    if (!value) return "";
    return String(value).split(/[_-]/).map((part) => {
      if (!part) return "";
      const upper = part.toUpperCase();
      const lower = part.toLowerCase();
      if (part.length <= 3 && part === upper) {
        return upper;
      }
      return upper.charAt(0) + lower.slice(1);
    }).join(" ");
  }
  #initials(name) {
    const value = (name || "").trim();
    if (!value) return "NA";
    const parts = value.split(/\s+/).slice(0, 2);
    const initials = parts.map((part) => part.charAt(0).toUpperCase()).join("");
    return initials || "NA";
  }
  #formatOfferType(value) {
    if (!value) return "";
    const key = String(value).trim().toLowerCase();
    return OFFER_TYPE_LABELS[key] || this.#formatToken(value);
  }
  async #maybeLoadOsiData() {
    if (!this.target || !this.#accessToken || this.#hasLoadedOsi) return;
    const osiId = this.target.getAttribute("wcs-osi");
    if (!osiId || !osiId.trim()) return;
    if (this.#osiController) {
      this.#osiController.abort();
    }
    const controller = new AbortController();
    this.#osiController = controller;
    try {
      const url = `https://aos.adobe.io/offer_selectors/${osiId.trim()}?api_key=wcms-commerce-ims-user-prod&environment=PROD&landscape=PUBLISHED`;
      const response = await fetch(url, {
        method: "GET",
        headers: {
          Accept: "application/json",
          Authorization: `Bearer ${this.#accessToken}`
        },
        signal: controller.signal
      });
      if (!response.ok) {
        console.warn("Unable to load offer selector data", response.status, response.statusText);
        return;
      }
      const data = await response.json();
      if (!data || typeof data !== "object") return;
      await this.#applyOsiData(data);
      this.#hasLoadedOsi = true;
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.warn("Error loading offer selector data", error);
      }
    } finally {
      if (this.#osiController === controller) {
        this.#osiController = null;
      }
    }
  }
  async #applyOsiData(data) {
    const store = this.store;
    if (!store) return;
    if (!store.products.length && !store.isLoadingProducts) {
      await this.#loadProducts();
    }
    if (store.isLoadingProducts) {
      await new Promise((resolve) => {
        const checkInterval = setInterval(() => {
          if (!store.isLoadingProducts) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
        setTimeout(() => {
          clearInterval(checkInterval);
          resolve();
        }, 1e4);
      });
    }
    const productArrangementCode = data.product_arrangement_code || "";
    if (productArrangementCode) {
      const product = store.products.find(
        (p30) => p30.arrangementCode === productArrangementCode || p30.id === productArrangementCode || p30.productCode === productArrangementCode
      );
      if (product) {
        store.setSelectedProductId(product.id);
        await this.#waitForStoreSync();
      }
    }
    const customerSegment = data.customer_segment || "";
    if (customerSegment && store.selectedProduct) {
      const availableSegments = store.availableCustomerSegments || [];
      const normalizedSegment = customerSegment.trim().toUpperCase();
      if (availableSegments.includes(normalizedSegment)) {
        store.setCustomerSegment(customerSegment);
      }
    }
    const offerType = data.offer_type || "";
    if (offerType) {
      store.setOfferType(offerType);
    }
    if (store.canGoNext && store.step === 0) {
      store.goToNextStep();
      await this.#waitForStoreSync();
    }
    const pricePoint = data.price_point || "";
    const term = data.term || "";
    const commitment = data.commitment || "";
    if (store.selectedProduct && store.customerSegment && store.offerType) {
      await store.loadOffers();
      const offers = store.offers || [];
      if (offers.length > 0) {
        const normalizeValue = (value) => (value || "").toString().trim().toUpperCase();
        const normalizedPricePoint = normalizeValue(pricePoint);
        const normalizedTerm = normalizeValue(term);
        const normalizedCommitment = normalizeValue(commitment);
        const matchingOffer = offers.find((offer) => {
          const offerPricePoint = normalizeValue(offer.pricePointLabel);
          const offerTerm = normalizeValue(offer.term);
          const offerCommitment = normalizeValue(offer.commitment);
          if (normalizedPricePoint && offerPricePoint !== normalizedPricePoint) {
            return false;
          }
          if (normalizedTerm && offerTerm !== normalizedTerm) {
            return false;
          }
          if (normalizedCommitment && offerCommitment !== normalizedCommitment) {
            return false;
          }
          return true;
        });
        if (matchingOffer) {
          store.setSelectedOfferId(matchingOffer.id);
        } else if (offers.length > 0) {
          store.setSelectedOfferId(offers[0].id);
        }
      }
    }
    if (store.canGoNext && store.step < 2) {
      store.setStep(2);
    }
  }
  #waitForStoreSync() {
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          resolve();
        });
      });
    });
  }
  async #ensureOfferOsiIds() {
    const store = this.store;
    if (!store || !this.#accessToken) return;
    const offers = store.offers || [];
    if (!offers.length) return;
    const product = store.selectedProduct;
    if (!product) return;
    const marketSegmentList = store.marketSegmentList || [];
    const marketSegment = marketSegmentList.length > 0 ? marketSegmentList[0] : "COM";
    const promises = offers.map(async (offer) => {
      if (this.#offerOsiMap.has(offer.id)) {
        return;
      }
      const pricePoint = offer.pricePoint || offer.pricePointLabel || "";
      const commitment = offer.commitment || this.#inferCommitment(offer.planType) || "YEAR";
      const term = offer.term || this.#inferTerm(offer.planType) || "ANNUAL";
      const payload = {
        product_arrangement_code: product.arrangementCode || product.productCode || "",
        buying_program: "RETAIL",
        commitment,
        term,
        customer_segment: store.customerSegment || "",
        market_segment: marketSegment,
        sales_channel: "DIRECT",
        offer_type: store.offerType || "BASE",
        price_point: pricePoint,
        merchant: "ADOBE"
      };
      const url = "https://aos.adobe.io/offer_selectors?api_key=wcms-commerce-ims-user-prod";
      try {
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${this.#accessToken}`
          },
          body: JSON.stringify(payload)
        });
        if (!response.ok) {
          console.warn("Failed to create offer selector", response.status, response.statusText);
          return;
        }
        const data = await response.json();
        if (data?.id) {
          this.#offerOsiMap.set(offer.id, data.id);
          this.requestUpdate();
        }
      } catch (error) {
        console.warn("Error creating offer selector", error);
      }
    });
    await Promise.all(promises);
  }
  #handleMasResolved(event, offerId) {
    if (!event || !offerId) return;
    const value = event.detail?.value || event.target?.value;
    if (value) {
      const planType = value.planType || value.plan_type || value.offerDetails?.planType || value.offerDetails?.plan_type;
      if (planType) {
        const planTypeStr = String(planType);
        if (this.#offerPlanTypeMap.get(offerId) !== planTypeStr) {
          this.#offerPlanTypeMap.set(offerId, planTypeStr);
          this.requestUpdate();
        }
      }
    }
  }
};
customElements.define("offer-selector-tool", makeLitObserver(OfferSelectorTool));

// src/custom-elements/acom/acom.library.js
var LIBRARY_ID5 = "acom";
function register5({
  registerLibrary: registerLibrary2,
  registerElement: registerElement2,
  LibraryLevel: LibraryLevel2
}) {
  registerLibrary2({
    id: LIBRARY_ID5,
    level: LibraryLevel2.ORG,
    name: "ACOM Experience",
    description: "Authoring elements for Adobe Commerce merchandising experiences."
  });
  [
    "acom-hero-marquee",
    "acom-aside",
    "acom-feature-card",
    "acom-feature-carousel",
    "acom-text",
    "acom-action-scroller",
    "acom-action-tile",
    "acom-faq",
    "acom-faq-item",
    "acom-breadcrumbs",
    "acom-promo-bar"
  ].forEach((tag3) => registerElement2(LIBRARY_ID5, tag3));
}

// src/libraries/libraries.js
register({ registerLibrary, registerElement, LibraryLevel });
register2({ registerLibrary, registerElement, LibraryLevel });
register3({ registerLibrary, registerElement, LibraryLevel });
register4({ registerLibrary, registerElement, LibraryLevel });
register5({ registerLibrary, registerElement, LibraryLevel });

// node_modules/@spectrum-web-components/menu/src/MenuDivider.js
init_src();

// node_modules/@spectrum-web-components/menu/src/menu-divider.css.js
init_src();
var i20 = i`
    :host{--spectrum-menu-divider-thickness:var(--spectrum-divider-thickness-medium);inline-size:auto;margin-block:var(--mod-menu-section-divider-margin-block,max(0px,(var(--spectrum-menu-item-section-divider-height) - var(--spectrum-menu-divider-thickness))/2));margin-inline:var(--mod-menu-item-label-inline-edge-to-content,var(--spectrum-menu-item-label-inline-edge-to-content));overflow:visible}.spectrum-Menu-back:focus-visible{box-shadow:var(--spectrum-menu-item-focus-indicator-shadow)var(--spectrum-menu-item-focus-indicator-border-width)0 0 0 var(--spectrum-menu-item-focus-indicator-color-default);outline:var(--spectrum-menu-item-focus-indicator-width)var(--spectrum-menu-item-focus-indicator-outline-style)var(--spectrum-menu-item-focus-indicator-color-default);outline-offset:var(--spectrum-menu-item-focus-indicator-offset);border-radius:var(--spectrum-menu-item-corner-radius)}.spectrum-Menu-back{padding-inline:var(--mod-menu-back-padding-inline-start,0)var(--mod-menu-back-padding-inline-end,var(--spectrum-menu-item-label-inline-edge-to-content));padding-block:var(--mod-menu-back-padding-block-start,0)var(--mod-menu-back-padding-block-end,0);flex-flow:wrap;align-items:center;display:flex}.spectrum-Menu-backButton{cursor:pointer;background:0 0;border:0;margin:0;padding:0;display:inline-flex}.spectrum-Menu-backButton:focus-visible{outline:var(--spectrum-focus-indicator-thickness)solid var(--spectrum-focus-indicator-color);outline-offset:calc((var(--spectrum-focus-indicator-thickness) + 1px)*-1)}.spectrum-Menu-backHeading{color:var(--highcontrast-menu-item-color-default,var(--mod-menu-back-heading-color,var(--spectrum-menu-section-header-color)));font-size:var(--mod-menu-section-header-font-size,var(--spectrum-menu-section-header-font-size));font-weight:var(--mod-menu-section-header-font-weight,var(--spectrum-menu-section-header-font-weight));line-height:var(--mod-menu-section-header-line-height,var(--spectrum-menu-section-header-line-height));display:block}:host{flex-shrink:0;display:block}
`;
var menu_divider_css_default = i20;

// node_modules/@spectrum-web-components/menu/src/MenuDivider.js
var MenuDivider = class extends SizedMixin(SpectrumElement, { validSizes: ["s", "m", "l"] }) {
  static get styles() {
    return [divider_css_default, menu_divider_css_default];
  }
  firstUpdated(e36) {
    super.firstUpdated(e36), this.setAttribute("role", "separator");
  }
};

// node_modules/@spectrum-web-components/menu/sp-menu-divider.js
init_define_element();
defineElement("sp-menu-divider", MenuDivider);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSelectNone.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/SelectNone.js
var SelectNoneIcon = ({ width: l16 = 24, height: r25 = 24, hidden: c33 = false, title: t34 = "Select None" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${r25}"
    viewBox="0 0 20 20"
    aria-hidden=${c33 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${t34}"
  >
    <path
      d="m12.75,3.5h-1.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.25c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m12.75,18h-1.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.25c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m8.5,3.5h-1.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.25c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m8.5,18h-1.25c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75h1.25c.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m17.25,5c-.41406,0-.75-.33594-.75-.75,0-.41309-.33691-.75-.75-.75-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75c1.24023,0,2.25,1.00977,2.25,2.25,0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m17.25,9.25c-.41406,0-.75-.33594-.75-.75v-1.25c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.25c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m2.75,9.25c-.41406,0-.75-.33594-.75-.75v-1.25c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.25c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m2.75,13.5c-.41406,0-.75-.33594-.75-.75v-1.25c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.25c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m17.25,13.5c-.41406,0-.75-.33594-.75-.75v-1.25c0-.41406.33594-.75.75-.75s.75.33594.75.75v1.25c0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m4.25,18c-1.24023,0-2.25-1.00977-2.25-2.25,0-.41406.33594-.75.75-.75s.75.33594.75.75c0,.41309.33691.75.75.75.41406,0,.75.33594.75.75s-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m15.75,18c-.41406,0-.75-.33594-.75-.75s.33594-.75.75-.75c.41309,0,.75-.33691.75-.75,0-.41406.33594-.75.75-.75s.75.33594.75.75c0,1.24023-1.00977,2.25-2.25,2.25Z"
      fill="currentColor"
    />
    <path
      d="m2.75,5c-.41406,0-.75-.33594-.75-.75,0-1.24023,1.00977-2.25,2.25-2.25.41406,0,.75.33594.75.75s-.33594.75-.75.75c-.41309,0-.75.33691-.75.75,0,.41406-.33594.75-.75.75Z"
      fill="currentColor"
    />
    <path
      d="m11.06055,10l1.71973-1.71973c.29297-.29297.29297-.76758,0-1.06055s-.76758-.29297-1.06055,0l-1.71973,1.71973-1.71973-1.71973c-.29297-.29297-.76758-.29297-1.06055,0s-.29297.76758,0,1.06055l1.71973,1.71973-1.71973,1.71973c-.29297.29297-.29297.76758,0,1.06055.14648.14648.33789.21973.53027.21973s.38379-.07324.53027-.21973l1.71973-1.71973,1.71973,1.71973c.14648.14648.33789.21973.53027.21973s.38379-.07324.53027-.21973c.29297-.29297.29297-.76758,0-1.06055l-1.71973-1.71973Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconSelectNone.js
var IconSelectNone = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? SelectNoneIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-select-none.js
init_define_element();
defineElement("sp-icon-select-none", IconSelectNone);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconBell.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Bell.js
var BellIcon = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: r25 = "Bell" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 20 20"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="m17.78613,12.67578c-.16846-.30859-.34082-.60742-.51123-.90234-.82666-1.43457-1.54102-2.67285-1.54102-4.62012,0-3.11914-2.5376-5.65723-5.65723-5.65723s-5.65723,2.53809-5.65723,5.65723c0,1.7666-.75879,3.04883-1.56201,4.40527-.22021.37207-.44141.74609-.64941,1.13086-.37598.69629-.35693,1.52051.05078,2.2041.41211.69043,1.13672,1.10254,1.93848,1.10254h3.05225c0,1.5166,1.2334,2.75,2.75,2.75s2.75-1.2334,2.75-2.75h3.05518c.80322,0,1.52783-.41309,1.93896-1.10547.40771-.6875.42383-1.51562.04248-2.21484Zm-7.78662,4.57031c-.68945,0-1.25-.56055-1.25-1.25h2.5c0,.68945-.56055,1.25-1.25,1.25Zm6.4541-3.12109c-.06641.11133-.26221.37109-.64893.37109H4.19727c-.26855,0-.51172-.13867-.65039-.37109-.06445-.1084-.19531-.39551-.01855-.72266.19824-.36816.40967-.72461.61963-1.0791.87109-1.4707,1.77148-2.99219,1.77148-5.16992,0-2.25391,1.90381-4.15723,4.15723-4.15723s4.15723,1.90332,4.15723,4.15723c0,2.34863.88525,3.88379,1.7417,5.36914.16455.28516.33057.57324.49365.87207.18066.33105.04932.62109-.01562.73047Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/icons/Bell.js
var BellIcon2 = ({ width: e36 = 24, height: t34 = 24, hidden: l16 = false, title: a23 = "Bell" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${e36}"
    height="${t34}"
    viewBox="0 0 36 36"
    aria-hidden=${l16 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${a23}"
  >
    <path
      d="M18 36a4.406 4.406 0 0 0 4-4h-8a4.406 4.406 0 0 0 4 4ZM27.143 11.385c0-3.437-3.206-4.891-7.143-5.268V3a1.079 1.079 0 0 0-1.143-1h-1.714A1.079 1.079 0 0 0 16 3v3.117c-3.937.377-7.143 1.831-7.143 5.268C8.857 26.8 4 26.111 4 28.154V30h28v-1.846C32 26 27.143 26.8 27.143 11.385Z"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconBell.js
var IconBell = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? BellIcon({ hidden: !this.label, title: this.label }) : BellIcon2({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-bell.js
init_define_element();
defineElement("sp-icon-bell", IconBell);

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTemplate.js
init_src();

// node_modules/@spectrum-web-components/icons-workflow/src/icons-s2/Template.js
var TemplateIcon = ({ width: l16 = 24, height: e36 = 24, hidden: t34 = false, title: r25 = "Template" } = {}) => tag`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="${l16}"
    height="${e36}"
    viewBox="0 0 20 20"
    aria-hidden=${t34 ? "true" : "false"}
    role="img"
    fill="currentColor"
    aria-label="${r25}"
  >
    <path
      d="M14.75,18H5.25c-1.24023,0-2.25-1.00928-2.25-2.25V3.25c0-1.24072,1.00977-2.25,2.25-2.25h9.5c1.24023,0,2.25,1.00928,2.25,2.25v12.5c0,1.24072-1.00977,2.25-2.25,2.25ZM5.25,2.5c-.41309,0-.75.33643-.75.75v12.5c0,.41357.33691.75.75.75h9.5c.41309,0,.75-.33643.75-.75V3.25c0-.41357-.33691-.75-.75-.75H5.25Z"
      fill="currentColor"
    />
    <path
      d="M9.65137,15.2666c-.16992,0-.34375-.03467-.5127-.10742-.5791-.25098-.87305-.85254-.71289-1.46338l.58887-2.21777h-2.13477c-.45215,0-.87012-.24512-1.09082-.63965-.2207-.39404-.21191-.87842.02441-1.26367l3.46777-5.34619c.32129-.52246.95605-.72705,1.54102-.48242.58203.24512.88086.84424.72656,1.45703l-.59863,2.29688h2.16992c.46094,0,.88281.25195,1.10059.6582.21875.40576.19629.89697-.05762,1.28174l-3.48047,5.25195c-.23047.36816-.61914.57471-1.03125.57471ZM9.42773,13.87158c-.00195.00244-.00391.00488-.00488.00732l.00488-.00732ZM7.33984,9.97803h2c.39062,0,.75195.17773.99023.48779.23926.30957.31836.70459.21777,1.08252l-.2793,1.05371,2.38672-3.60205h-2.02832c-.38965,0-.75-.17676-.98828-.48535-.23926-.30859-.32031-.70166-.22168-1.07861l.28711-1.104-2.36426,3.646ZM13.12012,9h.00977-.00977ZM10.54883,5.0293l-.00488.00732c.00195-.00244.00391-.00488.00488-.00732Z"
      fill="currentColor"
    />
  </svg>`;

// node_modules/@spectrum-web-components/icons-workflow/src/elements/IconTemplate.js
var IconTemplate = class extends IconBase {
  render() {
    return setCustomTemplateLiteralTag(x), this.spectrumVersion === 2 ? TemplateIcon({ hidden: !this.label, title: this.label }) : DefaultIcon({ hidden: !this.label, title: this.label });
  }
};

// node_modules/@spectrum-web-components/icons-workflow/icons/sp-icon-template.js
init_define_element();
defineElement("sp-icon-template", IconTemplate);

// src/experience-elements-home-new.js
var ExperienceElementsHomeNew = class extends CreationDialogMixin(i4) {
  static get styles() {
    return experienceElementsHomeNewStyles;
  }
  static get properties() {
    return {
      ...super.properties,
      store: { type: Store, observe: true },
      templateStore: { type: TemplateStore, observe: true },
      userStore: { type: UserStore, observe: true },
      searchQuery: { type: String },
      isLoadingTeam: { type: Boolean, converter: booleanConverter },
      shareDialogOpen: { type: Boolean, converter: booleanConverter }
    };
  }
  constructor() {
    super();
    this.searchQuery = "";
    this.templateStore = null;
    this.userStore = null;
    this.isLoadingTeam = false;
    this.shareDialogOpen = false;
    this.#previewManager = new ElementPreviewManager(this);
    this.#toast = new ToastController();
    this.#keyboard = null;
    this.#filesSection = null;
    this.#shareManager = null;
  }
  #previewManager;
  #toast;
  #keyboard;
  #filesSection;
  #shareManager;
  async connectedCallback() {
    super.connectedCallback();
    if (this.store?.documentStore) {
      this.store.homeElement = this;
      this.store.documentStore.registerToastTarget(this);
    }
    if (this.store?.templateSources && this.store.templateSources.length > 0) {
      this.templateStore?.loadTemplates(this.store.templateSources);
    }
    if (!this.#keyboard) {
      this.#keyboard = new WorkspaceKeyboardController({
        isCreationDialogOpen: () => !!this.store?.showCreationDialog,
        closeCreationDialog: () => this.closeCreationDialog(),
        isShareDialogOpen: () => !!this.shareDialogOpen,
        closeShareDialog: () => {
          if (this.#shareManager) {
            this.#shareManager.shareDialogOpen = false;
          }
        },
        isConfirmDeleteOpen: () => !!this.#shareManager?.confirmDeleteOpen,
        isSelectionMode: () => !!this.store?.selectionMode,
        exitSelectionMode: () => {
          this.store?.setSelectionMode?.(false);
          this.store?.clearSelection?.();
        },
        openCreationDialog: () => this.openCreationDialog()
      });
    }
    this.#keyboard.disconnect();
    this.#keyboard.connect();
    this.addEventListener("open-creation-dialog", (e36) => {
      this.openCreationDialog(e36.detail?.category);
    });
    this.addEventListener("open-element", (e36) => {
      this.openElementByUrn(e36.detail?.urn);
    });
    this.addEventListener("open-share-for-selection", () => {
      this.#shareManager?.openShareForSelection();
    });
    this.addEventListener("open-confirm-delete", () => {
      this.#shareManager?.openConfirmDelete();
    });
    this.addEventListener("show-toast", (e36) => {
      this.showToast(e36.detail?.label, e36.detail?.variant);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.#keyboard?.disconnect();
    this.#previewManager?.teardown();
    this.#toast?.disconnect();
    if (this.store?.homeElement === this) {
      this.store.homeElement = null;
    }
    this.store?.documentStore?.unregisterToastTarget?.(this);
  }
  firstUpdated() {
    super.firstUpdated?.();
    this.#filesSection = this.shadowRoot.querySelector("ee-files-section");
    this.#shareManager = this.shadowRoot.querySelector("ee-share-manager");
  }
  render() {
    const view = this.store?.galleryView ?? GalleryViews.ALL;
    const navSelection = this.store?.homeNavSelection || "home";
    return x`
      <div class="home-container">
        ${this.#sidebarNavUI}
        <div class="main-content">
          ${this.#headerUI}
          <div class="content-scroll">
            ${view === GalleryViews.MY_FILES || navSelection === "shared" ? "" : this.#heroSectionUI}
            <div class="content-section">
              ${navSelection === "shared" ? this.sharedWithMeSectionTemplate : view === GalleryViews.MY_FILES ? x`<ee-files-section .store=${this.store}></ee-files-section>` : this.#recentSectionUI}
            </div>
          </div>
        </div>
      </div>
      <ee-share-manager .store=${this.store} .documentStore=${this.store.documentStore}></ee-share-manager>
      ${this.store.showCreationDialog ? this.creationDialogTemplate : ""}
    `;
  }
  get sharedWithMeSectionTemplate() {
    return x`<ee-files-section .store=${this.store}></ee-files-section>`;
  }
  selectNavItem(item) {
    if (!this.store) {
      return;
    }
    if (item === "team-workspace") {
      this.store.setHomeNavSelection("team-workspace");
      return;
    }
    if (item === "home") {
      this.store.setHomeNavSelection("home");
      this.store.setGalleryView(GalleryViews.ALL);
    } else if (item === "my-workspace") {
      this.store.setHomeNavSelection("my-workspace");
      this.store.setGalleryView(GalleryViews.MY_FILES);
    } else if (item === "shared") {
      this.store.setHomeNavSelection("shared");
      this.store.setGalleryView(GalleryViews.SHARED);
    }
  }
  // Use persisted nav selection to avoid brief flicker of the wrong section/spinner on first paint
  get #sidebarNavUI() {
    const navSelection = this.store?.homeNavSelection || "home";
    return x`
      <div class="sidebar-nav">
        <div 
          class="nav-item ${navSelection === "home" ? "selected" : ""}"
          @click=${() => this.selectNavItem("home")}
        >
          <sp-action-button
            toggles
            ?selected=${navSelection === "home"}
            quiet
            tabindex="-1"
          >
            <sp-icon-home slot="icon" size="m"></sp-icon-home>
          </sp-action-button>
          <div class="nav-item-label">Home</div>
        </div>
        <div 
          class="nav-item ${navSelection === "my-workspace" ? "selected" : ""}"
          @click=${() => this.selectNavItem("my-workspace")}
        >
          <sp-action-button
            toggles
            ?selected=${navSelection === "my-workspace"}
            quiet
            tabindex="-1"
          >
            <sp-icon-user slot="icon" size="m"></sp-icon-user>
          </sp-action-button>
          <div class="nav-item-label">My Workspace</div>
        </div>
        <div 
          class="nav-item ${navSelection === "team-workspace" ? "selected" : ""}"
          @click=${() => this.selectNavItem("team-workspace")}
        >
          <sp-action-button
            toggles
            ?selected=${navSelection === "team-workspace"}
            quiet
            tabindex="-1"
          >
            <sp-icon-user-group slot="icon" size="m"></sp-icon-user-group>
          </sp-action-button>
          <div class="nav-item-label">Team Workspace</div>
        </div>
        <div 
          class="nav-item ${navSelection === "shared" ? "selected" : ""}"
          @click=${() => this.selectNavItem("shared")}
        >
          <sp-action-button
            toggles
            ?selected=${navSelection === "shared"}
            quiet
            tabindex="-1"
          >
            <sp-icon-user-group slot="icon" size="m"></sp-icon-user-group>
          </sp-action-button>
          <div class="nav-item-label">Shared with me</div>
        </div>
      </div>
    `;
  }
  get #headerUI() {
    return x`
      <div class="header">
        <div class="header-brand">
          <img src="src/assets/icons/adobe-logo.png" alt="Adobe" class="adobe-logo" />
          <div class="brand-text">Merch At Scale Experience Elements</div>
        </div>
        <div class="header-search">
          <sp-search
            placeholder="Search elements"
            value=${this.store.searchQuery}
            @input=${(e36) => this.store.setSearchQuery(e36.target.value)}
            size="m"
          ></sp-search>
        </div>
        <div class="header-actions">
          <sp-switch
            id="theme-switch-home-new"
            size="m"
            ?checked=${this.store.themeColor === "dark"}
            @change=${(event) => this.onThemeToggle(event)}
          >
            Dark
          </sp-switch>
          <sp-action-button quiet>
            <sp-icon-help-circle slot="icon" size="m"></sp-icon-help-circle>
          </sp-action-button>
          <sp-action-button quiet>
            <sp-icon-bell slot="icon" size="m"></sp-icon-bell>
          </sp-action-button>
          <sp-action-menu id="user-menu" quiet placement="bottom-end" @change=${this.handleUserMenuChange}>
            <div slot="icon" class="user-avatar">
              <img 
                src="${this.userStore?.currentUser?.avatarUrl || "src/assets/images/avatar.png"}" 
                alt="User avatar" 
                style="width:100%;height:100%;object-fit:cover;border-radius:12px;"
              />
            </div>
            <sp-menu-item disabled>${this.userStore?.currentUser?.displayName || "User"}</sp-menu-item>
            <sp-menu-divider></sp-menu-divider>
            <sp-menu-item value="signout">Sign Out</sp-menu-item>
          </sp-action-menu>
        </div>
      </div>
    `;
  }
  get #heroSectionUI() {
    return x`
      <div class="hero-section">
        <div class="hero-content">
          <h1 class="hero-headline">Scale. Simplify. Launch.</h1>
          <p class="hero-description">
            From Unified Paywalls to 3in1 Modals, Merch Cards, and Merch Content, create and scale experiences faster, all in one place. 
          </p>
          
          <div class="quick-action-card">
            <div class="quick-actions">
              <div class="quick-action-item">
                <button 
                  class="quick-action-button"
                @click=${() => this.openCreationDialog("templates")}
                >
                  <img src="src/assets/icons/template-icon.svg" alt="Template" width="64" height="64" />
                </button>
                <div class="quick-action-label">Start from template</div>
              </div>
              <div class="quick-action-item">
                <button 
                  class="quick-action-button"
                @click=${() => this.openCreationDialog("blank")}
                >
                  <img src="src/assets/icons/create-blank.svg" alt="Create blank" width="64" height="64" />
                </button>
                <div class="quick-action-label">Create blank element</div>
              </div>
            </div>
          </div>

          <div class="element-types">
            <div class="element-type-item" @click=${() => this.createElementOfType("merch-card")}>
              <div class="element-type-icon">
                <img src="src/assets/icons/merch-card-icon.svg" alt="Merch Card" width="36" height="36" />
              </div>
              <div class="element-type-label">Merch Card</div>
            </div>

            <div class="element-type-item" @click=${() => this.createElementOfType("paywall-container")}>
              <div class="element-type-icon">
                <img src="src/assets/icons/buy-modal-icon.svg" alt="Paywall" width="36" height="36" />
              </div>
              <div class="element-type-label">Paywall</div>
            </div>

            <div class="element-type-item" @click=${() => this.createElementOfType("acom-faq")}>
              <div class="element-type-icon">
                <img src="src/assets/icons/accordion-icon.svg" alt="FAQ" width="36" height="36" />
              </div>
              <div class="element-type-label">FAQ</div>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  onThemeToggle(event) {
    const checked = !!event?.target?.checked;
    this.store?.setThemeColor?.(checked ? "dark" : "light");
  }
  handleUserMenuChange(event) {
    const value = event.target?.value;
    if (value === "signout") {
      const host = window.location?.hostname || "";
      const isLocal = host === "localhost" || host === "127.0.0.1" || host === "::1";
      if (isLocal) {
        localStorage.removeItem("user-email");
        localStorage.removeItem("user-display-name");
        localStorage.removeItem("user-owner-org");
        localStorage.removeItem("ee:currentUser");
        window.location.reload();
      } else {
        window.adobeIMS?.signOut();
      }
    }
  }
  get #recentSectionUI() {
    const recentElements = this.store.filteredElements || [];
    const loading = !!this.store?.documentStore?.isLoadingElements;
    return x`
      <div class="recent-section">
        <div class="section-header">
          <h2 class="section-title">Recent</h2>
          <a id="viewAll" class="view-all-link" @click=${(e36) => {
      e36.preventDefault();
      this.selectNavItem("my-workspace");
    }}>
            View all
          </a>
        </div>
        ${loading ? x`<div class="recent-section-loading"><sp-progress-circle indeterminate size="l"></sp-progress-circle></div>` : recentElements.length === 0 ? x`
              <sp-illustrated-message 
                heading="Nothing here yet" 
                description="Create your first element to get started"
              ></sp-illustrated-message>
            ` : x`
              <div class="elements-grid">
                ${recentElements.map((doc3) => this.#elementCardUI(doc3))}
              </div>
            `}
      </div>
    `;
  }
  #elementCardUI(doc3) {
    return x`
      <div 
        class="element-card"
        @click=${() => this.openElementByUrn(doc3.urn)}
        data-element-urn=${doc3.urn}
      >
        <div class="element-thumbnail">
          <div class="element-preview" data-doc-urn=${doc3.urn}>
            <div class="element-preview-placeholder">Loading...</div>
          </div>
        </div>
        <div class="element-info">
          <div class="element-name">${doc3.name || "Untitled"}</div>
          <div class="element-time">${this.formatRelativeDate(doc3.lastModified)}</div>
        </div>
      </div>
    `;
  }
  // Template associations for quick-create tiles in the hero section
  get elementTypeTemplates() {
    return {
      // Merch Card quick-create uses the single card template
      "merch-card": {
        title: "Merch Card",
        url: "./templates/single-card.html"
      }
      // Other element types currently have no direct template mapping
    };
  }
  async createNewElement(elementName) {
    const tagName = String(elementName || "").toLowerCase();
    const registered = libraryManager.getElementByTag(tagName);
    if (registered && registered.allowBlank === false) {
      throw new Error(`Element '${tagName}' cannot be created from a blank.`);
    }
    const element = registered?.create ? registered.create() : this.createElementInstance(tagName);
    if (!(element instanceof HTMLElement)) {
      throw new Error(`Create failed: unable to instantiate '${tagName}'`);
    }
    element.id = `${tagName}-${Date.now()}`;
    const elementSchema2 = registered?.schema || this.#getElementSchema(element);
    if (elementSchema2?.attributes) {
      Object.entries(elementSchema2.attributes).forEach(([name, attr]) => {
        if (attr?.defaultValue === void 0) return;
        if (!element.hasAttribute(name)) {
          element.setAttribute(name, attr.defaultValue);
        }
      });
    }
    const parentUrn = this.#getCurrentParentUrn();
    const elementConfig = this.#buildElementConfig({
      name: `New ${registered?.displayName || tagName}`,
      html: this.store.documentStore.serializeElement(element),
      parentUrn
    });
    await this.#saveAndOpenElement(elementConfig);
  }
  async createFromHTML(htmlContent, title) {
    const parser = new DOMParser();
    const doc3 = parser.parseFromString(htmlContent, "text/html");
    const templateElement = doc3.body.firstElementChild;
    if (!templateElement) return;
    const elementName = templateElement.tagName.toLowerCase();
    const newElement = templateElement.cloneNode(true);
    newElement.id = `${elementName}-${Date.now()}`;
    const parentUrn = this.#getCurrentParentUrn();
    const elementConfig = this.#buildElementConfig({
      name: title || "New Element",
      html: this.store.documentStore.serializeElement(newElement),
      parentUrn
    });
    await this.#saveAndOpenElement(elementConfig);
  }
  async openElementByUrn(documentId) {
    this.store?.setSelectionMode?.(false);
    this.store?.clearSelection?.();
    await this.store.openElement(documentId);
  }
  #buildElementConfig({ name, html, parentUrn }) {
    return {
      name,
      html,
      created: (/* @__PURE__ */ new Date()).toISOString(),
      parentUrn
    };
  }
  #getCurrentParentUrn() {
    return this.store?.galleryView === GalleryViews.MY_FILES ? this.store.currentFolderUrn || null : null;
  }
  async #saveAndOpenElement(elementConfig) {
    const created = await this.store.documentStore.saveDocument(elementConfig, {
      create: true
    });
    const id = created?.urn || created?.path;
    if (!id) throw new Error("Create failed: missing identifier in response");
    await this.store.openElement(id);
  }
  // Helper methods
  #getElementSchema(elementOrTagName) {
    const isElement2 = elementOrTagName instanceof HTMLElement;
    const tagName = isElement2 ? elementOrTagName.tagName.toLowerCase() : elementOrTagName.toLowerCase();
    const element = isElement2 ? elementOrTagName : null;
    const constructor = isElement2 ? elementOrTagName.constructor : customElements.get(tagName);
    if (constructor) {
      const schema2 = getElementSchema(constructor, element);
      if (schema2) {
        return schema2;
      }
      if (constructor.schema) {
        return constructor.schema;
      }
    }
    return null;
  }
  formatRelativeDate(dateString) {
    return formatRelativeDate(dateString);
  }
  #handleKeyDown(e36) {
    if (e36.key === "Escape") {
      if (this.store.showCreationDialog) {
        e36.preventDefault();
        this.closeCreationDialog();
        return;
      }
      if (this.shareDialogOpen) {
        e36.preventDefault();
        this.shareDialogOpen = false;
        return;
      }
      if (this.confirmDeleteOpen) return;
      if (this.store?.selectionMode) {
        e36.preventDefault();
        this.store.setSelectionMode(false);
        this.store.clearSelection();
        return;
      }
    }
    const key = e36.key;
    const isCtrlOrCmd = e36.ctrlKey || e36.metaKey;
    if (key === "n" && isCtrlOrCmd) {
      e36.preventDefault();
      this.openCreationDialog();
    }
  }
  showToast(label, variant = "info") {
    this.#toast.show(label, variant);
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (changedProperties.has("store")) {
      const previousStore = changedProperties.get("store");
      if (previousStore?.homeElement === this) {
        previousStore.homeElement = null;
      }
      previousStore?.documentStore?.unregisterToastTarget?.(this);
      if (this.store) {
        this.store.homeElement = this;
        this.store.documentStore?.registerToastTarget?.(this);
      }
    }
    if (this.store?.showCreationDialog) {
      this.setupTemplateObserver();
    }
    if (this.store?.filteredElements?.length > 0) {
      this.#setupElementObserver();
    }
    const view = this.store?.galleryView;
    const desired = view === GalleryViews.MY_FILES ? "my-workspace" : view === GalleryViews.SHARED ? "shared" : "home";
    const navSelection = this.store?.homeNavSelection;
    if (navSelection !== "team-workspace" && navSelection !== desired) {
      this.store?.setHomeNavSelection?.(desired);
    }
  }
  #setupElementObserver() {
    this.#previewManager?.observe();
  }
};
customElements.define(
  "experience-elements-home-new",
  makeLitObserver(ExperienceElementsHomeNew)
);

// src/router.js
var Router = class {
  constructor(store) {
    this.store = store;
    this.isUpdatingFromUrl = false;
    this.isUpdatingFromStore = false;
    this.lastUrlUpdate = null;
    this.cleanupReaction = null;
    this.#navDisposer = null;
    this.#wasHome = false;
    this.setupStoreReactions();
    this.setupBrowserListeners();
    this.handleRoute();
  }
  // No base path manipulation needed for query-only routing
  setupStoreReactions() {
    this.cleanupReaction = reaction(
      this.store,
      (store) => [
        store?.editorStore?.currentElementId,
        store.galleryView,
        store.searchQuery,
        store.showCreationDialog,
        store.creationDialogCategory,
        // Track folder navigation to preserve in URL
        store.currentFolderUrn
      ],
      (currentElementId, galleryView, searchQuery, showCreationDialog, creationDialogCategory) => {
        if (this.isUpdatingFromUrl) {
          return;
        }
        this.isUpdatingFromStore = true;
        this.updateUrlFromStore();
        this.isUpdatingFromStore = false;
      },
      0
      // No debouncing, update immediately
    );
  }
  setupBrowserListeners() {
    this.handlePopState = () => {
      if (!this.isUpdatingFromStore) {
        this.handleRoute();
      }
    };
    window.addEventListener("popstate", this.handlePopState);
  }
  updateUrlFromStore() {
    const currentPath = window.location.pathname;
    const currentSearch = window.location.search;
    let newPath = currentPath;
    let newSearch = "";
    if (this.store?.editorStore?.currentElementId) {
      const params = new URLSearchParams();
      params.set("id", this.store.editorStore.currentElementId);
      const queryString = params.toString();
      newSearch = queryString ? `?${queryString}` : "";
    } else if (this.store.showCreationDialog) {
      const params = new URLSearchParams();
      params.set("new", "1");
      if (this.store.creationDialogCategory && this.store.creationDialogCategory !== "templates") {
        params.set("category", this.store.creationDialogCategory);
      }
      if (this.store.currentFolderUrn) params.set("folder", this.store.currentFolderUrn);
      if (this.store.galleryView && this.store.galleryView !== "all") params.set("view", this.store.galleryView);
      if (this.store.searchQuery) params.set("q", this.store.searchQuery);
      const queryString = params.toString();
      newSearch = queryString ? `?${queryString}` : "";
    } else {
      const params = new URLSearchParams();
      if (this.store.galleryView && this.store.galleryView !== "all") {
        params.set("view", this.store.galleryView);
      }
      if (this.store.searchQuery) {
        params.set("q", this.store.searchQuery);
      }
      if (this.store.galleryView === "files" && this.store.currentFolderUrn) {
        params.set("folder", this.store.currentFolderUrn);
      }
      const queryString = params.toString();
      newSearch = queryString ? `?${queryString}` : "";
    }
    const newUrl = `${newPath}${newSearch}`;
    const currentUrl = `${currentPath}${currentSearch}`;
    if (newUrl !== currentUrl && newUrl !== this.lastUrlUpdate) {
      this.lastUrlUpdate = newUrl;
      history.pushState(null, "", newUrl);
      const newParams = new URLSearchParams(newSearch);
      const wasEditing = currentSearch.includes("id=");
      const isNowGallery = !newParams.has("id");
      if (wasEditing && isNowGallery && !this.isUpdatingFromUrl) {
        Promise.resolve().then(() => {
          if (!this.isUpdatingFromUrl) {
            this.handleRoute();
          }
        });
      }
    }
  }
  async handleRoute() {
    this.isUpdatingFromUrl = true;
    this.store.setIsNavigating(true);
    if (this.#navDisposer) {
      this.#navDisposer();
      this.#navDisposer = null;
    }
    const params = new URLSearchParams(window.location.search);
    const rawViewParam = params.get("view");
    const fallbackView = this.#viewFromNavPreference();
    const viewParam = rawViewParam || fallbackView;
    const validViewsEarly = Object.values(GalleryViews);
    const validatedViewEarly = validViewsEarly.includes(viewParam) ? viewParam : "all";
    if (this.store.galleryView !== validatedViewEarly) {
      this.store.setGalleryView(validatedViewEarly);
    }
    const folderParam = params.get("folder");
    await this.#syncFolderFromParam(folderParam);
    if (params.has("id")) {
      const elementId = params.get("id");
      if (this.store.showCreationDialog && this.store.setShowCreationDialog) {
        this.store.setShowCreationDialog(false);
      }
      if (elementId) {
        if (this.store?.editorStore?.setCurrentElementId) {
          this.store.editorStore.setCurrentElementId(elementId);
        }
        if (this.store.openElement) {
          this.store.openElement(elementId);
        }
      }
      this.store.setIsNavigating(false);
    } else if (params.has("new")) {
      const category = params.get("category") || "templates";
      if (this.store.setShowCreationDialog) {
        this.store.setShowCreationDialog(true);
      }
      if (this.store.setCreationDialogCategory) {
        this.store.setCreationDialogCategory(category);
      }
      this.store.setIsNavigating(false);
    } else {
      if (this.store?.editorStore?.currentElementId) {
        if (this.store.closeElement) {
          this.store.closeElement();
        } else {
          this.store?.editorStore?.setCurrentElementId(null);
          this.store.setCurrentElement(null);
        }
      }
      this.store.setIsNavigating(false);
      if (this.store.showCreationDialog && this.store.setShowCreationDialog) {
        this.store.setShowCreationDialog(false);
      }
      const searchQuery = params.get("q") || "";
      if (this.store.searchQuery !== searchQuery) {
        this.store.setSearchQuery(searchQuery);
      }
    }
    this.isUpdatingFromUrl = false;
  }
  // Resolve folder path from a URN and reconstruct breadcrumbs in the store
  async #syncFolderFromParam(folderUrn) {
    const current = this.store.currentFolderUrn || null;
    const target = folderUrn && folderUrn.trim() !== "" ? folderUrn : null;
    if (current === target) return;
    if (!target) {
      if (this.store.setFolderChain) {
        this.store.setFolderChain([]);
      } else {
        this.store.setCurrentFolder(null);
      }
      return;
    }
    const chain = [];
    let cursor = target;
    const seen = /* @__PURE__ */ new Set();
    let hadFailure = false;
    for (let i21 = 0; i21 < 32 && cursor && !seen.has(cursor); i21++) {
      seen.add(cursor);
      const doc3 = await this.store.documentStore.getDocument(cursor).catch(() => null);
      if (!doc3) {
        hadFailure = true;
        break;
      }
      chain.push({
        urn: doc3.urn,
        name: doc3.name || "Folder",
        parent: doc3.parentUrn || null
      });
      cursor = doc3.parentUrn || null;
    }
    if (!chain.length && hadFailure) {
      this.store.setCurrentFolder(target);
      return;
    }
    chain.reverse();
    if (this.store.setFolderChain) {
      this.store.setFolderChain(chain);
      return;
    }
    this.store.setCurrentFolder(null);
    for (const item of chain) {
      this.store.setCurrentFolder(item.urn, item.name);
    }
  }
  cleanup() {
    if (this.handlePopState) {
      window.removeEventListener("popstate", this.handlePopState);
    }
    if (this.cleanupReaction) {
      this.cleanupReaction();
    }
  }
  #navDisposer;
  #wasHome;
  #viewFromNavPreference() {
    const nav2 = this.store?.homeNavSelection;
    if (nav2 === "my-workspace") {
      return GalleryViews.MY_FILES;
    }
    if (nav2 === "shared") {
      return GalleryViews.SHARED;
    }
    return GalleryViews.ALL;
  }
};

// src/reactions.js
function registerReactions({ appStore, editorStore, commentStore }) {
  const disposers = [];
  const add2 = (d22) => disposers.push(d22);
  const editor = () => document.querySelector("experience-elements-editor");
  add2(
    reaction(
      editorStore,
      (s19) => [s19.currentElementId],
      () => {
        const ed = editor();
        if (!ed) return;
        ed.loadEditorContent();
        const urn = editorStore.currentElementId;
        if (urn) appStore?.collaboration?.usedIn?.refreshFor?.(urn);
        appStore?.collaboration?.version?.refreshVersions?.();
      }
    )
  );
  add2(
    reaction(
      appStore,
      (s19) => [s19.currentElement && s19.currentElement.html],
      () => {
        const ed = editor();
        if (!ed) return;
        ed.loadEditorContent();
      }
    )
  );
  add2(
    reaction(
      editorStore,
      (s19) => [s19.editingElement, s19.currentSlot],
      () => {
        const ed = editor();
        if (!ed) return;
        ed.updateCommentsOverlay();
        const tree = ed?.shadowRoot?.querySelector?.("content-tree-nav");
        if (tree) {
          const el2 = editorStore.editingElement;
          const slotName2 = editorStore.currentSlot;
          if (el2) {
            let targetNode = null;
            if (slotName2) {
              targetNode = tree.findSlotNode(el2, slotName2);
            } else {
              targetNode = tree.findNodeForElement(el2);
            }
            if (targetNode) {
              const key = tree.getKeyFor(targetNode);
              if (key) {
                tree.focusRowByKey(key, { focus: false, scroll: true });
              }
            }
          }
        }
        const el = editorStore.editingElement;
        if (el) editorStore.toolbar.showEEToolbar(el);
        else editorStore.toolbar.hideEEToolbar();
        const last = editorStore.lastUserAction || {};
        const t34 = String(last.type || "");
        const isUser = !!last.user;
        if (!isUser) return;
        if (!t34.startsWith("tree:") && !t34.startsWith("comment:")) return;
        const slotName = editorStore.currentSlot || null;
        let anchor = el;
        if (slotName && el && el.shadowRoot) {
          const selector = slotName === "default" ? "slot:not([name])" : `slot[name="${slotName}"]`;
          const slotEl = el.shadowRoot.querySelector(selector);
          if (slotEl) anchor = slotEl;
        }
        const viewport = ed?.shadowRoot?.querySelector?.("#surface-wrapper");
        const { outOfViewport, anchorRect: ar2, viewportRect: vr2 } = isElementOutOfViewport(anchor, viewport);
        if (!vr2 || !ar2) return;
        if (outOfViewport) {
          ed.centerOnElement(anchor);
          editorStore.setLastAction?.(
            t34.startsWith("tree:") ? "tree:center-on-exec" : "comment:center-on-exec",
            {}
          );
        } else {
          editorStore.setLastAction?.(
            t34.startsWith("tree:") ? "tree:center-on-skip" : "comment:center-on-skip",
            {
              reason: "visible",
              viewport: {
                x: Math.round(vr2.left),
                y: Math.round(vr2.top),
                w: Math.round(vr2.width),
                h: Math.round(vr2.height)
              },
              anchor: {
                x: Math.round(ar2.left),
                y: Math.round(ar2.top),
                w: Math.round(ar2.width),
                h: Math.round(ar2.height)
              }
            }
          );
        }
      }
    )
  );
  let lastHoveredEl = null;
  const updateComments = () => {
    const ed = editor();
    if (!ed) return;
    ed.syncCommentsPanelView();
    ed.updateCommentsOverlay();
    const id = commentStore.hoveredCommentId;
    const el = ed.getElementForComment(id);
    if (lastHoveredEl && lastHoveredEl !== el) {
      lastHoveredEl.removeAttribute("data-ee-comment-hovered");
      lastHoveredEl = null;
    }
    if (el) {
      el.setAttribute("data-ee-comment-hovered", "");
      lastHoveredEl = el;
    }
  };
  add2(
    reaction(
      commentStore,
      (cs2) => [cs2.hoveredCommentId, cs2.commentsPanelOpen],
      updateComments
    )
  );
  add2(
    reaction(
      commentStore,
      (cs2) => [cs2.selectedCommentId],
      () => {
        const ed = editor();
        if (!ed) return;
        const id = commentStore.selectedCommentId;
        const el = ed.getElementForComment(id);
        ed.editorStore?.selection?.selectElement(el);
      }
    )
  );
  const onResize = () => updateComments();
  window.addEventListener("resize", onResize);
  let currentContainer = null;
  const bindScrollListener = () => {
    const ed = editor();
    if (!ed) return;
    const container = ed.shadowRoot.querySelector("#canvas-container");
    if (!container) return;
    if (currentContainer === container) return;
    if (currentContainer) currentContainer.removeEventListener("scroll", onScroll, { passive: true });
    currentContainer = container;
    currentContainer.addEventListener("scroll", onScroll, { passive: true });
  };
  const onScroll = () => updateComments();
  add2(
    reaction(
      editorStore,
      (s19) => [s19.currentElementId, s19.editingElement],
      () => bindScrollListener()
    )
  );
  let wasHome = false;
  add2(
    reaction(
      appStore,
      (s19) => [s19.editorStore.currentElementId, s19.showCreationDialog, s19.isNavigating],
      () => {
        const isHome = !appStore.editorStore.currentElementId && !appStore.showCreationDialog;
        if (isHome && !appStore.isNavigating) {
          if (!wasHome) {
            wasHome = true;
            appStore.documentStore.loadAllElementsInto(appStore);
          }
        } else {
          wasHome = false;
        }
      },
      200
    )
  );
  let prevSaving = appStore.documentStore.isSaving;
  add2(
    reaction(
      appStore.documentStore,
      (s19) => [s19.isSaving],
      () => {
        const isHome = !appStore.editorStore.currentElementId && !appStore.showCreationDialog;
        const now = appStore.documentStore.isSaving;
        if (prevSaving && !now && isHome) {
          appStore.documentStore.loadAllElementsInto(appStore);
        }
        prevSaving = now;
      },
      200
    )
  );
  add2(
    reaction(
      appStore,
      (s19) => [s19.currentFolderUrn, s19.isNavigating],
      () => {
        const isHome = !appStore.editorStore.currentElementId && !appStore.showCreationDialog;
        if (isHome && !appStore.isNavigating) {
          appStore.documentStore.loadAllElementsInto(appStore);
        }
      },
      200
    )
  );
  add2(
    reaction(
      appStore,
      (s19) => [s19.galleryView, s19.isNavigating],
      () => {
        const isHome = !appStore.editorStore.currentElementId && !appStore.showCreationDialog;
        if (isHome && !appStore.isNavigating) {
          appStore.documentStore.loadAllElementsInto(appStore);
        }
      },
      200
    )
  );
  return () => {
    window.removeEventListener("resize", onResize);
    if (currentContainer) currentContainer.removeEventListener("scroll", onScroll, { passive: true });
    for (const d22 of disposers.splice(0)) d22();
  };
}

// src/experience-elements-app.js
var ExperienceElementsApp = class extends i4 {
  static properties = {
    router: { type: Object },
    store: { type: Store, observe: true },
    userStore: { type: UserStore, observe: true }
  };
  constructor() {
    super();
    this.store = new Store();
    this.userStore = this.store.userStore;
    if (typeof window !== "undefined") {
      const params = new URLSearchParams(window.location.search);
      const id = params.get("id");
      if (id) {
        this.store.editorStore.setCurrentElementId(id);
        if (this.store.setIsNavigating) this.store.setIsNavigating(true);
      }
    }
    this.store.init().then(() => {
      this.router = new Router(this.store);
    });
  }
  createRenderRoot() {
    return this;
  }
  initUserStore() {
    if (this.store?.documentStore?.isMcpActive) {
      this.store.setIsReady(true);
      return;
    }
    if (typeof window !== "undefined") {
      const profilePromise = window.adobeIMS?.getProfile?.();
      if (profilePromise) {
        profilePromise.then((profile) => {
          if (!profile) return;
          const email = profile.email || profile.userId;
          if (!email) return;
          const displayName = profile.displayName || profile.name || this.userStore.extractNameFromEmail(email);
          const ownerOrg = profile.ownerOrg;
          this.userStore.setCurrentUser(email, displayName, ownerOrg);
        });
        return;
      }
      if (!this.userStore.loadCurrentUser()) {
        const savedEmail = localStorage.getItem("user-email");
        const savedName = localStorage.getItem("user-display-name");
        const savedOrg = localStorage.getItem("user-owner-org") || "";
        if (savedEmail) {
          this.userStore.setCurrentUser(savedEmail, savedName, savedOrg);
        }
      }
    }
    this.store.setIsReady(true);
  }
  promptUserSetup() {
    const email = prompt(
      "Please enter your email address:"
    );
    if (email) {
      const displayName = prompt(
        "Please enter your display name:",
        this.userStore.extractNameFromEmail(email)
      );
      localStorage.setItem("user-email", email);
      if (displayName) {
        localStorage.setItem("user-display-name", displayName);
      }
      this.userStore.setCurrentUser(email, displayName);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.updateComplete.then(() => {
      if (!this.#cleanupAppReactions) {
        this.#cleanupAppReactions = registerReactions({
          appStore: this.store,
          editorStore: this.store.editorStore,
          commentStore: this.store?.collaboration?.comment
        });
      }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#cleanupAppReactions) this.#cleanupAppReactions();
    this.#cleanupAppReactions = null;
  }
  #cleanupAppReactions;
  firstUpdated() {
    super.firstUpdated?.();
    window.eeStores = {
      ...window.eeStores,
      // Main application store (contains sub-stores)
      store: this.store,
      documentStore: this.store.documentStore,
      templateStore: this.store.templateStore,
      domStore: this.store.domStore,
      userStore: this.store.userStore,
      galleryStore: this.store.galleryStore,
      workspaceStore: this.store.workspaceStore,
      commentStore: this.store.collaboration?.comment,
      versionStore: this.store.collaboration?.version,
      usedInStore: this.store.collaboration?.usedIn,
      libraryStore: libraryManager
    };
  }
  get home() {
    if (this.store.isEditingElement || this.store?.editorStore?.currentElementId)
      return E;
    return x`<experience-elements-home-new
      .store=${this.store}
      .templateStore=${this.store.templateStore}
      .userStore=${this.store.userStore}
    ></experience-elements-home-new>`;
  }
  get editor() {
    return x`<experience-elements-editor
      .store=${this.store}
      .domStore=${this.store.domStore}
      .userStore=${this.store.userStore}
      .editorStore=${this.store.editorStore}
      .commentStore=${this.store?.collaboration?.comment}
      ?open=${this.store.editorStore.isEditorOpen}
    ></experience-elements-editor>`;
  }
  render() {
    return x`<sp-theme
      color="${this.store.themeColor}"
      scale="medium"
      system="spectrum-two"
    >
      ${this.userStore.error ? x`<sp-illustrated-message
            heading="Authentication Required"
            description="${this.userStore.error}"
          >
            <sp-button @click=${this.promptUserSetup}>Sign In</sp-button>
          </sp-illustrated-message>` : x`<div>${this.home} ${this.editor}</div>`}
    </sp-theme>`;
  }
};
customElements.define(
  "experience-elements-app",
  makeLitObserver(ExperienceElementsApp)
);
export {
  makeLitObserver,
  makeObservable,
  notify,
  observe,
  reaction,
  subscribe,
  track
};
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
lit-html/lit-html.js:
lit-element/lit-element.js:
@lit/reactive-element/decorators/custom-element.js:
@lit/reactive-element/decorators/property.js:
@lit/reactive-element/decorators/state.js:
@lit/reactive-element/decorators/event-options.js:
@lit/reactive-element/decorators/base.js:
@lit/reactive-element/decorators/query.js:
@lit/reactive-element/decorators/query-all.js:
@lit/reactive-element/decorators/query-async.js:
@lit/reactive-element/decorators/query-assigned-nodes.js:
lit-html/directive.js:
lit-html/directives/repeat.js:
lit-html/async-directive.js:
lit-html/directives/until.js:
lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
lit-html/directives/private-async-helpers.js:
lit-html/directives/when.js:
lit-html/directives/join.js:
@lit-labs/virtualizer/layouts/shared/SizeCache.js:
@lit-labs/virtualizer/layouts/shared/BaseLayout.js:
@lit-labs/virtualizer/layouts/flow.js:
@lit-labs/virtualizer/events.js:
@lit-labs/virtualizer/ScrollerController.js:
@lit-labs/virtualizer/Virtualizer.js:
@lit-labs/virtualizer/virtualize.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
lit-html/directives/class-map.js:
lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
lit-html/directives/live.js:
lit-html/directives/ref.js:
lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.6.5
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
